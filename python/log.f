c.....driver program for A Multi-Phase Transport model
      PROGRAM AMPT
c
      double precision xmp, xmu, alpha, rscut2, cutof2, dshadow
      double precision smearp,smearh,dpcoal,drcoal,ecritl
      CHARACTER FRAME*8, PROJ*8, TARG*8
      character*25 amptvn
      COMMON/HMAIN1/EATT,JATT,NATT,NT,NP,N0,N01,N10,N11
      COMMON /HPARNT/HIPR1(100), IHPR2(50), HINT1(100), IHNT2(50)
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
      COMMON /ARPRNT/ ARPAR1(100), IAPAR2(50), ARINT1(100), IAINT2(50)
      COMMON /AROUT/ IOUT
      COMMON /AREVT/ IAEVT, IARUN, MISS
      COMMON /smearz/smearp,smearh
      COMMON/RNDF77/NSEED
      common/anim/nevent,isoft,isflag,izpc
c     parton coalescence radii in case of string melting:
      common /coal/dpcoal,drcoal,ecritl
      common/snn/efrm,npart1,npart2,epsiPz,epsiPt,PZPROJ,PZTARG
c     initialization value for parton cascade:
      common /para2/ xmp, xmu, alpha, rscut2, cutof2
      common /para7/ ioscar,nsmbbbar,nsmmeson
      common /para8/ idpert,npertd,idxsec
      common /rndm3/ iseedp
c     initialization value for hadron cascade:
      COMMON /RUN/ NUM
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
      COMMON /INPUT2/ ILAB, MANYB, NTMAX, ICOLL, INSYS, IPOT, MODE, 
     &   IMOMEN, NFREQ, ICFLOW, ICRHO, ICOU, KPOTEN, KMUL
      common/oscar1/iap,izp,iat,izt
      common/oscar2/FRAME,amptvn
      common/resdcy/NSAV,iksdcy
clin-4/2012-6/2009:
c      common/phidcy/iphidcy
      common/phidcy/iphidcy,pttrig,ntrig,maxmiss,ipi0dcy
      common/embed/iembed,nsembd,pxqembd,pyqembd,xembd,yembd,
     1     psembd,tmaxembd,phidecomp
clin-7/2009:
      common/cmsflag/dshadow,ishadow
clin-2/2012 allow random orientation of reaction plane:
      common /phiHJ/iphirp,phiRP

      EXTERNAL HIDATA, PYDATA, LUDATA, ARDATA, PPBDAT, zpcbdt
      SAVE   
c****************
      OPEN (24, FILE = 'input.ampt', STATUS = 'UNKNOWN')
      OPEN (12, FILE = 'ana/version', STATUS = 'UNKNOWN')
      READ (24, *) EFRM
c     format-read characters (for ALPHA compilers):
      READ (24, 111) FRAME
      READ (24, 111) PROJ
      READ (24, 111) TARG
      READ (24, *) IAP
      READ (24, *) IZP
      READ (24, *) IAT
      READ (24, *) IZT
      READ (24, *) NEVNT
      READ (24, *) BMIN
      READ (24, *) BMAX
c     flag to select default AMPT or string melting:
      READ (24, *) isoft
c     read initialization value for hadron cascade:
      READ (24, *) NTMAX
      READ (24, *) DT
c     parj(41) and (42) are a and b parameters in Lund string fragmentation:
      READ (24, *) PARJ(41)
      READ (24, *) PARJ(42)
c     IHPR2(11)=3 (or 2) allows the popcorn mechanism in PYTHIA and 
c     increase the net-baryon stopping in rapidity (value HIJING is 1):
      READ (24, *) ipop
      if(ipop.eq.1) IHPR2(11)=3
c     PARJ(5) controls the fraction of BMBbar vs BBbar in popcorn:
      READ (24, *) PARJ(5)
c     shadowing flag in HIJING:
      READ (24, *) IHPR2(6)
c     quenching flag in HIJING:
      READ (24, *) IHPR2(4)
c     quenching rate when quenching flag is on (=1.0 GeV/fm):
      READ (24, *) HIPR1(14)
c     Minimum pt of hard or semihard scatterings in HIJING: D=2.0 GeV. 
      READ (24, *) HIPR1(8)
c     read initialization value for parton cascade:
      READ (24, *) xmu
      READ (24, *) izpc
      READ (24, *) alpha
c     quark coalescence radii in momentum and space for string melting:
      READ (24, *) dpcoal
      READ (24, *) drcoal
c     flag: read in HIJING random # seed at runtime(1) or from input.ampt(D=0):
      READ (24, *) ihjsed
c     2 seeds for random number generators in HIJING/hadron cascade and ZPC:
      READ (24, *) nseed
      READ (24, *) iseedp
      READ (24, *) iksdcy
      READ (24, *) iphidcy
      READ (24, *) ipi0dcy
c     flag for OSCAR output for final partons and hadrons:
      READ (24, *) ioscar
clin-5/2008     flag for perturbative treatment of deuterons:
      READ (24, *) idpert
      READ (24, *) npertd
      READ (24, *) idxsec
clin-6/2009 To select events that have at least 1 high-Pt minijet parton:
      READ (24, *) pttrig
      READ (24, *) maxmiss
      READ (24, *) IHPR2(2)
      READ (24, *) IHPR2(5)
clin-6/2009 To embed a back-to-back q/qbar pair into each event:
      READ (24, *) iembed
      READ (24, *) pxqembd, pyqembd
      READ (24, *) xembd, yembd
      READ (24, *) nsembd,psembd,tmaxembd
clin-7/2009 Allow modification of nuclear shadowing:
      READ (24, *) ishadow
      READ (24, *) dshadow
      READ (24, *) iphirp
c
      CLOSE (24)
 111  format(a8)
clin-6/2009 ctest off turn on jet triggering:
c      IHPR2(3)=1
c     Trigger Pt of high-pt jets in HIJING:
c      HIPR1(10)=7.
c
      if(isoft.eq.1) then
         amptvn = '1.26t7 (Default)'
      elseif(isoft.eq.4) then
         amptvn = '2.26t7 (StringMelting)'
      else
         amptvn = 'Test-Only'
      endif
      WRITE(6,50) amptvn
      WRITE(12,50) amptvn
 50   FORMAT(' '/
     &11X,'##################################################'/1X,
     &10X,'#      AMPT (A Multi-Phase Transport) model      #'/1X,
     &10X,'#          Version ',a25,                  '     #'/1X,
     &10X,'#               10/28/2016                       #'/1X,
     &10X,'##################################################'/1X,
     &10X,' ')
c     when ihjsed=11: use environment variable at run time for HIJING nseed:
      if(ihjsed.eq.11) then
         PRINT *,
     1 '# Read in NSEED in HIJING at run time (e.g. 20030819):'
      endif
      READ (*, *) nseedr
      if(ihjsed.eq.11) then
         nseed=nseedr
      endif
      if(ihjsed.eq.11) then      
         PRINT *, '#   read in: ', nseed
         WRITE(12,*) '# Read in NSEED in HIJING at run time:',nseed
      endif
      CLOSE(12)
clin-5/2015 an odd number is needed for the random number generator:
c      if(mod(NSEED,2).eq.0) NSEED=NSEED+1
      NSEED=2*NSEED+1
c     9/26/03 random number generator for f77 compiler:
      CALL SRAND(NSEED)
c
c.....turn on warning messages in nohup.out when an event is repeated:
      IHPR2(10) = 1
c     string formation time:
      ARPAR1(1) = 0.7
c     smearp is the smearing halfwidth on parton z0, 
c     set to 0 for now to avoid overflow in eta.
c     smearh is the smearing halfwidth on string production point z0.
      smearp=0d0
      IAmax=max(iap,iat)
      smearh=1.2d0*IAmax**0.3333d0/(dble(EFRM)/2/0.938d0)
      nevent=NEVNT
c
c     AMPT momentum and space info at freezeout:
      OPEN (16, FILE = 'ana/ampt.dat', STATUS = 'UNKNOWN')
      OPEN (14, FILE = 'ana/zpc.dat', STATUS = 'UNKNOWN')
ctest off for resonance (phi, K*) studies:
c      OPEN (17, FILE = 'ana/res-gain.dat', STATUS = 'UNKNOWN')
c      OPEN (18, FILE = 'ana/res-loss.dat', STATUS = 'UNKNOWN')
      CALL HIJSET(EFRM, FRAME, PROJ, TARG, IAP, IZP, IAT, IZT)
      CALL ARTSET
      CALL INIZPC
clin-5/2009 ctest off:
c      call flowp(0)
c      call flowh0(NEVNT,0)
c      call iniflw(NEVNT,0)
c      call frztm(NEVNT,0)
c
       DO 2000 J = 1, NEVNT
          IAEVT = J
          DO 1000 K = 1, NUM
             IARUN = K
             IF (IAEVT .EQ. NEVNT .AND. IARUN .EQ. NUM) THEN
                IOUT = 1
             END IF
             PRINT *, ' EVENT ', J, ', RUN ', K
             imiss=0
 100         CALL HIJING(FRAME, BMIN, BMAX)
             IAINT2(1) = NATT             

clin-6/2009 ctest off
           if(J.eq.-2) then 
              write(98,*) HIPR1
              write(98,*) ' '
              write(98,*) IHPR2
              write(98,*) ' '
              write(98,*) (HINT1(i),i=1,20)
              write(98,*) ' '
              write(98,*) (HINT1(i),i=21,40)
              write(98,*) ' '
              write(98,*) (HINT1(i),i=41,60)
              write(98,*) ' '
              write(98,*) (HINT1(i),i=61,80)
              write(98,*) ' '
              write(98,*) (HINT1(i),i=81,100)
              write(98,*) ' '
              write(98,*) IHNT2
           endif

c     evaluate Npart (from primary NN collisions) for both proj and targ:
             call getnp
c     switch for final parton fragmentation:
             IF (IHPR2(20) .EQ. 0) GOTO 2000
c     In the unlikely case of no interaction (even after loop of 20 in HIJING),
c     still repeat the event to get an interaction 
c     (this may have an additional "trigger" effect):
             if(NATT.eq.0) then
                imiss=imiss+1
                if(imiss.le.20) then
                   write(6,*) 'repeated event: natt=0,j,imiss=',j,imiss
                   goto 100
                else
                   write(6,*) 'missed event: natt=0,j=',j
                   goto 2000
                endif
             endif
c.....ART initialization and run
             CALL ARINI
             CALL ARINI2(K)
 1000     CONTINUE
c
          CALL ARTAN1
clin-9/2012 Analysis is not used:
c          CALL HJANA3
          CALL ARTMN
clin-9/2012 Analysis is not used:
c          CALL HJANA4
          CALL ARTAN2
 2000  CONTINUE
c
       CALL ARTOUT(NEVNT)
clin-5/2009 ctest off:
c       call flowh0(NEVNT,2)
c       call flowp(2)
c       call iniflw(NEVNT,2)
c       call frztm(NEVNT,2)
c
       STOP
       END
c     FYI: taken file unit numbers are 10-88, 91-93; 
c     so free file unit numbers are 1-4,7-9,89,97-99.
c....................amptsub.f
c.....this file contains 4 sections:
c.....1. ART subroutines;
c.....2. ART functions;
c.....3. ART block data;
c.....4. subprocesses borrowed from other codes.
c.....5. the previous artana.f
c.....6. the previous zpcsub.f
c.....7. subroutine getnp
c.....Note that Parts1-4 are the previous artsub.f
c
c=======================================================================
c.....subroutine to set up ART parameters and analysis files
c.....before looping different events
      SUBROUTINE ARTSET
c
      PARAMETER (AMU= 0.9383,nxymax=10001)
      double precision dpcoal,drcoal,ecritl
      INTEGER ZTA, ZPR
      common  /gg/      dx,dy,dz,dpx,dpy,dpz
clin-10/03/03 
c     "SAVE   " (without argument) is used for most subroutines and functions,
c     this is important for the success when using "f77" to compile:
cc      SAVE /gg/
      common  /zz/      zta,zpr
cc      SAVE /zz/
      COMMON  /RUN/     NUM
cc      SAVE /RUN/
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON /INPUT2/ ILAB, MANYB, NTMAX, ICOLL, INSYS, IPOT, MODE, 
     &   IMOMEN, NFREQ, ICFLOW, ICRHO, ICOU, KPOTEN, KMUL
cc      SAVE /INPUT2/
      COMMON /INPUT3/ PLAB, ELAB, ZEROPT, B0, BI, BM, DENCUT, CYCBOX
cc      SAVE /INPUT3/
      common /imulst/ iperts
cc      SAVE /imulst/
      common /coal/dpcoal,drcoal,ecritl
      common/anim/nevent,isoft,isflag,izpc
      common /para7/ ioscar,nsmbbbar,nsmmeson
      common/embed/iembed,nsembd,pxqembd,pyqembd,xembd,yembd,
     1     psembd,tmaxembd,phidecomp
      common/xyembed/nxyjet,xyjet(nxymax,2)
      SAVE   
clin-10/03/03  ecritl: local energy density below which a parton 
c     will freeze out (in GeV/fm^3), for improvements on string melting, 
c     not used in this version of AMPT:
clin-4/2008
c      data ecritl/1.d0/
      ecritl=1.d0
c
c     combine ART initialization into ampt.ini:
c     (Note that the following values are relics from the old ART structure)
c.....input parameter file
c      OPEN(13, FILE = 'art1.ini', STATUS = 'UNKNOWN')
c      READ (13, *) MASSTA, ZTA
      MASSTA=1
      ZTA=1
c      write(12,*) massta, zta, ' massta, zta'
c      READ (13, *) MASSPR, ZPR
      MASSPR=1
      ZPR=1
c      write(12,*) masspr, zpr, ' masspr, zpr'
c      READ (13, *) PLAB, IPLAB
      PLAB=14.6 
      IPLAB=2
c      write(12,*) plab, iplab, ' plab, iplab'
      if(iplab.eq.2)then
         elab=sqrt(plab**2+amu**2)-amu
      else
         elab=plab
      endif
      elab=elab*1000.
c      READ (13, *) ZEROPT
      ZEROPT=0.
c      write(12,*) zeropt, ' zeropt'
clin-10/03/03 ISEED was used as a seed for random number inside ART, 
c     not used in AMPT:
      ISEED=700721
c     0/1: (Normal or Perturbative) multistrange partice production.
c     Perturbative option is disabled for now:
      iperts=0
c      READ (13, *) MANYB, B0, BI, BM
c     2/04/00 MANYB MUST BE SET TO 1 !
c     in order to skip impact parameter setting by ART, then B0 has no effect.
      MANYB=1
      B0=1
      BI=0
      BM=0
c      write(12,*) manyb, b0, bi, bm, ' manyb, b0, bi, bm'
c      READ (13, *) ISEED
c      write(12,*) iseed, ' iseed'
c      READ (13, *) DT
c      write(12,*) dt, ' dt'
c      READ (13, *) NTMAX
c      write(12,*) ntmax, ' ntmax'
c      READ (13, *) ICOLL
      ICOLL=-1
c      write(12,*) icoll, ' icoll'
c      READ (13, *) NUM
c     2/11/03 run events without test particles for now:
      NUM=1
c      write(12,*) num, ' num'
c      READ (13, *) INSYS
      INSYS=1
c      write(12,*) insys, ' insys'
c      READ (13, *) IPOT
      IPOT=3
c      write(12,*) ipot, ' ipot'
c      READ (13, *) MODE
      MODE=0
      IF(ICOLL.EQ.-1)IPOT=0
c      write(12,*) mode, ' mode'
c      READ (13, *) DX, DY, DZ
      DX=2.73
      DY=2.73
      DZ=2.73
c      write(12,*) dx,dy,dz,' dx,dy,dz'
c      READ (13, *) DPX, DPY, DPZ
      DPX=0.6
      DPY=0.6
      DPZ=0.6
c      write(12,*) dpx,dpy,dpz,' dpx,dpy,dpz'
c      READ (13, *) IAVOID
      IAVOID=1
c      write(12,*) iavoid, ' iavoid'
c      READ (13, *) IMOMEN
      IMOMEN=1
c      write(12,*) imomen, ' imomen'
      if(icoll.eq.-1)imomen=3
c      READ (13, *) NFREQ
      NFREQ=10
c      write(12,*) nfreq, ' nfreq'
c      READ (13, *) ICFLOW
      ICFLOW=0
c      write(12,*) ICFLOW, ' ICFLOW'
c      READ (13, *) ICRHO
      ICRHO=0
c      write(12,*) ICRHO, ' ICRHO'
c      READ (13, *) ICOU
      ICOU=0
c      write(12,*)icou, ' icou'
* kaon potential control parameter
* KMUL IS A MULTIPLIER TO THE STANDARD K-N SCATTERING LENGTH
c      READ (13, *) KPOTEN, KMUL
      KPOTEN=0
      KMUL=1
c      write(12,*)kpoten,kmul, ' kpoten, kmul'
* mean field control parameter FOR BARYONS
* no mean filed is used for baryons if their 
* local density is higher than dencut. 
c      READ (13, *) DENCUT
      DENCUT=15
c      write(12,*)dencut, ' dencut'
* test reactions in a box of side-length cycbox
* input cycbox
c      READ (13, *) CYCBOX
      CYCBOX=0
c      write(12,*) cycbox, ' cycbox'
c
clin-5b/2008
c      if(ioscar.eq.2) then
      if(ioscar.eq.2.or.ioscar.eq.3) then
         OPEN (92,FILE='ana/parton-initial-afterPropagation.dat',
     1        STATUS = 'UNKNOWN')
      endif
      if(ioscar.eq.3) then
clin-6/2009 write out full parton collision history:
         OPEN (95,FILE='ana/parton-collisionsHistory.dat',
     1        STATUS='UNKNOWN')
clin-6/2009 write out initial minijet information:
         OPEN (96,FILE='ana/minijet-initial-beforePropagation.dat',
     1        STATUS='UNKNOWN')
clin-6/2009 write out parton info after coalescence:
         if(isoft.eq.4.or.isoft.eq.5) then
            OPEN (85,FILE='ana/parton-after-coalescence.dat',
     1           STATUS='UNKNOWN')
         endif
      endif
clin-6/2009 write out initial transverse positions of initial nucleons:
      OPEN (94,FILE='ana/npart-xy.dat',STATUS='UNKNOWN')
c
clin-8/2009 In case that random positions are used to embed high-Pt jets:
      if(iembed.eq.3.or.iembed.eq.4) then
         OPEN (97,FILE='embed-jet-xy.txt',STATUS = 'UNKNOWN')
         read(97,*) nxyjet
c     Save positions in array to reuse when embedding more jet pairs 
c     than the number of entries in the position file:
         if(nevent.gt.nxyjet) then
            if(nxyjet.gt.nxymax) then
               print *, 'Too many lines in embed-jet-xy.txt: 
     1 increase value of the parameter nxymax'
               stop
            elseif(nxyjet.le.0) then
               print *, 'Check number of entries in embed-jet-xy.txt' 
               stop
            endif
            do ixy=1,nxyjet
               read(97,*) xyjet(ixy,1),xyjet(ixy,2)
            enddo
         endif
      endif

      RETURN
      END

c-----------------------------------------------------------------------

c.....subroutine to initialize cascade.

      SUBROUTINE ARINI

c.....before invoking ARINI:
c.....IAPAR2(1), IAINT2(1) must be set.
      COMMON /ARPRNT/ ARPAR1(100), IAPAR2(50), ARINT1(100), IAINT2(50)
cc      SAVE /ARPRNT/
      SAVE   

ctest off for resonance (phi, K*) studies:
c      OPEN (89, FILE = 'ana/decay_rec.dat', STATUS = 'UNKNOWN')

      IFLG = IAPAR2(1)
      GOTO (200, 200, 300) IFLG

c.....error choice of initialization
      PRINT *, 'IAPAR2(1) must be 1, 2, or 3'
      STOP

c.....to use default initial conditions generated by the cascade,
c.....or to read in initial conditions.
 200  RETURN

c.....to generate formation time and the position at formation time from 
c.....read-in initial conditions with an averaged formation proper time.
 300  CALL ARINI1
c.....ordering the particle label according to increasing order of 
c.....formation time.
      CALL ARTORD
      RETURN

      END

c-----------------------------------------------------------------------

c.....subroutine to generate formation time and position at formation time
c.....from read-in initial conditions with an averaged formation proper 
c.....time.

      SUBROUTINE ARINI1

c.....before invoking ARINI1:
c.....ARPAR1(1), IAINT2(1) must be set:
      PARAMETER (MAXSTR=150001)
      double precision  smearp,smearh

      COMMON /ARPRNT/ ARPAR1(100), IAPAR2(50), ARINT1(100), IAINT2(50)
cc      SAVE /ARPRNT/
      COMMON /ARPRC/ ITYPAR(MAXSTR),
     &     GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
     &     PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
     &     XMAR(MAXSTR)
cc      SAVE /ARPRC/
      COMMON /smearz/smearp,smearh
cc      SAVE /smearz/
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
      common /nzpc/nattzp
cc      SAVE /nzpc/
      COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      common /para8/ idpert,npertd,idxsec
      SAVE   

clin-5/2008 for perturbatively-produced hadrons (currently only deuterons):
      OPEN (91, FILE = 'ana/deuteron_processes.dat', 
     1     STATUS = 'UNKNOWN')
      if(idpert.eq.1.or.idpert.eq.2) then
         OPEN (90, FILE = 'ana/ampt_pert.dat', STATUS = 'UNKNOWN')
      endif
c.....generate formation time and position at formation time.
      TAU0 = ARPAR1(1)
      NP = IAINT2(1)
clin-7/10/01     initial positions already given for hadrons 
c     formed from partons inside ZPC (from string melting):
      if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) then
clin-8/2015 fixed a bug that may skip "dpertp(I)=1." in addhad and
c     cause the first few events to be missing in ampt.dat 
c     (mostly for low-multiplicity events such as PP collisions):
c         if(NP.le.nattzp) return
         if(NP.gt.nattzp) then

         do 1001 I = nattzp+1, NP
clin-9/2012 determine rapidity more generally 
c     to prevent overflow when Pt~=0 and E=|Pz|:
c            IF (ABS(PZAR(I)) .GE. PEAR(I)) THEN
c               PRINT *, ' IN ARINI1'
c               PRINT *, 'ABS(PZ) .GE. EE for particle ', I
c               PRINT *, ' FLAV = ', ITYPAR(I), ' PX = ', PXAR(I), 
c     &              ' PY = ', PYAR(I)
c               PRINT *, ' PZ = ', PZAR(I), ' EE = ', PEAR(I)
c               PRINT *, ' XM = ', XMAR(I)
c               RAP = 1000000.0
c               GOTO 50
c            END IF
cc            RAP=0.5*LOG((PEAR(I)+PZAR(I))/(PEAR(I)-PZAR(I)))
c            RAP=0.5*LOG((PEAR(I)+PZAR(I)+1e-5)/(PEAR(I)-PZAR(I)+1e-5))
c 50         CONTINUE
            if((XMAR(I)**2+PXAR(I)**2+PYAR(I)**2).gt.0.) then
               RAP=asinh(PZAR(I)/sqrt(XMAR(I)**2+PXAR(I)**2+PYAR(I)**2))
            else
               PRINT *, ' IN ARINI1 mt=0'
               RAP = 1000000.0*sign(1.,PZAR(I))
            endif

            VX = PXAR(I) / PEAR(I)
            VY = PYAR(I) / PEAR(I)
            FTAR(I) = TAU0 * COSH(RAP)
            GXAR(I) = GXAR(I) + VX * FTAR(I)
            GYAR(I) = GYAR(I) + VY * FTAR(I)
            GZAR(I) = TAU0 * SINH(RAP)
clin-5/2009 No formation time for spectator projectile or target nucleons:
            if(PXAR(I).eq.0.and.PYAR(I).eq.0
     2           .and.(ITYPAR(I).eq.2112.or.ITYPAR(I).eq.2212)) then
clin-2/2013 for spectator target nucleons in LAB frame:
c     1           .and.(PEAR(I)*2/HINT1(1)).gt.0.99
              if((PEAR(I)/HINT1(6).gt.0.99.and.PEAR(I)/HINT1(6).lt.1.01)
     1 .or.(PEAR(I)/HINT1(7).gt.0.99.and.PEAR(I)/HINT1(7).lt.1.01)) then
c
               TAUI=1.E-20
               FTAR(I)=TAUI*COSH(RAP)
               GZAR(I)=TAUI*SINH(RAP)
               endif
            endif
 1001    continue
clin-8/2015:
         endif
clin-7/10/01-end
clin-3/2009 cleanup of program flow:
      else
         DO 1002 I = 1, NP
clin-9/2012 determine rapidity more generally:
c            IF (ABS(PZAR(I)) .GE. PEAR(I)) THEN
c               PRINT *, ' IN ARINI1'
c               PRINT *, 'ABS(PZ) .GE. EE for particle ', I
c               PRINT *, ' FLAV = ', ITYPAR(I), ' PX = ', PXAR(I), 
c     &              ' PY = ', PYAR(I)
c               PRINT *, ' PZ = ', PZAR(I), ' EE = ', PEAR(I)
c               PRINT *, ' XM = ', XMAR(I)
c               RAP = 1000000.0
c               GOTO 100
cc               STOP
c            END IF
c 100        CONTINUE
c            RAP=0.5*LOG((PEAR(I)+PZAR(I)+1e-5)/(PEAR(I)-PZAR(I)+1e-5))
            if((XMAR(I)**2+PXAR(I)**2+PYAR(I)**2).gt.0.) then
               RAP=asinh(PZAR(I)/sqrt(XMAR(I)**2+PXAR(I)**2+PYAR(I)**2))
            else
               PRINT *, ' IN ARINI1 mt=0'
               RAP = 1000000.0*sign(1.,PZAR(I))
            endif

            VX = PXAR(I) / PEAR(I)
            VY = PYAR(I) / PEAR(I)
c.....give initial formation time shift
            TAUI = FTAR(I) + TAU0
            FTAR(I) = TAUI * COSH(RAP)
            GXAR(I) = GXAR(I) + VX * TAU0 * COSH(RAP)
            GYAR(I) = GYAR(I) + VY * TAU0 * COSH(RAP)
c     4/25/03: hadron z-position upon formation determined the same way as x,y:
            GZAR(I) = TAUI * SINH(RAP)
c     the old prescription:
c            GZAR(I) = GZAR(I) + TAU0 * SINH(RAP)
            zsmear=sngl(smearh)*(2.*RANART(NSEED)-1.)
            GZAR(I)=GZAR(I)+zsmear
cbz1/28/99end
c     10/05/01 no formation time for spectator projectile or target nucleons:
            if(PXAR(I).eq.0.and.PYAR(I).eq.0
     2           .and.(ITYPAR(I).eq.2112.or.ITYPAR(I).eq.2212)) then
clin-2/2013 for spectator target nucleons in LAB frame:
c     1           .and.(PEAR(I)*2/HINT1(1)).gt.0.99
              if((PEAR(I)/HINT1(6).gt.0.99.and.PEAR(I)/HINT1(6).lt.1.01)
     1 .or.(PEAR(I)/HINT1(7).gt.0.99.and.PEAR(I)/HINT1(7).lt.1.01)) then
c
clin-5/2008:
c               TAUI=0.00001
               TAUI=1.E-20
               FTAR(I)=TAUI*COSH(RAP)
               GZAR(I)=TAUI*SINH(RAP)+zsmear
               endif
            endif
 1002    CONTINUE
clin-3/2009 cleanup of program flow:
      endif

clin-3/2009 Add initial hadrons before the hadron cascade starts:
      call addhad

      RETURN
      END

c-----------------------------------------------------------------------

c.....subroutine to order particle labels according to increasing 
c.....formation time

      SUBROUTINE ARTORD

c.....before invoking ARTORD:
c.....IAINT2(1) must be set:
      PARAMETER (MAXSTR=150001,MAXR=1)
      COMMON /ARPRNT/ ARPAR1(100), IAPAR2(50), ARINT1(100), IAINT2(50)
cc      SAVE /ARPRNT/
      COMMON /ARPRC/ ITYPAR(MAXSTR),
     &     GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
     &     PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
     &     XMAR(MAXSTR)
cc      SAVE /ARPRC/
clin-3/2009 Take care of particle weights when user inserts initial hadrons:
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      DIMENSION dptemp(MAXSTR)
c
      DIMENSION ITYP0(MAXSTR), 
     &   GX0(MAXSTR), GY0(MAXSTR), GZ0(MAXSTR), FT0(MAXSTR),
     &   PX0(MAXSTR), PY0(MAXSTR), PZ0(MAXSTR), EE0(MAXSTR),
     &   XM0(MAXSTR)
      DIMENSION INDX(MAXSTR)
      EXTERNAL ARINDX
      SAVE   
c
      NPAR = 0
      NP = IAINT2(1)
      DO 1001 I = 1, NP
         ITYP0(I) = ITYPAR(I)
         GX0(I) = GXAR(I)
         GY0(I) = GYAR(I)
         GZ0(I) = GZAR(I)
         FT0(I) = FTAR(I)
         PX0(I) = PXAR(I)
         PY0(I) = PYAR(I)
         PZ0(I) = PZAR(I)
         EE0(I) = PEAR(I)
         XM0(I) = XMAR(I)
clin-3/2009:
         dptemp(I) = dpertp(I)
 1001 CONTINUE
      CALL ARINDX(MAXSTR, NP, FT0, INDX)
      DO 1002 I = 1, NP
cbz12/3/98
c         IF (ITYP0(INDX(I)) .EQ. 211) THEN
c         IF (ITYP0(INDX(I)) .EQ. 211 .OR. ITYP0(INDX(I)) .EQ. 321) THEN
c         IF (ITYP0(INDX(I)) .EQ. 211 .OR. ITYP0(INDX(I)) .EQ. 2212 .OR.
c     &      ITYP0(INDX(I)) .EQ. 2112 .OR. ITYP0(INDX(I)) .EQ. -211 .OR.
c     &      ITYP0(INDX(I)) .EQ. 111) THEN
c         IF (ITYP0(INDX(I)) .EQ. 211 .OR. ITYP0(INDX(I)) .EQ. 2212 .OR.
c     &      ITYP0(INDX(I)) .EQ. 2112) THEN
         NPAR = NPAR + 1
c         ITYPAR(I) = ITYP0(INDX(I))
c         GXAR(I) = GX0(INDX(I))
c         GYAR(I) = GY0(INDX(I))
c         GZAR(I) = GZ0(INDX(I))
c         FTAR(I) = FT0(INDX(I))
c         PXAR(I) = PX0(INDX(I))
c         PYAR(I) = PY0(INDX(I))
c         PZAR(I) = PZ0(INDX(I))
c         PEAR(I) = EE0(INDX(I))
c         XMAR(I) = XM0(INDX(I))
         ITYPAR(NPAR) = ITYP0(INDX(I))
         GXAR(NPAR) = GX0(INDX(I))
         GYAR(NPAR) = GY0(INDX(I))
         GZAR(NPAR) = GZ0(INDX(I))
         FTAR(NPAR) = FT0(INDX(I))
         PXAR(NPAR) = PX0(INDX(I))
         PYAR(NPAR) = PY0(INDX(I))
         PZAR(NPAR) = PZ0(INDX(I))
         PEAR(NPAR) = EE0(INDX(I))
         XMAR(NPAR) = XM0(INDX(I))
clin-3/2009:
         dpertp(NPAR)=dptemp(INDX(I))
c         END IF
cbz12/3/98end
 1002 CONTINUE
      IAINT2(1) = NPAR
c
      RETURN
      END

c-----------------------------------------------------------------------

c.....subroutine to copy individually generated particle record into
c.....particle record for many test particle runs.

      SUBROUTINE ARINI2(K)

      PARAMETER (MAXSTR=150001,MAXR=1)
      COMMON /ARPRNT/ ARPAR1(100), IAPAR2(50), ARINT1(100), IAINT2(50)
cc      SAVE /ARPRNT/
      COMMON /ARPRC/ ITYPAR(MAXSTR),
     &     GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
     &     PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
     &     XMAR(MAXSTR)
cc      SAVE /ARPRC/
      COMMON /ARERC1/MULTI1(MAXR)
cc      SAVE /ARERC1/
      COMMON /ARPRC1/ITYP1(MAXSTR, MAXR),
     &     GX1(MAXSTR, MAXR), GY1(MAXSTR, MAXR), GZ1(MAXSTR, MAXR), 
     &     FT1(MAXSTR, MAXR),
     &     PX1(MAXSTR, MAXR), PY1(MAXSTR, MAXR), PZ1(MAXSTR, MAXR),
     &     EE1(MAXSTR, MAXR), XM1(MAXSTR, MAXR)
cc      SAVE /ARPRC1/
      COMMON/tdecay/tfdcy(MAXSTR),tfdpi(MAXSTR,MAXR),tft(MAXSTR)
cc      SAVE /tdecay/
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON /INPUT2/ ILAB, MANYB, NTMAX, ICOLL, INSYS, IPOT, MODE, 
     &     IMOMEN, NFREQ, ICFLOW, ICRHO, ICOU, KPOTEN, KMUL
cc      SAVE /INPUT2/
      COMMON/RNDF77/NSEED
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
cc      SAVE /RNDF77/
      SAVE   

      MULTI1(K) = IAINT2(1)
      DO 1001 I = 1, MULTI1(K)
         ITYP1(I, K) = ITYPAR(I)
         GX1(I, K) = GXAR(I)
         GY1(I, K) = GYAR(I)
         GZ1(I, K) = GZAR(I)
         FT1(I, K) = FTAR(I)
         PX1(I, K) = PXAR(I)
         PY1(I, K) = PYAR(I)
         PZ1(I, K) = PZAR(I)
         EE1(I, K) = PEAR(I)
         XM1(I, K) = XMAR(I)
clin-3/2009 hadron weights are initialized in addhad():
clin-5/2008 all hadrons not perturbatively-produced have the weight of 1:
c         dpp1(I,K)=1.
         dpp1(I,K)=dpertp(I)
 1001 CONTINUE

c     initialize final time of each particle to ntmax*dt except for 
c     decay daughters, which have values given by tfdcy() and >(ntmax*dt):
      do 1002 ip=1,MAXSTR
         tfdcy(ip)=NTMAX*DT
         tft(ip)=NTMAX*DT
 1002 continue
c
      do 1004 irun=1,MAXR
         do 1003 ip=1,MAXSTR
            tfdpi(ip,irun)=NTMAX*DT
 1003    continue
 1004 continue

      RETURN
      END

c=======================================================================

c.....function to convert PDG flavor code into ART flavor code.

      FUNCTION IARFLV(IPDG)

      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

c.....anti-Delta-
      IF (IPDG .EQ. -1114) THEN
         IARFLV = -6
         RETURN
      END IF

c.....anti-Delta0
      IF (IPDG .EQ. -2114) THEN
         IARFLV = -7
         RETURN
      END IF

c.....anti-Delta+
      IF (IPDG .EQ. -2214) THEN
         IARFLV = -8
         RETURN
      END IF

c.....anti-Delta++
      IF (IPDG .EQ. -2224) THEN
         IARFLV = -9
         RETURN
      END IF

cbzdbg2/23/99
c.....anti-proton
      IF (IPDG .EQ. -2212) THEN
         IARFLV = -1
         RETURN
      END IF

c.....anti-neutron
      IF (IPDG .EQ. -2112) THEN
         IARFLV = -2
         RETURN
      END IF
cbzdbg2/23/99end

c.....eta
      IF (IPDG .EQ. 221) THEN
         IARFLV = 0
         RETURN
      END IF

c.....proton
      IF (IPDG .EQ. 2212) THEN
         IARFLV = 1
         RETURN
      END IF

c.....neutron
      IF (IPDG .EQ. 2112) THEN
         IARFLV = 2
         RETURN
      END IF

c.....pi-
      IF (IPDG .EQ. -211) THEN
         IARFLV = 3
         RETURN
      END IF

c.....pi0
      IF (IPDG .EQ. 111) THEN
         IARFLV = 4
         RETURN
      END IF

c.....pi+
      IF (IPDG .EQ. 211) THEN
         IARFLV = 5
         RETURN
      END IF

c.....Delta-
      IF (IPDG .EQ. 1114) THEN
         IARFLV = 6
         RETURN
      END IF

c.....Delta0
      IF (IPDG .EQ. 2114) THEN
         IARFLV = 7
         RETURN
      END IF

c.....Delta+
      IF (IPDG .EQ. 2214) THEN
         IARFLV = 8
         RETURN
      END IF

c.....Delta++
      IF (IPDG .EQ. 2224) THEN
         IARFLV = 9
         RETURN
      END IF

c.....Lambda
      IF (IPDG .EQ. 3122) THEN
         IARFLV = 14
         RETURN
      END IF

c.....Lambda-bar
      IF (IPDG .EQ. -3122) THEN
         IARFLV = -14
         RETURN
      END IF

c.....Sigma-
      IF (IPDG .EQ. 3112) THEN
         IARFLV = 15
         RETURN
      END IF

c.....Sigma-bar
      IF (IPDG .EQ. -3112) THEN
         IARFLV = -15
         RETURN
      END IF 

c.....Sigma0
      IF (IPDG .EQ. 3212) THEN
         IARFLV = 16
         RETURN
      END IF

c.....Sigma0-bar
      IF (IPDG .EQ. -3212) THEN
         IARFLV = -16
         RETURN
      END IF 

c.....Sigma+
      IF (IPDG .EQ. 3222) THEN
         IARFLV = 17
         RETURN
      END IF

c.....Sigma+ -bar
      IF (IPDG .EQ. -3222) THEN
         IARFLV = -17
         RETURN
      END IF 

c.....K-
      IF (IPDG .EQ. -321) THEN
         IARFLV = 21
         RETURN
      END IF

c.....K+
      IF (IPDG .EQ. 321) THEN
         IARFLV = 23
         RETURN
      END IF

c.....temporary entry for K0
      IF (IPDG .EQ. 311) THEN
         IARFLV = 23
         RETURN
      END IF

c.....temporary entry for K0bar
      IF (IPDG .EQ. -311) THEN
         IARFLV = 21
         RETURN
      END IF

c.....temporary entry for K0S and K0L
      IF (IPDG .EQ. 310 .OR. IPDG .EQ. 130) THEN
         R = RANART(NSEED)
         IF (R .GT. 0.5) THEN
            IARFLV = 23
         ELSE
            IARFLV = 21
         END IF
         RETURN
      END IF

c.....rho-
      IF (IPDG .EQ. -213) THEN
         IARFLV = 25
         RETURN
      END IF

c.....rho0
      IF (IPDG .EQ. 113) THEN
         IARFLV = 26
         RETURN
      END IF

c.....rho+
      IF (IPDG .EQ. 213) THEN
         IARFLV = 27
         RETURN
      END IF

c.....omega
      IF (IPDG .EQ. 223) THEN
         IARFLV = 28
         RETURN
      END IF

c.....phi
      IF (IPDG .EQ. 333) THEN
         IARFLV = 29
         RETURN
      END IF

c.....K*+
      IF (IPDG .EQ. 323) THEN
         IARFLV = 30
         RETURN
      END IF
c.....K*-
      IF (IPDG .EQ. -323) THEN
         IARFLV = -30
         RETURN
      END IF
c.....temporary entry for K*0
      IF (IPDG .EQ. 313) THEN
         IARFLV = 30
         RETURN
      END IF
c.....temporary entry for K*0bar
      IF (IPDG .EQ. -313) THEN
         IARFLV = -30
         RETURN
      END IF

c...... eta-prime
      IF (IPDG .EQ. 331) THEN
         IARFLV = 31
         RETURN
      END IF
 
c...... a1
c     IF (IPDG .EQ. 777) THEN
c        IARFLV = 32
c        RETURN
c     END IF
                                
c... cascade-
      IF (IPDG .EQ. 3312) THEN
         IARFLV = 40
         RETURN
      END IF
 
c... cascade+ (bar)
      IF (IPDG .EQ. -3312) THEN
         IARFLV = -40
         RETURN
      END IF
 
c... cascade0
      IF (IPDG .EQ. 3322) THEN
         IARFLV = 41
         RETURN
      END IF
 
c... cascade0 -bar
      IF (IPDG .EQ. -3322) THEN
         IARFLV = -41
         RETURN
      END IF
 
c... Omega-
      IF (IPDG .EQ. 3334) THEN
         IARFLV = 45
         RETURN
      END IF 

c... Omega+ (bar)
      IF (IPDG .EQ. -3334) THEN
         IARFLV = -45
         RETURN
      END IF

c... Di-Omega
      IF (IPDG .EQ. 6666) THEN
         IARFLV = 44
         RETURN
      END IF
c sp06/05/01 end    

clin-3/2009 keep the same ID numbers in case there are initial deuterons:
      IF (IPDG .EQ. 42 .or. IPDG .EQ. -42) THEN
         IARFLV = IPDG
         RETURN
      END IF

c.....other
      IARFLV = IPDG + 10000

      RETURN
      END

c-----------------------------------------------------------------------

c.....function to convert ART flavor code into PDG flavor code.

      FUNCTION INVFLV(IART)

      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

c.....anti-Delta-
      IF (IART .EQ. -6) THEN
         INVFLV = -1114
         RETURN
      END IF

c.....anti-Delta0
      IF (IART .EQ. -7) THEN
         INVFLV = -2114
         RETURN
      END IF

c.....anti-Delta+
      IF (IART .EQ. -8) THEN
         INVFLV = -2214
         RETURN
      END IF

c.....anti-Delta++
      IF (IART .EQ. -9) THEN
         INVFLV = -2224
         RETURN
      END IF

cbzdbg2/23/99
c.....anti-proton
      IF (IART .EQ. -1) THEN
         INVFLV = -2212
         RETURN
      END IF

c.....anti-neutron
      IF (IART .EQ. -2) THEN
         INVFLV = -2112
         RETURN
      END IF
cbzdbg2/23/99end

c.....eta
      IF (IART .EQ. 0) THEN
         INVFLV = 221
         RETURN
      END IF

c.....proton
      IF (IART .EQ. 1) THEN
         INVFLV = 2212
         RETURN
      END IF

c.....neutron
      IF (IART .EQ. 2) THEN
         INVFLV = 2112
         RETURN
      END IF

c.....pi-
      IF (IART .EQ. 3) THEN
         INVFLV = -211
         RETURN
      END IF

c.....pi0
      IF (IART .EQ. 4) THEN
         INVFLV = 111
         RETURN
      END IF

c.....pi+
      IF (IART .EQ. 5) THEN
         INVFLV = 211
         RETURN
      END IF

c.....Delta-
      IF (IART .EQ. 6) THEN
         INVFLV = 1114
         RETURN
      END IF

c.....Delta0
      IF (IART .EQ. 7) THEN
         INVFLV = 2114
         RETURN
      END IF

c.....Delta+
      IF (IART .EQ. 8) THEN
         INVFLV = 2214
         RETURN
      END IF

c.....Delta++
      IF (IART .EQ. 9) THEN
         INVFLV = 2224
         RETURN
      END IF

cc.....N*(1440), N*(1535) temporary entry
c      IF (IART .GE. 10 .AND. IART .LE.13) THEN
c         INVFLV = 0
c         RETURN
c      END IF

c.....Lambda
      IF (IART .EQ. 14) THEN
         INVFLV = 3122
         RETURN
      END IF
c.....Lambda-bar
      IF (IART .EQ. -14) THEN
         INVFLV = -3122
         RETURN
      END IF 

cbz3/12/99
c.....temporary entry for Sigma's
c      IF (IART .EQ. 15) THEN
c         R = RANART(NSEED)
c         IF (R .GT. 2. / 3.) THEN
c            INVFLV = 3112
c         ELSE IF (R .GT. 1./ 3. .AND. R .LE. 2. / 3.) THEN
c            INVFLV = 3212
c         ELSE
c            INVFLV = 3222
c         END IF
c         RETURN
c      END IF

c.....Sigma-
      IF (IART .EQ. 15) THEN
         INVFLV = 3112
         RETURN
      END IF

c.....Sigma- bar
      IF (IART .EQ. -15) THEN
         INVFLV = -3112
         RETURN
      END IF 

c.....Sigma0
      IF (IART .EQ. 16) THEN
         INVFLV = 3212
         RETURN
      END IF

c.....Sigma0 -bar
      IF (IART .EQ. -16) THEN
         INVFLV = -3212
         RETURN
      END IF

c.....Sigma+
      IF (IART .EQ. 17) THEN
         INVFLV = 3222
         RETURN
      END IF

c.....Sigma+ -bar
      IF (IART .EQ. -17) THEN
         INVFLV = -3222
         RETURN
      END IF 

clin-2/23/03 K0S and K0L are generated at the last timestep:
c.....temporary entry for K- and K0bar
      IF (IART .EQ. 21) THEN
c         R = RANART(NSEED)
c         IF (R .GT. 0.5) THEN
            INVFLV = -321
c         ELSE
c            INVFLV = -311
c            R = RANART(NSEED)
c            IF (R .GT. 0.5) THEN
c               INVFLV = 310
c            ELSE
c               INVFLV = 130
c            END IF
c         END IF
         RETURN
      END IF

c.....temporary entry for K+ and K0
      IF (IART .EQ. 23) THEN
c         R = RANART(NSEED)
c         IF (R .GT. 0.5) THEN
            INVFLV = 321
c         ELSE
c            INVFLV = 311
c            R = RANART(NSEED)
c            IF (R .GT. 0.5) THEN
c               INVFLV = 310
c            ELSE
c               INVFLV = 130
c            END IF
c         END IF
         RETURN
      END IF

c.....K0Long:
      IF (IART .EQ. 22) THEN
         INVFLV = 130
         RETURN
      ENDIF
c.....K0Short:
      IF (IART .EQ. 24) THEN
         INVFLV = 310
         RETURN
      ENDIF

c.....rho-
      IF (IART .EQ. 25) THEN
         INVFLV = -213
         RETURN
      END IF

c.....rho0
      IF (IART .EQ. 26) THEN
         INVFLV = 113
         RETURN
      END IF

c.....rho+
      IF (IART .EQ. 27) THEN
         INVFLV = 213
         RETURN
      END IF

c.....omega
      IF (IART .EQ. 28) THEN
         INVFLV = 223
         RETURN
      END IF

c.....phi
      IF (IART .EQ. 29) THEN
         INVFLV = 333
         RETURN
      END IF

c.....temporary entry for K*+ and K*0
      IF (IART .EQ. 30) THEN
         INVFLV = 323
         IF (RANART(NSEED).GT.0.5) INVFLV = 313
         RETURN
      END IF

c.....temporary entry for K*- and K*0bar
      IF (IART .EQ. -30) THEN
         INVFLV = -323
         IF (RANART(NSEED).GT.0.5) INVFLV = -313
         RETURN
      END IF

c... eta-prime (bar)
      IF (IART .EQ. 31) THEN
         INVFLV = 331
         RETURN
      END IF
 
c... a1
      IF (IART .EQ. 32) THEN
         INVFLV = 777
         RETURN
      END IF
 
c... cascade-
      IF (IART .EQ. 40) THEN
         INVFLV = 3312
         RETURN
      END IF                   

c... cascade+ (bar)
      IF (IART .EQ. -40) THEN
         INVFLV = -3312
         RETURN
      END IF
 
c... cascade0
      IF (IART .EQ. 41) THEN
         INVFLV = 3322
         RETURN
      END IF
 
c... cascade0 -bar
      IF (IART .EQ. -41) THEN
         INVFLV = -3322
         RETURN
      END IF
 
c... Omega-
      IF (IART .EQ. 45) THEN
         INVFLV = 3334
         RETURN
      END IF

c... Omega+ (bar)
      IF (IART .EQ. -45) THEN
         INVFLV = -3334
         RETURN
      END IF

c... Di-Omega
      IF (IART .EQ. 44) THEN
         INVFLV = 6666
         RETURN
      END IF
c sp 12/19/00 end           

clin-5/2008 deuteron ID numbers in ART and ampt.dat:
      IF (IART .EQ. 42) THEN
         INVFLV = 42
         RETURN
      ELSEIF (IART .EQ. -42) THEN         
         INVFLV = -42
         RETURN
      END IF
c
c.....other
      INVFLV = IART - 10000

      RETURN
      END

c=======================================================================

      BLOCK DATA ARDATA

      COMMON /ARPRNT/ ARPAR1(100), IAPAR2(50), ARINT1(100), IAINT2(50)
cc      SAVE /ARPRNT/
      SAVE   
      DATA ARPAR1/1.19, 99 * 0.0/
      DATA IAPAR2/3, 49 * 0/
      DATA ARINT1/100 * 0.0/
      DATA IAINT2/50 * 0/

      END

c=======================================================================

c.....Routine borrowed from ZPC.
c.....double precision  is modified to real*4.

cbz1/29/99
c      subroutine index1(n, m, arrin, indx)
      subroutine arindx(n, m, arrin, indx)
cbz1/29/99end
c     indexes the first m elements of ARRIN of length n, i.e., outputs INDX
c     such that ARRIN(INDEX(J)) is in ascending order for J=1,...,m

c      implicit real*4 (a-h, o-z)

      dimension arrin(n), indx(n)
      SAVE   
      do 1001 j = 1, m
         indx(j) = j
 1001 continue
      l = m / 2 + 1
      ir = m
 10   continue
      if (l .gt. 1) then
         l = l - 1
         indxt = indx(l)
         q = arrin(indxt)
      else
         indxt = indx(ir)
         q = arrin(indxt)
         indx(ir) = indx(1)
         ir = ir - 1
         if (ir .eq. 1) then
            indx(1) = indxt
            return
         end if
      end if
      i = l
      j = l + l
 20   if (j .le. ir) then
         if (j .lt. ir) then
            if (arrin(indx(j)) .lt. arrin(indx(j + 1))) j = j + 1
         end if
         if (q .lt. arrin(indx(j))) then
            indx(i) = indx(j)
            i = j
            j = j + j
         else
            j = ir + 1
         end if
      goto 20
      end if
      indx(i) = indxt
      goto 10

      end

c-----------------------------------------------------------------------

c.....extracted from G. Song's ART expasion including K- interactions
c.....file `NEWKAON.FOR'

c     5/01/03 send iblock value into art1f.f, necessary for resonance studies:
c        subroutine newka(icase,irun,iseed,dt,nt,ictrl,i1,i2,
c     &                                   srt,pcx,pcy,pcz)
        subroutine newka(icase,irun,iseed,dt,nt,ictrl,i1,i2,
     &                                   srt,pcx,pcy,pcz,iblock)
      PARAMETER      (MAXSTR=150001,MAXR=1)
      PARAMETER      (AKA=0.498)
      COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
      COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
      COMMON   /EE/  ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      COMMON   /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
      COMMON   /NN/NNN
cc      SAVE /NN/
      COMMON   /RUN/NUM
cc      SAVE /RUN/
      COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
      COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
      COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
      COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
c
        logical lb1bn, lb2bn,lb1mn,lb2mn
cbz3/7/99 neutralk
c        logical lb1bn1, lb2bayon1, lb1bn0, lb2bn0
        logical lb1bn1, lb2bn1, lb1bn0, lb2bn0
cbz3/7/99 neutralk end
        logical lb1mn0, lb2mn0, lb1mn1, lb2mn1
        logical lb1mn2, lb2mn2
        icase=-1
c        icase: flag for the type of reaction that is going to happen.
c        icase=-1,  no desired reaction, return to main program.
c              1,  NN,ND,DD
c              2,  PI+N, PI+D
c              3,  K(-) absorption.
        nchrg=-100
c        nchrg: Net charges of the two incoming particles.
        ictrl = 1
        lb1=lb(i1)
        lb2=lb(i2)
        em1=e(i1)
        em2=e(i2)
        lb1bn=lb1.eq.1.or.lb1.eq.2.or.(lb1.gt.5.and.lb1.le.13)
        lb2bn=lb2.eq.1.or.lb2.eq.2.or.(lb2.gt.5.and.lb2.le.13)
        lb1bn0=lb1.eq.2.or.lb1.eq.7.or.lb1.eq.10.or.lb1.eq.12
        lb2bn0=lb2.eq.2.or.lb2.eq.7.or.lb2.eq.10.or.lb2.eq.12
        lb1bn1=lb1.eq.1.or.lb1.eq.8.or.lb1.eq.11.or.lb1.eq.13
        lb2bn1=lb2.eq.1.or.lb2.eq.8.or.lb2.eq.11.or.lb2.eq.13
        lb1mn=em1.lt.0.2.or.lb1.eq.0.or.(lb1.ge.25.and.lb1.le.29)
        lb2mn=em2.lt.0.2.or.lb2.eq.0.or.(lb2.ge.25.and.lb2.le.29)
        lb1mn0=lb1.eq.0.or.lb1.eq.4.or.lb1.eq.26.or.
     &                        lb1.eq.28.or.lb1.eq.29
        lb2mn0=lb2.eq.0.or.lb2.eq.4.or.lb2.eq.26.or.
     &                        lb2.eq.28.or.lb2.eq.29
        lb1mn1= lb1.eq.5.or.lb1.eq.27
        lb2mn1= lb2.eq.5.or.lb2.eq.27
        lb1mn2=lb1.eq.3.or.lb1.eq.25
        lb2mn2=lb2.eq.3.or.lb2.eq.25

c        1. consider N+N, N+Resonance, R + R reactions
        if(lb1bn.and.lb2bn) then
c     NN,ND,DD:
           icase=1
c     total cross section
           sig=40.
           if(lb1.eq.9.and.lb2.eq.9) then
                nchrg=4
           endif   
           if((lb1bn1.and.lb2.eq.9)
     &        .or.(lb2bn1.and.lb1.eq.9))then
                nchrg=3
           endif
           if((lb1bn0.and.lb2.eq.9)
     &        .or.(lb2bn0.and.lb1.eq.9)
     &        .or.(lb1bn1.and.lb2bn1)) then
                   nchrg=2
           endif
           if((lb1bn1.and.lb2bn0).or.(lb1.eq.6.and.lb2.eq.9)
     &        .or.(lb2bn1.and.lb1bn0)
     &        .or.(lb2.eq.6.and.lb1.eq.9))then
                   nchrg=1
           endif
           if((lb1bn0.and.lb2bn0).or.(lb1bn1.and.lb2.eq.6)
     &              .or.(lb2bn1.and.lb1.eq.6)) then
                   nchrg=0
           endif
           if((lb1bn0.and.lb2.eq.6)
     &        .or.(lb2bn0.and.lb1.eq.6))then
                nchrg=-1
           endif
           if(lb1.eq.6.and.lb2.eq.6) then
                nchrg=-2
           endif
c     brsig = x2kaon_no_isospin(srt)
           if(nchrg.ge.-1.and.nchrg.le.2) then
c     K,Kbar prduction x sect.
                   brsig = x2kaon(srt)
           else
                   brsig=0.0
c                if(nchrg.eq.-2.or.nchrg.eq.3) then
c                   brsig = x2kaon(srt+0.938-1.232)
c                else
c     nchrg=4
c                   brsig = x2kaon(srt+2.*(0.938-1.232))
c                endif
           endif

cbz3/7/99 neutralk
           BRSIG = 2.0 * BRSIG
cbz3/7/99 neutralk end

        endif

c        2. consider PI(meson:eta,omega,rho,phi) + N(N*,D)
        if((lb1bn.and.lb2mn).OR.(lb2bn.and.lb1mn)) then
c     PN,PD
          icase=2
          sig=20.
          sigma0 = piNsg0(srt)
          brsig=0.0
          if((lb1bn1.and.lb2mn0)
     &       .or.(lb2bn1.and.lb1mn0).
     & or.(lb1bn0.and.lb2mn1).or.(lb2bn0.and.lb1mn1).
     & or.(lb1.eq.9.and.lb2mn2).or.(lb2.eq.9.and.lb1mn2))then
                nchrg=1
cbz3/2/99/song
c                if(lb1bn1.or.lb2bn1) brsig=2.0*sigma0
c                if(lb1bn0.or.lb2bn0) brsig=0.5*sigma0
                if(lb1bn1.or.lb2bn1) brsig=0.5*sigma0
                if(lb1bn0.or.lb2bn0) brsig=2.0*sigma0
cbz3/2/99/song end
c                if(lb1.eq.9.or.lb2.eq.9) brsig=1.5*sigma0
          endif
          if( (lb1bn0.and.lb2mn0 )
     &       .or.(lb2bn0.and.lb1mn0)
     &  .or.(lb1bn1.and.lb2mn2).or.(lb2bn1.and.lb1mn2)
     &  .or.(lb1.eq.6.and.lb2mn1).or.(lb2.eq.6.and.lb1mn1)) then
                nchrg=0
                if(lb1bn1.or.lb2bn1) then
cbz3/2/99/song
c                  brsig=1.5*sigma0
                  brsig=3.0*sigma0
cbz3/2/99/song end
cbz3/11/99/song
c                  ratiok = 1./3.
                  ratiok = 2./3.
cbz3/11/99/song end

c                  ratiok: the ratio of channels: ->nK+k- vs. -> pK0K-
                endif
                if(lb1bn0.or.lb2bn0) then
                  brsig=2.5*sigma0
cbz3/2/99/song
c                  ratiok = 0.8
                  ratiok = 0.2
cbz3/2/99/song end
                endif
c                if(lb1.eq.6.or.lb2.eq.6) then
c     lb=6 : D-
c                  brsig=1.5*sigma0
c                  ratiok = 0.5
c                endif
          endif
          if( (lb1bn0.and.lb2mn2)
     &       .or.(lb2bn0.and.lb1mn2)
     & .or.(lb1.eq.6.and.lb2mn0).or.(lb2.eq.6.and.lb1mn0)) then
                nchrg=-1
                if(lb1bn0.or.lb2bn0) brsig=sigma0
c                if(lb1.eq.6.or.lb2.eq.6) brsig=sigma0
          endif
c          if((lb1.eq.6.and.lb2mn2).or.(lb2.eq.6.and.lb1mn2))then
c                nchrg=-2
c          endif
c          if((lb1bn1.and.lb2mn1).or.(lb2bn1.and.lb1mn1)
c    &           .or.(lb1.eq.9.and.lb2mn0).or.(lb2.eq.9.and.lb1mn0)) then
c                nchrg=2
c          endif

cbz3/11/99 neutralk
          if((lb1.eq.6.and.lb2mn2)
     &       .or.(lb2.eq.6.and.lb1mn2))then
                nchrg=-2
          endif
cbz3/11/99 neutralk
cbz3/8/99 neutralk
          if((lb1bn1.and.lb2mn1)
     &       .or.(lb2bn1.and.lb1mn1)
     & .or.(lb1.eq.9.and.lb2mn0).or.(lb2.eq.9.and.lb1mn0)) then
                nchrg=2
          endif
cbz3/8/99 neutralk end

cbz3/7/99 neutralk
          IF (NCHRG .GE. -2 .AND. NCHRG .LE. 2) THEN
             BRSIG = 3.0 * SIGMA0
          END IF
cbz3/7/99 neutralk end

        endif

c        3. consider K- + N(N*,D) absorption.
c        if((lb1bn.and.lb2.eq.21).OR.(lb2bn.and.lb1.eq.21)) then
        if( (lb1bn.and.(lb2.eq.21.or.lb2.eq.-30)).OR.
     &     (lb2bn.and.(lb1.eq.21.or.lb1.eq.-30)) )then 
c          bmass=em1+em2-aka
          bmass=0.938
          if(srt.le.(bmass+aka)) then
cbz3/2/99
c                write(100,*)'--lb1,lb2,em1,em2,srt',lb1,lb2,em1,em2,srt
cbz3/2/99end
                pkaon=0.
          else
            pkaon=sqrt(((srt**2-(aka**2+bmass**2))/2./bmass)**2-aka**2)
          endif
          sig=0.
          if(lb1.eq.1.or.lb2.eq.1.or.lb1.eq.8.or.lb2.eq.8.or.
     &    lb1.eq.11.or.lb2.eq.11.or.lb1.eq.13.or.lb2.eq.13) then
c          K- + (D+,N*+)p ->
              nchrg=0
              sigela=akPel(pkaon)
              sigsgm=3.*akPsgm(pkaon)
              sig=sigela+sigsgm+akPlam(pkaon)
          endif
          if(lb1.eq.2.or.lb2.eq.2.or.lb1.eq.7.or.lb2.eq.7.or.
     &    lb1.eq.10.or.lb2.eq.10.or.lb1.eq.12.or.lb2.eq.12) then
c          K- + (D0, N*0)n ->
              nchrg=-1
              sigela=akNel(pkaon)
              sigsgm=2.*akNsgm(pkaon)
              sig=sigela+sigsgm+akNlam(pkaon)
          endif
          if(lb1.eq.6.or.lb2.eq.6) then
c     K- + D-
              nchrg=-2
              sigela=akNel(pkaon)
              sigsgm=akNsgm(pkaon)
              sig=sigela+sigsgm
          endif
          if(lb1.eq.9.or.lb2.eq.9) then
c     K- + D++
              nchrg=1
              sigela=akPel(pkaon)
              sigsgm=2.*akPsgm(pkaon)
              sig=sigela+sigsgm+akPlam(pkaon)
          endif

cbz3/8/99 neutralk
          sigela = 0.5 * (AKPEL(PKAON) + AKNEL(PKAON))
          SIGSGM = 1.5 * AKPSGM(PKAON) + AKNSGM(PKAON)
          SIG = sigela + SIGSGM + AKPLAM(PKAON)
cbz3/8/99 neutralk end

          if(sig.gt.1.e-7) then
c     K(-) + N reactions
              icase=3
              brel=sigela/sig
              brsgm=sigsgm/sig
c              branch_lambda=akNlam(pkaon)/sig
              brsig = sig
          endif
        endif

c        4. meson + hyperon -> K- + N
c        if(((lb1.ge.14.and.lb1.le.17).and.lb2mn).OR.
c     &     ((lb2.ge.14.and.lb2.le.17).and.lb1mn)) then
        if(((lb1.ge.14.and.lb1.le.17).and.(lb2.ge.3.and.lb2.le.5)).OR.
     &     ((lb2.ge.14.and.lb2.le.17).and.(lb1.ge.3.and.lb1.le.5)))then
c        first classify the reactions due to total charge.
           nchrg=-100
           if((lb1.eq.15.and.(lb2.eq.3.or.lb2.eq.25)).OR.
     &              (lb2.eq.15.and.(lb1.eq.3.or.lb1.eq.25))) then
                nchrg=-2
c     D-
                  bmass=1.232
           endif
           if((lb1.eq.15.and.lb2mn0).or.(lb2.eq.15.and.lb1mn0).OR.
     &       ((lb1.eq.14.or.lb1.eq.16).and.(lb2.eq.3.or.lb2.eq.25)).OR.
     &       ((lb2.eq.14.or.lb2.eq.16).and.(lb1.eq.3.or.lb1.eq.25)))then
                nchrg=-1
c     n
                 bmass=0.938
           endif
           if((lb1.eq.15.and.(lb2.eq.5.or.lb2.eq.27)).OR.
     &              (lb2.eq.15.and.(lb1.eq.5.or.lb1.eq.27)).or.
     &        (lb1.eq.17.and.(lb2.eq.3.or.lb2.eq.25)).OR.
     &              (lb2.eq.17.and.(lb1.eq.3.or.lb1.eq.25)).or.
     &       ((lb1.eq.14.or.lb1.eq.16).and.lb2mn0).OR.
     &       ((lb2.eq.14.or.lb2.eq.16).and.lb1mn0)) then
                nchrg=0
c     p
                 bmass=0.938
           endif
           if((lb1.eq.17.and.lb2mn0).or.(lb2.eq.17.and.lb1mn0).OR.
     &       ((lb1.eq.14.or.lb1.eq.16).and.(lb2.eq.5.or.lb2.eq.27)).OR.
     &       ((lb2.eq.14.or.lb2.eq.16).and.(lb1.eq.5.or.lb1.eq.27)))then
                nchrg=1
c     D++
                 bmass=1.232
           endif
           sig = 0.
           if(nchrg.ne.-100.and.srt.gt.(aka+bmass)) then
c     PI+sigma or PI + Lambda => Kbar + N reactions
             icase=4
c             pkaon=sqrt(((srt**2-(aka**2+bmass**2))/2./bmass)**2-aka**2)
             pkaon=sqrt(((srt**2-(aka**2+0.938**2))/2./0.938)**2-aka**2)
c     lambda + Pi
             if(lb1.eq.14.or.lb2.eq.14) then
                if(nchrg.ge.0) sigma0=akPlam(pkaon)
                if(nchrg.lt.0) sigma0=akNlam(pkaon)
c     sigma + pi
             else
c     K-p or K-D++
                if(nchrg.ge.0) sigma0=akPsgm(pkaon)
c     K-n or K-D-
                if(nchrg.lt.0) sigma0=akNsgm(pkaon)

cbz3/8/99 neutralk
                SIGMA0 = 1.5 * AKPSGM(PKAON) + AKNSGM(PKAON)
cbz3/8/99 neutralk end

             endif
             sig=(srt**2-(aka+bmass)**2)*(srt**2-(aka-bmass)**2)/
     &         (srt**2-(em1+em2)**2)/(srt**2-(em1-em2)**2)*sigma0
cbz3/8/99 neutralk
c     if(nchrg.eq.-2.or.nchrg.eq.1) sig=2.*sig K-D++, K-D-
c     K0barD++, K-D-
             if(nchrg.eq.-2.or.nchrg.eq.2) sig=2.*sig

cbz3/8/99 neutralk end

c             the factor 2 comes from spin of delta, which is 3/2
c             detailed balance. copy from Page 423 of N.P. A614 1997

cbz3/8/99 neutralk
             IF (LB1 .EQ. 14 .OR. LB2 .EQ. 14) THEN
                SIG = 4.0 / 3.0 * SIG
             ELSE IF (NCHRG .EQ. -2 .OR. NCHRG .EQ. 2) THEN
                SIG = 8.0 / 9.0 * SIG
             ELSE
                SIG = 4.0 / 9.0 * SIG
             END IF
cbz3/8/99 neutralk end
             brsig = sig
             if(sig.lt.1.e-7) sig = 1.e-7
           endif
csp05/07/01
* comment icase=4 statement below if only inelastic
c     PI+L/Si => Kbar + N  OR ELASTIC SCATTERING
           icase=4
           brsig = sig
c     elastic xsecn of 10mb
           sigela = 10.
           sig = sig + sigela
           brel = sigela/sig
cc          brsig = sig
csp05/07/01 end   
        endif
c
c        if(em2.lt.0.2.and.em1.lt.0.2) then
c     PI + PI 
c             icase=5
c     assumed PI PI total x section.
c              sig=50.
c     Mk + Mkbar
c              s0=aka+aka
c              brsig = 0.
c              if(srt.gt.s0) brsig = 2.7*(1.-s0**2/srt**2)**0.76
c              x section for PIPI->KKbar   PRC43 (1991) 1881
c        endif
        if(icase.eq.-1) then
           ictrl = -1
           return
        endif
        px1cm=pcx
        py1cm=pcy
        pz1cm=pcz
        ds=sqrt(sig/31.4)
        dsr=ds+0.1
        ec=(em1+em2+0.02)**2
c        ec=3.59709
c        if((e(i1).ge.1.).and.(e(i2).ge.1.)) ec = 4.75

        call distce(i1,i2,dsr,ds,dt,ec,srt,ic,px1cm,py1cm,pz1cm)
        if(ic.eq.-1) then
c     no anti-kaon production
           ictrl = -1
c           in=in+1
c           write(60,*)'--------------distance-----',in
           return
        endif

clin-10/24/02 set to 0: ik,ik0-3,il,im,im3-4,in,inpion,ipipi, 
c     sgsum,sgsum1,sgsum3:
        ik=0
        ik0=0
        ik1=0
        ik2=0
        ik3=0
        il=0
        im=0
        im3=0
        im4=0
        in=0
        inpion=0
        ipipi=0
        sgsum=0.
        sgsum1=0.
        sgsum3=0.
        if(icase.eq.1) then
           ik=ik+1
           if(srt.gt.2.8639) then
                ik0=ik0+1
                if(em1.lt.1.0.and.em2.lt.1.0) then
                        ik1=ik1+1
                        sgsum1=sgsum1+brsig
c                        ratio_1=sgsum1/ik1/40.
                endif
                if(em1.gt.1.0.and.em2.gt.1.0) then
                        ik3=ik3+1
                        sgsum3=sgsum3+brsig
c                        ratio_3=sgsum3/ik3/40.
                endif
                if(em1.gt.1.0.and.em2.lt.1.0) ik2=ik2+1
                if(em1.lt.1.0.and.em2.gt.1.0) ik2=ik2+1
                sgsum=sgsum+brsig
c                ratio=sgsum/ik0/40.
           endif
        endif
        if(icase.eq.2) inpion=inpion+1
        if(icase.eq.5) ipipi=ipipi+1
c        write(62,*)'ik1,ik2,ik3',ik1,ik2,ik3,ratio_1,ratio_3,ratio
c        write(62,*)'inpion,ipipi',inpion,ipipi
        if(RANART(NSEED).gt.(brsig/sig)) then
c     no anti-kaon production
           ictrl = -1
           return
        endif
        il=il+1
c        kaons could be created now.
        if(icase.eq.1) then
          in=in+1
c          write(60,*)'------in,s2kaon,sig=',in,brsig,sig,lb1,lb2
          call nnkaon(irun,iseed,
     &          ictrl,i1,i2,iblock,srt,pcx,pcy,pcz,nchrg)
        endif
        if(icase.eq.2) then
          im=im+1
c          call npik(irun,iseed,dt,nt,ictrl,i1,i2,srt,
c     &              pcx,pcy,pcz,nchrg,ratiok)
          call npik(irun,iseed,dt,nt,ictrl,i1,i2,srt,
     &              pcx,pcy,pcz,nchrg,ratiok,iblock)
        endif
c
        if(icase.eq.3) then
          im3=im3+1
c          write(63,*)'im3,lb1,lb2,pkaon',im3,lb1,lb2,pkaon
c          write(63,*)'sig,el,sigma',sig,brel,brsgm
c          write(63,*)'srt,pcx,pcy,pcz,em1,em2',srt,pcx,pcy,pcz,em1,em2
          call kaonN(brel,brsgm,irun,iseed,dt,nt,ictrl,
     &                i1,i2,iblock,srt,pcx,pcy,pcz,nchrg)
c         this subroutine format is diff. since three final states are possible
        endif
c

        if(icase.eq.4) then
          im4=im4+1
c          write(64,*)'im4,sigma0,branch,sig=',im4,sigma0,brsig,sig
c          write(64,*)'lb1,lb2,em1,em2,pkaon=',lb1,lb2,em1,em2,pkaon

csp06/07/01
      if(RANART(NSEED).lt.brel) then
         ielstc = 1
      else
         ielstc = 0
      endif                  
c          call Pihypn(ielstc,irun,iseed,dt,nt,ictrl,i1,i2,srt,
c     &                   pcx,pcy,pcz,nchrg)
          call Pihypn(ielstc,irun,iseed,dt,nt,ictrl,i1,i2,srt,
     &                   pcx,pcy,pcz,nchrg,iblock)

csp06/07/01 end
        endif
c        if(icase.eq.5) then
c          im5=im5+1
c          write(65,*)'---im5,s2kaon,sig=',im5,brsig,sig
c          call pipikaon(irun,iseed,dt,nt,ictrl,i1,i2,srt,pcx,pcy,pcz)
c        endif
cbz3/2/99
c        write(101,*)lb1,lb2,lb(i1),lb(i2)
c        write(101,*)em1,em2,e(i1),e(i2),srt
cbz3/2/99end

        return
        end

******************************************
* for pp-->pp + kaon + anti-kaon
c      real*4 function X2kaon(srt)
      real function X2kaon(srt)
      SAVE   
*  This function contains the experimental total pp->pp+K(+)K(-) Xsections    *
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*                                                                             *
******************************************
c     minimum c.m.s. energy to create 2 kaon. = 2*(mp+mk)        
        smin = 2.8639
        x2kaon=0.0000001
        if(srt.lt.smin)return
        sigma1 = 2.8
        sigma2 = 7.7
        sigma3 = 3.9
        x = srt**2/smin**2 + 0.0000001
        f1 = (1.+1./sqrt(x))*alog(x) - 4.*(1.-1./sqrt(x))
        f2 = 1. - (1./sqrt(x))*(1.+alog(sqrt(x)))
        f3 = ((x-1.)/x**2)**3.5
        x2kaon = (1.-1./x)**3*(sigma1*f1 + sigma2*f2) + sigma3*f3
        return
        END

        real function piNsg0(srt)
      SAVE   
* cross section in mb for PI- + P -> P + K0 + K-
c     Mn + 2* Mk
        srt0 = 0.938 + 2.*0.498
        if(srt.lt.srt0) then
           piNsg0 = 0.0
           return
        endif
        ratio = srt0**2/srt**2
        piNsg0=1.121*(1.-ratio)**1.86*ratio**2
        return
        end

        real function akNel(pkaon)
      SAVE   
*cross section in mb for K- + N reactions.
c        the following data come from PRC 41 (1701)
c        sigma1: K(-) + neutron elastic
        if(pkaon.lt.0.5.or. pkaon.ge.4.0) sigma1=0.
        if(pkaon.ge.0.5.and.pkaon.lt.1.0) sigma1=20.*pkaon**2.74
        if(pkaon.ge.1.0.and.pkaon.lt.4.0) sigma1=20.*pkaon**(-1.8)
        akNel=sigma1
        return
        end

        real function akPel(pkaon)
      SAVE   
*cross section in mb for K- + N reactions.
c        the following data come from PRC 41 (1701)
c        sigma2: K(-) + proton elastic
        if(pkaon.lt.0.25.or. pkaon.ge.4.0) sigma2=0.
        if(pkaon.ge.0.25.and.pkaon.lt.4.0) sigma2=13.*pkaon**(-0.9)
        akPel=sigma2
        return
        end

        real function akNsgm(pkaon)
      SAVE   
*cross section in mb for K- + N reactions.
c        sigma2: x section for K- + n -> sigma0 + PI-
        if(pkaon.lt.0.5.or. pkaon.ge.6.0) sigma2=0.
        if(pkaon.ge.0.5.and.pkaon.lt.1.0) sigma2=1.2*pkaon**(-1.3)
        if(pkaon.ge.1.0.and.pkaon.lt.6.0) sigma2=1.2*pkaon**(-2.3)
        akNsgm=sigma2
        return
        end

        real function akPsgm(pkaon)
      SAVE   
*cross section in mb for K- + N reactions.
c        sigma1: x section for K- + p -> sigma0 + PI0
        if(pkaon.lt.0.2.or. pkaon.ge.1.5) sigma1=0.
        if(pkaon.ge.0.2.and.pkaon.lt.1.5) sigma1=0.6*pkaon**(-1.8)
        akPsgm=sigma1
        return
        end

        real function akPlam(pkaon)
      SAVE   
*cross section in mb for K- + N reactions.
c        sigma: x section for K- + p -> lambda + PI0
        p=pkaon
        if(pkaon.lt.0.2.or. pkaon.ge.10.0) sigma=0.
        if(pkaon.ge.0.2.and.pkaon.lt.0.9) sigma=50.*p**2-67.*p+24.
        if(pkaon.ge.0.9.and.pkaon.lt.10.0) sigma=3.0*pkaon**(-2.6)
        akPlam=sigma
        return
        end

        real function akNlam(pkaon)
      SAVE   
*cross section in mb for K- + N reactions.
        akNlam=akPlam(pkaon)
        return
        end

* GQ Li parametrization (without resonance)
        real function akNPsg(pkaon)
      SAVE   
*cross section in mb for K- + N reactions.
c       sigma1: x section for K- + p/n -> sigma0 + PI0
         if(pkaon.le.0.345)then
           sigma1=0.624*pkaon**(-1.83)
         else
           sigma1=0.7*pkaon**(-2.09)
         endif
        akNPsg=sigma1
        return
        end   

c-----------------------------------------------------------------------

c.....extracted from G. Song's ART expasion including K- interactions
c.....file `NEWNNK.FOR'

        subroutine nnkaon(irun,iseed,ictrl,i1,i2,iblock,
     &                                   srt,pcx,pcy,pcz,nchrg)
c        <pt>=0.27+0.037*log(srt) was changed to 0.632 + ... on Aug. 14, 1997
c     CANCELED also alpha=1 changed to alpha=3 to decrease the leadng effect.
      PARAMETER      (MAXSTR=150001,MAXR=1)
      PARAMETER      (AKA=0.498)
      COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
      COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
      COMMON   /EE/  ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      COMMON   /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
      COMMON   /NN/NNN
cc      SAVE /NN/
      COMMON   /RUN/NUM
cc      SAVE /RUN/
      COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
      COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
      COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
      COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      dimension px(4),py(4),pz(4)
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      SAVE   
c      dm1=e(i1)
c      dm2=e(i2)
      dm3=0.938
      dm4=0.938
c     10/24/02 initialize n to 0:
      n=0

cbz3/11/99 neutralk
c        if(nchrg.eq.-2.or.nchrg.ge.3) dm3=1.232
c        if(nchrg.eq.4) dm4=1.232
        if(nchrg.le.-1.or.nchrg.ge.3) dm3=1.232
        if(nchrg.eq.-2.or.nchrg.eq.4) dm4=1.232
cbz3/11/99 neutralk end
          iblock = 0 
        call fstate(iseed,srt,dm3,dm4,px,py,pz,iflag)
        if(iflag.lt.0) then
c           write(60,*)'------------final state fail-------',n
c     no anti-kaon production
           ictrl = -1
           n=n+1
           return
        endif
        iblock = 12
* Rotate the momenta of particles in the cms of I1 & I2
* px(1), py(1), pz(1): momentum of I1
* px(2), py(2), pz(2): momentum of I2
* px(3), py(3), pz(3): momentum of anti-kaon
* px(4), py(4), pz(4): momentum of kaon


c     10/28/02 get rid of argument usage mismatch in rotate():
        pxrota=px(1)
        pyrota=py(1)
        pzrota=pz(1)
c        call rotate(pcx,pcy,pcz,px(1),py(1),pz(1))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        px(1)=pxrota
        py(1)=pyrota
        pz(1)=pzrota
c
        pxrota=px(2)
        pyrota=py(2)
        pzrota=pz(2)
c        call rotate(pcx,pcy,pcz,px(2),py(2),pz(2))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        px(2)=pxrota
        py(2)=pyrota
        pz(2)=pzrota
c
        pxrota=px(3)
        pyrota=py(3)
        pzrota=pz(3)
c        call rotate(pcx,pcy,pcz,px(3),py(3),pz(3))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        px(3)=pxrota
        py(3)=pyrota
        pz(3)=pzrota
c
        pxrota=px(4)
        pyrota=py(4)
        pzrota=pz(4)
c        call rotate(pcx,pcy,pcz,px(4),py(4),pz(4))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        px(4)=pxrota
        py(4)=pyrota
        pz(4)=pzrota

        nnn=nnn+2
c     K+
        lpion(nnn,irun)=23
        if(nchrg.eq.-1.or.nchrg.eq.-2) then
c        To keep charge conservation. D-n->nnK0K-, D-D- -> nD-K0K-

cbz3/7/99 neutralk
c           lpion(nnn,irun)=24 ! K0
cbz3/7/99 neutralk end

        endif
c     aka: rest mass of K
        epion(nnn,irun)=aka
c     K-
        lpion(nnn-1,irun)=21
c     aka: rest mass of K
        epion(nnn-1,irun)=aka
* Find the momenta of particles in the final state in the nucleus_nucleus
* cms frame.   Lorentz transformation into lab frame.
        e1cm   = sqrt(dm3**2 + px(1)**2 + py(1)**2 + pz(1)**2)
        p1beta = px(1)*betax + py(1)*betay + pz(1)*betaz
        transf = gamma * ( gamma*p1beta / (gamma+1) + e1cm)
        pt1i1 = betax*transf + px(1)
        pt2i1 = betay*transf + py(1)
        pt3i1 = betaz*transf + pz(1)
        eti1  = dm3
c        lb1   = lb(i1)
        lb1   = 2
        if(nchrg.ge.-2.and.nchrg.le.1) lb1=2

cbz3/7/99 neutralk
        if (nchrg .eq. -2 .or. nchrg .eq. -1) then
           lb1 = 6
        end if
cbz3/7/99 neutralk end

cbz3/11/99 neutralk
c        if(nchrg.eq.2.or.nchrg.eq.3) lb1=1
c        if(nchrg.eq.4) lb1=9
        if(nchrg.eq.1.or.nchrg.eq.2) lb1=1
        if(nchrg.eq.3.or.nchrg.eq.4) lb1=9
cbz3/11/99 neutralk end

* For second nulceon, same
        e2cm   = sqrt(dm4**2 + px(2)**2 + py(2)**2 + pz(2)**2)
        p2beta = px(2)*betax + py(2)*betay + pz(2)*betaz
        transf = gamma * ( gamma*p2beta / (gamma+1) + e2cm)
        pt1i2 = betax*transf + px(2)
        pt2i2 = betay*transf + py(2)
        pt3i2 = betaz*transf + pz(2)
        eti2  = dm4
c        lb2   = lb(i2)
        lb2   = 2

cbz3/11/99 neutralk
c        if(nchrg.eq.-1.or.nchrg.eq.0) lb2=2
c        if(nchrg.eq. 2.or.nchrg.eq.1) lb2=1
c        if(nchrg.eq. 4.or.nchrg.eq.3) lb2=9
c        if(nchrg.eq.-2) lb2=6
        if(nchrg.ge.-1.or.nchrg.le.1) lb2=2
        if(nchrg.eq. 2.or.nchrg.eq.3) lb2=1
        if(nchrg.eq. 4) lb2=9
        if(nchrg.eq.-2) lb2=6
cbz3/11/99 neutralk end

c        if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0.)then
                p(1,i1)=pt1i1
                p(2,i1)=pt2i1
                p(3,i1)=pt3i1
                e(i1)=eti1
                lb(i1)=lb1
                p(1,i2)=pt1i2
                p(2,i2)=pt2i2
                p(3,i2)=pt3i2
                e(i2)=eti2
                lb(i2)=lb2

c                px1 = p(1,i1)
c                py1 = p(2,i1)
c                pz1 = p(3,i1)
c                em1 = e(i1)
c                id(i1) = 2
c                id(i2) = 2
c                id1 = id(i1)
c                iblock = 101  ! K(+)K(-) production
* Get anti-kaons' momenta and coordinates in nucleus-nucleus cms. frame.
        epcmk = sqrt(epion(nnn-1,irun)**2 + px(3)**2+py(3)**2+pz(3)**2)
        betak = px(3)*betax + py(3)*betay + pz(3)*betaz
        transf= gamma*(gamma*betak/(gamma+1.) + epcmk)
        ppion(1,nnn-1,irun)=betax*transf + px(3)
        ppion(2,nnn-1,irun)=betay*transf + py(3)
        ppion(3,nnn-1,irun)=betaz*transf + pz(3)
        rpion(1,nnn-1,irun)=r(1,i1)
        rpion(2,nnn-1,irun)=r(2,i1)
        rpion(3,nnn-1,irun)=r(3,i1)
clin-5/2008:
        dppion(nnn-1,irun)=dpertp(i1)*dpertp(i2)
* Same thing for kaon **************************************
        epcmak = sqrt(epion(nnn,irun)**2 + px(4)**2 +py(4)**2+pz(4)**2)
        betaak = px(4)*betax + py(4)*betay + pz(4)*betaz
        transf= gamma*(gamma*betaak/(gamma+1.) + epcmak)
        ppion(1,nnn,irun)=betax*transf + px(4)
        ppion(2,nnn,irun)=betay*transf + py(4)
        ppion(3,nnn,irun)=betaz*transf + pz(4)
        rpion(1,nnn,irun)=r(1,i2)
        rpion(2,nnn,irun)=r(2,i2)
        rpion(3,nnn,irun)=r(3,i2)
clin-5/2008:
        dppion(nnn,irun)=dpertp(i1)*dpertp(i2)
        return
        end

        subroutine lorntz(ilo,b,pi,pj)
c       It uses to perform Lorentz (or inverse Lorentz) transformation
        dimension pi(4),pj(4),b(3)
      SAVE   
c       dimension db(3)
        bb=b(1)*b(1)+b(2)*b(2)+b(3)*b(3)
        deno3=sqrt(1.-bb)
        if(deno3.eq.0.)deno3=1.e-10
        gam=1./deno3
        ga=gam*gam/(gam+1.)
        if(ilo.eq.1) goto 100
c       Lorentz transformation
        pib=pi(1)*b(1)+pi(2)*b(2)+pi(3)*b(3)
        pjb=pj(1)*b(1)+pj(2)*b(2)+pj(3)*b(3)
c       drb=drd(1)*b(1)+drd(2)*b(2)+drd(3)*b(3)
c       drdb=db(1)*b(1)+db(2)*b(2)+db(3)*b(3)
        do 1001 i=1,3
           pi(i)=pi(i)+b(i)*(ga*pib-gam*pi(4))
           pj(i)=pj(i)+b(i)*(ga*pjb-gam*pj(4))
c       drd(i)=drd(i)+b(i)*ga*drb
c       db(i)=db(i)+b(i)*ga*drdb
 1001   continue
        pi(4)=gam*(pi(4)-pib)
        pj(4)=gam*(pj(4)-pjb)
        return
100     continue
c       inverse Lorentz transformation
        pib=pi(1)*b(1)+pi(2)*b(2)+pi(3)*b(3)
        pjb=pj(1)*b(1)+pj(2)*b(2)+pj(3)*b(3)
        do 1002 i=1,3
           pi(i)=pi(i)+b(i)*(ga*pib+gam*pi(4))
           pj(i)=pj(i)+b(i)*(ga*pjb+gam*pj(4))
 1002   continue
        pi(4)=gam*(pi(4)+pib)
        pj(4)=gam*(pj(4)+pjb)
        return
        end
        
        subroutine fstate(iseed,srt,dm3,dm4,px,py,pz,iflag)
*        function: decide final momentum for N,N,K(+),and K(-)        
        dimension px(4), py(4), pz(4), pe(4)
        COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   

        iflag=-1
c        iflag=-1: fail to find momenta
c             = 1: success
        pio=3.1415926
        aka=0.498
c        v=0.43
c        w=-0.84
c        b=3.78
c        c=0.47
c        d=3.60
c        fmax=1.056
c        gmax=1.+c

        icount=0
        ekmax=(srt-dm3-dm4)/2.
        if(ekmax.le.aka) return
        pkmax=sqrt(ekmax**2-aka**2)

        if(dm3.le.0.0.or.dm4.le.0.0) then
           write(1,*)'error: minus mass!!!'
           return
        endif

c        after we have the momenta for both nucleus, we sample the
c        transverse momentum for K-. 
c        dsigma/dpt**2 = exp(-4.145*pt**2) obtained by fitting data on
c        page 72, fig 23i.
50        continue
        icount=icount+1
        if(icount.gt.10) return
        ptkmi2=-1./4.145*alog(RANART(NSEED))
        ptkm=sqrt(ptkmi2)
3        v1=RANART(NSEED)
        v2=RANART(NSEED)
        rsq=v1**2+v2**2
        if(rsq.ge.1.0.or.rsq.le.0.) goto 3
        fac=sqrt(-2.*alog(rsq)/rsq)
        guass=v1*fac
        if(guass.ge.5.) goto 3
        xstar=guass/5.
        pzkm=pkmax*xstar
        ekm=sqrt(aka**2+pzkm**2+ptkm**2)
        if(RANART(NSEED).gt.aka/ekm) goto 50
        bbb=RANART(NSEED)
        px(3)=ptkm*cos(2.*pio*bbb)
        py(3)=ptkm*sin(2.*pio*bbb)
        if(RANART(NSEED).gt.0.5) pzkm=-1.*pzkm
        pz(3)=pzkm
        pe(3)=ekm
150        ptkpl2=-1./3.68*alog(RANART(NSEED))
        ptkp=sqrt(ptkpl2)
13        v1=RANART(NSEED)
        v2=RANART(NSEED)
        rsq=v1**2+v2**2
        if(rsq.ge.1.0.or.rsq.le.0.) goto 13
        fac=sqrt(-2.*alog(rsq)/rsq)
        guass=v1*fac
        if(guass.ge.3.25) goto 13
        xstar=guass/3.25
        pzkp=pkmax*xstar
        ekp=sqrt(aka**2+pzkp**2+ptkp**2)
        if(RANART(NSEED).gt.aka/ekp) goto 150
        bbb=RANART(NSEED)
        px(4)=ptkp*cos(2.*pio*bbb)
        py(4)=ptkp*sin(2.*pio*bbb)
        if(RANART(NSEED).gt.0.5) pzkp=-1.*pzkp
        pz(4)=pzkp
        pe(4)=ekp

        resten=srt-pe(3)-pe(4)
        restpz=-pz(3)-pz(4)
c     resample
        if(resten.le.abs(restpz)) goto 50
        restms=sqrt(resten**2-restpz**2)
c     resample 
        if(restms.lt.(dm3+dm4)) goto 50
        ptp2=-1./2.76*alog(RANART(NSEED))
        ptp=sqrt(ptp2)
        bbb=RANART(NSEED)
        px(2)=ptp*cos(2.*pio*bbb)
        py(2)=ptp*sin(2.*pio*bbb)
        px(1)=-1.*(px(4)+px(3)+px(2))
        py(1)=-1.*(py(4)+py(3)+py(2))
c     transverse mass for K-
        rmt3=sqrt(dm3**2+px(1)**2+py(1)**2)
c     transverse mass for K+
        rmt4=sqrt(dm4**2+px(2)**2+py(2)**2)
        if(restms.lt.(rmt3+rmt4)) goto 50
c        else: sampling success!
        pzcms=sqrt((restms**2-(rmt3+rmt4)**2)*
     &             (restms**2-(rmt3-rmt4)**2))/2./restms
        if(RANART(NSEED).gt.0.5) then
           pz(1)=pzcms
           pz(2)=-pzcms
        else
           pz(1)=-pzcms
           pz(2)=pzcms
        endif
        beta=restpz/resten        
        gama=1./sqrt(1.-beta**2)
        pz(1)=pz(1)*gama + beta*gama*sqrt(rmt3**2+pz(1)**2)
        pz(2)=pz(2)*gama + beta*gama*sqrt(rmt4**2+pz(2)**2)
        pe(1)=sqrt(rmt3**2+pz(1)**2)
        pe(2)=sqrt(rmt4**2+pz(2)**2)

        iflag=1
        return
        end

c-----------------------------------------------------------------------

c.....extracted from G. Song's ART expasion including K- interactions
c.....file `NPIK.FOR'

****************************************
c        subroutine npik(irun,iseed,dt,nt,ictrl,i1,i2,srt,
c     &                  pcx,pcy,pcz,nchrg,ratiok)
        subroutine npik(irun,iseed,dt,nt,ictrl,i1,i2,srt,
     &                  pcx,pcy,pcz,nchrg,ratiok,iblock)
*
* Process: PI + N -> K(-) + ANYTHING
* 1.  PI- + P -> P + K0 + K-
* 2.  PI+ + N -> P + K+ + K- 
* 3.  PI0 + P -> P + K+ + K-
* 4.  PI0 + N -> P + K0 + K-
* 5.  PI0 + N -> N + K+ + K-
* 6.  PI- + P -> N + K+ + K-
* 7.  PI- + N -> N + K0 + K-
* NOTE: the mass of K is assumed to be same as K0. ie. 0.498 NOT 0.494
****************************************
      PARAMETER      (MAXSTR=150001,MAXR=1,PI=3.1415926)
      PARAMETER      (AKA=0.498)
      COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
      COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
      COMMON   /EE/  ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      COMMON   /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
      COMMON   /NN/NNN
cc      SAVE /NN/
      COMMON   /RUN/NUM
cc      SAVE /RUN/
      COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
      COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
      COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
      COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      dimension bb(3),p1(4),p2(4),p3(4),px(4),py(4),pz(4)
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      SAVE   
        px1cm=pcx
        py1cm=pcy
        pz1cm=pcz
        ictrl = 1
        lb1=lb(i1)
        lb2=lb(i2)
        k1=i1
        k2=i2
c        k1 must be bayron. k2 be meson. If not, exchange.
        if(lb2.eq.1.or.lb2.eq.2.or.(lb2.ge.6.and.lb2.le.13)) then
            k1=i2
            k2=i1
        endif
cbz3/8/99 neutralk
cbz10/12/99
c        LB(I1) = 1 + 2 * RANART(NSEED)
c        LB(I2) = 23
        LB(k1) = 1 + int(2*RANART(NSEED))
        LB(k2) = 23
c       pkmax=sqrt((srt**2-(aka+0.938+aka)**2)*(srt**2-(aka+0.938-aka)**2))
c     &           /2./srt
        pkmax=sqrt((srt**2-(aka+0.938+aka)**2)
     &           *(srt**2-(aka+0.938-aka)**2))/2./srt
        pk = RANART(NSEED)*pkmax
c-----------------------------------------------------
        css=1.-2.*RANART(NSEED)
        sss=sqrt(1.-css**2)
        fai=2*3.1415926*RANART(NSEED)
        p3(1)=pk*sss*cos(fai)
        p3(2)=pk*sss*sin(fai)
        p3(3)=pk*css
        eip = srt - sqrt(aka**2 + pk**2)
        rmnp=sqrt(eip**2-pk**2)
        do 1001 i= 1, 3
           bb(i) = -1.*p3(i)/eip
 1001   continue
c        bb: velocity of the other two particles as a whole.
        pznp=sqrt((rmnp**2-(aka+0.938)**2)
     c  *(rmnp**2-(0.938-aka)**2))/2./rmnp    
c-----------------------------------------------------
        css=1.-2.*RANART(NSEED)
        sss=sqrt(1.-css**2)
        fai=2*3.1415926*RANART(NSEED)
        p1(1)=pznp*sss*cos(fai)
        p1(2)=pznp*sss*sin(fai)
        p1(3)=pznp*css
        p1(4)=sqrt(0.938**2+pznp**2)
        p2(4)=sqrt(aka**2+pznp**2)
        do 1002 i=1,3
           p2(i)=-1.*p1(i)
 1002   continue
c        p1,p2: the momenta of the two particles in their cms
c        p1: momentum of N or P
c        p2: momentum of anti_kaon
c        p3: momentum of K0 or K+
        ilo=1
c        write(61,*)'--------p1,p2',p1,p2
c        write(61,*)'--------bb',bb
        call lorntz(ilo,bb,p1,p2)
c******* Checking *************
c        pxsum = p1(1)+p2(1)+p3(1)
c        pysum = p1(2)+p2(2)+p3(2)
c        pzsum = p1(3)+p2(3)+p3(3)
c        pesum = p1(4)+p2(4)+sqrt(p3(1)**2+p3(2)**2+p3(3)**2+aka**2)-srt
c        write(61,*)'---p1,pxsum',p1,pxsum
c        write(61,*)'---p2,pysum',p2,pysum
c        write(61,*)'---p3,pzsum',p3,pzsum
c        write(61,*)'---pesum',pesum
c***********************************

* Rotate the momenta of particles in the cms of I1 & I2
* px(1), py(1), pz(1): momentum of I1
* px(2), py(2), pz(2): momentum of I2
* px(3), py(3), pz(3): momentum of anti-kaon

c     10/28/02 get rid of argument usage mismatch in rotate():
        pxrota=p1(1)
        pyrota=p1(2)
        pzrota=p1(3)
c        call rotate(pcx,pcy,pcz,p1(1),p1(2),p1(3))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        p1(1)=pxrota
        p1(2)=pyrota
        p1(3)=pzrota
c
        pxrota=p2(1)
        pyrota=p2(2)
        pzrota=p2(3)
c        call rotate(pcx,pcy,pcz,p2(1),p2(2),p2(3))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        p2(1)=pxrota
        p2(2)=pyrota
        p2(3)=pzrota
c
        pxrota=p3(1)
        pyrota=p3(2)
        pzrota=p3(3)
c        call rotate(pcx,pcy,pcz,p3(1),p3(2),p3(3))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        p3(1)=pxrota
        p3(2)=pyrota
        p3(3)=pzrota

        nnn=nnn+1
c     K(-)
        lpion(nnn,irun)=21
c     aka: rest mass of K
        epion(nnn,irun)=aka
* Find the momenta of particles in the final state in the nucleus_nucleus
* cms frame.   Lorentz transformation into lab frame.
        e1cm   = sqrt(0.938**2 + p1(1)**2 + p1(2)**2 + p1(3)**2)
        p1beta = p1(1)*betax + p1(2)*betay + p1(3)*betaz
        transf = gamma * ( gamma*p1beta / (gamma+1) + e1cm)
        pt1i1 = betax*transf + p1(1)
        pt2i1 = betay*transf + p1(2)
        pt3i1 = betaz*transf + p1(3)
        eti1  = 0.938
        lb1   = lb(k1)
         
* For second nulceon, same
        e2cm   = sqrt(aka**2 + p3(1)**2 + p3(2)**2 + p3(3)**2)
        p2beta = p3(1)*betax + p3(2)*betay + p3(3)*betaz
        transf = gamma * ( gamma*p2beta / (gamma+1) + e2cm)
        pt1i2 = betax*transf + p3(1)
        pt2i2 = betay*transf + p3(2)
        pt3i2 = betaz*transf + p3(3)
        eti2  = aka
        lb2   = lb(k2)

c        if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0.)then
*       k1 stand for nucleon, k2 stand for kaon. lpion stand for Kbar.
                p(1,k1)=pt1i1
                p(2,k1)=pt2i1
                p(3,k1)=pt3i1
                e(k1)=eti1
                lb(k1)=lb1
                p(1,k2)=pt1i2
                p(2,k2)=pt2i2
                p(3,k2)=pt3i2
                e(k2)=eti2
                lb(k2)=lb2

c                px1 = p(1,i1)
c                py1 = p(2,i1)
c                pz1 = p(3,i1)
c                em1 = e(i1)
c                id(i1) = 2
c                id(i2) = 2
c                id1 = id(i1)
c     K(+)K(-) production
                iblock = 101
* Get Kaons' momenta and coordinates in nucleus-nucleus cms. frame.
c  p2:  momentum of anti-kaon.
c        epcmk = sqrt(epion(nnn,irun)**2 + p2(1)**2 + p2(2)**2 + p2(3)**2)
        epcmk = sqrt(epion(nnn,irun)**2 + p2(1)**2+p2(2)**2+p2(3)**2)
        betak = p2(1)*betax + p2(2)*betay + p2(3)*betaz
        transf= gamma*(gamma*betak/(gamma+1.) + epcmk)
        ppion(1,nnn,irun)=betax*transf + p2(1)
        ppion(2,nnn,irun)=betay*transf + p2(2)
        ppion(3,nnn,irun)=betaz*transf + p2(3)
clin-5/2008:
        dppion(nnn,irun)=dpertp(i1)*dpertp(i2)
cbz3/2/99
c        write(400,*)'2 ', ppion(1,nnn,irun), ppion(2,nnn,irun),
c     &                    ppion(3,nnn,irun), dt*nt, srt
cbz3/2/99end
c        write(420,*)ppion(1,nnn,irun), ppion(2,nnn,irun),
c     &                    ppion(3,nnn,irun), dt*nt, srt
        k=i2
        if(lb(i1).eq.1.or.lb(i1).eq.2) k=i1
        rpion(1,nnn,irun)=r(1,k)
        rpion(2,nnn,irun)=r(2,k)
        rpion(3,nnn,irun)=r(3,k)
        return
        end

c-----------------------------------------------------------------------

c.....extracted from G. Song's ART expasion including K- interactions
c.....file `PIHYPN.FOR'

******************************************
        subroutine pihypn(ielstc,irun,iseed,dt,nt,ictrl,i1,i2,
     &     srt,pcx,pcy,pcz,nchrg,iblock)
*
* Process: PI + sigma(or Lambda) -> Kbar + N
* NOTE: the mass of K is assumed to be same as K0. ie. 0.498 NOT 0.494
******************************************

c NOTE: for PI + Hyperon: the produced kaons have mass 0.498
      PARAMETER      (MAXSTR=150001,MAXR=1,PI=3.1415926)
      PARAMETER      (AKA=0.498)
      COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
      COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
      COMMON   /EE/  ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      COMMON   /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
      COMMON   /NN/NNN
cc      SAVE /NN/
      COMMON   /RUN/NUM
cc      SAVE /RUN/
      COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
      COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
      COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
      COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      dimension p1(4),p2(4)
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
        px1cm=pcx
        py1cm=pcy
        pz1cm=pcz
        ictrl = 1
csp06/07/01
        if(ielstc .eq. 1) then
*    L/Si + meson -> L/Si + meson
             k1=i1
             k2=i2
           dm3=e(k1)
           dm4=e(k2)
           iblock = 10
        else
           iblock = 12
csp06/07/01 end  
c        PI + Sigma(or Lambda) -> Kbar + N
        k1=i1
        k2=i2
c        k1 must be bayron! So if I1 is PI, exchange k1 & k2.
        if(lb(i1).lt.14.or.lb(i1).gt.17) then
           k1=i2
           k2=i1
        endif
cbz3/8/99 neutralk
        LB(K1) = 1 + int(2*RANART(NSEED))
        if(nchrg.eq.-2) lb(k1)=6
c     if(nchrg.eq.-1) lb(k1)=2
c     if(nchrg.eq. 0) lb(k1)=1
c     if(nchrg.eq. 1) lb(k1)=9
        IF (NCHRG .EQ. 2) LB(K1) = 9
cbz3/8/99 neutralk end

c     K-
        lb(k2)=21
        dm3=0.938
        if(nchrg.eq.-2.or.nchrg.eq.1) dm3=1.232
        dm4=aka
c        dm3,dm4: the mass of final state particles.
         endif
    
********Now, antikaon will be created.
c        call antikaon_fstate(iseed,srt,dm1,dm2,dm3,dm4,px,py,pz,icou1)
c        pkmax: the maximum momentum of anti-kaon
        pkmax=sqrt((srt**2-(dm3+dm4)**2)*(srt**2-(dm3-dm4)**2))
     &         /2./srt
        pk=pkmax
c-----------------------------------------------------
        css=1.-2.*RANART(NSEED)
        sss=sqrt(1.-css**2)
        fai=2*3.1415926*RANART(NSEED)
        p1(1)=pk*sss*cos(fai)
        p1(2)=pk*sss*sin(fai)
        p1(3)=pk*css
        do 1001 i=1,3
           p2(i)=-1.*p1(i)
 1001   continue
c        p1,p2: the momenta of the two particles in their cms
c        p1: momentum of kaon
c        p2: momentum of Kbar

* Rotate the momenta of particles in the cms of I1 & I2
clin-10/28/02 get rid of argument usage mismatch in rotate():
        pxrota=p1(1)
        pyrota=p1(2)
        pzrota=p1(3)
c        call rotate(pcx,pcy,pcz,p1(1),p1(2),p1(3))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        p1(1)=pxrota
        p1(2)=pyrota
        p1(3)=pzrota
c
        pxrota=p2(1)
        pyrota=p2(2)
        pzrota=p2(3)
c        call rotate(pcx,pcy,pcz,p2(1),p2(2),p2(3))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        p2(1)=pxrota
        p2(2)=pyrota
        p2(3)=pzrota
clin-10/28/02-end

* Find the momenta of particles in the final state in the nucleus_nucleus
* cms frame.   Lorentz transformation into lab frame.
        e1cm   = sqrt(dm3**2 + p1(1)**2 + p1(2)**2 + p1(3)**2)
        p1beta = p1(1)*betax + p1(2)*betay + p1(3)*betaz
        transf = gamma * ( gamma*p1beta / (gamma+1) + e1cm)
        pt1i1 = betax*transf + p1(1)
        pt2i1 = betay*transf + p1(2)
        pt3i1 = betaz*transf + p1(3)
        eti1  = dm3
        lb1   = lb(k1)
         
* For second kaon, same
        e2cm   = sqrt(dm4**2 + p2(1)**2 + p2(2)**2 + p2(3)**2)
        p2beta = p2(1)*betax + p2(2)*betay + p2(3)*betaz
        transf = gamma * ( gamma*p2beta / (gamma+1) + e2cm)
        pt1i2 = betax*transf + p2(1)
        pt2i2 = betay*transf + p2(2)
        pt3i2 = betaz*transf + p2(3)
cbz3/2/99
c        write(400,*)'3 ', pt1i2, pt2i2, pt3i2, dt*nt, srt
cbz3/2/99end
c        write(430,*)pt1i2, pt2i2, pt3i2, dt*nt, srt
        eti2  = dm4
        lb2   = lb(k2)

c        if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0.)then
c        k1=i1
c        k2=i2
*       k1 stand for nucleon, k2 stand for kaon.
                p(1,k1)=pt1i1
                p(2,k1)=pt2i1
                p(3,k1)=pt3i1
                e(k1)=eti1
                lb(k1)=lb1
                p(1,k2)=pt1i2
                p(2,k2)=pt2i2
                p(3,k2)=pt3i2
                e(k2)=eti2
                lb(k2)=lb2

cc                iblock = 101  ! K(+)K(-) production
* Get Kaons' momenta and coordinates in nucleus-nucleus cms. frame.
        return
        end

c-----------------------------------------------------------------------

c.....extracted from G. Song's ART expasion including K- interactions
c.....file `KAONN.FOR'

****************************************
        subroutine kaonN(brel,brsgm,irun,iseed,dt,nt,
     &     ictrl,i1,i2,iblock,srt,pcx,pcy,pcz,nchrg)
*
* Process: PI + sigma(or Lambda) <- Kbar + N
* NOTE: the mass of K is assumed to be same as K0. ie. 0.498 NOT 0.494
****************************************
      PARAMETER      (MAXSTR=150001,MAXR=1,PI=3.1415926)
      PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
      COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
      COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
      COMMON   /EE/  ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      COMMON   /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
      COMMON   /NN/NNN
cc      SAVE /NN/
      COMMON   /RUN/NUM
cc      SAVE /RUN/
      COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
      COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
      COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
      COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      dimension p1(4),p2(4)
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
        px1cm=pcx
        py1cm=pcy
        pz1cm=pcz
        ictrl = 1
c        ratio: used for isospin decision.
        k1=i1
        k2=i2
c        k1 must be bayron! So if I1 is Kaon, exchange k1 & k2.
        if(e(i1).lt.0.5.and.e(i1).gt.0.01) then
           k1=i2
           k2=i1
        endif
*** note: for print out only *******************************
c     record kaon's mass
        eee=e(k2)
*** end **************
        rrr=RANART(NSEED)
        if(rrr.lt.brel) then
c       Kbar + N -> Kbar + N
           lb1=lb(k1)
           lb2=lb(k2)
           em1=e(k1)
           em2=e(k2)
           iblock = 10
        else 
           iblock = 12
        if(rrr.lt.(brel+brsgm)) then
c        nchrg: Net charges of the two incoming particles.
c           Kbar + N -> Sigma + PI
           em1=asa
           em2=0.138

cbz3/8/99 neutralk
           LB1 = 15 + int(3*RANART(NSEED))
           LB2 = 3 + int(3*RANART(NSEED))
        else
c           Kbar + N -> Lambda + PI
           em1=ala
           em2=0.138
c     LAmbda
           lb1=14
cbz3/8/99 neutralk
           LB2 = 3 + int(3*RANART(NSEED))
c           if(nchrg.eq.1)  lb2=5  ! K- + D++ -> Lambda + PI+
c           if(nchrg.eq.0)  lb2=4  ! K- + p(D+,N*+) -> Lambda + PI0
c          if(nchrg.eq.-1) lb2=3 ! K- + n(D,N*) -> Lambda + PI-
cbz3/8/99 neutralk

        endif
        endif
        lb(k1)=lb1
        lb(k2)=lb2
    
********Now, antikaon will be created.
c        call antikaon_fstate(iseed,srt,dm1,dm2,dm3,dm4,px,py,pz,icou1)
c        pkmax: the maximum momentum of anti-kaon
c        write(63,*)'srt,em1,em2',srt,em1,em2
c        write(63,*)'-srt,em1,em2',srt,em1,em2
        pkmax=sqrt((srt**2-(em1+em2)**2)*(srt**2-(em1-em2)**2))
     &         /2./srt
        pk=pkmax
c-----------------------------------------------------
        css=1.-2.*RANART(NSEED)
        sss=sqrt(1.-css**2)
        fai=2*3.1415926*RANART(NSEED)
        p1(1)=pk*sss*cos(fai)
        p1(2)=pk*sss*sin(fai)
        p1(3)=pk*css
        do 1001 i=1,3
           p2(i)=-1.*p1(i)
 1001   continue
c        p1,p2: the momenta of the two particles in their cms
c        p1: momentum of kaon
c        p2: momentum of Kbar

* Rotate the momenta of particles in the cms of I1 & I2

clin-10/28/02 get rid of argument usage mismatch in rotate():
        pxrota=p1(1)
        pyrota=p1(2)
        pzrota=p1(3)
c        call rotate(pcx,pcy,pcz,p1(1),p1(2),p1(3))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        p1(1)=pxrota
        p1(2)=pyrota
        p1(3)=pzrota
c
        pxrota=p2(1)
        pyrota=p2(2)
        pzrota=p2(3)
c        call rotate(pcx,pcy,pcz,p2(1),p2(2),p2(3))
        call rotate(pcx,pcy,pcz,pxrota,pyrota,pzrota)
        p2(1)=pxrota
        p2(2)=pyrota
        p2(3)=pzrota
clin-10/28/02-end

* Find the momenta of particles in the final state in the nucleus_nucleus
* cms frame.   Lorentz transformation into lab frame.
        e1cm   = sqrt(em1**2 + p1(1)**2 + p1(2)**2 + p1(3)**2)
        p1beta = p1(1)*betax + p1(2)*betay + p1(3)*betaz
        transf = gamma * ( gamma*p1beta / (gamma+1) + e1cm)
        pt1i1 = betax*transf + p1(1)
        pt2i1 = betay*transf + p1(2)
        pt3i1 = betaz*transf + p1(3)
        eti1  = em1
         
* For second kaon, same
        e2cm   = sqrt(em2**2 + p2(1)**2 + p2(2)**2 + p2(3)**2)
        p2beta = p2(1)*betax + p2(2)*betay + p2(3)*betaz
        transf = gamma * ( gamma*p2beta / (gamma+1) + e2cm)
        pt1i2 = betax*transf + p2(1)
        pt2i2 = betay*transf + p2(2)
        pt3i2 = betaz*transf + p2(3)
        eti2  = em2

c        if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0.)then
c        k1=i1
c        k2=i2
*       k1 stand for bayron, k2 stand for meson.
                p(1,k1)=pt1i1
                p(2,k1)=pt2i1
                p(3,k1)=pt3i1
                e(k1)=eti1
                p(1,k2)=pt1i2
                p(2,k2)=pt2i2
                p(3,k2)=pt3i2
                e(k2)=eti2

cc                iblock = 101  ! K(+)K(-) production
* Get Kaons' momenta and coordinates in nucleus-nucleus cms. frame.
        return
        end

c=======================================================================

clin Below is the previous artana.f:
c=======================================================================

c.....analysis subroutine before the hadronic space-time evolution

      SUBROUTINE ARTAN1
      PARAMETER (MAXSTR=150001, MAXR=1)
c.....y cut for mt spectrum
cbz3/17/99
c      PARAMETER (YMT1 = -0.4, YMT2 = 0.4)
      PARAMETER (YMT1 = -1.0, YMT2 = 1.0)
cbz3/17/99 end
c.....bin width for mt spectrum and y spectrum
clin-9/26/03 no symmetrization in y (or eta) for ana/*.dat:
c      PARAMETER (BMT = 0.05, BY = 0.2)
      PARAMETER (BMT = 0.05, BY = 0.4)
      COMMON /RUN/ NUM
cc      SAVE /RUN/
      COMMON /ARERC1/MULTI1(MAXR)
cc      SAVE /ARERC1/
      COMMON /ARPRC1/ITYP1(MAXSTR, MAXR),
     &     GX1(MAXSTR, MAXR), GY1(MAXSTR, MAXR), GZ1(MAXSTR, MAXR), 
     &     FT1(MAXSTR, MAXR),
     &     PX1(MAXSTR, MAXR), PY1(MAXSTR, MAXR), PZ1(MAXSTR, MAXR),
     &     EE1(MAXSTR, MAXR), XM1(MAXSTR, MAXR)
cbz3/17/99
c     &     dm1k0s(50), DMT1LA(50), DMT1LB(50)
cc      SAVE /ARPRC1/
      COMMON /ARANA1/
     &     dy1ntb(50), dy1ntp(50), DY1HM(50), 
     &     DY1KP(50), DY1KM(50), DY1K0S(50),
     &     DY1LA(50), DY1LB(50), DY1PHI(50),
     &     dm1pip(50), dm1pim(50), DMT1PR(50),
     &     DMT1PB(50), DMT1KP(50), dm1km(50),
     &     dm1k0s(50), DMT1LA(50), DMT1LB(50),
     &     dy1msn(50), DY1PIP(50), DY1PIM(50), 
     &     DY1PI0(50), DY1PR(50), DY1PB(50)
     &     ,DY1NEG(50), DY1CH(50), DE1NEG(50), DE1CH(50)
cc      SAVE /ARANA1/
      SAVE   

cbz3/17/99 end
      DO 1002 J = 1, NUM
         DO 1001 I = 1, MULTI1(J)
            ITYP = ITYP1(I, J)
            PX = PX1(I, J)
            PY = PY1(I, J)
            PZ = PZ1(I, J)
            EE = EE1(I, J)
            XM = XM1(I, J)
c     2/24/03 leptons and photons:
            if(xm.lt.0.01) goto 200
            ptot = sqrt(PX ** 2 + PY ** 2 + pz ** 2)
clin-9/2012 determine pseudo-rapidity more generally:
c            eta = 0.5*alog((Ptot+pz+1e-5)/(ptot-pz+1e-5))
            if((PX**2+PY**2).gt.0.) then
               eta=asinh(PZ/sqrt(PX**2+PY**2))
            else
               eta = 1000000.0*sign(1.,PZ)
clin-2/2013 for spectator target nucleons in LAB frame,
c     note that finite precision of HBOOST 
c     would give spectator target nucleons a small but non-zero pz:
               if(abs(pz).le.1e-3) eta=0.
            endif

            XMT = SQRT(PX ** 2 + PY ** 2 + XM ** 2)
            DXMT = XMT - XM
clin-9/2012 determine rapidity more generally:
c            IF (ABS(PZ) .GE. EE) THEN
c               PRINT *, 'IN ARTAN1'
c               PRINT *, 'PARTICLE ', I, ' RUN ', J, 'PREC ERR'
ccbzdbg2/16/99
c               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
ccbzdbg2/16/99
ccbzdbg2/15/99
c               PRINT *, ' PZ = ', PZ, ' EE = ', EE
ccbzdbg2/16/99
c               PRINT *, ' XM = ', XM
ccbzdbg2/16/99end
c               GOTO 200
c            else
cc            Y = 0.5 * LOG((EE + PZ) / (EE - PZ))
c               Y = 0.5 * LOG((EE + PZ +1e-5) / (EE - PZ +1e-5))
cc               STOP
ccbzdbg2/15/99end
c            END IF
            if(XMT.gt.0.) then
               Y=asinh(PZ/XMT)
            else
               PRINT *, ' IN ARTAN1 mt=0'
               Y = 1000000.0*sign(1.,PZ)
            endif

c.....rapidity cut for the rapidity distribution
            IF (ABS(Y) .GE. 10.0) GOTO 100
clin-9/26/03 no symmetrization in y (or eta) for ana/*.dat:
c            IY = 1 + int(ABS(Y) / BY)
c            Ieta = 1 + int(ABS(eta) / BY)
            IF (ABS(eta) .GE. 10.0) GOTO 100
            IY = 1 + int((Y+10.) / BY)
            Ieta = 1 + int((eta+10.) / BY)

            IF (ITYP .LT. -1000) THEN
               dy1ntb(IY) = dy1ntb(IY) - 1.0
            END IF
            IF (ITYP .GT. 1000) THEN
               dy1ntb(IY) = dy1ntb(IY) + 1.0
            END IF
            IF (ITYP .EQ. -2212) THEN
               dy1ntp(IY) = dy1ntp(IY) - 1.0
            END IF
            IF (ITYP .EQ. 2212) THEN
               dy1ntp(IY) = dy1ntp(IY) + 1.0
            END IF
c            IF (ITYP .EQ. -211 .OR. ITYP .EQ. -321 .OR.
c     &         ITYP .EQ. -2212) THEN
            IF (ITYP .EQ. -2112) THEN
               DY1HM(IY) = DY1HM(IY) + 1.0
            END IF
c
            IF (LUCHGE(ITYP).ne.0) THEN
               DY1CH(IY) = DY1CH(IY) + 1.0
               DE1CH(Ieta) = DE1CH(Ieta) + 1.0
               IF (LUCHGE(ITYP).lt.0) THEN
                  DY1NEG(IY) = DY1NEG(IY) + 1.0
                  DE1NEG(Ieta) = DE1NEG(Ieta) + 1.0
               endif
            END IF

cbz3/17/99
            IF ((ITYP .GE. 100 .AND. ITYP .LT. 1000) .OR. 
     &         (ITYP .GT. -1000 .AND. ITYP .LE. -100)) THEN
               dy1msn(IY) = dy1msn(IY) + 1.0
            END IF
            IF (ITYP .EQ. 211) THEN
               DY1PIP(IY) = DY1PIP(IY) + 1.0
            END IF
            IF (ITYP .EQ. -211) THEN
               DY1PIM(IY) = DY1PIM(IY) + 1.0
            END IF
            IF (ITYP .EQ. 111) THEN
               DY1PI0(IY) = DY1PI0(IY) + 1.0
            END IF
            IF (ITYP .EQ. 2212) THEN
               DY1PR(IY) = DY1PR(IY) + 1.0
            END IF
            IF (ITYP .EQ. -2212) THEN
               DY1PB(IY) = DY1PB(IY) + 1.0
            END IF
cbz3/17/99 end
            IF (ITYP .EQ. 321) THEN
               DY1KP(IY) = DY1KP(IY) + 1.0
            END IF
            IF (ITYP .EQ. -321) THEN
               DY1KM(IY) = DY1KM(IY) + 1.0
            END IF
clin-4/24/03 evaluate K0L instead of K0S, since sometimes we may decay K0S:
c            IF (ITYP .EQ. 310) THEN
            IF (ITYP .EQ. 130) THEN
               DY1K0S(IY) = DY1K0S(IY) + 1.0
            END IF
            IF (ITYP .EQ. 3122) THEN
               DY1LA(IY) = DY1LA(IY) + 1.0
            END IF
            IF (ITYP .EQ. -3122) THEN
               DY1LB(IY) = DY1LB(IY) + 1.0
            END IF
            IF (ITYP .EQ. 333) THEN
               DY1PHI(IY) = DY1PHI(IY) + 1.0
            END IF

c.....insert rapidity cut for mt spectrum here
 100        IF (Y .LT. YMT1 .OR. Y .GT. YMT2) GOTO 200
            IF (DXMT .GE. 50.0 * BMT .OR. DXMT .EQ. 0) GOTO 200
            IMT = 1 + int(DXMT / BMT)
            IF (ITYP .EQ. 211) THEN
               dm1pip(IMT) = dm1pip(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. -211) THEN
               dm1pim(IMT) = dm1pim(IMT) + 
     &            1.0 / XMT
            END IF
            IF (ITYP .EQ. 2212) THEN
               DMT1PR(IMT) = DMT1PR(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. -2212) THEN
               DMT1PB(IMT) = DMT1PB(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. 321) THEN
               DMT1KP(IMT) = DMT1KP(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. -321) THEN
               dm1km(IMT) = dm1km(IMT) + 1.0 / XMT
            END IF
clin-4/24/03:
c            IF (ITYP .EQ. 310) THEN
            IF (ITYP .EQ. 130) THEN
               dm1k0s(IMT) = dm1k0s(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. 3122) THEN
               DMT1LA(IMT) = DMT1LA(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. -3122) THEN
               DMT1LB(IMT) = DMT1LB(IMT) + 1.0 / XMT
            END IF

 200        CONTINUE
 1001    CONTINUE
 1002 CONTINUE

      RETURN
      END

c-----------------------------------------------------------------------

c.....analysis subroutine after the hadronic space-time evolution

      SUBROUTINE ARTAN2

      PARAMETER (MAXSTR=150001, MAXR=1)
c.....y cut for mt spectrum
cbz3/17/99
c      PARAMETER (YMT1 = -0.4, YMT2 = 0.4)
      PARAMETER (YMT1 = -1.0, YMT2 = 1.0)
cbz3/17/99 end
c.....bin width for mt spectrum and y spectrum
c      PARAMETER (BMT = 0.05, BY = 0.2)
      PARAMETER (BMT = 0.05, BY = 0.4)
      COMMON /RUN/ NUM
cc      SAVE /RUN/
      COMMON /ARERC1/MULTI1(MAXR)
cc      SAVE /ARERC1/
      COMMON /ARPRC1/ITYP1(MAXSTR, MAXR),
     &     GX1(MAXSTR, MAXR), GY1(MAXSTR, MAXR), GZ1(MAXSTR, MAXR), 
     &     FT1(MAXSTR, MAXR),
     &     PX1(MAXSTR, MAXR), PY1(MAXSTR, MAXR), PZ1(MAXSTR, MAXR),
     &     EE1(MAXSTR, MAXR), XM1(MAXSTR, MAXR)
cbz3/17/99
c     &     dm2k0s(50), DMT2LA(50), DMT2LB(50)
cc      SAVE /ARPRC1/
      COMMON /ARANA2/
     &     dy2ntb(50), dy2ntp(50), DY2HM(50), 
     &     DY2KP(50), DY2KM(50), DY2K0S(50),
     &     DY2LA(50), DY2LB(50), DY2PHI(50),
     &     dm2pip(50), dm2pim(50), DMT2PR(50),
     &     DMT2PB(50), DMT2KP(50), dm2km(50),
     &     dm2k0s(50), DMT2LA(50), DMT2LB(50),
     &     dy2msn(50), DY2PIP(50), DY2PIM(50), 
     &     DY2PI0(50), DY2PR(50), DY2PB(50)
     &     ,DY2NEG(50), DY2CH(50), DE2NEG(50), DE2CH(50)
cbz3/17/99 end
cc      SAVE /ARANA2/
      SAVE   

      DO 1002 J = 1, NUM
         DO 1001 I = 1, MULTI1(J)
            ITYP = ITYP1(I, J)
            PX = PX1(I, J)
            PY = PY1(I, J)
            PZ = PZ1(I, J)
            EE = EE1(I, J)
            XM = XM1(I, J)
            XMT = SQRT(PX ** 2 + PY ** 2 + XM ** 2)
c     2/24/03 leptons and photons:
            if(xm.lt.0.01) goto 200
            DXMT = XMT - XM
            ptot = sqrt(PX ** 2 + PY ** 2 + pz ** 2)
clin-9/2012 determine pseudo-rapidity more generally:
c            eta = 0.5*alog((Ptot+pz+1e-5)/(ptot-pz+1e-5))
            if((PX**2+PY**2).gt.0.) then
               eta=asinh(PZ/sqrt(PX**2+PY**2))
            else
               eta = 1000000.0*sign(1.,PZ)
clin-2/2013 for spectator target nucleons in LAB frame:
               if(abs(pz).le.1e-3) eta=0.
            endif

clin-9/2012 determine rapidity more generally:
c            IF (ABS(PZ) .GE. EE) THEN
c               PRINT *, 'IN ARTAN2'
c               PRINT *, 'PARTICLE ', I, ' RUN ', J, 'PREC ERR'
ccbzdbg2/16/99
c               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
ccbzdbg2/16/99
ccbzdbg2/15/99
c               PRINT *, ' PZ = ', PZ, ' EE = ', EE
ccbzdbg2/16/99
c               PRINT *, ' XM = ', XM
ccbzdbg2/16/99end
c               GOTO 200
cc               STOP
ccbzdbg2/15/99end
c            END IF
c            Y = 0.5 * LOG((EE + PZ +1e-5) / (EE - PZ + 1e-5))
            if(XMT.gt.0.) then
               Y=asinh(PZ/XMT)
            else
               PRINT *, ' IN ARTAN2 mt=0'
               Y = 1000000.0*sign(1.,PZ)
            endif

c.....rapidity cut for the rapidity distribution
            IF (ABS(Y) .GE. 10.0) GOTO 100
c            IY = 1 + int(ABS(Y) / BY)
c            Ieta = 1 + int(ABS(eta) / BY)
            IF (ABS(eta) .GE. 10.0) GOTO 100
            IY = 1 + int((Y+10.) / BY)
            Ieta = 1 + int((eta+10.) / BY)

            IF (ITYP .LT. -1000) THEN
               dy2ntb(IY) = dy2ntb(IY) - 1.0
            END IF
            IF (ITYP .GT. 1000) THEN
               dy2ntb(IY) = dy2ntb(IY) + 1.0
            END IF
            IF (ITYP .EQ. -2212) THEN
               dy2ntp(IY) = dy2ntp(IY) - 1.0
            END IF
            IF (ITYP .EQ. 2212) THEN
               dy2ntp(IY) = dy2ntp(IY) + 1.0
            END IF
            IF (ITYP .EQ. -2112) THEN
               DY2HM(IY) = DY2HM(IY) + 1.0
            END IF

            IF (LUCHGE(ITYP).ne.0) THEN
               DY2CH(IY) = DY2CH(IY) + 1.0
               DE2CH(Ieta) = DE2CH(Ieta) + 1.0
               IF (LUCHGE(ITYP).lt.0) THEN
                  DY2NEG(IY) = DY2NEG(IY) + 1.0
                  DE2NEG(Ieta) = DE2NEG(Ieta) + 1.0
               endif
            END IF

cbz3/17/99
            IF ((ITYP .GE. 100 .AND. ITYP .LT. 1000) .OR. 
     &         (ITYP .GT. -1000 .AND. ITYP .LE. -100)) THEN
               dy2msn(IY) = dy2msn(IY) + 1.0
            END IF
            IF (ITYP .EQ. 211) THEN
               DY2PIP(IY) = DY2PIP(IY) + 1.0
            END IF
            IF (ITYP .EQ. -211) THEN
               DY2PIM(IY) = DY2PIM(IY) + 1.0
            END IF
            IF (ITYP .EQ. 111) THEN
               DY2PI0(IY) = DY2PI0(IY) + 1.0
            END IF
            IF (ITYP .EQ. 2212) THEN
               DY2PR(IY) = DY2PR(IY) + 1.0
            END IF
            IF (ITYP .EQ. -2212) THEN
               DY2PB(IY) = DY2PB(IY) + 1.0
            END IF
cbz3/17/99 end
            IF (ITYP .EQ. 321) THEN
               DY2KP(IY) = DY2KP(IY) + 1.0
            END IF
            IF (ITYP .EQ. -321) THEN
               DY2KM(IY) = DY2KM(IY) + 1.0
            END IF
clin-4/24/03:
c            IF (ITYP .EQ. 310) THEN
            IF (ITYP .EQ. 130) THEN
               DY2K0S(IY) = DY2K0S(IY) + 1.0
            END IF
            IF (ITYP .EQ. 3122) THEN
               DY2LA(IY) = DY2LA(IY) + 1.0
            END IF
            IF (ITYP .EQ. -3122) THEN
               DY2LB(IY) = DY2LB(IY) + 1.0
            END IF
            IF (ITYP .EQ. 333) THEN
               DY2PHI(IY) = DY2PHI(IY) + 1.0
            END IF

c.....insert rapidity cut for mt spectrum here
 100        IF (Y .LT. YMT1 .OR. Y .GT. YMT2) GOTO 200
            IF (DXMT .GE. 50.0 * BMT .OR. DXMT .EQ. 0) GOTO 200
            IMT = 1 + int(DXMT / BMT)
            IF (ITYP .EQ. 211) THEN
               dm2pip(IMT) = dm2pip(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. -211) THEN
               dm2pim(IMT) = dm2pim(IMT) + 
     &            1.0 / XMT
            END IF
            IF (ITYP .EQ. 2212) THEN
               DMT2PR(IMT) = DMT2PR(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. -2212) THEN
               DMT2PB(IMT) = DMT2PB(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. 321) THEN
               DMT2KP(IMT) = DMT2KP(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. -321) THEN
               dm2km(IMT) = dm2km(IMT) + 1.0 / XMT
            END IF
clin-4/24/03:
c            IF (ITYP .EQ. 310) THEN
            IF (ITYP .EQ. 130) THEN
               dm2k0s(IMT) = dm2k0s(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. 3122) THEN
               DMT2LA(IMT) = DMT2LA(IMT) + 1.0 / XMT
            END IF
            IF (ITYP .EQ. -3122) THEN
               DMT2LB(IMT) = DMT2LB(IMT) + 1.0 / XMT
            END IF

 200        CONTINUE
 1001    CONTINUE
 1002 CONTINUE

      RETURN
      END

c-----------------------------------------------------------------------

c.....output analysis results at the end of the simulation

      SUBROUTINE ARTOUT(NEVNT)

      PARAMETER (MAXSTR=150001, MAXR=1)
c.....y cut for mt spectrum
cbz3/17/99
c      PARAMETER (YMT1 = -0.4, YMT2 = 0.4)
      PARAMETER (YMT1 = -1.0, YMT2 = 1.0)
cbz3/17/99 end
c.....bin width for mt spectrum and y spectrum
c      PARAMETER (BMT = 0.05, BY = 0.2)
      PARAMETER (BMT = 0.05, BY = 0.4)
      COMMON /RUN/ NUM
cc      SAVE /RUN/
      COMMON /ARPRC1/ITYP1(MAXSTR, MAXR),
     &     GX1(MAXSTR, MAXR), GY1(MAXSTR, MAXR), GZ1(MAXSTR, MAXR), 
     &     FT1(MAXSTR, MAXR),
     &     PX1(MAXSTR, MAXR), PY1(MAXSTR, MAXR), PZ1(MAXSTR, MAXR),
     &     EE1(MAXSTR, MAXR), XM1(MAXSTR, MAXR)
cbz3/17/99
c     &     dm1k0s(50), DMT1LA(50), DMT1LB(50)
cc      SAVE /ARPRC1/
      COMMON /ARANA1/
     &     dy1ntb(50), dy1ntp(50), DY1HM(50), 
     &     DY1KP(50), DY1KM(50), DY1K0S(50),
     &     DY1LA(50), DY1LB(50), DY1PHI(50),
     &     dm1pip(50), dm1pim(50), DMT1PR(50),
     &     DMT1PB(50), DMT1KP(50), dm1km(50),
     &     dm1k0s(50), DMT1LA(50), DMT1LB(50),
     &     dy1msn(50), DY1PIP(50), DY1PIM(50), 
     &     DY1PI0(50), DY1PR(50), DY1PB(50)
     &     ,DY1NEG(50), DY1CH(50), DE1NEG(50), DE1CH(50)
cbz3/17/99 end
cc      SAVE /ARANA1/
cbz3/17/99
c     &     dm2k0s(50), DMT2LA(50), DMT2LB(50)
      COMMON /ARANA2/
     &     dy2ntb(50), dy2ntp(50), DY2HM(50), 
     &     DY2KP(50), DY2KM(50), DY2K0S(50),
     &     DY2LA(50), DY2LB(50), DY2PHI(50),
     &     dm2pip(50), dm2pim(50), DMT2PR(50),
     &     DMT2PB(50), DMT2KP(50), dm2km(50),
     &     dm2k0s(50), DMT2LA(50), DMT2LB(50),
     &     dy2msn(50), DY2PIP(50), DY2PIM(50), 
     &     DY2PI0(50), DY2PR(50), DY2PB(50)
     &     ,DY2NEG(50), DY2CH(50), DE2NEG(50), DE2CH(50)
cc      SAVE /ARANA2/
      SAVE   
cbz3/17/99 end
      OPEN (30, FILE = 'ana/dndy_netb.dat', STATUS = 'UNKNOWN')
      OPEN (31, FILE = 'ana/dndy_netp.dat', STATUS = 'UNKNOWN')
      OPEN (32, FILE = 'ana/dndy_nb.dat', STATUS = 'UNKNOWN')
      OPEN (33, FILE = 'ana/dndy_neg.dat', STATUS = 'UNKNOWN')
      OPEN (34, FILE = 'ana/dndy_ch.dat', STATUS = 'UNKNOWN')
      OPEN (35, FILE = 'ana/dnde_neg.dat', STATUS = 'UNKNOWN')
      OPEN (36, FILE = 'ana/dnde_ch.dat', STATUS = 'UNKNOWN')
      OPEN (37, FILE = 'ana/dndy_kp.dat', STATUS = 'UNKNOWN')
      OPEN (38, FILE = 'ana/dndy_km.dat', STATUS = 'UNKNOWN')
clin-4/24/03
c      OPEN (39, FILE = 'ana/dndy_k0s.dat', STATUS = 'UNKNOWN')
      OPEN (39, FILE = 'ana/dndy_k0l.dat', STATUS = 'UNKNOWN')
      OPEN (40, FILE = 'ana/dndy_la.dat', STATUS = 'UNKNOWN')
      OPEN (41, FILE = 'ana/dndy_lb.dat', STATUS = 'UNKNOWN')
      OPEN (42, FILE = 'ana/dndy_phi.dat', STATUS = 'UNKNOWN')
cbz3/17/99
      OPEN (43, FILE = 'ana/dndy_meson.dat', STATUS = 'UNKNOWN')
      OPEN (44, FILE = 'ana/dndy_pip.dat', STATUS = 'UNKNOWN')
      OPEN (45, FILE = 'ana/dndy_pim.dat', STATUS = 'UNKNOWN')
      OPEN (46, FILE = 'ana/dndy_pi0.dat', STATUS = 'UNKNOWN')
      OPEN (47, FILE = 'ana/dndy_pr.dat', STATUS = 'UNKNOWN')
      OPEN (48, FILE = 'ana/dndy_pb.dat', STATUS = 'UNKNOWN')
cbz3/17/99 end

      OPEN (50, FILE = 'ana/dndmtdy_pip.dat', STATUS = 'UNKNOWN')
      OPEN (51, FILE = 'ana/dndmtdy_0_1_pim.dat', STATUS = 'UNKNOWN')
      OPEN (52, FILE = 'ana/dndmtdy_pr.dat', STATUS = 'UNKNOWN')
      OPEN (53, FILE = 'ana/dndmtdy_pb.dat', STATUS = 'UNKNOWN')
      OPEN (54, FILE = 'ana/dndmtdy_kp.dat', STATUS = 'UNKNOWN')
      OPEN (55, FILE = 'ana/dndmtdy_0_5_km.dat', STATUS = 'UNKNOWN')
      OPEN (56, FILE = 'ana/dndmtdy_k0s.dat', STATUS = 'UNKNOWN')
      OPEN (57, FILE = 'ana/dndmtdy_la.dat', STATUS = 'UNKNOWN')
      OPEN (58, FILE = 'ana/dndmtdy_lb.dat', STATUS = 'UNKNOWN')
clin-9/26/03 no symmetrization in y (or eta) for ana/*.dat:
c      SCALE1 = 1. / REAL(NEVNT * NUM) / BY / 2.0
      SCALE1 = 1. / REAL(NEVNT * NUM) / BY
      SCALE2 = 1. / REAL(NEVNT * NUM) / BMT / (YMT2 - YMT1)
c
      DO 1001 I = 1, 50
         ymid=-10.+BY * (I - 0.5)
         WRITE (30, 333) ymid, SCALE1 * dy1ntb(I)
         WRITE (31, 333) ymid, SCALE1 * dy1ntp(I)
         WRITE (32, 333) ymid, SCALE1 * DY1HM(I)
         WRITE (37, 333) ymid, SCALE1 * DY1KP(I)
         WRITE (38, 333) ymid, SCALE1 * DY1KM(I)
         WRITE (39, 333) ymid, SCALE1 * DY1K0S(I)
         WRITE (40, 333) ymid, SCALE1 * DY1LA(I)
         WRITE (41, 333) ymid, SCALE1 * DY1LB(I)
         WRITE (42, 333) ymid, SCALE1 * DY1PHI(I)
         WRITE (33, 333) ymid, SCALE1 * DY1NEG(I)
         WRITE (34, 333) ymid, SCALE1 * DY1CH(I)
         WRITE (35, 333) ymid, SCALE1 * DE1NEG(I)
         WRITE (36, 333) ymid, SCALE1 * DE1CH(I)
         WRITE (43, 333) ymid, SCALE1 * dy1msn(I)
         WRITE (44, 333) ymid, SCALE1 * DY1PIP(I)
         WRITE (45, 333) ymid, SCALE1 * DY1PIM(I)
         WRITE (46, 333) ymid, SCALE1 * DY1PI0(I)
         WRITE (47, 333) ymid, SCALE1 * DY1PR(I)
         WRITE (48, 333) ymid, SCALE1 * DY1PB(I)

         IF (dm1pip(I) .NE. 0.0) THEN
            WRITE (50, 333) BMT * (I - 0.5), SCALE2 * dm1pip(I)
         END IF
         IF (dm1pim(I) .NE. 0.0) THEN
            WRITE (51, 333) BMT * (I - 0.5), SCALE2 * 0.1 * 
     &         dm1pim(I)
         END IF
         IF (DMT1PR(I) .NE. 0.0) THEN
            WRITE (52, 333) BMT * (I - 0.5), SCALE2 * DMT1PR(I)
         END IF
         IF (DMT1PB(I) .NE. 0.0) THEN
            WRITE (53, 333) BMT * (I - 0.5), SCALE2 * DMT1PB(I)
         END IF
         IF (DMT1KP(I) .NE. 0.0) THEN
            WRITE (54, 333) BMT * (I - 0.5), SCALE2 * DMT1KP(I)
         END IF
         IF (dm1km(I) .NE. 0.0) THEN
            WRITE (55, 333) BMT * (I - 0.5), SCALE2 * 0.5 *
     &         dm1km(I)
         END IF
         IF (dm1k0s(I) .NE. 0.0) THEN
            WRITE (56, 333) BMT * (I - 0.5), SCALE2 * dm1k0s(I)
         END IF
         IF (DMT1LA(I) .NE. 0.0) THEN
            WRITE (57, 333) BMT * (I - 0.5), SCALE2 * DMT1LA(I)
         END IF
         IF (DMT1LB(I) .NE. 0.0) THEN
            WRITE (58, 333) BMT * (I - 0.5), SCALE2 * DMT1LB(I)
         END IF
 1001 CONTINUE
c
      DO 1002 I = 30, 48
         WRITE (I, *) 'after hadron evolution'
 1002    CONTINUE
      DO 1003 I = 50, 58
         WRITE (I, *) 'after hadron evolution'
 1003 CONTINUE

      DO 1004 I = 1, 50
         ymid=-10.+BY * (I - 0.5)
         WRITE (30, 333) ymid, SCALE1 * dy2ntb(I)
         WRITE (31, 333) ymid, SCALE1 * dy2ntp(I)
         WRITE (32, 333) ymid, SCALE1 * DY2HM(I)
         WRITE (37, 333) ymid, SCALE1 * DY2KP(I)
         WRITE (38, 333) ymid, SCALE1 * DY2KM(I)
         WRITE (39, 333) ymid, SCALE1 * DY2K0S(I)
         WRITE (40, 333) ymid, SCALE1 * DY2LA(I)
         WRITE (41, 333) ymid, SCALE1 * DY2LB(I)
         WRITE (42, 333) ymid, SCALE1 * DY2PHI(I)
         WRITE (33, 333) ymid, SCALE1 * DY2NEG(I)
         WRITE (34, 333) ymid, SCALE1 * DY2CH(I)
         WRITE (35, 333) ymid, SCALE1 * DE2NEG(I)
         WRITE (36, 333) ymid, SCALE1 * DE2CH(I)
         WRITE (43, 333) ymid, SCALE1 * dy2msn(I)
         WRITE (44, 333) ymid, SCALE1 * DY2PIP(I)
         WRITE (45, 333) ymid, SCALE1 * DY2PIM(I)
         WRITE (46, 333) ymid, SCALE1 * DY2PI0(I)
         WRITE (47, 333) ymid, SCALE1 * DY2PR(I)
         WRITE (48, 333) ymid, SCALE1 * DY2PB(I)
c
         IF (dm2pip(I) .NE. 0.0) THEN
            WRITE (50, 333) BMT * (I - 0.5), SCALE2 * dm2pip(I)
         END IF
         IF (dm2pim(I) .NE. 0.0) THEN
            WRITE (51, 333) BMT * (I - 0.5), SCALE2 * 0.1 * 
     &         dm2pim(I)
         END IF
         IF (DMT2PR(I) .NE. 0.0) THEN
            WRITE (52, 333) BMT * (I - 0.5), SCALE2 * DMT2PR(I)
         END IF
         IF (DMT2PB(I) .NE. 0.0) THEN
            WRITE (53, 333) BMT * (I - 0.5), SCALE2 * DMT2PB(I)
         END IF
         IF (DMT2KP(I) .NE. 0.0) THEN
            WRITE (54, 333) BMT * (I - 0.5), SCALE2 * DMT2KP(I)
         END IF
         IF (dm2km(I) .NE. 0.0) THEN
            WRITE (55, 333) BMT * (I - 0.5), SCALE2 * 0.5 * 
     &         dm2km(I)
         END IF
         IF (dm2k0s(I) .NE. 0.0) THEN
            WRITE (56, 333) BMT * (I - 0.5), SCALE2 * dm2k0s(I)
         END IF
         IF (DMT2LA(I) .NE. 0.0) THEN
            WRITE (57, 333) BMT * (I - 0.5), SCALE2 * DMT2LA(I)
         END IF
         IF (DMT2LB(I) .NE. 0.0) THEN
            WRITE (58, 333) BMT * (I - 0.5), SCALE2 * DMT2LB(I)
         END IF
 1004 CONTINUE
 333  format(2(f12.5,1x))

      RETURN
      END

c-----------------------------------------------------------------------

c.....analysis subroutine in HIJING before parton cascade evolution
      SUBROUTINE HJANA1

      PARAMETER (YMAX = 1.0, YMIN = -1.0)
      PARAMETER (DMT = 0.05, DY = 0.2)
      PARAMETER (DR = 0.2)
      PARAMETER (MAXPTN=400001,MAXSTR=150001)
      DIMENSION dyp1(50), DMYP1(200), DEYP1(50)
      DIMENSION dyg1(50), DMYG1(200), DEYG1(50)
      DIMENSION SNYP1(50), SMYP1(200), SEYP1(50)
      DIMENSION SNYG1(50), SMYG1(200), SEYG1(50)
      DIMENSION dnrpj1(50), dnrtg1(50), dnrin1(50),
     &   dnrtt1(50)
      DIMENSION dyg1c(50), dmyg1c(50), deyg1c(50)
      DIMENSION snrpj1(50), snrtg1(50), snrin1(50),
     &   snrtt1(50)
      DIMENSION snyg1c(50), smyg1c(50), seyg1c(50)
      DOUBLE PRECISION  GX0, GY0, GZ0, FT0, PX0, PY0, PZ0, E0, XMASS0

      COMMON /PARA1/ MUL
cc      SAVE /PARA1/
      COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
      COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
      COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &   PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &   PJPM(300,500),NTJ(300),KFTJ(300,500),
     &   PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &   PJTE(300,500),PJTM(300,500)
cc      SAVE /HJJET1/
      COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &   K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &   PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
      COMMON /prec1/GX0(MAXPTN),GY0(MAXPTN),GZ0(MAXPTN),FT0(MAXPTN),
     &     PX0(MAXPTN), PY0(MAXPTN), PZ0(MAXPTN), E0(MAXPTN),
     &     XMASS0(MAXPTN), ITYP0(MAXPTN)
cc      SAVE /prec1/
      COMMON /AREVT/ IAEVT, IARUN, MISS
cc      SAVE /AREVT/
      COMMON /AROUT/ IOUT
cc      SAVE /AROUT/
      SAVE   
      DATA IW/0/

      IF (isevt .EQ. IAEVT .AND. isrun .EQ. IARUN) THEN
         DO 1001 I = 1, 200
            DMYP1(I) = SMYP1(I)
            DMYG1(I) = SMYG1(I)
 1001    CONTINUE

         DO 1002 I = 1, 50
            dyp1(I) = SNYP1(I)
            DEYP1(I) = SEYP1(I)
            dyg1(I) = SNYG1(I)
            DEYG1(I) = SEYG1(I)
            dnrpj1(I) = snrpj1(I)
            dnrtg1(I) = snrtg1(I)
            dnrin1(I) = snrin1(I)
            dnrtt1(I) = snrtt1(I)
            dyg1c(I) = snyg1c(I)
            dmyg1c(I) = smyg1c(I)
            deyg1c(I) = seyg1c(I)
 1002    CONTINUE
         nsubp = nsubpS
         nsubg = nsubgS
         NISG = NISGS
      ELSE
         DO 1003 I = 1, 200
            SMYP1(I) = DMYP1(I)
            SMYG1(I) = DMYG1(I)
 1003    CONTINUE

         DO 1004 I = 1, 50
            SNYP1(I) = dyp1(I)
            SEYP1(I) = DEYP1(I)
            SNYG1(I) = dyg1(I)
            SEYG1(I) = DEYG1(I)
            snrpj1(I) = dnrpj1(I)
            snrtg1(I) = dnrtg1(I)
            snrin1(I) = dnrin1(I)
            snrtt1(I) = dnrtt1(I)
            snyg1c(I) = dyg1c(I)
            smyg1c(I) = dmyg1c(I)
            seyg1c(I) = deyg1c(I)
 1004    CONTINUE
         nsubpS = nsubp
         nsubgS = nsubg
         NISGS = NISG
         isevt = IAEVT
         isrun = IARUN
         IW = IW + 1
      END IF
c.....analysis
      DO 1006 I = 1, IHNT2(1)
         DO 1005 J = 1, NPJ(I)
            ITYP = KFPJ(I, J)
            PX = PJPX(I, J)
            PY = PJPY(I, J)
            PZ = PJPZ(I, J)
            PE = PJPE(I, J)
            PM = PJPM(I, J)
            XMT = SQRT(PX ** 2 + PY ** 2 + PM ** 2)
            DXMT = XMT - PM
clin-9/2012 determine rapidity more generally:
c            IF (ABS(PZ) .GE. PE) THEN
c               PRINT *, ' IN HJANA1, PROJ STR ', I, ' PART ', J
c               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
c               PRINT *, ' PZ = ', PZ, ' EE = ', PE
c               PRINT *, ' XM = ', PM
c               GOTO 200
c            END IF
c            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
            if(XMT.gt.0.) then
               RAP=asinh(PZ/XMT)
            else
               RAP = 1000000.0*sign(1.,PZ)
            endif

            IY = 1 + int(ABS(RAP) / DY)
clin-8/2014 prevent possible segmentation fault (due to IY<=0):
c            IF (IY .GT. 50) GOTO 100
            IF (IY.lt.1 .or.IY .GT. 50) GOTO 100
            dyp1(IY) = dyp1(IY) + 1.0
            DEYP1(IY) = DEYP1(IY) + XMT
            IF (ITYP .EQ. 21) THEN
               dyg1(IY) = dyg1(IY) + 1.0
               DEYG1(IY) = DEYG1(IY) + XMT
            END IF
 100        CONTINUE
            IMT = 1 + int(DXMT / DMT)
            IF (RAP .GT. YMAX .OR. RAP .LE. YMIN) GOTO 200
            IF (IMT .GT. 200) GOTO 200
            DMYP1(IMT) = DMYP1(IMT) + 1.0 / XMT
            IF (ITYP .EQ. 21) THEN
               DMYG1(IMT) = DMYG1(IMT) + 1.0 / XMT
            END IF
 200        CONTINUE
 1005    CONTINUE
 1006 CONTINUE

      DO 1008 I = 1, IHNT2(3)
         DO 1007 J = 1, NTJ(I)
            ITYP = KFTJ(I, J)
            PX = PJTX(I, J)
            PY = PJTY(I, J)
            PZ = PJTZ(I, J)
            PE = PJTE(I, J)
            PM = PJTM(I, J)
            XMT = SQRT(PX ** 2 + PY ** 2 + PM ** 2)
            DXMT = XMT - PM
clin-9/2012 determine rapidity more generally:
c            IF (ABS(PZ) .GE. PE) THEN
c               PRINT *, ' IN HJANA1, TARG STR ', I, ' PART ', J
c               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
c               PRINT *, ' PZ = ', PZ, ' EE = ', PE
c               PRINT *, ' XM = ', PM
c               GOTO 400
c            END IF
c            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
            if(XMT.gt.0.) then
               RAP=asinh(PZ/XMT)
            else
               PRINT *, ' IN HJANA1 mt=0'
               RAP = 1000000.0*sign(1.,PZ)
            endif

            IY = 1 + int(ABS(RAP) / DY)
clin-8/2014 prevent possible segmentation fault (due to IY<=0):
c            IF (IY .GT. 50) GOTO 300
            IF (IY.lt.1 .or.IY .GT. 50) GOTO 300
            dyp1(IY) = dyp1(IY) + 1.0
            DEYP1(IY) = DEYP1(IY) + XMT
            IF (ITYP .EQ. 21) THEN
               dyg1(IY) = dyg1(IY) + 1.0
               DEYG1(IY) = DEYG1(IY) + XMT
            END IF
 300        CONTINUE
            IF (RAP .GT. YMAX .OR. RAP .LE. YMIN) GOTO 400
            IMT = 1 + int(DXMT / DMT)
            IF (IMT .GT. 200) GOTO 400
            DMYP1(IMT) = DMYP1(IMT) + 1.0 / XMT
            IF (ITYP .EQ. 21) THEN
               DMYG1(IMT) = DMYG1(IMT) + 1.0 / XMT
            END IF
 400        CONTINUE
 1007    CONTINUE
 1008 CONTINUE

      DO 1010 I = 1, NSG
         DO 1009 J = 1, NJSG(I)
            ITYP = K2SG(I, J)
            PX = PXSG(I, J)
            PY = PYSG(I, J)
            PZ = PZSG(I, J)
            PE = PESG(I, J)
            PM = PMSG(I, J)
            XMT = SQRT(PX ** 2 + PY ** 2 + PM ** 2)
            DXMT = XMT - PM
clin-9/2012 determine rapidity more generally:
c            IF (ABS(PZ) .GE. PE) THEN
c               PRINT *, ' IN HJANA1, INDP STR ', I, ' PART ', J
c               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
c               PRINT *, ' PZ = ', PZ, ' EE = ', PE
c               PRINT *, ' XM = ', PM
c               GOTO 600
c            END IF
c            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
            if(XMT.gt.0.) then
               RAP=asinh(PZ/XMT)
            else
               PRINT *, ' IN HJANA1 mt=0'
               RAP = 1000000.0*sign(1.,PZ)
            endif

            IY = 1 + int(ABS(RAP) / DY)
clin-8/2014 prevent possible segmentation fault (due to IY<=0):
c            IF (IY .GT. 50) GOTO 500
            IF (IY.lt.1 .or.IY .GT. 50) GOTO 500
            dyp1(IY) = dyp1(IY) + 1.0
            DEYP1(IY) = DEYP1(IY) + XMT
            IF (ITYP .EQ. 21) THEN
               dyg1(IY) = dyg1(IY) + 1.0
               DEYG1(IY) = DEYG1(IY) + XMT
            END IF
 500        CONTINUE
            IF (RAP .GT. YMAX .OR. RAP .LE. YMIN) GOTO 600
            IMT = 1 + int(DXMT / DMT)
            IF (IMT .GT. 200) GOTO 600
            DMYP1(IMT) = DMYP1(IMT) + 1.0 / XMT
            IF (ITYP .EQ. 21) THEN
               DMYG1(IMT) = DMYG1(IMT) + 1.0 / XMT
            END IF
 600        CONTINUE
 1009    CONTINUE
 1010 CONTINUE

      DO 1011 I = 1, IHNT2(1)
         YR = SQRT(YP(1, I) ** 2 + YP(2, I) ** 2)
         IR = 1 + int(YR / DR)
clin-4/2008 protect against out-of-bound errors:
c         IF (IR .GT. 50) GOTO 601
         IF (IR .GT. 50 .or. IR .LT. 1) GOTO 601
         dnrpj1(IR) = dnrpj1(IR) + 1.0
         dnrtt1(IR) = dnrtt1(IR) + 1.0
 601     CONTINUE
 1011 CONTINUE

      DO 1012 I = 1, IHNT2(3)
         YR = SQRT(YT(1, I) ** 2 + YT(2, I) ** 2)
         IR = 1 + int(YR / DR)
         IF (IR .GT. 50 .or. IR .LT. 1) GOTO 602
         dnrtg1(IR) = dnrtg1(IR) + 1.0
         dnrtt1(IR) = dnrtt1(IR) + 1.0
 602     CONTINUE
 1012 CONTINUE

      DO 1013 I = 1, NSG
         Y1 = 0.5 * (YP(1, IASG(I, 1)) + YT(1, IASG(I, 2)))
         Y2 = 0.5 * (YP(2, IASG(I, 1)) + YT(2, IASG(I, 2)))
         YR = SQRT(Y1 ** 2 + Y2 ** 2)
         IR = 1 + int(YR / DR)
         IF (IR .GT. 50 .or. IR .LT. 1) GOTO 603
         dnrin1(IR) = dnrin1(IR) + 1.0
         dnrtt1(IR) = dnrtt1(IR) + 1.0
 603     CONTINUE
 1013 CONTINUE

      DO 1014 I = 1, MUL
         ITYP = ITYP0(I)
         PX = sngl(PX0(I))
         PY = sngl(PY0(I))
         PZ = sngl(PZ0(I))
         PE = sngl(E0(I))
         PM = sngl(XMASS0(I))
         XMT = SQRT(PX ** 2 + PY ** 2 + PM ** 2)
         DXMT = XMT - PM
clin-9/2012 determine rapidity more generally:
c         IF (ABS(PZ) .GE. PE) THEN
c            PRINT *, ' IN HJANA1, GLUON ', I
c            PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
c            PRINT *, ' PZ = ', PZ, ' EE = ', PE
c            PRINT *, ' XM = ', PM
c            GOTO 800
c         END IF
c         RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
         if(XMT.gt.0.) then
            RAP=asinh(PZ/XMT)
         else
            PRINT *, ' IN HJANA1 mt=0'
            RAP = 1000000.0*sign(1.,PZ)
         endif

         IY = 1 + int(ABS(RAP) / DY)
clin-8/2014 prevent possible segmentation fault (due to IY<=0):
c         IF (IY .GT. 50) GOTO 700
         IF (IY.lt.1 .or.IY .GT. 50) GOTO 700
         dyg1c(IY) = dyg1c(IY) + 1.0
         deyg1c(IY) = deyg1c(IY) + XMT
 700     CONTINUE
         IF (RAP .GT. YMAX .OR. RAP .LE. YMIN) GOTO 800
         IMT = 1 + int(DXMT / DMT)
         IF (IMT .GT. 50) GOTO 800
         dmyg1c(IMT) = dmyg1c(IMT) + 1.0 / XMT
 800     CONTINUE
 1014 CONTINUE
c.....count number of particles
      DO 1016 I = 1, IHNT2(1)
         DO 1015 J = 1, NPJ(I)
            nsubp = nsubp + 1
            IF (KFPJ(I, J) .EQ. 21) nsubg = nsubg + 1
 1015    CONTINUE
 1016 CONTINUE

      DO 1018 I = 1, IHNT2(3)
         DO 1017 J = 1, NTJ(I)
            nsubp = nsubp + 1
            IF (KFTJ(I, J) .EQ. 21) nsubg = nsubg + 1
 1017    CONTINUE
 1018 CONTINUE

      DO 1020 I = 1, NSG
         DO 1019 J = 1, NJSG(I)
            nsubp = nsubp + 1
            IF (K2SG(I, J) .EQ. 21) nsubg = nsubg + 1
 1019    CONTINUE
 1020 CONTINUE
      NISG = NISG + NSG
      IF (IOUT .EQ. 1) THEN
cbzdbg2/16/99
c      PRINT *, ' in HJANA1 '
c      PRINT *, ' total number of partons = ', nsubp
c      PRINT *, ' total number of gluons = ', nsubg, MUL
c      PRINT *, ' number of projectile strings = ', IHNT2(1)
c      PRINT *, ' number of target strings = ', IHNT2(3)
c      PRINT *, ' number of independent strings = ', NSG
      PRINT *, ' in HJANA1 '
      PRINT *, ' total number of partons = ', nsubp / IW
      PRINT *, ' total number of gluons = ', nsubg / IW
c      PRINT *, ' number of projectile strings = ', IHNT2(1)
c      PRINT *, ' number of target strings = ', IHNT2(3)
      PRINT *, ' number of independent strings = ', NISG / IW
cbzdbg2/16/99end
      END IF
c
      RETURN
      END

c-----------------------------------------------------------------------

c.....analysis subroutine in ZPC after generation of additional initial
c.....phase space distributions.

      SUBROUTINE HJAN1A
      PARAMETER (MAXPTN=400001)
      PARAMETER (DGX = 0.2, DGY = 0.2, DT = 0.2)
      DIMENSION dgxg1a(50), dgyg1a(50), dtg1a(50)
      DIMENSION sgxg1a(50), sgyg1a(50), stg1a(50)
      DOUBLE PRECISION  GX5, GY5, GZ5, FT5, PX5, PY5, PZ5, E5, XMASS5
      COMMON /PARA1/ MUL
cc      SAVE /PARA1/
      COMMON /prec2/GX5(MAXPTN),GY5(MAXPTN),GZ5(MAXPTN),FT5(MAXPTN),
     &   PX5(MAXPTN), PY5(MAXPTN), PZ5(MAXPTN), E5(MAXPTN),
     &   XMASS5(MAXPTN), ITYP5(MAXPTN)
cc      SAVE /prec2/
      COMMON /AREVT/ IAEVT, IARUN, MISS
cc      SAVE /AREVT/
      COMMON /AROUT/ IOUT
cc      SAVE /AROUT/
      SAVE   
      DATA IW/0/

      IF (isevt .EQ. IAEVT .AND. isrun .EQ. IARUN) THEN
         DO 1001 I = 1, 50
            dgxg1a(I) = sgxg1a(I)
            dgyg1a(I) = sgyg1a(I)
            dtg1a(I) = stg1a(I)
 1001    CONTINUE
      ELSE
         DO 1002 I = 1, 50
            sgxg1a(I) = dgxg1a(I)
            sgyg1a(I) = dgyg1a(I)
            stg1a(I) = dtg1a(I)
 1002    CONTINUE
         isevt = IAEVT
         isrun = IARUN
         IW = IW + 1
      END IF
c.....analysis
      DO 1003 I = 1, MUL
         IGX = 1 + int(sngl(ABS(GX5(I))) / DGX)
clin-4/2008 protect against out-of-bound errors:
c         IF (IGX .GT. 50) GOTO 100
         IF (IGX .GT. 50 .or. IGX .LT. 1) GOTO 100
         dgxg1a(IGX) = dgxg1a(IGX) + 1.0
 100     CONTINUE
         IGY = 1 + int(sngl(ABS(GY5(I))) / DGY)
         IF (IGY .GT. 50 .or. IGY .LT. 1) GOTO 200
         dgyg1a(IGY) = dgyg1a(IGY) + 1.0
 200     CONTINUE
clin-9/2015 to avoid Floating-Point Exception:
c         IT = 1 + int(sngl(SQRT(FT5(I) ** 2 - GZ5(I) ** 2)) / DT)
         diff2=sngl(FT5(I)**2 - GZ5(I)**2)
         if(diff2.lt.0.) then
            write(6,*) '1:I,ft5,gz5,diff2=',I,ft5(i),gz5(i),diff2
            IT=1
         else
            IT = 1 + int(SQRT(diff2)/DT)
         endif
c
         IF (IT .GT. 50 .or. IT .LT. 1) GOTO 300
         dtg1a(IT) = dtg1a(IT) + 1.0
 300     CONTINUE
 1003 CONTINUE
      CALL HJAN1B
c
      RETURN
      END

c-----------------------------------------------------------------------

c.....analysis subroutine in HJAN1A

      SUBROUTINE HJAN1B
      PARAMETER (MAXPTN=400001,MAXSTR=150001)
      PARAMETER (DR = 0.2, DT = 0.2)
      DIMENSION DNRG1B(50), dtg1b(50)
      DIMENSION SNRG1B(50), stg1b(50)
      DOUBLE PRECISION  GX5, GY5, GZ5, FT5, PX5, PY5, PZ5, E5, XMASS5
      COMMON /PARA1/ MUL
cc      SAVE /PARA1/
      COMMON /prec2/GX5(MAXPTN),GY5(MAXPTN),GZ5(MAXPTN),FT5(MAXPTN),
     &   PX5(MAXPTN), PY5(MAXPTN), PZ5(MAXPTN), E5(MAXPTN),
     &   XMASS5(MAXPTN), ITYP5(MAXPTN)
cc      SAVE /prec2/
      COMMON /ilist8/ LSTRG1(MAXPTN), LPART1(MAXPTN)
cc      SAVE /ilist8/
      COMMON /SREC1/ NSP, NST, NSI
cc      SAVE /SREC1/
      COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
      COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &   K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &   PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
      COMMON /AREVT/ IAEVT, IARUN, MISS
cc      SAVE /AREVT/
      COMMON /AROUT/ IOUT
cc      SAVE /AROUT/
      SAVE   
      DATA IW/0/

      IF (isevt .EQ. IAEVT .AND. isrun .EQ. IARUN) THEN
         DO 1001 I = 1, 50
            DNRG1B(I) = SNRG1B(I)
            dtg1b(I) = stg1b(I)
 1001    CONTINUE
      ELSE
         DO 1002 I = 1, 50
            SNRG1B(I) = DNRG1B(I)
            stg1b(I) = dtg1b(I)
 1002    CONTINUE
         isevt = IAEVT
         isrun = IARUN
         IW = IW + 1
      END IF
c.....analysis
      DO 1003 I = 1, MUL
         J = LSTRG1(I)

         IF (J .LE. NSP) THEN
            K = J
            GX0 = YP(1, J)
            GY0 = YP(2, J)
         ELSE IF (J .LE. NSP + NST) THEN
            K = J - NSP
            GX0 = YT(1, K)
            GY0 = YT(2, K)
         ELSE
            K = J - NSP - NST
            GX0 = 0.5 * (YP(1, IASG(K, 1)) + YT(1, IASG(K, 2)))
            GY0 = 0.5 * (YP(2, IASG(K, 1)) + YT(2, IASG(K, 2)))
         END IF
         R0 = SQRT((sngl(GX5(I)) - GX0)**2 + (sngl(GY5(I)) - GY0)**2)
         IR = 1 + int(R0 / DR)
         IF (IR .GT. 50 .or. IR .LT. 1) GOTO 100
         DNRG1B(IR) = DNRG1B(IR) + 1.0
 100     CONTINUE
clin-9/2015 to avoid Floating-Point Exception:
c         TAU7 = SQRT(sngl(FT5(I) ** 2 - GZ5(I) ** 2))
         diff2=sngl(FT5(I)**2 - GZ5(I)**2)
         if(diff2.lt.0.) then
            write(6,*) '5:I,ft5,gz5,diff2=',I,ft5(i),gz5(i),diff2
            TAU7 = 1e-6
         else
            TAU7 = SQRT(diff2)
         endif
c
         IT = 1 + int(TAU7 / DT)
         IF (IT .GT. 50 .or. IT .LT. 1) GOTO 200
         dtg1b(IT) = dtg1b(IT) + 1.0
 200     CONTINUE
 1003 CONTINUE
c
      RETURN
      END

c-----------------------------------------------------------------------

c.....analysis subroutine in HIJING after parton cascade evolution
      SUBROUTINE HJANA2
c
      PARAMETER (YMAX = 1.0, YMIN = -1.0)
      PARAMETER (DMT = 0.05, DY = 0.2)
      PARAMETER (DR = 0.2, DT = 0.2)
      PARAMETER (MAXPTN=400001)
      PARAMETER (MAXSTR=150001)
      DOUBLE PRECISION  PXSGS,PYSGS,PZSGS,PESGS,PMSGS,
     1     GXSGS,GYSGS,GZSGS,FTSGS
      DIMENSION dyp2(50), DMYP2(200), DEYP2(50)
      DIMENSION dyg2(50), DMYG2(200), DEYG2(50)
      DIMENSION SNYP2(50), SMYP2(200), SEYP2(50)
      DIMENSION SNYG2(50), SMYG2(200), SEYG2(50)
      DIMENSION dnrpj2(50), dnrtg2(50), dnrin2(50),
     &   dnrtt2(50)
      DIMENSION dtpj2(50), dttg2(50), dtin2(50),
     &   dttot2(50)
      DIMENSION dyg2c(50), dmyg2c(50), deyg2c(50)
      DIMENSION snrpj2(50), snrtg2(50), snrin2(50),
     &   snrtt2(50)
      DIMENSION stpj2(50), sttg2(50), stin2(50),
     &   sttot2(50)
      DIMENSION snyg2c(50), smyg2c(50), seyg2c(50)
      DOUBLE PRECISION  ATAUI, ZT1, ZT2, ZT3
      DOUBLE PRECISION  GX5, GY5, GZ5, FT5, PX5, PY5, PZ5, E5, XMASS5
      COMMON /PARA1/ MUL
cc      SAVE /PARA1/
      COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
      COMMON /SREC2/ATAUI(MAXSTR),ZT1(MAXSTR),ZT2(MAXSTR),ZT3(MAXSTR)
cc      SAVE /SREC2/
      COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &   PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &   PJPM(300,500),NTJ(300),KFTJ(300,500),
     &   PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &   PJTE(300,500),PJTM(300,500)
cc      SAVE /HJJET1/
      COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &   K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &   PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
      COMMON /prec2/GX5(MAXPTN),GY5(MAXPTN),GZ5(MAXPTN),FT5(MAXPTN),
     &   PX5(MAXPTN), PY5(MAXPTN), PZ5(MAXPTN), E5(MAXPTN),
     &   XMASS5(MAXPTN), ITYP5(MAXPTN)
cc      SAVE /prec2/
      COMMON /AREVT/ IAEVT, IARUN, MISS
cc      SAVE /AREVT/
      COMMON /AROUT/ IOUT
cc      SAVE /AROUT/
      common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
      COMMON/SOFT/PXSGS(MAXSTR,3),PYSGS(MAXSTR,3),PZSGS(MAXSTR,3),
     &     PESGS(MAXSTR,3),PMSGS(MAXSTR,3),GXSGS(MAXSTR,3),
     &     GYSGS(MAXSTR,3),GZSGS(MAXSTR,3),FTSGS(MAXSTR,3),
     &     K1SGS(MAXSTR,3),K2SGS(MAXSTR,3),NJSGS(MAXSTR)
cc      SAVE /SOFT/
      SAVE   
      DATA IW/0/

      IF (isevt .EQ. IAEVT .AND. isrun .EQ. IARUN) THEN
         DO 1001 I = 1, 200
            DMYP2(I) = SMYP2(I)
            DMYG2(I) = SMYG2(I)
 1001    CONTINUE

         DO 1002 I = 1, 50
            dyp2(I) = SNYP2(I)
            DEYP2(I) = SEYP2(I)
            dyg2(I) = SNYG2(I)
            DEYG2(I) = SEYG2(I)
            dnrpj2(I) = snrpj2(I)
            dnrtg2(I) = snrtg2(I)
            dnrin2(I) = snrin2(I)
            dnrtt2(I) = snrtt2(I)
            dtpj2(I) = stpj2(I)
            dttg2(I) = sttg2(I)
            dtin2(I) = stin2(I)
            dttot2(I) = sttot2(I)
            dyg2c(I) = snyg2c(I)
            dmyg2c(I) = smyg2c(I)
            deyg2c(I) = seyg2c(I)
 1002    CONTINUE
         nsubp = nsubpS
         nsubg = nsubgS
         NISG = NISGS
      ELSE
         DO 1003 I = 1, 200
            SMYP2(I) = DMYP2(I)
            SMYG2(I) = DMYG2(I)
 1003    CONTINUE

         DO 1004 I = 1, 50
            SNYP2(I) = dyp2(I)
            SEYP2(I) = DEYP2(I)
            SNYG2(I) = dyg2(I)
            SEYG2(I) = DEYG2(I)
            snrpj2(I) = dnrpj2(I)
            snrtg2(I) = dnrtg2(I)
            snrin2(I) = dnrin2(I)
            snrtt2(I) = dnrtt2(I)
            stpj2(I) = dtpj2(I)
            sttg2(I) = dttg2(I)
            stin2(I) = dtin2(I)
            sttot2(I) = dttot2(I)
            snyg2c(I) = dyg2c(I)
            smyg2c(I) = dmyg2c(I)
            seyg2c(I) = deyg2c(I)
 1004    CONTINUE
         nsubpS = nsubp
         nsubgS = nsubg
         NISGS = NISG
         isevt = IAEVT
         isrun = IARUN
         IW = IW + 1
      END IF

clin-4/28/01:
      if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) goto 510

c.....analysis
      DO 1006 I = 1, IHNT2(1)
         DO 1005 J = 1, NPJ(I)
            ITYP = KFPJ(I, J)
            PX = PJPX(I, J)
            PY = PJPY(I, J)
            PZ = PJPZ(I, J)
            PE = PJPE(I, J)
            PM = PJPM(I, J)
            XMT = SQRT(PX ** 2 + PY ** 2 + PM ** 2)
            DXMT = XMT - PM
clin-9/2012 determine rapidity more generally:
ccbzdbg2/16/99
cc            IF (ABS(PZ) .GE. PE) GOTO 200
c            IF (ABS(PZ) .GE. PE) THEN
c               PRINT *, ' IN HJANA2, PROJ STR ', I, ' PART ', J
c               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
c               PRINT *, ' PZ = ', PZ, ' EE = ', PE
c               PRINT *, ' XM = ', PM
c               GOTO 200
c            END IF
ccbzdbg2/16/99end
c            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
            if(XMT.gt.0.) then
               RAP=asinh(PZ/XMT)
            else
               PRINT *, ' IN HJANA2 mt=0'
               RAP = 1000000.0*sign(1.,PZ)
            endif

            IY = 1 + int(ABS(RAP) / DY)
clin-8/2014 prevent possible segmentation fault (due to IY<=0):
c            IF (IY .GT. 50) GOTO 100
            IF (IY.lt.1 .or.IY .GT. 50) GOTO 100
            dyp2(IY) = dyp2(IY) + 1.0
            DEYP2(IY) = DEYP2(IY) + XMT
            IF (ITYP .EQ. 21) THEN
               dyg2(IY) = dyg2(IY) + 1.0
               DEYG2(IY) = DEYG2(IY) + XMT
            END IF
 100        CONTINUE
            IF (RAP .GT. YMAX .OR. RAP .LE. YMIN) GOTO 200
            IMT = 1 + int(DXMT / DMT)
            IF (IMT .GT. 200) GOTO 200
            DMYP2(IMT) = DMYP2(IMT) + 1.0 / XMT
            IF (ITYP .EQ. 21) THEN
               DMYG2(IMT) = DMYG2(IMT) + 1.0 / XMT
            END IF
 200        CONTINUE
 1005    CONTINUE
 1006 CONTINUE

      DO 1008 I = 1, IHNT2(3)
         DO 1007 J = 1, NTJ(I)
            ITYP = KFTJ(I, J)
            PX = PJTX(I, J)
            PY = PJTY(I, J)
            PZ = PJTZ(I, J)
            PE = PJTE(I, J)
            PM = PJTM(I, J)
            XMT = SQRT(PX ** 2 + PY ** 2 + PM ** 2)
            DXMT = XMT - PM
clin-9/2012 determine rapidity more generally:
ccbzdbg2/16/99
cc            IF (ABS(PZ) .GE. PE) GOTO 400
c            IF (ABS(PZ) .GE. PE) THEN
c               PRINT *, ' IN HJANA2, TARG STR ', I, ' PART ', J
c               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
c               PRINT *, ' PZ = ', PZ, ' EE = ', PE
c               PRINT *, ' XM = ', PM
c               GOTO 400
c            END IF
ccbzdbg2/16/99end
c            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
            if(XMT.gt.0.) then
               RAP=asinh(PZ/XMT)
            else
               PRINT *, ' IN HJANA2 mt=0'
               RAP = 1000000.0*sign(1.,PZ)
            endif

            IY = 1 + int(ABS(RAP) / DY)
clin-8/2014 prevent possible segmentation fault (due to IY<=0):
c            IF (IY .GT. 50) GOTO 300
            IF (IY.lt.1 .or.IY .GT. 50) GOTO 300
            dyp2(IY) = dyp2(IY) + 1.0
            DEYP2(IY) = DEYP2(IY) + XMT
            IF (ITYP .EQ. 21) THEN
               dyg2(IY) = dyg2(IY) + 1.0
               DEYG2(IY) = DEYG2(IY) + XMT
            END IF
 300        CONTINUE
            IF (RAP .GT. YMAX .OR. RAP .LE. YMIN) GOTO 400
            IMT = 1 + int(DXMT / DMT)
            IF (IMT .GT. 200) GOTO 400
            DMYP2(IMT) = DMYP2(IMT) + 1.0 / XMT
            IF (ITYP .EQ. 21) THEN
               DMYG2(IMT) = DMYG2(IMT) + 1.0 / XMT
            END IF
 400        CONTINUE
 1007    CONTINUE
 1008 CONTINUE

clin-4/28/01:
 510  continue

      DO 1010 I = 1, NSG
clin-4/25/01 soft3:
c         DO J = 1, NJSG(I)
         NJ=NJSG(I)
         if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) NJ=NJSGS(I)
         DO 1009 J = 1, NJ
clin-4/25/01-end

            ITYP = K2SG(I, J)
            PX = PXSG(I, J)
            PY = PYSG(I, J)
            PZ = PZSG(I, J)
            PE = PESG(I, J)
            PM = PMSG(I, J)
clin-4/25/01 soft3:
            if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) then
               ITYP = K2SGS(I, J)
               PX = sngl(PXSGS(I, J))
               PY = sngl(PYSGS(I, J))
               PZ = sngl(PZSGS(I, J))
               PE = sngl(PESGS(I, J))
               PM = sngl(PMSGS(I, J))
            endif
clin-4/25/01-end

clin-9/2012 determine rapidity more generally:
            XMT = SQRT(PX ** 2 + PY ** 2 + PM ** 2)
            DXMT = XMT - PM
ccbzdbg2/16/99
cc            IF (ABS(PZ) .GE. PE) GOTO 600
c            IF (ABS(PZ) .GE. PE) THEN
c               PRINT *, ' IN HJANA2, INDP STR ', I, ' PART ', J
c               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
c               PRINT *, ' PZ = ', PZ, ' EE = ', PE
c               PRINT *, ' XM = ', PM
c               GOTO 600
c            END IF
ccbzdbg2/16/99end
c            RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
            if(XMT.gt.0.) then
               RAP=asinh(PZ/XMT)
            else
               PRINT *, ' IN HJANA2 mt=0'
               RAP = 1000000.0*sign(1.,PZ)
            endif

            IY = 1 + int(ABS(RAP) / DY)
clin-8/2014 prevent possible segmentation fault (due to IY<=0):
c            IF (IY .GT. 50) GOTO 500
            IF (IY.lt.1 .or.IY .GT. 50) GOTO 500
            dyp2(IY) = dyp2(IY) + 1.0
            DEYP2(IY) = DEYP2(IY) + XMT
            IF (ITYP .EQ. 21) THEN
               dyg2(IY) = dyg2(IY) + 1.0
               DEYG2(IY) = DEYG2(IY) + XMT
            END IF
 500        CONTINUE
            IF (RAP .GT. YMAX .OR. RAP .LE. YMIN) GOTO 600
            IMT = 1 + int(DXMT / DMT)
            IF (IMT .GT. 200) GOTO 600
            DMYP2(IMT) = DMYP2(IMT) + 1.0 / XMT
            IF (ITYP .EQ. 21) THEN
               DMYG2(IMT) = DMYG2(IMT) + 1.0 / XMT
            END IF
 600        CONTINUE
 1009    CONTINUE
 1010 CONTINUE

clin-4/28/01:
      if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) goto 520

      DO 1011 I = 1, IHNT2(1)
         J = I
         YR = SQRT(sngl(ZT1(J) ** 2 + ZT2(J) ** 2))
         IR = 1 + int(YR / DR)
         IF (IR .GT. 50 .or. IR .LT. 1) GOTO 601
         dnrpj2(IR) = dnrpj2(IR) + 1.0
         dnrtt2(IR) = dnrtt2(IR) + 1.0
 601     CONTINUE
         IT = 1 + int(sngl(ATAUI(J)) / DT)
         IF (IT .GT. 50 .or. IT .LT. 1) GOTO 602
         dtpj2(IT) = dtpj2(IT) + 1.0
         dttot2(IT) = dttot2(IT) + 1.0
 602     CONTINUE
 1011 CONTINUE

      DO 1012 I = 1, IHNT2(3)
         J = I + IHNT2(1)
         YR = SQRT(sngl(ZT1(J) ** 2 + ZT2(J) ** 2))
         IR = 1 + int(YR / DR)
         IF (IR .GT. 50 .or. IR .LT. 1) GOTO 603
         dnrtg2(IR) = dnrtg2(IR) + 1.0
         dnrtt2(IR) = dnrtt2(IR) + 1.0
 603     CONTINUE
         IT = 1 + int(sngl(ATAUI(J)) / DT)
         IF (IT .GT. 50 .or. IT .LT. 1) GOTO 604
         dttg2(IT) = dttg2(IT) + 1.0
         dttot2(IT) = dttot2(IT) + 1.0
 604     CONTINUE
 1012 CONTINUE

clin-4/28/01:
 520  continue

      DO 1013 I = 1, NSG
         J = I + IHNT2(1) + IHNT2(3)
clin-4/28/01:
         if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) J = I

         YR = SQRT(sngl(ZT1(J) ** 2 + ZT2(J) ** 2))
         IR = 1 + int(YR / DR)
         IF (IR .GT. 50 .or. IR .LT. 1) GOTO 605
         dnrin2(IR) = dnrin2(IR) + 1.0
         dnrtt2(IR) = dnrtt2(IR) + 1.0
 605     CONTINUE
         IT = 1 + int(sngl(ATAUI(J)) / DT)
         IF (IT .GT. 50 .or. IT .LT. 1) GOTO 606
         dtin2(IT) = dtin2(IT) + 1.0
         dttot2(IT) = dttot2(IT) + 1.0
 606     CONTINUE
 1013 CONTINUE

      DO 1014 I = 1, MUL
         ITYP = ITYP5(I)
         PX = sngl(PX5(I))
         PY = sngl(PY5(I))
         PZ = sngl(PZ5(I))
         PE = sngl(E5(I))
         PM = sngl(XMASS5(I))
clin-9/2012 determine rapidity more generally:
         XMT = SQRT(PX ** 2 + PY ** 2 + PM ** 2)
         DXMT = XMT - PM
ccbzdbg2/16/99
cc            IF (ABS(PZ) .GE. PE) GOTO 800
c         IF (ABS(PZ) .GE. PE) THEN
c            PRINT *, ' IN HJANA2, GLUON ', I
c            PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
c            PRINT *, ' PZ = ', PZ, ' EE = ', PE
c            PRINT *, ' XM = ', PM
c            GOTO 800
c         END IF
ccbzdbg2/16/99end
c         RAP = 0.5 * LOG((PE + PZ +1e-5) / (PE - PZ + 1e-5))
         if(XMT.gt.0.) then
            RAP=asinh(PZ/XMT)
         else
            PRINT *, ' IN HJANA2 mt=0'
            RAP = 1000000.0*sign(1.,PZ)
         endif

         IY = 1 + int(ABS(RAP) / DY)
clin-9/2012 prevent possible segmentation fault (due to IY<=0):
c         IF (IY .GT. 50) GOTO 700
         IF (IY.lt.1 .or.IY .GT. 50) GOTO 700
         dyg2c(IY) = dyg2c(IY) + 1.0
         deyg2c(IY) = deyg2c(IY) + XMT
 700     CONTINUE
         IF (RAP .GT. YMAX .OR. RAP .LE. YMIN) GOTO 800
         IMT = 1 + int(DXMT / DMT)
         IF (IMT .GT. 50) GOTO 800
         dmyg2c(IMT) = dmyg2c(IMT) + 1.0 / XMT
 800     CONTINUE
 1014 CONTINUE

clin-4/25/01 soft3:
      if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) goto 530

c.....count number of particles
      DO 1016 I = 1, IHNT2(1)
         DO 1015 J = 1, NPJ(I)
            nsubp = nsubp + 1
            IF (KFPJ(I, J) .EQ. 21) nsubg = nsubg + 1
 1015    CONTINUE
 1016 CONTINUE

      DO 1018 I = 1, IHNT2(3)
         DO 1017 J = 1, NTJ(I)
            nsubp = nsubp + 1
            IF (KFTJ(I, J) .EQ. 21) nsubg = nsubg + 1
 1017    CONTINUE
 1018 CONTINUE

clin-4/25/01 soft3:
 530  continue

      DO 1020 I = 1, NSG
clin-4/25/01 soft3:
c         DO J = 1, NJSG(I)
         NJ=NJSG(I)
         if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) NJ=NJSGS(I)
         DO 1019 J = 1, NJ
clin-4/25/01-end

            nsubp = nsubp + 1

clin-4/25/01
c            IF (K2SG(I, J) .EQ. 21) nsubg = nsubg + 1
            if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) then
               IF(K2SGS(I, J) .EQ. 21) nsubg = nsubg + 1
            else
               IF (K2SG(I, J) .EQ. 21) nsubg = nsubg + 1
            endif
clin-4/25/01-end
 1019    CONTINUE
 1020 CONTINUE
cbzdbg2/16/99
      NISG = NISG + NSG

      IF (IOUT .EQ. 1) THEN
cbzdbg2/16/99end
cbzdbg2/16/99
c      PRINT *, ' in HJANA2 '
c      PRINT *, ' total number of partons = ', nsubp
c      PRINT *, ' total number of gluons = ', nsubg, MUL
c      PRINT *, ' number of projectile strings = ', IHNT2(1)
c      PRINT *, ' number of target strings = ', IHNT2(3)
c      PRINT *, ' number of independent strings = ', NSG
      PRINT *, ' in HJANA2 '
      PRINT *, ' total number of partons = ', nsubp / IW
      PRINT *, ' total number of gluons = ', nsubg / IW
c      PRINT *, ' number of projectile strings = ', IHNT2(1)
c      PRINT *, ' number of target strings = ', IHNT2(3)
      PRINT *, ' number of independent strings = ', NISG / IW
      END IF

      CALL HJAN2A
      CALL HJAN2B

      RETURN
      END

c-----------------------------------------------------------------------

c.....subroutine called by HJANA2
      SUBROUTINE HJAN2A

      PARAMETER (DGX = 0.2, DGY = 0.2, DT = 0.2)
      PARAMETER (MAXPTN=400001,MAXSTR=150001)
      DIMENSION dgxp2a(50), dgyp2a(50), dtp2a(50)
      DIMENSION dgxg2a(50), dgyg2a(50), dtg2a(50)
      DIMENSION sgxp2a(50), sgyp2a(50), stp2a(50)
      DIMENSION sgxg2a(50), sgyg2a(50), stg2a(50)
      DOUBLE PRECISION  GX5, GY5, GZ5, FT5, PX5, PY5, PZ5, E5, XMASS5
      COMMON /PARA1/ MUL
cc      SAVE /PARA1/
      COMMON /prec2/GX5(MAXPTN),GY5(MAXPTN),GZ5(MAXPTN),FT5(MAXPTN),
     &   PX5(MAXPTN), PY5(MAXPTN), PZ5(MAXPTN), E5(MAXPTN),
     &   XMASS5(MAXPTN), ITYP5(MAXPTN)
cc      SAVE /prec2/
      COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
      COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
      COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &   PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &   PJPM(300,500),NTJ(300),KFTJ(300,500),
     &   PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &   PJTE(300,500),PJTM(300,500)
cc      SAVE /HJJET1/
      COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &   K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &   PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
      COMMON /AREVT/ IAEVT, IARUN, MISS
cc      SAVE /AREVT/
      COMMON /AROUT/ IOUT
cc      SAVE /AROUT/
      SAVE   
      DATA IW/0/

      IF (isevt .EQ. IAEVT .AND. isrun .EQ. IARUN) THEN
         DO 1001 I = 1, 50
            dgxp2a(I) = sgxp2a(I)
            dgyp2a(I) = sgyp2a(I)
            dtp2a(I) = stp2a(I)
            dgxg2a(I) = sgxg2a(I)
            dgyg2a(I) = sgyg2a(I)
            dtg2a(I) = stg2a(I)
 1001    CONTINUE
      ELSE
         DO 1002 I = 1, 50
            sgxp2a(I) = dgxp2a(I)
            sgyp2a(I) = dgyp2a(I)
            stp2a(I) = dtp2a(I)
            sgxg2a(I) = dgxg2a(I)
            sgyg2a(I) = dgyg2a(I)
            stg2a(I) = dtg2a(I)
 1002    CONTINUE
         isevt = IAEVT
         isrun = IARUN
         IW = IW + 1
      END IF
c.....analysis
      DO 1004 I = 1, IHNT2(1)
         DO 1003 J = 1, NPJ(I)
            IF (KFPJ(I, J) .NE. 21) THEN
               IGX = 1 + int(ABS(YP(1, I)) / DGX)
               IF (IGX .GT. 50 .or. IGX .LT. 1) GOTO 100
               dgxp2a(IGX) = dgxp2a(IGX) + 1.0
 100           CONTINUE
               IGY = 1 + int(ABS(YP(2, I)) / DGY)
               IF (IGY .GT. 50 .or. IGY .LT. 1) GOTO 200
               dgyp2a(IGY) = dgyp2a(IGY) + 1.0
 200           CONTINUE
               IT = 1
               dtp2a(IT) = dtp2a(IT) + 1.0
            END IF
 1003    CONTINUE
 1004 CONTINUE

      DO 1006 I = 1, IHNT2(3)
         DO 1005 J = 1, NTJ(I)
            IF (KFTJ(I, J) .NE. 21) THEN
               IGX = 1 + int(ABS(YT(1, I)) / DGX)
               IF (IGX .GT. 50 .or. IGX .LT. 1) GOTO 300
               dgxp2a(IGX) = dgxp2a(IGX) + 1.0
 300           CONTINUE
               IGY = 1 + int(ABS(YT(2, I)) / DGY)
               IF (IGY .GT. 50 .or. IGY .LT. 1) GOTO 400
               dgyp2a(IGY) = dgyp2a(IGY) + 1.0
 400           CONTINUE
               IT = 1
               dtp2a(IT) = dtp2a(IT) + 1.0
            END IF
 1005    CONTINUE
 1006 CONTINUE

      DO 1008 I = 1, NSG
         DO 1007 J = 1, NJSG(I)
            IF (K2SG(I, J) .NE. 21) THEN
               IGX = 1 + int(ABS(0.5 * 
     &            (YP(1, IASG(I, 1)) + YT(1, IASG(I, 2)))) / DGX)
               IF (IGX .GT. 50 .or. IGX .LT. 1) GOTO 500
               dgxp2a(IGX) = dgxp2a(IGX) + 1.0
 500           CONTINUE
               IGY = 1 + int(ABS(0.5 * 
     &            (YP(2, IASG(I, 1)) + YT(2, IASG(I, 2)))) / DGY)
               IF (IGY .GT. 50 .or. IGY .LT. 1) GOTO 600
               dgyp2a(IGY) = dgyp2a(IGY) + 1.0
 600           CONTINUE
               IT = 1
               dtp2a(IT) = dtp2a(IT) + 1.0               
            END IF
 1007    CONTINUE
 1008 CONTINUE

      DO 1009 I = 1, MUL
         IGX = 1 + int(ABS(sngl(GX5(I))) / DGX)
         IF (IGX .GT. 50 .or. IGX .LT. 1) GOTO 700
         dgxg2a(IGX) = dgxg2a(IGX) + 1.0
         dgxp2a(IGX) = dgxp2a(IGX) + 1.0
 700     CONTINUE
         IGY = 1 + int(ABS(sngl(GY5(I))) / DGY)
         IF (IGY .GT. 50 .or. IGY .LT. 1) GOTO 800
         dgyg2a(IGY) = dgyg2a(IGY) + 1.0
         dgyp2a(IGY) = dgyp2a(IGY) + 1.0
 800     CONTINUE
clin-9/2015 to avoid Floating-Point Exception:
c         IT = 1 + int(SQRT(sngl(FT5(I) ** 2 - GZ5(I) ** 2)) / DT)
         diff2=sngl(FT5(I)**2 - GZ5(I)**2)
         if(diff2.lt.0.) then
            write(6,*) '3:I,ft5,gz5,diff2=',I,ft5(i),gz5(i),diff2
            IT=1
         else
            IT = 1 + int(SQRT(diff2)/DT)
         endif
c
         IF (IT .GT. 50 .or. IT .LT. 1) GOTO 900
         dtg2a(IT) = dtg2a(IT) + 1.0
         dtp2a(IT) = dtp2a(IT) + 1.0
 900     CONTINUE
 1009 CONTINUE
c
      RETURN
      END

c-----------------------------------------------------------------------

c.....analysis subroutine in HJANA2

      SUBROUTINE HJAN2B

      PARAMETER (MAXPTN=400001)
      PARAMETER (MAXSTR=150001)
      PARAMETER (DR = 0.2, DT = 0.2)
      DIMENSION DNRG2B(50), dtg2b(-24:25)
      DIMENSION SNRG2B(50), stg2b(-24:25)
      DOUBLE PRECISION  GX5, GY5, GZ5, FT5, PX5, PY5, PZ5, E5, XMASS5
      DOUBLE PRECISION  ATAUI, ZT1, ZT2, ZT3
      COMMON /PARA1/ MUL
cc      SAVE /PARA1/
      COMMON /prec2/GX5(MAXPTN),GY5(MAXPTN),GZ5(MAXPTN),FT5(MAXPTN),
     &   PX5(MAXPTN), PY5(MAXPTN), PZ5(MAXPTN), E5(MAXPTN),
     &   XMASS5(MAXPTN), ITYP5(MAXPTN)
cc      SAVE /prec2/
      COMMON /ilist8/ LSTRG1(MAXPTN), LPART1(MAXPTN)
cc      SAVE /ilist8/
      COMMON /SREC1/ NSP, NST, NSI
cc      SAVE /SREC1/
      COMMON /SREC2/ATAUI(MAXSTR),ZT1(MAXSTR),ZT2(MAXSTR),ZT3(MAXSTR)
cc      SAVE /SREC2/
      COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
      COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &   K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &   PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
      COMMON /AREVT/ IAEVT, IARUN, MISS
cc      SAVE /AREVT/
      COMMON /AROUT/ IOUT
cc      SAVE /AROUT/
      SAVE   
      DATA IW/0/

      IF (isevt .EQ. IAEVT .AND. isrun .EQ. IARUN) THEN
         DO 1001 I = 1, 50
            DNRG2B(I) = SNRG2B(I)
            dtg2b(I - 25) = stg2b(I - 25)
 1001    CONTINUE
      ELSE
         DO 1002 I = 1, 50
            SNRG2B(I) = DNRG2B(I)
            stg2b(I - 25) = dtg2b(I - 25)
 1002    CONTINUE
         isevt = IAEVT
         isrun = IARUN
         IW = IW + 1
      END IF
c.....analysis
      DO 1003 I = 1, MUL
         J = LSTRG1(I)
         GX0 = sngl(ZT1(J))
         GY0 = sngl(ZT2(J))
         R0 = SQRT((sngl(GX5(I)) - GX0)**2 + (sngl(GY5(I)) - GY0)**2)
         IR = 1 + int(R0 / DR)
         IF (IR .GT. 50 .or. IR .LT. 1) GOTO 100
         DNRG2B(IR) = DNRG2B(IR) + 1.0
 100     CONTINUE
clin-9/2015 to avoid Floating-Point Exception:
c         TAU7 = SQRT(sngl(FT5(I) ** 2 - GZ5(I) ** 2))
         diff2=sngl(FT5(I)**2 - GZ5(I)**2)
         if(diff2.lt.0.) then
            write(6,*) '4:I,ft5,gz5,diff2=',I,ft5(i),gz5(i),diff2
            TAU7=1e-6
         else
            TAU7 = SQRT(diff2)
         endif
c
         DTAU=TAU7 - sngl(ATAUI(J))
         IT = 1 + int(DTAU / DT)
cbzdbg2/21/99
c         IF (ABS(IT) .GT. 25) GOTO 200
         IF (IT .GT. 25 .OR. IT .LT. -24) GOTO 200
cbzdbg2/21/99end
         dtg2b(IT) = dtg2b(IT) + 1.0
 200     CONTINUE
 1003 CONTINUE
c
      RETURN
      END

c-----------------------------------------------------------------------

c.....analysis subroutine before ARTMN
      SUBROUTINE HJANA3
c
      PARAMETER (MAXSTR=150001, MAXR=1)
c.....y cut for mt spectrum
      PARAMETER (YMIN = -1.0, YMAX = 1.0)
cbz11/7/99 end
c.....bin width for mt spectrum and y spectrum
      PARAMETER (DMT = 0.05, DY = 0.2)
      DOUBLE PRECISION v2i,eti,xmulti,v2mi,s2mi,xmmult,
     1     v2bi,s2bi,xbmult
      DIMENSION dndyh3(50), DMYH3(50), DEYH3(50)
      COMMON /RUN/ NUM
cc      SAVE /RUN/
      COMMON /ARERC1/MULTI1(MAXR)
cc      SAVE /ARERC1/
      COMMON /ARPRC1/ITYP1(MAXSTR, MAXR),
     &     GX1(MAXSTR, MAXR), GY1(MAXSTR, MAXR), GZ1(MAXSTR, MAXR), 
     &     FT1(MAXSTR, MAXR),
     &     PX1(MAXSTR, MAXR), PY1(MAXSTR, MAXR), PZ1(MAXSTR, MAXR),
     &     EE1(MAXSTR, MAXR), XM1(MAXSTR, MAXR)
cc      SAVE /ARPRC1/
      COMMON /AROUT/ IOUT
cc      SAVE /AROUT/
      COMMON/iflow/v2i,eti,xmulti,v2mi,s2mi,xmmult,v2bi,s2bi,xbmult
cc      SAVE /iflow/
      SAVE   
      DATA IW/0/

      IW = IW + 1
      DO 1002 J = 1, NUM
         DO 1001 I = 1, MULTI1(J)
            ITYP = ITYP1(I, J)
            IF (ITYP .GT. -100 .AND. ITYP .LT. 100) GOTO 200
            PX = PX1(I, J)
            PY = PY1(I, J)
            PZ = PZ1(I, J)
            EE = EE1(I, J)
            XM = XM1(I, J)
            XMT = SQRT(PX ** 2 + PY ** 2 + XM ** 2)
            DXMT = XMT - XM
clin-9/2012 determine rapidity more generally:
c            IF (ABS(PZ) .GE. EE) THEN
c               PRINT *, 'IN HJANA3'
c               PRINT *, ' PARTICLE ', I, ' RUN ', J, 'PREC ERR'
c               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
c               PRINT *, ' PZ = ', PZ, ' EE = ', EE
c               PRINT *, ' XM = ', XM
c               GOTO 200
c            END IF
c            Y = 0.5 * LOG((EE + PZ +1e-5) / (EE - PZ + 1e-5))
            if(XMT.gt.0.) then
               Y=asinh(PZ/XMT)
            else
               PRINT *, ' IN HJANA3 mt=0'
               Y = 1000000.0*sign(1.,PZ)
            endif

c.....rapidity cut for the rapidity distribution
c            IY = 1 + int(ABS(Y) / DY)
clin-8/2014 no rapidity shift here:
c            IY = 1 + int((Y+10.) / DY)
            IY = 1 + int(Y/DY)
clin-9/2012 prevent possible segmentation fault (due to IY<=0):
c            IF (IY .GT. 50) GOTO 100
            IF (IY.lt.1 .or.IY .GT. 50) GOTO 100
            dndyh3(IY) = dndyh3(IY) + 1.0
            DEYH3(IY) = DEYH3(IY) + XMT
 100        CONTINUE
c.....insert rapidity cut for mt spectrum here
            IF (Y. LT. YMIN .OR. Y .GE. YMAX) GOTO 200
            IMT = 1 + int(DXMT / DMT)
            IF (IMT .GT. 50) GOTO 200
            DMYH3(IMT) = DMYH3(IMT) + 1.0 / XMT
 200        CONTINUE
 1001    CONTINUE
 1002 CONTINUE
c
      RETURN
      END

c-----------------------------------------------------------------------

c.....analysis subroutine after ARTMN
      SUBROUTINE HJANA4
      PARAMETER (MAXSTR=150001, MAXR=1)
c.....y cut for mt spectrum
cbz11/7/99
c      PARAMETER (YMIN = -0.5, YMAX = 0.5)
      PARAMETER (YMIN = -1.0, YMAX = 1.0)
cbz11/7/99 end
c.....bin width for mt spectrum and y spectrum
      PARAMETER (DMT = 0.05, DY = 0.2)

      DIMENSION dndyh4(50), DMYH4(50), DEYH4(50)
      COMMON /RUN/ NUM
cc      SAVE /RUN/
      COMMON /ARERC1/MULTI1(MAXR)
cc      SAVE /ARERC1/
      COMMON /ARPRC1/ITYP1(MAXSTR, MAXR),
     &     GX1(MAXSTR, MAXR), GY1(MAXSTR, MAXR), GZ1(MAXSTR, MAXR), 
     &     FT1(MAXSTR, MAXR),
     &     PX1(MAXSTR, MAXR), PY1(MAXSTR, MAXR), PZ1(MAXSTR, MAXR),
     &     EE1(MAXSTR, MAXR), XM1(MAXSTR, MAXR)
cc      SAVE /ARPRC1/
      COMMON /AROUT/ IOUT
cc      SAVE /AROUT/
      COMMON /fflow/ v2f,etf,xmultf,v2fpi,xmulpi
cc      SAVE /fflow/
      SAVE   
      DATA IW/0/

      IW = IW + 1
      DO 1002 J = 1, NUM
         DO 1001 I = 1, MULTI1(J)
            ITYP = ITYP1(I, J)
            IF (ITYP .GT. -100 .AND. ITYP .LT. 100) GOTO 200
            PX = PX1(I, J)
            PY = PY1(I, J)
            PZ = PZ1(I, J)
            EE = EE1(I, J)
            XM = XM1(I, J)
            XMT = SQRT(PX ** 2 + PY ** 2 + XM ** 2)
            DXMT = XMT - XM
clin-9/2012 determine rapidity more generally:
c            IF (ABS(PZ) .GE. EE) THEN
c               PRINT *, 'IN HJANA4'
c               PRINT *, ' PARTICLE ', I, ' RUN ', J, 'PREC ERR'
c               PRINT *, ' FLAV = ', ITYP, ' PX = ', PX, ' PY = ', PY
c               PRINT *, ' PZ = ', PZ, ' EE = ', EE
c               PRINT *, ' XM = ', XM
c               GOTO 200
c            END IF
c            Y = 0.5 * LOG((EE + PZ +1e-5) / (EE - PZ + 1e-5))
            if(XMT.gt.0.) then
               Y=asinh(PZ/XMT)
            else
               PRINT *, ' IN HJANA4 mt=0'
               Y = 1000000.0*sign(1.,PZ)
            endif

c.....rapidity cut for the rapidity distribution
c            IY = 1 + int(ABS(Y) / DY)
clin-8/2014 no rapidity shift here:
c            IY = 1 + int((Y+10.) / DY)
            IY = 1 + int(Y/DY)
clin-9/2012 prevent possible segmentation fault (due to IY<=0):
c            IF (IY .GT. 50) GOTO 100
            IF (IY.lt.1 .or.IY .GT. 50) GOTO 100
            dndyh4(IY) = dndyh4(IY) + 1.0
            DEYH4(IY) = DEYH4(IY) + XMT
 100        CONTINUE
c.....insert rapidity cut for mt spectrum here
            IF (Y. LT. YMIN .OR. Y .GE. YMAX) GOTO 200
            IMT = 1 + int(DXMT / DMT)
            IF (IMT .GT. 50) GOTO 200
            DMYH4(IMT) = DMYH4(IMT) + 1.0 / XMT
 200        CONTINUE
 1001    CONTINUE
 1002 CONTINUE
c
      RETURN
      END

c=======================================================================

c.....subroutine to get average values for different strings

      SUBROUTINE zpstrg

      IMPLICIT DOUBLE PRECISION (A-H, O-Z)
      PARAMETER (MAXPTN=400001)
      PARAMETER (MAXSTR=150001)
c      REAL*4 YP, YT, PXSG, PYSG, PZSG, PESG, PMSG, HIPR1, HINT1, BB
      REAL YP, YT, PXSG, PYSG, PZSG, PESG, PMSG, HIPR1, HINT1, BB

      COMMON /PARA1/ MUL
cc      SAVE /PARA1/
      COMMON /prec2/GX5(MAXPTN),GY5(MAXPTN),GZ5(MAXPTN),FT5(MAXPTN),
     &   PX5(MAXPTN), PY5(MAXPTN), PZ5(MAXPTN), E5(MAXPTN),
     &   XMASS5(MAXPTN), ITYP5(MAXPTN)
cc      SAVE /prec2/
      COMMON /ilist8/ LSTRG1(MAXPTN), LPART1(MAXPTN)
cc      SAVE /ilist8/
      COMMON /SREC1/ NSP, NST, NSI
cc      SAVE /SREC1/
      COMMON /SREC2/ATAUI(MAXSTR),ZT1(MAXSTR),ZT2(MAXSTR),ZT3(MAXSTR)
cc      SAVE /SREC2/
      COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
      COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &   K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &   PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
cbz6/28/99 flow1
      COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
cbz6/28/99 flow1 end
      common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
      common/strg/np(maxstr)
cc      SAVE /strg/
clin-6/06/02 test local freezeout:
      common /frzprc/ 
     &     gxfrz(MAXPTN), gyfrz(MAXPTN), gzfrz(MAXPTN), ftfrz(MAXPTN),
     &     pxfrz(MAXPTN), pyfrz(MAXPTN), pzfrz(MAXPTN), efrz(MAXPTN),
     &     xmfrz(MAXPTN), 
     &     tfrz(302), ifrz(MAXPTN), idfrz(MAXPTN), itlast
cc      SAVE /frzprc/
      SAVE   

clin-6/06/02 test local freezeout for string melting,
c     use space-time values at local freezeout saved in /frzprc/:
      if(isoft.eq.5) then
         do 1001 I = 1, MUL
            ITYP5(i)=idfrz(i)
            GX5(i)=gxfrz(i)
            GY5(i)=gyfrz(i)
            GZ5(i)=gzfrz(i)
            FT5(i)=ftfrz(i)
            PX5(i)=pxfrz(i)
            PY5(i)=pyfrz(i)
            PZ5(i)=pzfrz(i)
            E5(i)=efrz(i)
            XMASS5(i)=xmfrz(i)
 1001    continue
      endif
clin-6/06/02-end

      DO 1002 I = 1, MAXSTR
         ATAUI(I) = 0d0
         ZT1(I) = 0d0
         ZT2(I) = 0d0
clin-4/25/03 add zt3(I) to track longitudinal positions of partons/strings:
         ZT3(I) = 0d0
         NP(I) = 0
 1002 CONTINUE
      DO 1003 I = 1, MUL
         ISTRG = LSTRG1(I)
clin-9/2015 to avoid Floating-Point Exception:
c         TAU7 = SQRT(FT5(I) ** 2 - GZ5(I) ** 2)
         diff2=FT5(I)**2 - GZ5(I)**2
         if(diff2.lt.0d0) then
            write(6,*) '2:I,ft5,gz5,diff2=',I,ft5(i),gz5(i),diff2
            TAU7=1d-6
         else
            TAU7 = dSQRT(diff2)
         endif
c
         ATAUI(ISTRG) = ATAUI(ISTRG) + TAU7
         ZT1(ISTRG) = ZT1(ISTRG) + GX5(I)
         ZT2(ISTRG) = ZT2(ISTRG) + GY5(I)
         ZT3(ISTRG) = ZT3(ISTRG) + GZ5(I)
         NP(ISTRG) = NP(ISTRG) + 1
 1003 CONTINUE
      
      NSTR = NSP + NST + NSI

clin-7/03/01 correct averaging on transverse coordinates, no shift needed:
      if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) then
         DO 1004 I = 1, NSTR
            IF (NP(I) .NE. 0) THEN
               ATAUI(I) = ATAUI(I) / NP(I)
               ZT1(I) = ZT1(I) / NP(I)
               ZT2(I) = ZT2(I) / NP(I)
               ZT3(I) = ZT3(I) / NP(I)
            ENDIF
 1004    CONTINUE
         return
      endif
clin-7/03/01-end

      DO 1005 I = 1, NSTR
         IF (NP(I) .NE. 0) THEN
            ATAUI(I) = ATAUI(I) / NP(I)
            ZT1(I) = ZT1(I) / NP(I)
            ZT2(I) = ZT2(I) / NP(I)
            ZT3(I) = ZT3(I) / NP(I)
         ELSE
            IF (I .LE. NSP) THEN
               J = I
               ZT1(I) = dble(YP(1, J))
               ZT2(I) = dble(YP(2, J))
               ZT3(I) = 0d0
            ELSE IF (I .GT. NSP .AND. I .LE. NSP + NST) THEN
               J = I - NSP
               ZT1(I) = dble(YT(1, J))
               ZT2(I) = dble(YT(2, J))
               ZT3(I) = 0d0
            ELSE
               J = I - NSP - NST
               ZT1(I) = 0.5d0*
     1              dble((YP(1, IASG(J, 1)) + YT(1, IASG(J, 2))))
               ZT2(I) = 0.5d0 *
     1              dble((YP(2, IASG(J, 1)) + YT(2, IASG(J, 2))))
               ZT3(I) = 0d0
            END IF
         END IF
 1005 CONTINUE

cbz6/28/99 flow1
      BB = HINT1(19)
      DO 1006 I = 1, NSTR
         IF (NP(I).NE.0) THEN
            SHIFT=0d0
         ELSE
            SHIFT=0.5d0*dble(BB)
         END IF
         IF (I .LE. NSP) THEN
            ZT1(I) = ZT1(I) + SHIFT
         ELSE IF (I .GT. NSP .AND. I .LE. NSP + NST) THEN
            ZT1(I) = ZT1(I) - SHIFT
         END IF
 1006 CONTINUE
cbz6/28/99 flow1 end
c
      RETURN
      END

clin-10/01/03 random number generator for f77:
      function RANART(NSEED)
      SAVE   
clin-4/2008 ran(nseed) is renamed to avoid conflict with system functions:
c      ran=rand()
      ranart=rand(0)
c     one may also use the following random number generator in PYTHIA/JETSET:
c      ranart=rlu(0)
      return
      end

clin-3/2009
c     Initialize hadron weights; 
c     Can add initial hadrons before the hadron cascade starts (but after ZPC).
      subroutine addhad
      PARAMETER (MAXSTR=150001,MAXR=1,xmd=1.8756)
      double precision  smearp,smearh
      COMMON /ARPRNT/ ARPAR1(100), IAPAR2(50), ARINT1(100), IAINT2(50)
      COMMON /ARPRC/ ITYPAR(MAXSTR),
     &     GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
     &     PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
     &     XMAR(MAXSTR)
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      COMMON /smearz/smearp,smearh
      COMMON/RNDF77/NSEED
      common /para8/ idpert,npertd,idxsec
      SAVE   

c     All hadrons at the start of hadron cascade have the weight of 1
c     except those inserted by the user in this subroutine:
      np0=IAINT2(1)
      DO i=1,np0
         dpertp(I)=1.
      ENDDO
c     Specify number, species, weight, initial x,p,m for inserted hadrons here:
      nadd=0
      tau0=ARPAR1(1)
      DO 100 i=np0+1,np0+nadd
         ITYPAR(I)=42
clin-5/2012 fix type mismatch:
c         dpertp(I)=1d0/dble(nadd)
         dpertp(I)=1./float(nadd)
         GXAR(I)=5.*(1.-2.*RANART(NSEED))
         GYAR(I)=5.*(1.-2.*RANART(NSEED))
         GZAR(I)=2.*(1.-2.*RANART(NSEED))
         FTAR(I)=0.
         PXAR(I)=1.
         PYAR(I)=0.
         PZAR(I)=1.
         XMAR(I)=xmd
c
         PEAR(I)=sqrt(PXAR(I)**2+PYAR(I)**2+PZAR(I)**2+XMAR(I)**2)
clin-9/2012 determine rapidity more generally:
c         RAP=0.5*alog((PEAR(I)+PZAR(I)+1e-5)/(PEAR(I)-PZAR(I)+1e-5))
         RAP=asinh(PZAR(I)/sqrt(XMAR(I)**2+PXAR(I)**2+PYAR(I)**2))
c
         VX=PXAR(I)/PEAR(I)
         VY=PYAR(I)/PEAR(I)
c.....give initial formation time shift and boost according to rapidity:
         TAUI=FTAR(I)+TAU0
         FTAR(I)=TAUI*COSH(RAP)
         GXAR(I)=GXAR(I)+VX*TAU0*COSH(RAP)
         GYAR(I)=GYAR(I)+VY*TAU0*COSH(RAP)
c     Allow the intial z-position to be different from the Bjorken picture:
         GZAR(I)=TAUI*SINH(RAP)+GZAR(I)
c         GZAR(I)=TAUI*SINH(RAP)
         zsmear=sngl(smearh)*(2.*RANART(NSEED)-1.)
         GZAR(I)=GZAR(I)+zsmear
 100  CONTINUE
      IAINT2(1)=IAINT2(1)+nadd
c
      if(nadd.ge.1.and.idpert.ne.1.and.idpert.ne.2) then
         write(16,*) 'IDPERT must be 1 or 2 to add initial hadrons,
     1 set NPERTD to 0 if you do not need perturbative deuterons'
         stop
      endif
      if(IAINT2(1).gt.MAXSTR) then
         write(16,*) 'Too many initial hadrons, array size is exceeded!'
         stop
      endif
c
      return
      end

clin-8/2014 define function asinh():
      FUNCTION asinh(x)
      SAVE
      if(x.gt.0) then
         ASINH=alog(x+sqrt(x**2+1.))
      else
c     a la suggestion de YP Liu:
         ASINH=-alog(-x+sqrt(x**2+1.))
      endif
      return
      end
c....................art1f.f
**************************************
*
*                           PROGRAM ART1.0 
*
*        A relativistic transport (ART) model for heavy-ion collisions
*
*   sp/01/04/2002
*   calculates K+K- from phi decay, dimuons from phi decay
*   has finite baryon density & possibilites of varying Kaon 
*   in-medium mass in phiproduction-annhilation channel only.
*
*
* RELEASING DATE: JAN., 1997 
***************************************
* 
* Bao-An Li & Che Ming Ko
* Cyclotron Institute, Texas A&M University.
* Phone: (409) 845-1411
* e-mail: Bali@comp.tamu.edu & Ko@comp.tamu.edu 
* http://wwwcyc.tamu.edu/~bali
***************************************
* Speical notice on the limitation of the code:
* 
* (1) ART is a hadronic transport model
* 
* (2) E_beam/A <= 15 GeV
* 
* (3) The mass of the colliding system is limited by the dimensions of arrays
*    which can be extended purposely. Presently the dimensions are large enough
*     for running Au+Au at 15 GeV/A.
*
* (4) The production and absorption of antiparticles (e.g., ki-, anti-nucleons,
*     etc) are not fully included in this version of the model. They, however, 
*     have essentially no effect on the reaction dynamics and observables 
*     related to nucleons, pions and kaons (K+) at and below AGS energies.
* 
* (5) Bose enhancement for mesons and Pauli blocking for fermions are 
*     turned off.
* 
*********************************
*
* USEFUL REFERENCES ON PHYSICS AND NUMERICS OF NUCLEAR TRANSPORT MODELS:
*     G.F. BERTSCH AND DAS GUPTA, PHYS. REP. 160 (1988) 189.
*     B.A. LI AND W. BAUER, PHYS. REV. C44 (1991) 450.
*     B.A. LI, W. BAUER AND G.F. BERTSCH, PHYS. REV. C44 (1991) 2095.
*     P. DANIELEWICZ AND G.F. BERTSCH, NUCL. PHYS. A533 (1991) 712.
* 
* MAIN REFERENCES ON THIS VERSION OF ART MODEL:
*     B.A. LI AND C.M. KO, PHYS. REV. C52 (1995) 2037; 
*                          NUCL. PHYS. A601 (1996) 457. 
*
**********************************
**********************************
*  VARIABLES IN INPUT-SECTION:                                               * 
*                                                                      *
*  1) TARGET-RELATED QUANTITIES                                        *
*       MASSTA, ZTA -  TARGET MASS IN AMU, TARGET CHARGE  (INTEGER)    *
*                                                                      *
*  2) PROJECTILE-RELATED QUANTITIES                                    *
*       MASSPR, ZPR -  PROJECTILE MASS IN AMU, PROJ. CHARGE(INTEGER)   *
*       ELAB     -  BEAM ENERGY IN [MEV/NUCLEON]               (REAL)  *
*       ZEROPT   -  DISPLACEMENT OF THE SYSTEM IN Z-DIREC. [FM](REAL)  *
*       B        -  IMPACT PARAMETER [FM]                      (REAL)  *
*                                                                      *
*  3) PROGRAM-CONTROL PARAMETERS                                       *
*       ISEED    -  SEED FOR RANDOM NUMBER GENERATOR        (INTEGER)  *
*       DT       -  TIME-STEP-SIZE [FM/C]                      (REAL)  *
*       NTMAX    -  TOTAL NUMBER OF TIMESTEPS               (INTEGER)  *
*       ICOLL    -  (= 1 -> MEAN FIELD ONLY,                           *
*                -   =-1 -> CACADE ONLY, ELSE FULL ART)     (INTEGER)  *
*       NUM      -  NUMBER OF TESTPARTICLES PER NUCLEON     (INTEGER)  *
*       INSYS    -  (=0 -> LAB-SYSTEM, ELSE C.M. SYSTEM)    (INTEGER)  *
*       IPOT     -  1 -> SIGMA=2; 2 -> SIGMA=4/3; 3 -> SIGMA=7/6       *
*                   IN MEAN FIELD POTENTIAL                 (INTEGER)  *
*       MODE     -  (=1 -> interpolation for pauli-blocking,           *
*                    =2 -> local lookup, other -> unblocked)(integer)  *
*       DX,DY,DZ -  widths of cell for paulat in coor. sp. [fm](real)  *
*       DPX,DPY,DPZ-widths of cell for paulat in mom. sp.[GeV/c](real) *
*       IAVOID   -  (=1 -> AVOID FIRST COLL. WITHIN SAME NUCL.         *
*                    =0 -> ALLOW THEM)                      (INTEGER)  *
*       IMOMEN   -  FLAG FOR CHOICE OF INITIAL MOMENTUM DISTRIBUTION   *
*                   (=1 -> WOODS-SAXON DENSITY AND LOCAL THOMAS-FERMI  *
*                    =2 -> NUCLEAR MATTER DEN. AND LOCAL THOMAS-FERMI  *
*                    =3 -> COHERENT BOOST IN Z-DIRECTION)   (INTEGER)  *
*  4) CONTROL-PRINTOUT OPTIONS                                         *
*       NFREQ    -  NUMBER OF TIMSTEPS AFTER WHICH PRINTOUT            *
*                   IS REQUIRED OR ON-LINE ANALYSIS IS PERFORMED       *
*       ICFLOW      =1 PERFORM ON-LINE FLOW ANALYSIS EVERY NFREQ STEPS *
*       ICRHO       =1 PRINT OUT THE BARYON,PION AND ENERGY MATRIX IN  *
*                      THE REACTION PLANE EVERY NFREQ TIME-STEPS       *
*  5)
*       CYCBOX   -  ne.0 => cyclic boundary conditions;boxsize CYCBOX  *
*
**********************************
*               Lables of particles used in this code                     *
**********************************
*         
*         LB(I) IS USED TO LABEL PARTICLE'S CHARGE STATE
*    
*         LB(I)   =
clin-11/07/00:
*                -30 K*-
clin-8/29/00
*                -13 anti-N*(+1)(1535),s_11
*                -12 anti-N*0(1535),s_11
*                 -11 anti-N*(+1)(1440),p_11
*                 -10 anti-N*0(1440), p_11
*                  -9 anti-DELTA+2
*                  -8 anti-DELTA+1
*                  -7 anti-DELTA0
*                  -6 anti-DELTA-1
clin-8/29/00-end

cbali2/7/99 
*                  -2 antineutron 
*                             -1       antiproton
cbali2/7/99 end 
*                   0 eta
*                        1 PROTON
*                   2 NUETRON
*                   3 PION-
*                   4 PION0
*                   5 PION+
*                   6 DELTA-1
*                   7 DELTA0
*                   8 DELTA+1
*                   9 DELTA+2
*                   10 N*0(1440), p_11
*                   11 N*(+1)(1440),p_11
*                  12 N*0(1535),s_11
*                  13 N*(+1)(1535),s_11
*                  14 LAMBDA
*                   15 sigma-, since we used isospin averaged xsection for
*                   16 sigma0  sigma associated K+ production, sigma0 and 
*                   17 sigma+  sigma+ are counted as sigma-
*                   21 kaon-
*                   23 KAON+
*                   24 kaon0
*                   25 rho-
*                         26 rho0
*                   27 rho+
*                   28 omega meson
*                   29 phi
clin-11/07/00:
*                  30 K*+
* sp01/03/01
*                 -14 LAMBDA(bar)
*                  -15 sigma-(bar)
*                  -16 sigma0(bar)
*                  -17 sigma+(bar)
*                   31 eta-prime
*                   40 cascade-
*                  -40 cascade-(bar)
*                   41 cascade0
*                  -41 cascade0(bar)
*                   45 Omega baryon
*                  -45 Omega baryon(bar)
* sp01/03/01 end
clin-5/2008:
*                   42 Deuteron (same in ampt.dat)
*                  -42 anti-Deuteron (same in ampt.dat)
c
*                   ++  ------- SEE BAO-AN LI'S NOTE BOOK
**********************************
cbz11/16/98
c      PROGRAM ART
       SUBROUTINE ARTMN
cbz11/16/98end
**********************************
* PARAMETERS:                                                           *
*  MAXPAR     - MAXIMUM NUMBER OF PARTICLES      PROGRAM CAN HANDLE     *
*  MAXP       - MAXIMUM NUMBER OF CREATED MESONS PROGRAM CAN HANDLE     *
*  MAXR       - MAXIMUM NUMBER OF EVENTS AT EACH IMPACT PARAMETER       *
*  MAXX       - NUMBER OF MESHPOINTS IN X AND Y DIRECTION = 2 MAXX + 1  *
*  MAXZ       - NUMBER OF MESHPOINTS IN Z DIRECTION       = 2 MAXZ + 1  *
*  AMU        - 1 ATOMIC MASS UNIT "GEV/C**2"                           *
*  MX,MY,MZ   - MESH SIZES IN COORDINATE SPACE [FM] FOR PAULI LATTICE   *
*  MPX,MPY,MPZ- MESH SIZES IN MOMENTUM SPACE [GEV/C] FOR PAULI LATTICE  *
*---------------------------------------------------------------------- *
clin      PARAMETER     (maxpar=200000,MAXR=50,AMU= 0.9383,
      PARAMETER     (MAXSTR=150001,MAXR=1,AMU= 0.9383,
     1               AKA=0.498,etaM=0.5475)
      PARAMETER     (MAXX   =   20,  MAXZ  =    24)
      PARAMETER     (ISUM   =   1001,  IGAM  =    1100)
      parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
clin      PARAMETER (MAXP = 14000)
*----------------------------------------------------------------------*
      INTEGER   OUTPAR, zta,zpr
      COMMON  /AA/      R(3,MAXSTR)
cc      SAVE /AA/
      COMMON  /BB/      P(3,MAXSTR)
cc      SAVE /BB/
      COMMON  /CC/      E(MAXSTR)
cc      SAVE /CC/
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      COMMON  /EE/      ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      COMMON  /HH/  PROPER(MAXSTR)
cc      SAVE /HH/
      common  /ff/f(-mx:mx,-my:my,-mz:mz,-mpx:mpx,-mpy:mpy,-mpz:mpzp)
cc      SAVE /ff/
      common  /gg/      dx,dy,dz,dpx,dpy,dpz
cc      SAVE /gg/
      COMMON  /INPUT/ NSTAR,NDIRCT,DIR
cc      SAVE /INPUT/
      COMMON  /PP/      PRHO(-20:20,-24:24)
      COMMON  /QQ/      PHRHO(-MAXZ:MAXZ,-24:24)
      COMMON  /RR/      MASSR(0:MAXR)
cc      SAVE /RR/
      common  /ss/      inout(20)
cc      SAVE /ss/
      common  /zz/      zta,zpr
cc      SAVE /zz/
      COMMON  /RUN/     NUM
cc      SAVE /RUN/
clin-4/2008:
c      COMMON  /KKK/     TKAON(7),EKAON(7,0:200)
      COMMON  /KKK/     TKAON(7),EKAON(7,0:2000)
cc      SAVE /KKK/
      COMMON  /KAON/    AK(3,50,36),SPECK(50,36,7),MF
cc      SAVE /KAON/
      COMMON/TABLE/ xarray(0:1000),earray(0:1000)
cc      SAVE /TABLE/
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON  /DDpi/    piRHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DDpi/
      common  /tt/  PEL(-maxx:maxx,-maxx:maxx,-maxz:maxz)
     &,rxy(-maxx:maxx,-maxx:maxx,-maxz:maxz)
cc      SAVE /tt/
clin-4/2008:
c      DIMENSION TEMP(3,MAXSTR),SKAON(7),SEKAON(7,0:200)
      DIMENSION TEMP(3,MAXSTR),SKAON(7),SEKAON(7,0:2000)
cbz12/2/98
      COMMON /INPUT2/ ILAB, MANYB, NTMAX, ICOLL, INSYS, IPOT, MODE, 
     &   IMOMEN, NFREQ, ICFLOW, ICRHO, ICOU, KPOTEN, KMUL
cc      SAVE /INPUT2/
      COMMON /INPUT3/ PLAB, ELAB, ZEROPT, B0, BI, BM, DENCUT, CYCBOX
cc      SAVE /INPUT3/
cbz12/2/98end
cbz11/16/98
      COMMON /ARPRNT/ ARPAR1(100), IAPAR2(50), ARINT1(100), IAINT2(50)
cc      SAVE /ARPRNT/

c.....note in the below, since a common block in ART is called EE,
c.....the variable EE in /ARPRC/is changed to PEAR.
clin-9/29/03 changed name in order to distinguish from /prec2/
c        COMMON /ARPRC/ ITYPAR(MAXSTR),
c     &       GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
c     &       PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
c     &       XMAR(MAXSTR)
cc      SAVE /ARPRC/
clin-9/29/03-end
      COMMON /ARERCP/PRO1(MAXSTR, MAXR)
cc      SAVE /ARERCP/
      COMMON /ARERC1/MULTI1(MAXR)
cc      SAVE /ARERC1/
      COMMON /ARPRC1/ITYP1(MAXSTR, MAXR),
     &     GX1(MAXSTR, MAXR), GY1(MAXSTR, MAXR), GZ1(MAXSTR, MAXR), 
     &     FT1(MAXSTR, MAXR),
     &     PX1(MAXSTR, MAXR), PY1(MAXSTR, MAXR), PZ1(MAXSTR, MAXR),
     &     EE1(MAXSTR, MAXR), XM1(MAXSTR, MAXR)
cc      SAVE /ARPRC1/
c
      DIMENSION NPI(MAXR)
      DIMENSION RT(3, MAXSTR, MAXR), PT(3, MAXSTR, MAXR)
     &     , ET(MAXSTR, MAXR), LT(MAXSTR, MAXR), PROT(MAXSTR, MAXR)

      EXTERNAL IARFLV, INVFLV
cbz11/16/98end
      common /lastt/itimeh,bimp 
cc      SAVE /lastt/
      common/snn/efrm,npart1,npart2,epsiPz,epsiPt,PZPROJ,PZTARG
cc      SAVE /snn/
      COMMON/hbt/lblast(MAXSTR),xlast(4,MAXSTR),plast(4,MAXSTR),nlast
cc      SAVE /hbt/
      common/resdcy/NSAV,iksdcy
cc      SAVE /resdcy/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      COMMON/FTMAX/ftsv(MAXSTR),ftsvt(MAXSTR, MAXR)
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
clin-4/2008 zet() expanded to avoid out-of-bound errors:
      real zet(-45:45)
      SAVE   
      data zet /
     4     1.,0.,0.,0.,0.,
     3     1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
     2     -1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
     1     0.,0.,0.,-1.,0.,1.,0.,-1.,0.,-1.,
     s     0.,-2.,-1.,0.,1.,0.,0.,0.,0.,-1.,
     e     0.,
     s     1.,0.,-1.,0.,1.,-1.,0.,1.,2.,0.,
     1     1.,0.,1.,0.,-1.,0.,1.,0.,0.,0.,
     2     -1.,0.,1.,0.,-1.,0.,1.,0.,0.,1.,
     3     0.,0.,0.,0.,0.,0.,0.,0.,0.,-1.,
     4     0.,0.,0.,0.,-1./

      nlast=0
      do 1002 i=1,MAXSTR
         ftsv(i)=0.
         do 1101 irun=1,maxr
            ftsvt(i,irun)=0.
 1101    continue
         lblast(i)=999
         do 1001 j=1,4
clin-4/2008 bugs pointed out by Vander Molen & Westfall:
c            xlast(i,j)=0.
c            plast(i,j)=0.
            xlast(j,i)=0.
            plast(j,i)=0.
 1001    continue
 1002 continue

*-------------------------------------------------------------------*
* Input information about the reaction system and contral parameters* 
*-------------------------------------------------------------------*
*              input section starts here                           *
*-------------------------------------------------------------------*

cbz12/2/98
c.....input section is moved to subroutine ARTSET
cbz12/2/98end

*-----------------------------------------------------------------------*
*                   input section ends here                            *
*-----------------------------------------------------------------------*
* read in the table for gengrating the transverse momentum
* IN THE NN-->DDP PROCESS
       call tablem
* several control parameters, keep them fixed in this code. 
       ikaon=1
       nstar=1
       ndirct=0
       dir=0.02
       asy=0.032
       ESBIN=0.04
       MF=36
*----------------------------------------------------------------------*
c      CALL FRONT(12,MASSTA,MASSPR,ELAB)
*----------------------------------------------------------------------*
      RADTA  = 1.124 * FLOAT(MASSTA)**(1./3.)
      RADPR  = 1.124 * FLOAT(MASSPR)**(1./3.)
      ZDIST  = RADTA + RADPR
c      if ( cycbox.ne.0 ) zdist=0
      BMAX   = RADTA + RADPR
      MASS   = MASSTA + MASSPR
      NTOTAL = NUM * MASS
*
      IF (NTOTAL .GT. MAXSTR) THEN
        WRITE(12,'(//10X,''**** FATAL ERROR: TOO MANY TEST PART. ****'//
     & ' '')')
        STOP
      END IF
*
*-----------------------------------------------------------------------
*       RELATIVISTIC KINEMATICS
*
*       1) LABSYSTEM
*
      ETA    = FLOAT(MASSTA) * AMU
      PZTA   = 0.0
      BETATA = 0.0
      GAMMTA = 1.0
*
      EPR    = FLOAT(MASSPR) * (AMU + 0.001 * ELAB)
      PZPR   = SQRT( EPR**2 - (AMU * FLOAT(MASSPR))**2 )
      BETAPR = PZPR / EPR
      GAMMPR = 1.0 / SQRT( 1.0 - BETAPR**2 )
*
* BETAC AND GAMMAC OF THE C.M. OBSERVED IN THE LAB. FRAME
        BETAC=(PZPR+PZTA)/(EPR+ETA)
        GAMMC=1.0 / SQRT(1.-BETAC**2)
*
c      WRITE(12,'(/10x,''****    KINEMATICAL PARAMETERS    ****''/)')
c      WRITE(12,'(10x,''1) LAB-FRAME:        TARGET PROJECTILE'')')
c      WRITE(12,'(10x,''   ETOTAL "GEV" '',2F11.4)') ETA, EPR
c      WRITE(12,'(10x,''   P "GEV/C"    '',2F11.4)') PZTA, PZPR
c      WRITE(12,'(10x,''   BETA         '',2F11.4)') BETATA, BETAPR
c      WRITE(12,'(10x,''   GAMMA        '',2F11.4)') GAMMTA, GAMMPR
      IF (INSYS .NE. 0) THEN
*
*       2) C.M. SYSTEM
*
        S      = (EPR+ETA)**2 - PZPR**2
        xx1=4.*alog(float(massta))
        xx2=4.*alog(float(masspr))
        xx1=exp(xx1)
        xx2=exp(xx2)
        PSQARE = (S**2 + (xx1+ xx2) * AMU**4
     &             - 2.0 * S * AMU**2 * FLOAT(MASSTA**2 + MASSPR**2)
     &             - 2.0 * FLOAT(MASSTA**2 * MASSPR**2) * AMU**4)
     &           / (4.0 * S)
*
        ETA    = SQRT ( PSQARE + (FLOAT(MASSTA) * AMU)**2 )
        PZTA   = - SQRT(PSQARE)
        BETATA = PZTA / ETA
        GAMMTA = 1.0 / SQRT( 1.0 - BETATA**2 )
*
        EPR    = SQRT ( PSQARE + (FLOAT(MASSPR) * AMU)**2 )
        PZPR   = SQRT(PSQARE)
        BETAPR = PZPR/ EPR
        GAMMPR = 1.0 / SQRT( 1.0 - BETAPR**2 )
*
c        WRITE(12,'(10x,''2) C.M.-FRAME:  '')')
c        WRITE(12,'(10x,''   ETOTAL "GEV" '',2F11.4)') ETA, EPR
c        WRITE(12,'(10x,''   P "GEV/C"    '',2F11.4)') PZTA, PZPR
c        WRITE(12,'(10x,''   BETA         '',2F11.4)') BETATA, BETAPR
c        WRITE(12,'(10x,''   GAMMA        '',2F11.4)') GAMMTA, GAMMPR
c        WRITE(12,'(10x,''S "GEV**2"      '',F11.4)')  S
c        WRITE(12,'(10x,''PSQARE "GEV/C"2 '',E14.3)')  PSQARE
c        WRITE(12,'(/10x,''*** CALCULATION DONE IN CM-FRAME ***''/)')
      ELSE
c        WRITE(12,'(/10x,''*** CALCULATION DONE IN LAB-FRAME ***''/)')
      END IF
* MOMENTUM PER PARTICLE
      PZTA = PZTA / FLOAT(MASSTA)
      PZPR = PZPR / FLOAT(MASSPR)
* total initial energy in the N-N cms frame
      ECMS0=ETA+EPR
*-----------------------------------------------------------------------
*
* Start loop over many runs of different impact parameters
* IF MANYB=1, RUN AT A FIXED IMPACT PARAMETER B0, OTHERWISE GENERATE 
* MINIMUM BIAS EVENTS WITHIN THE IMPACT PARAMETER RANGE OF B_MIN AND B_MAX
       DO 50000 IMANY=1,MANYB
*------------------------------------------------------------------------
* Initialize the impact parameter B
       if (manyb. gt.1) then
111       BX=1.0-2.0*RANART(NSEED)
       BY=1.0-2.0*RANART(NSEED)
       B2=BX*BX+BY*BY
       IF(B2.GT.1.0) GO TO 111       
       B=SQRT(B2)*(BM-BI)+BI
       ELSE
       B=B0
       ENDIF
c      WRITE(12,'(///10X,''RUN NUMBER:'',I6)') IMANY       
c      WRITE(12,'(//10X,''IMPACT PARAMETER B FOR THIS RUN:'',
c     &             F9.3,'' FM''/10X,49(''*'')/)') B
*
*-----------------------------------------------------------------------
*       INITIALIZATION
*1 INITIALIZATION IN ISOSPIN SPACE FOR BOTH THE PROJECTILE AND TARGET
      call coulin(masspr,massta,NUM)
*2 INITIALIZATION IN PHASE SPACE FOR THE TARGET
      CALL INIT(1       ,MASSTA   ,NUM     ,RADTA,
     &          B/2.    ,ZEROPT+ZDIST/2.   ,PZTA,
     &          GAMMTA  ,ISEED    ,MASS    ,IMOMEN)
*3.1 INITIALIZATION IN PHASE SPACE FOR THE PROJECTILE
      CALL INIT(1+MASSTA,MASS     ,NUM     ,RADPR,
     &          -B/2.   ,ZEROPT-ZDIST/2.   ,PZPR,
     &          GAMMPR  ,ISEED    ,MASS    ,IMOMEN)
*3.2 OUTPAR IS THE NO. OF ESCAPED PARTICLES
      OUTPAR = 0
*3.3 INITIALIZATION FOR THE NO. OF PARTICLES IN EACH SAMPLE
*    THIS IS NEEDED DUE TO THE FACT THAT PIONS CAN BE PRODUCED OR ABSORBED
      MASSR(0)=0
      DO 1003 IR =1,NUM
      MASSR(IR)=MASS
 1003 CONTINUE
*3.4 INITIALIZation FOR THE KAON SPECTRUM
*      CALL KSPEC0(BETAC,GAMMC)
* calculate the local baryon density matrix
      CALL DENS(IPOT,MASS,NUM,OUTPAR)
*
*-----------------------------------------------------------------------
*       CONTROL PRINTOUT OF INITIAL CONFIGURATION
*
*      WRITE(12,'(''**********  INITIAL CONFIGURATION  **********''/)')
*
c print out the INITIAL density matrix in the reaction plane
c       do ix=-10,10
c       do iz=-10,10
c       write(1053,992)ix,iz,rho(ix,0,iz)/0.168
c       end do
c       end do
*-----------------------------------------------------------------------
*       CALCULATE MOMENTA FOR T = 0.5 * DT 
*       (TO OBTAIN 2ND DEGREE ACCURACY!)
*       "Reference: J. AICHELIN ET AL., PHYS. REV. C31, 1730 (1985)"
*
      IF (ICOLL .NE. -1) THEN
        DO 700 I = 1,NTOTAL
          IX = NINT( R(1,I) )
          IY = NINT( R(2,I) )
          IZ = NINT( R(3,I) )
clin-4/2008 check bounds:
          IF(IX.GE.MAXX.OR.IY.GE.MAXX.OR.IZ.GE.MAXZ
     1         .OR.IX.LE.-MAXX.OR.IY.LE.-MAXX.OR.IZ.LE.-MAXZ) goto 700
          CALL GRADU(IPOT,IX,IY,IZ,GRADX,GRADY,GRADZ)
          P(1,I) = P(1,I) - (0.5 * DT) * GRADX
          P(2,I) = P(2,I) - (0.5 * DT) * GRADY
          P(3,I) = P(3,I) - (0.5 * DT) * GRADZ
  700   CONTINUE
      END IF
*-----------------------------------------------------------------------
*-----------------------------------------------------------------------
*4 INITIALIZATION OF TIME-LOOP VARIABLES
*4.1 COLLISION NUMBER COUNTERS
clin 51      RCNNE  = 0
        RCNNE  = 0
       RDD  = 0
       RPP  = 0
       rppk = 0
       RPN  = 0
       rpd  = 0
       RKN  = 0
       RNNK = 0
       RDDK = 0
       RNDK = 0
      RCNND  = 0
      RCNDN  = 0
      RCOLL  = 0
      RBLOC  = 0
      RDIRT  = 0
      RDECAY = 0
      RRES   = 0
*4.11 KAON PRODUCTION PROBABILITY COUNTER FOR PERTURBATIVE CALCULATIONS ONLY
      DO 1005 KKK=1,5
         SKAON(KKK)  = 0
         DO 1004 IS=1,2000
            SEKAON(KKK,IS)=0
 1004    CONTINUE
 1005 CONTINUE
*4.12 anti-proton and anti-kaon counters
       pr0=0.
       pr1=0.
       ska0=0.
       ska1=0.
*       ============== LOOP OVER ALL TIME STEPS ================       *
*                             STARTS HERE                              *
*       ========================================================       *
cbz11/16/98
      IF (IAPAR2(1) .NE. 1) THEN
         DO 1016 I = 1, MAXSTR
            DO 1015 J = 1, 3
               R(J, I) = 0.
               P(J, I) = 0.
 1015       CONTINUE
            E(I) = 0.
            LB(I) = 0
cbz3/25/00
            ID(I)=0
c     sp 12/19/00
           PROPER(I) = 1.
 1016   CONTINUE
         MASS = 0
cbz12/22/98
c         MASSR(1) = 0
c         NP = 0
c         NPI = 1
         NP = 0
         DO 1017 J = 1, NUM
            MASSR(J) = 0
            NPI(J) = 1
 1017    CONTINUE
         DO 1019 I = 1, MAXR
            DO 1018 J = 1, MAXSTR
               RT(1, J, I) = 0.
               RT(2, J, I) = 0.
               RT(3, J, I) = 0.
               PT(1, J, I) = 0.
               PT(2, J, I) = 0.
               PT(3, J, I) = 0.
               ET(J, I) = 0.
               LT(J, I) = 0
c     sp 12/19/00
               PROT(J, I) = 1.
 1018       CONTINUE
 1019    CONTINUE
cbz12/22/98end
      END IF
cbz11/16/98end
        
      DO 10000 NT = 1,NTMAX
*TEMPORARY PARTICLE COUNTERS
*4.2 PION COUNTERS : LP1,LP2 AND LP3 ARE THE NO. OF P+,P0 AND P-
      LP1=0
      LP2=0
      LP3=0
*4.3 DELTA COUNTERS : LD1,LD2,LD3 AND LD4 ARE THE NO. OF D++,D+,D0 AND D-
      LD1=0
      LD2=0
      LD3=0
      LD4=0
*4.4 N*(1440) COUNTERS : LN1 AND LN2 ARE THE NO. OF N*+ AND N*0
      LN1=0
      LN2=0
*4.5 N*(1535) counters
      LN5=0
*4.6 ETA COUNTERS
      LE=0
*4.7 KAON COUNTERS
      LKAON=0

clin-11/09/00:
* KAON* COUNTERS
      LKAONS=0

*-----------------------------------------------------------------------
        IF (ICOLL .NE. 1) THEN
* STUDYING BINARY COLLISIONS AMONG PARTICLES DURING THIS TIME INTERVAL *
clin-10/25/02 get rid of argument usage mismatch in relcol(.nt.):
           numnt=nt
          CALL RELCOL(LCOLL,LBLOC,LCNNE,LDD,LPP,lppk,
     &    LPN,lpd,LRHO,LOMEGA,LKN,LNNK,LDDK,LNDK,LCNND,
     &    LCNDN,LDIRT,LDECAY,LRES,LDOU,LDDRHO,LNNRHO,
     &    LNNOM,numnt,ntmax,sp,akaon,sk)
c     &    LNNOM,NT,ntmax,sp,akaon,sk)
clin-10/25/02-end
*-----------------------------------------------------------------------

c dilepton production from Dalitz decay
c of pi0 at final time
*      if(nt .eq. ntmax) call dalitz_pi(nt,ntmax)
*                                                                      *
**********************************
*                Lables of collision channels                             *
**********************************
*         LCOLL   - NUMBER OF COLLISIONS              (INTEGER,OUTPUT) *
*         LBLOC   - NUMBER OF PULI-BLOCKED COLLISIONS (INTEGER,OUTPUT) *
*         LCNNE   - NUMBER OF ELASTIC COLLISION       (INTEGER,OUTPUT) *
*         LCNND   - NUMBER OF N+N->N+DELTA REACTION   (INTEGER,OUTPUT) *
*         LCNDN   - NUMBER OF N+DELTA->N+N REACTION   (INTEGER,OUTPUT) *
*         LDD     - NUMBER OF RESONANCE+RESONANCE COLLISIONS
*         LPP     - NUMBER OF PION+PION elastic COLIISIONS
*         lppk    - number of pion(RHO,OMEGA)+pion(RHO,OMEGA)
*                 -->K+K- collisions
*         LPN     - NUMBER OF PION+N-->KAON+X
*         lpd     - number of pion+n-->delta+pion
*         lrho    - number of pion+n-->Delta+rho
*         lomega  - number of pion+n-->Delta+omega
*         LKN     - NUMBER OF KAON RESCATTERINGS
*         LNNK    - NUMBER OF bb-->kAON PROCESS
*         LDDK    - NUMBER OF DD-->KAON PROCESS
*         LNDK    - NUMBER OF ND-->KAON PROCESS
***********************************
* TIME-INTEGRATED COLLISIONS NUMBERS OF VARIOUS PROCESSES
          RCOLL = RCOLL + FLOAT(LCOLL)/num
          RBLOC = RBLOC + FLOAT(LBLOC)/num
          RCNNE = RCNNE + FLOAT(LCNNE)/num
         RDD   = RDD   + FLOAT(LDD)/num
         RPP   = RPP   + FLOAT(LPP)/NUM
         rppk  =rppk   + float(lppk)/num
         RPN   = RPN   + FLOAT(LPN)/NUM
         rpd   =rpd    + float(lpd)/num
         RKN   = RKN   + FLOAT(LKN)/NUM
         RNNK  =RNNK   + FLOAT(LNNK)/NUM
         RDDK  =RDDK   + FLOAT(LDDK)/NUM
         RNDK  =RNDK   + FLOAT(LNDK)/NUM
          RCNND = RCNND + FLOAT(LCNND)/num
          RCNDN = RCNDN + FLOAT(LCNDN)/num
          RDIRT = RDIRT + FLOAT(LDIRT)/num
          RDECAY= RDECAY+ FLOAT(LDECAY)/num
          RRES  = RRES  + FLOAT(LRES)/num
* AVERAGE RATES OF VARIOUS COLLISIONS IN THE CURRENT TIME STEP
          ADIRT=LDIRT/DT/num
          ACOLL=(LCOLL-LBLOC)/DT/num
          ACNND=LCNND/DT/num
          ACNDN=LCNDN/DT/num
          ADECAY=LDECAY/DT/num
          ARES=LRES/DT/num
         ADOU=LDOU/DT/NUM
         ADDRHO=LDDRHO/DT/NUM
         ANNRHO=LNNRHO/DT/NUM
         ANNOM=LNNOM/DT/NUM
         ADD=LDD/DT/num
         APP=LPP/DT/num
         appk=lppk/dt/num
          APN=LPN/DT/num
         apd=lpd/dt/num
         arh=lrho/dt/num
         aom=lomega/dt/num
         AKN=LKN/DT/num
         ANNK=LNNK/DT/num
         ADDK=LDDK/DT/num
         ANDK=LNDK/DT/num
* PRINT OUT THE VARIOUS COLLISION RATES
* (1)N-N COLLISIONS 
c       WRITE(1010,9991)NT*DT,ACNND,ADOU,ADIRT,ADDRHO,ANNRHO+ANNOM
c9991       FORMAT(6(E10.3,2X))
* (2)PION-N COLLISIONS
c       WRITE(1011,'(5(E10.3,2X))')NT*DT,apd,ARH,AOM,APN
* (3)KAON PRODUCTION CHANNELS
c        WRITE(1012,9993)NT*DT,ANNK,ADDK,ANDK,APN,Appk
* (4)D(N*)+D(N*) COLLISION
c       WRITE(1013,'(4(E10.3,2X))')NT*DT,ADDK,ADD,ADD+ADDK
* (5)MESON+MESON
c       WRITE(1014,'(4(E10.3,2X))')NT*DT,APPK,APP,APP+APPK
* (6)DECAY AND RESONANCE
c       WRITE(1016,'(3(E10.3,2X))')NT*DT,ARES,ADECAY
* (7)N+D(N*)
c       WRITE(1017,'(4(E10.3,2X))')NT*DT,ACNDN,ANDK,ACNDN+ANDK
c9992    FORMAT(5(E10.3,2X))
c9993    FORMAT(6(E10.3,2X))
* PRINT OUT TIME-INTEGRATED COLLISION INFORMATION
cbz12/28/98
c        write(1018,'(5(e10.3,2x),/, 4(e10.3,2x))')
c     &           RCNNE,RCNND,RCNDN,RDIRT,rpd,
c     &           RDECAY,RRES,RDD,RPP
c        write(1018,'(6(e10.3,2x),/, 5(e10.3,2x))')
c     &           NT*DT,RCNNE,RCNND,RCNDN,RDIRT,rpd,
c     &           NT*DT,RDECAY,RRES,RDD,RPP
cbz12/18/98end
* PRINT OUT TIME-INTEGRATED KAON MULTIPLICITIES FROM DIFFERENT CHANNELS
c       WRITE(1019,'(7(E10.3,2X))')NT*DT,RNNK,RDDK,RNDK,RPN,Rppk,
c     &                           RNNK+RDDK+RNDK+RPN+Rppk
*                                                                      *

        END IF
*
*       UPDATE BARYON DENSITY
*
        CALL DENS(IPOT,MASS,NUM,OUTPAR)
*
*       UPDATE POSITIONS FOR ALL THE PARTICLES PRESENT AT THIS TIME
*
       sumene=0
        ISO=0
        DO 201 MRUN=1,NUM
        ISO=ISO+MASSR(MRUN-1)
        DO 201 I0=1,MASSR(MRUN)
        I =I0+ISO
        ETOTAL = SQRT( E(I)**2 + P(1,I)**2 + P(2,I)**2 +P(3,I)**2 )
       sumene=sumene+etotal
C for kaons, if there is a potential
C CALCULATE THE ENERGY OF THE KAON ACCORDING TO THE IMPULSE APPROXIMATION
C REFERENCE: B.A. LI AND C.M. KO, PHYS. REV. C 54 (1996) 3283. 
         if(kpoten.ne.0.and.lb(i).eq.23)then
             den=0.
              IX = NINT( R(1,I) )
              IY = NINT( R(2,I) )
              IZ = NINT( R(3,I) )
clin-4/2008:
c       IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
c     & ABS(IZ) .LT. MAXZ) den=rho(ix,iy,iz)
              IF(IX.LT.MAXX.AND.IY.LT.MAXX.AND.IZ.LT.MAXZ
     1             .AND.IX.GT.-MAXX.AND.IY.GT.-MAXX.AND.IZ.GT.-MAXZ)
     2             den=rho(ix,iy,iz)
c         ecor=0.1973**2*0.255*kmul*4*3.14159*(1.+0.4396/0.938)
c         etotal=sqrt(etotal**2+ecor*den)
c** G.Q Li potential form with n_s = n_b and pot(n_0)=29 MeV, m^*=m
c     GeV^2 fm^3
          akg = 0.1727
c     GeV fm^3
          bkg = 0.333
         rnsg = den
         ecor = - akg*rnsg + (bkg*den)**2
         etotal = sqrt(etotal**2 + ecor)
         endif
c
         if(kpoten.ne.0.and.lb(i).eq.21)then
             den=0.
              IX = NINT( R(1,I) )
              IY = NINT( R(2,I) )
              IZ = NINT( R(3,I) )
clin-4/2008:
c       IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
c     & ABS(IZ) .LT. MAXZ) den=rho(ix,iy,iz)
              IF(IX.LT.MAXX.AND.IY.LT.MAXX.AND.IZ.LT.MAXZ
     1             .AND.IX.GT.-MAXX.AND.IY.GT.-MAXX.AND.IZ.GT.-MAXZ)
     2             den=rho(ix,iy,iz)
c* for song potential no effect on position
c** G.Q Li potential form with n_s = n_b and pot(n_0)=29 MeV, m^*=m
c     GeV^2 fm^3
          akg = 0.1727
c     GeV fm^3
          bkg = 0.333
         rnsg = den
         ecor = - akg*rnsg + (bkg*den)**2
         etotal = sqrt(etotal**2 + ecor)
          endif
c
C UPDATE POSITIONS
          R(1,I) = R(1,I) + DT*P(1,I)/ETOTAL
          R(2,I) = R(2,I) + DT*P(2,I)/ETOTAL
          R(3,I) = R(3,I) + DT*P(3,I)/ETOTAL
c use cyclic boundary conitions
            if ( cycbox.ne.0 ) then
              if ( r(1,i).gt. cycbox/2 ) r(1,i)=r(1,i)-cycbox
              if ( r(1,i).le.-cycbox/2 ) r(1,i)=r(1,i)+cycbox
              if ( r(2,i).gt. cycbox/2 ) r(2,i)=r(2,i)-cycbox
              if ( r(2,i).le.-cycbox/2 ) r(2,i)=r(2,i)+cycbox
              if ( r(3,i).gt. cycbox/2 ) r(3,i)=r(3,i)-cycbox
              if ( r(3,i).le.-cycbox/2 ) r(3,i)=r(3,i)+cycbox
            end if
* UPDATE THE DELTA, N* AND PION COUNTERS
          LB1=LB(I)
* 1. FOR DELTA++
        IF(LB1.EQ.9)LD1=LD1+1
* 2. FOR DELTA+
        IF(LB1.EQ.8)LD2=LD2+1
* 3. FOR DELTA0
        IF(LB1.EQ.7)LD3=LD3+1
* 4. FOR DELTA-
        IF(LB1.EQ.6)LD4=LD4+1
* 5. FOR N*+(1440)
        IF(LB1.EQ.11)LN1=LN1+1
* 6. FOR N*0(1440)
        IF(LB1.EQ.10)LN2=LN2+1
* 6.1 FOR N*(1535)
       IF((LB1.EQ.13).OR.(LB1.EQ.12))LN5=LN5+1
* 6.2 FOR ETA
       IF(LB1.EQ.0)LE=LE+1
* 6.3 FOR KAONS
       IF(LB1.EQ.23)LKAON=LKAON+1
clin-11/09/00: FOR KAON*
       IF(LB1.EQ.30)LKAONS=LKAONS+1

* UPDATE PION COUNTER
* 7. FOR PION+
        IF(LB1.EQ.5)LP1=LP1+1
* 8. FOR PION0
        IF(LB1.EQ.4)LP2=LP2+1
* 9. FOR PION-
        IF(LB1.EQ.3)LP3=LP3+1
201     CONTINUE
        LP=LP1+LP2+LP3
        LD=LD1+LD2+LD3+LD4
        LN=LN1+LN2
        ALP=FLOAT(LP)/FLOAT(NUM)
        ALD=FLOAT(LD)/FLOAT(NUM)
        ALN=FLOAT(LN)/FLOAT(NUM)
       ALN5=FLOAT(LN5)/FLOAT(NUM)
        ATOTAL=ALP+ALD+ALN+0.5*ALN5
       ALE=FLOAT(LE)/FLOAT(NUM)
       ALKAON=FLOAT(LKAON)/FLOAT(NUM)
* UPDATE MOMENTUM DUE TO COULOMB INTERACTION 
        if (icou .eq. 1) then
*       with Coulomb interaction
          iso=0
          do 1026 irun = 1,num
            iso=iso+massr(irun-1)
            do 1021 il = 1,massr(irun)
               temp(1,il) = 0.
               temp(2,il) = 0.
               temp(3,il) = 0.
 1021       continue
            do 1023 il = 1, massr(irun)
              i=iso+il
              if (zet(lb(i)).ne.0) then
                do 1022 jl = 1,il-1
                  j=iso+jl
                  if (zet(lb(j)).ne.0) then
                    ddx=r(1,i)-r(1,j)
                    ddy=r(2,i)-r(2,j)
                    ddz=r(3,i)-r(3,j)
                    rdiff = sqrt(ddx**2+ddy**2+ddz**2)
                    if (rdiff .le. 1.) rdiff = 1.
                    grp=zet(lb(i))*zet(lb(j))/rdiff**3
                    ddx=ddx*grp
                    ddy=ddy*grp
                    ddz=ddz*grp
                    temp(1,il)=temp(1,il)+ddx
                    temp(2,il)=temp(2,il)+ddy
                    temp(3,il)=temp(3,il)+ddz
                    temp(1,jl)=temp(1,jl)-ddx
                    temp(2,jl)=temp(2,jl)-ddy
                    temp(3,jl)=temp(3,jl)-ddz
                  end if
 1022          continue
              end if
 1023      continue
            do 1025 il = 1,massr(irun)
              i= iso+il
              if (zet(lb(i)).ne.0) then
                do 1024 idir = 1,3
                  p(idir,i) = p(idir,i) + temp(idir,il)
     &                                    * dt * 0.00144
 1024          continue
              end if
 1025      continue
 1026   continue
        end if
*       In the following, we shall:  
*       (1) UPDATE MOMENTA DUE TO THE MEAN FIELD FOR BARYONS AND KAONS,
*       (2) calculate the thermalization, temperature in a sphere of 
*           radius 2.0 fm AROUND THE CM
*       (3) AND CALCULATE THE NUMBER OF PARTICLES IN THE HIGH DENSITY REGION 
       spt=0
       spz=0
       ncen=0
       ekin=0
          NLOST = 0
          MEAN=0
         nquark=0
         nbaryn=0
csp06/18/01
           rads = 2.
           zras = 0.1
           denst = 0.
           edenst = 0.
csp06/18/01 end
          DO 6000 IRUN = 1,NUM
          MEAN=MEAN+MASSR(IRUN-1)
          DO 5800 J = 1,MASSR(irun)
          I=J+MEAN
c
csp06/18/01
           radut = sqrt(r(1,i)**2+r(2,i)**2)
       if( radut .le. rads )then
        if( abs(r(3,i)) .le. zras*nt*dt )then
c         vols = 3.14159*radut**2*abs(r(3,i))      ! cylinder pi*r^2*l
c     cylinder pi*r^2*l
         vols = 3.14159*rads**2*zras
         engs=sqrt(p(1,i)**2+p(2,i)**2+p(3,i)**2+e(i)**2)
         gammas=1.
         if(e(i).ne.0.)gammas=engs/e(i)
c     rho
         denst = denst + 1./gammas/vols
c     energy density
         edenst = edenst + engs/gammas/gammas/vols
        endif
       endif
csp06/18/01 end
c
         drr=sqrt(r(1,i)**2+r(2,i)**2+r(3,i)**2)
         if(drr.le.2.0)then
         spt=spt+p(1,i)**2+p(2,i)**2
         spz=spz+p(3,i)**2
         ncen=ncen+1
         ekin=ekin+sqrt(p(1,i)**2+p(2,i)**2+p(3,i)**2+e(i)**2)-e(i)
         endif
              IX = NINT( R(1,I) )
              IY = NINT( R(2,I) )
              IZ = NINT( R(3,I) )
C calculate the No. of particles in the high density region
clin-4/2008:
c              IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
c     & ABS(IZ) .LT. MAXZ) THEN
              IF(IX.LT.MAXX.AND.IY.LT.MAXX.AND.IZ.LT.MAXZ
     1          .AND.IX.GT.-MAXX.AND.IY.GT.-MAXX.AND.IZ.GT.-MAXZ) THEN
       if(rho(ix,iy,iz)/0.168.gt.dencut)go to 5800
       if((rho(ix,iy,iz)/0.168.gt.5.).and.(e(i).gt.0.9))
     &  nbaryn=nbaryn+1
       if(pel(ix,iy,iz).gt.2.0)nquark=nquark+1
       endif
c*
c If there is a kaon potential, propogating kaons 
        if(kpoten.ne.0.and.lb(i).eq.23)then
        den=0.
clin-4/2008:
c       IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
c     & ABS(IZ) .LT. MAXZ)then
        IF(IX.LT.MAXX.AND.IY.LT.MAXX.AND.IZ.LT.MAXZ
     1       .AND.IX.GT.-MAXX.AND.IY.GT.-MAXX.AND.IZ.GT.-MAXZ) THEN
           den=rho(ix,iy,iz)
c        ecor=0.1973**2*0.255*kmul*4*3.14159*(1.+0.4396/0.938)
c       etotal=sqrt(P(1,i)**2+p(2,I)**2+p(3,i)**2+e(i)**2+ecor*den)
c** for G.Q Li potential form with n_s = n_b and pot(n_0)=29 MeV
c     !! GeV^2 fm^3
            akg = 0.1727
c     !! GeV fm^3
            bkg = 0.333
          rnsg = den
          ecor = - akg*rnsg + (bkg*den)**2
          etotal = sqrt(P(1,i)**2+p(2,I)**2+p(3,i)**2+e(i)**2 + ecor)
          ecor = - akg + 2.*bkg**2*den + 2.*bkg*etotal
c** G.Q. Li potential (END)           
        CALL GRADUK(IX,IY,IZ,GRADXk,GRADYk,GRADZk)
        P(1,I) = P(1,I) - DT * GRADXk*ecor/(2.*etotal)
        P(2,I) = P(2,I) - DT * GRADYk*ecor/(2.*etotal)
        P(3,I) = P(3,I) - DT * GRADZk*ecor/(2.*etotal)
        endif
         endif
c
        if(kpoten.ne.0.and.lb(i).eq.21)then
         den=0.
clin-4/2008:
c           IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
c     &        ABS(IZ) .LT. MAXZ)then
         IF(IX.LT.MAXX.AND.IY.LT.MAXX.AND.IZ.LT.MAXZ
     1        .AND.IX.GT.-MAXX.AND.IY.GT.-MAXX.AND.IZ.GT.-MAXZ) THEN
               den=rho(ix,iy,iz)
        CALL GRADUK(IX,IY,IZ,GRADXk,GRADYk,GRADZk)
c        P(1,I) = P(1,I) - DT * GRADXk*(-0.12/0.168)    !! song potential
c        P(2,I) = P(2,I) - DT * GRADYk*(-0.12/0.168)
c        P(3,I) = P(3,I) - DT * GRADZk*(-0.12/0.168)
c** for G.Q Li potential form with n_s = n_b and pot(n_0)=29 MeV
c    !! GeV^2 fm^3
            akg = 0.1727
c     !! GeV fm^3
            bkg = 0.333
          rnsg = den
          ecor = - akg*rnsg + (bkg*den)**2
          etotal = sqrt(P(1,i)**2+p(2,I)**2+p(3,i)**2+e(i)**2 + ecor)
          ecor = - akg + 2.*bkg**2*den - 2.*bkg*etotal
        P(1,I) = P(1,I) - DT * GRADXk*ecor/(2.*etotal)
        P(2,I) = P(2,I) - DT * GRADYk*ecor/(2.*etotal)
        P(3,I) = P(3,I) - DT * GRADZk*ecor/(2.*etotal)
c** G.Q. Li potential (END)           
        endif
         endif
c
c for other mesons, there is no potential
       if(j.gt.mass)go to 5800         
c  with mean field interaction for baryons   (open endif below) !!sp05
**      if( (iabs(lb(i)).eq.1.or.iabs(lb(i)).eq.2) .or.
**    &     (iabs(lb(i)).ge.6.and.iabs(lb(i)).le.17) .or.
**    &      iabs(lb(i)).eq.40.or.iabs(lb(i)).eq.41 )then  
        IF (ICOLL .NE. -1) THEN
* check if the baryon has run off the lattice
*             IX0=NINT(R(1,I)/DX)
*             IY0=NINT(R(2,I)/DY)
*             IZ0=NINT(R(3,I)/DZ)
*             IPX0=NINT(P(1,I)/DPX)
*             IPY0=NINT(P(2,I)/DPY)
*             IPZ0=NINT(P(3,I)/DPZ)
*      if ( (abs(ix0).gt.mx) .or. (abs(iy0).gt.my) .or. (abs(iz0).gt.mz)
*     &  .or. (abs(ipx0).gt.mpx) .or. (abs(ipy0) 
*     &  .or. (ipz0.lt.-mpz) .or. (ipz0.gt.mpzp)) NLOST=NLOST+1
clin-4/2008:
c              IF (ABS(IX) .LT. MAXX .AND. ABS(IY) .LT. MAXX .AND.
c     &                                    ABS(IZ) .LT. MAXZ     ) THEN
           IF(IX.LT.MAXX.AND.IY.LT.MAXX.AND.IZ.LT.MAXZ
     1          .AND.IX.GT.-MAXX.AND.IY.GT.-MAXX.AND.IZ.GT.-MAXZ) THEN
                CALL GRADU(IPOT,IX,IY,IZ,GRADX,GRADY,GRADZ)
              TZ=0.
              GRADXN=0
              GRADYN=0
              GRADZN=0
              GRADXP=0
              GRADYP=0
              GRADZP=0
             IF(ICOU.EQ.1)THEN
                CALL GRADUP(IX,IY,IZ,GRADXP,GRADYP,GRADZP)
                CALL GRADUN(IX,IY,IZ,GRADXN,GRADYN,GRADZN)
               IF(ZET(LB(I)).NE.0)TZ=-1
               IF(ZET(LB(I)).EQ.0)TZ= 1
             END IF
           if(iabs(lb(i)).ge.14.and.iabs(lb(i)).le.17)then
              facl = 2./3.
            elseif(iabs(lb(i)).eq.40.or.iabs(lb(i)).eq.41)then
              facl = 1./3.
            else
              facl = 1.
            endif
        P(1,I) = P(1,I) - facl*DT * (GRADX+asy*(GRADXN-GRADXP)*TZ)
        P(2,I) = P(2,I) - facl*DT * (GRADY+asy*(GRADYN-GRADYP)*TZ)
        P(3,I) = P(3,I) - facl*DT * (GRADZ+asy*(GRADZN-GRADZP)*TZ)
                end if                                                       
              ENDIF
**          endif          !!sp05     
 5800       CONTINUE
 6000       CONTINUE
c print out the average no. of particles in regions where the local 
c baryon density is higher than 5*rho0 
c       write(1072,'(e10.3,2x,e10.3)')nt*dt,float(nbaryn)/float(num)
C print out the average no. of particles in regions where the local 
c energy density is higher than 2 GeV/fm^3. 
c       write(1073,'(e10.3,2x,e10.3)')nt*dt,float(nquark)/float(num)
c print out the no. of particles that have run off the lattice
*          IF (NLOST .NE. 0 .AND. (NT/NFREQ)*NFREQ .EQ. NT) THEN
*            WRITE(12,'(5X,''***'',I7,'' TESTPARTICLES LOST AFTER '',
*     &                   ''TIME STEP NUMBER'',I4)') NLOST, NT
*         END IF
*
*       update phase space density
*        call platin(mode,mass,num,dx,dy,dz,dpx,dpy,dpz,fnorm)
*
*       CONTROL-PRINTOUT OF CONFIGURATION (IF REQUIRED)
*
*        if (inout(5) .eq. 2) CALL ENERGY(NT,IPOT,NUM,MASS,EMIN,EMAX)
*
* 
* print out central baryon density as a function of time
       CDEN=RHO(0,0,0)/0.168
cc        WRITE(1002,990)FLOAT(NT)*DT,CDEN
c        WRITE(1002,1990)FLOAT(NT)*DT,CDEN,denst/real(num)
* print out the central energy density as a function of time
cc        WRITE(1003,990)FLOAT(NT)*DT,PEL(0,0,0)
c        WRITE(1003,1990)FLOAT(NT)*DT,PEL(0,0,0),edenst/real(num)
* print out the no. of pion-like particles as a function of time 
c        WRITE(1004,9999)FLOAT(NT)*DT,ALD,ALN,ALP,ALN5,
c     &               ALD+ALN+ALP+0.5*ALN5
* print out the no. of eta-like particles as a function of time
c        WRITE(1005,991)FLOAT(NT)*DT,ALN5,ALE,ALE+0.5*ALN5
c990       FORMAT(E10.3,2X,E10.3)
c1990       FORMAT(E10.3,2X,E10.3,2X,E10.3)
c991       FORMAT(E10.3,2X,E10.3,2X,E10.3,2X,E10.3)
c9999    FORMAT(e10.3,2X,e10.3,2X,E10.3,2X,E10.3,2X,
c     1  E10.3,2X,E10.3)
C THE FOLLOWING OUTPUTS CAN BE TURNED ON/OFF by setting icflow and icrho=0  
c print out the baryon and meson density matrix in the reaction plane
        IF ((NT/NFREQ)*NFREQ .EQ. NT ) THEN
       if(icflow.eq.1)call flow(nt)
cbz11/18/98
c       if(icrho.ne.1)go to 10000 
c       if (icrho .eq. 1) then 
cbz11/18/98end
c       do ix=-10,10
c       do iz=-10,10
c       write(1053,992)ix,iz,rho(ix,0,iz)/0.168
c       write(1054,992)ix,iz,pirho(ix,0,iz)/0.168
c       write(1055,992)ix,iz,pel(ix,0,iz)
c       end do
c       end do
cbz11/18/98
c        end if
cbz11/18/98end
c992       format(i3,i3,e11.4)
       endif
c print out the ENERGY density matrix in the reaction plane
C CHECK LOCAL MOMENTUM EQUILIBRIUM IN EACH CELL, 
C AND PERFORM ON-LINE FLOW ANALYSIS AT A FREQUENCY OF NFREQ
c        IF ((NT/NFREQ)*NFREQ .EQ. NT ) THEN
c       call flow(nt)
c       call equ(ipot,mass,num,outpar)
c       do ix=-10,10
c       do iz=-10,10
c       write(1055,992)ix,iz,pel(ix,0,iz)
c       write(1056,992)ix,iz,rxy(ix,0,iz)
c       end do
c       end do
c       endif
C calculate the volume of high BARYON AND ENERGY density 
C matter as a function of time
c       vbrho=0.
c       verho=0.
c       do ix=-20,20
c       do iy=-20,20
c       do iz=-20,20
c       if(rho(ix,iy,iz)/0.168.gt.5.)vbrho=vbrho+1.
c       if(pel(ix,iy,iz).gt.2.)verho=verho+1.
c       end do
c       end do
c       end do
c       write(1081,993)dt*nt,vbrho
c       write(1082,993)dt*nt,verho
c993       format(e11.4,2x,e11.4)
*-----------------------------------------------------------------------
cbz11/16/98
c.....for read-in initial conditions produce particles from read-in 
c.....common block.
c.....note that this part is only for cascade with number of test particles
c.....NUM = 1.
      IF (IAPAR2(1) .NE. 1) THEN
         CT = NT * DT
cbz12/22/98
c         NP = MASSR(1)
c         DO WHILE (FTAR(NPI) .GT. CT - DT .AND. FTAR(NPI) .LE. CT)
c            NP = NP + 1
c            R(1, NP) = GXAR(NPI) + PXAR(NPI) / PEAR(NPI) * (CT - FTAR(NPI))
c            R(2, NP) = GYAR(NPI) + PYAR(NPI) / PEAR(NPI) * (CT - FTAR(NPI))
c            R(3, NP) = GZAR(NPI) + PZAR(NPI) / PEAR(NPI) * (CT - FTAR(NPI))
c            P(1, NP) = PXAR(NPI)
c            P(2, NP) = PYAR(NPI)
c            P(3, NP) = PZAR(NPI)
c            E(NP) = XMAR(NPI)
c            LB(NP) = IARFLV(ITYPAR(NPI))
c            NPI = NPI + 1
c         END DO
c         MASSR(1) = NP
         IA = 0
         DO 1028 IRUN = 1, NUM
            DO 1027 IC = 1, MASSR(IRUN)
               IE = IA + IC
               RT(1, IC, IRUN) = R(1, IE)
               RT(2, IC, IRUN) = R(2, IE)
               RT(3, IC, IRUN) = R(3, IE)
               PT(1, IC, IRUN) = P(1, IE)
               PT(2, IC, IRUN) = P(2, IE)
               PT(3, IC, IRUN) = P(3, IE)
               ET(IC, IRUN) = E(IE)
               LT(IC, IRUN) = LB(IE)
c         !! sp 12/19/00
               PROT(IC, IRUN) = PROPER(IE)
clin-5/2008:
               dpertt(IC, IRUN)=dpertp(IE)
 1027       CONTINUE
            NP = MASSR(IRUN)
            NP1 = NPI(IRUN)

cbz10/05/99
c            DO WHILE (FT1(NP1, IRUN) .GT. CT - DT .AND. 
c     &           FT1(NP1, IRUN) .LE. CT)
cbz10/06/99
c            DO WHILE (NPI(IRUN).LE.MULTI1(IRUN).AND.
cbz10/06/99 end
clin-11/13/00 finally read in all unformed particles and do the decays in ART:
c           DO WHILE (NP1.LE.MULTI1(IRUN).AND.
c    &           FT1(NP1, IRUN) .GT. CT - DT .AND. 
c    &           FT1(NP1, IRUN) .LE. CT)
c
               ctlong = ct
             if(nt .eq. (ntmax-1))then
               ctlong = 1.E30
             elseif(nt .eq. ntmax)then
               go to 1111
             endif
c
            DO WHILE (NP1.LE.MULTI1(IRUN).AND.
     &           FT1(NP1, IRUN) .GT. ((NT-1) * DT) .AND. 
     &           FT1(NP1, IRUN) .LE. ctlong)
clin-ma-5/2016 changed the following to 2nd line above to avoid bug 
c     that leads to loss of hadrons inside ART due to finite accuracy 
c     [which results in (ct-dt) + dt != ct exactly]:
c     &           FT1(NP1, IRUN) .GT. (CT - DT) .AND. 
               NP = NP + 1
               UDT = (CT - FT1(NP1, IRUN)) / EE1(NP1, IRUN)
clin-10/28/03 since all unformed hadrons at time ct are read in at nt=ntmax-1, 
c     their positions should not be propagated to time ct:
               if(nt.eq.(ntmax-1)) then
                  ftsvt(NP,IRUN)=FT1(NP1, IRUN)
                  if(FT1(NP1, IRUN).gt.ct) UDT=0.
               endif
               RT(1, NP, IRUN) = GX1(NP1, IRUN) + 
     &              PX1(NP1, IRUN) * UDT
               RT(2, NP, IRUN) = GY1(NP1, IRUN) + 
     &              PY1(NP1, IRUN) * UDT
               RT(3, NP, IRUN) = GZ1(NP1, IRUN) + 
     &              PZ1(NP1, IRUN) * UDT
               PT(1, NP, IRUN) = PX1(NP1, IRUN)
               PT(2, NP, IRUN) = PY1(NP1, IRUN)
               PT(3, NP, IRUN) = PZ1(NP1, IRUN)
               ET(NP, IRUN) = XM1(NP1, IRUN)
               LT(NP, IRUN) = IARFLV(ITYP1(NP1, IRUN))
clin-5/2008:
               dpertt(NP,IRUN)=dpp1(NP1,IRUN)
clin-4/30/03 ctest off 
c     record initial phi,K*,Lambda(1520) resonances formed during the timestep:
c               if(LT(NP, IRUN).eq.29.or.iabs(LT(NP, IRUN)).eq.30)
c     1              write(17,112) 'formed',LT(NP, IRUN),PX1(NP1, IRUN),
c     2 PY1(NP1, IRUN),PZ1(NP1, IRUN),XM1(NP1, IRUN),nt
c 112           format(a10,1x,I4,4(1x,f9.3),1x,I4)
c
               NP1 = NP1 + 1
c     !! sp 12/19/00
               PROT(NP, IRUN) = 1.
            END DO
*
 1111      continue
            NPI(IRUN) = NP1
            IA = IA + MASSR(IRUN)
            MASSR(IRUN) = NP
 1028    CONTINUE
         IA = 0
         DO 1030 IRUN = 1, NUM
            IA = IA + MASSR(IRUN - 1)
            DO 1029 IC = 1, MASSR(IRUN)
               IE = IA + IC
               R(1, IE) = RT(1, IC, IRUN)
               R(2, IE) = RT(2, IC, IRUN)
               R(3, IE) = RT(3, IC, IRUN)
               P(1, IE) = PT(1, IC, IRUN)
               P(2, IE) = PT(2, IC, IRUN)
               P(3, IE) = PT(3, IC, IRUN)
               E(IE) = ET(IC, IRUN)
               LB(IE) = LT(IC, IRUN)
c     !! sp 12/19/00
               PROPER(IE) = PROT(IC, IRUN)
               if(nt.eq.(ntmax-1)) ftsv(IE)=ftsvt(IC,IRUN)
clin-5/2008:
               dpertp(IE)=dpertt(IC, IRUN)
 1029       CONTINUE
clin-3/2009 Moved here to better take care of freezeout spacetime:
            call hbtout(MASSR(IRUN),nt,ntmax)
 1030    CONTINUE
cbz12/22/98end
      END IF
cbz11/16/98end

clin-5/2009 ctest off:
c      call flowh(ct) 

10000       continue

*                                                                      *
*       ==============  END OF TIME STEP LOOP   ================       *

************************************
*     WRITE OUT particle's MOMENTA ,and/OR COORDINATES ,
*     label and/or their local baryon density in the final state
        iss=0
        do 1032 lrun=1,num
           iss=iss+massr(lrun-1)
           do 1031 l0=1,massr(lrun)
              ipart=iss+l0
 1031      continue
 1032   continue

cbz11/16/98
      IF (IAPAR2(1) .NE. 1) THEN
cbz12/22/98
c        NSH = MASSR(1) - NPI + 1
c        IAINT2(1) = IAINT2(1) + NSH
c.....to shift the unformed particles to the end of the common block
c        IF (NSH .GT. 0) THEN
c           IB = IAINT2(1)
c           IE = MASSR(1) + 1
c           II = -1
c        ELSE IF (NSH .LT. 0) THEN
c           IB = MASSR(1) + 1
c           IE = IAINT2(1)
c           II = 1
c        END IF
c        IF (NSH .NE. 0) THEN
c           DO I = IB, IE, II
c              J = I - NSH
c              ITYPAR(I) = ITYPAR(J)
c              GXAR(I) = GXAR(J)
c              GYAR(I) = GYAR(J)
c              GZAR(I) = GZAR(J)
c              FTAR(I) = FTAR(J)
c              PXAR(I) = PXAR(J)
c              PYAR(I) = PYAR(J)
c              PZAR(I) = PZAR(J)
c              PEAR(I) = PEAR(J)
c              XMAR(I) = XMAR(J)
c           END DO
c        END IF

c.....to copy ART particle info to COMMON /ARPRC/
c        DO I = 1, MASSR(1)
c           ITYPAR(I) = INVFLV(LB(I))
c           GXAR(I) = R(1, I)
c           GYAR(I) = R(2, I)
c           GZAR(I) = R(3, I)
c           FTAR(I) = CT
c           PXAR(I) = P(1, I)
c           PYAR(I) = P(2, I)
c           PZAR(I) = P(3, I)
c           XMAR(I) = E(I)
c           PEAR(I) = SQRT(PXAR(I) ** 2 + PYAR(I) ** 2 + PZAR(I) ** 2
c     &        + XMAR(I) ** 2)
c        END DO
        IA = 0
        DO 1035 IRUN = 1, NUM
           IA = IA + MASSR(IRUN - 1)
           NP1 = NPI(IRUN)
           NSH = MASSR(IRUN) - NP1 + 1
           MULTI1(IRUN) = MULTI1(IRUN) + NSH
c.....to shift the unformed particles to the end of the common block
           IF (NSH .GT. 0) THEN
              IB = MULTI1(IRUN)
              IE = MASSR(IRUN) + 1
              II = -1
           ELSE IF (NSH .LT. 0) THEN
              IB = MASSR(IRUN) + 1
              IE = MULTI1(IRUN)
              II = 1
           END IF
           IF (NSH .NE. 0) THEN
              DO 1033 I = IB, IE, II
                 J = I - NSH
                 ITYP1(I, IRUN) = ITYP1(J, IRUN)
                 GX1(I, IRUN) = GX1(J, IRUN)
                 GY1(I, IRUN) = GY1(J, IRUN)
                 GZ1(I, IRUN) = GZ1(J, IRUN)
                 FT1(I, IRUN) = FT1(J, IRUN)
                 PX1(I, IRUN) = PX1(J, IRUN)
                 PY1(I, IRUN) = PY1(J, IRUN)
                 PZ1(I, IRUN) = PZ1(J, IRUN)
                 EE1(I, IRUN) = EE1(J, IRUN)
                 XM1(I, IRUN) = XM1(J, IRUN)
c     !! sp 12/19/00
                 PRO1(I, IRUN) = PRO1(J, IRUN)
clin-5/2008:
                 dpp1(I,IRUN)=dpp1(J,IRUN)
 1033         CONTINUE
           END IF
           
c.....to copy ART particle info to COMMON /ARPRC1/
           DO 1034 I = 1, MASSR(IRUN)
              IB = IA + I
              ITYP1(I, IRUN) = INVFLV(LB(IB))
              GX1(I, IRUN) = R(1, IB)
              GY1(I, IRUN) = R(2, IB)
              GZ1(I, IRUN) = R(3, IB)
clin-10/28/03:
c since all unformed hadrons at time ct are read in at nt=ntmax-1, 
c their formation time ft1 should be kept to determine their freezeout(x,t):
c              FT1(I, IRUN) = CT
              if(FT1(I, IRUN).lt.CT) FT1(I, IRUN) = CT
              PX1(I, IRUN) = P(1, IB)
              PY1(I, IRUN) = P(2, IB)
              PZ1(I, IRUN) = P(3, IB)
              XM1(I, IRUN) = E(IB)
              EE1(I, IRUN) = SQRT(PX1(I, IRUN) ** 2 + 
     &             PY1(I, IRUN) ** 2 +
     &             PZ1(I, IRUN) ** 2 + 
     &             XM1(I, IRUN) ** 2)
c     !! sp 12/19/00
              PRO1(I, IRUN) = PROPER(IB)
 1034      CONTINUE
 1035   CONTINUE
cbz12/22/98end
      END IF
cbz11/16/98end
c
**********************************
*                                                                      *
*       ======= END OF MANY LOOPS OVER IMPACT PARAMETERS ==========    *
*                                                               *
**********************************
50000   CONTINUE
*
*-----------------------------------------------------------------------
*                       ==== ART COMPLETED ====
*-----------------------------------------------------------------------
cbz11/16/98
c      STOP
      RETURN
cbz11/16/98end
      END
**********************************
      subroutine coulin(masspr,massta,NUM)
*                                                                      *
*     purpose:   initialization of array zet() and lb() for all runs  *
*                lb(i) = 1   =>  proton                               *
*                lb(i) = 2   =>  neutron                              *
**********************************
        integer  zta,zpr
        PARAMETER (MAXSTR=150001)
        common  /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON  /ZZ/ ZTA,ZPR
cc      SAVE /zz/
      SAVE   
        MASS=MASSTA+MASSPR
        DO 500 IRUN=1,NUM
        do 100 i = 1+(IRUN-1)*MASS,zta+(IRUN-1)*MASS
        LB(i) = 1
  100   continue
        do 200 i = zta+1+(IRUN-1)*MASS,massta+(IRUN-1)*MASS
        LB(i) = 2
  200   continue
        do 300 i = massta+1+(IRUN-1)*MASS,massta+zpr+(IRUN-1)*MASS
        LB(i) = 1
  300   continue
        do 400 i = massta+zpr+1+(IRUN-1)*MASS,
     1  massta+masspr+(IRUN-1)*MASS
        LB(i) = 2
  400   continue
  500   CONTINUE
        return
        end
**********************************
*                                                                      *
      SUBROUTINE RELCOL(LCOLL,LBLOC,LCNNE,LDD,LPP,lppk,
     &LPN,lpd,lrho,lomega,LKN,LNNK,LDDK,LNDK,LCNND,LCNDN,
     &LDIRT,LDECAY,LRES,LDOU,LDDRHO,LNNRHO,LNNOM,
     &NT,ntmax,sp,akaon,sk)
*                                                                      *
*       PURPOSE:    CHECK CONDITIONS AND CALCULATE THE KINEMATICS      * 
*                   FOR BINARY COLLISIONS AMONG PARTICLES              *
*                                 - RELATIVISTIC FORMULA USED          *
*                                                                      *
*       REFERENCES: HAGEDORN, RELATIVISTIC KINEMATICS (1963)           *
*                                                                      *
*       VARIABLES:                                                     *
*         MASSPR  - NUMBER OF NUCLEONS IN PROJECTILE   (INTEGER,INPUT) *
*         MASSTA  - NUMBER OF NUCLEONS IN TARGET       (INTEGER,INPUT) *
*         NUM     - NUMBER OF TESTPARTICLES PER NUCLEON(INTEGER,INPUT) *
*         ISEED   - SEED FOR RANDOM NUMBER GENERATOR   (INTEGER,INPUT) *
*         IAVOID  - (= 1 => AVOID FIRST CLLISIONS WITHIN THE SAME      *
*                   NUCLEUS, ELSE ALL COLLISIONS)      (INTEGER,INPUT) *
*         DELTAR  - MAXIMUM SPATIAL DISTANCE FOR WHICH A COLLISION     *
*                   STILL CAN OCCUR                       (REAL,INPUT) *
*         DT      - TIME STEP SIZE                        (REAL,INPUT) *
*         LCOLL   - NUMBER OF COLLISIONS              (INTEGER,OUTPUT) *
*         LBLOC   - NUMBER OF PULI-BLOCKED COLLISIONS (INTEGER,OUTPUT) *
*         LCNNE   - NUMBER OF ELASTIC COLLISION       (INTEGER,OUTPUT) *
*         LCNND   - NUMBER OF N+N->N+DELTA REACTION   (INTEGER,OUTPUT) *
*         LCNDN   - NUMBER OF N+DELTA->N+N REACTION   (INTEGER,OUTPUT) *
*         LDD     - NUMBER OF RESONANCE+RESONANCE COLLISIONS
*         LPP     - NUMBER OF PION+PION elastic COLIISIONS
*         lppk    - number of pion(RHO,OMEGA)+pion(RHO,OMEGA)
*                   -->K+K- collisions
*         LPN     - NUMBER OF PION+N-->KAON+X
*         lpd     - number of pion+n-->delta+pion
*         lrho    - number of pion+n-->Delta+rho
*         lomega  - number of pion+n-->Delta+omega
*         LKN     - NUMBER OF KAON RESCATTERINGS
*         LNNK    - NUMBER OF bb-->kAON PROCESS
*         LDDK    - NUMBER OF DD-->KAON PROCESS
*         LNDK    - NUMBER OF ND-->KAON PROCESS
*         LB(I) IS USED TO LABEL PARTICLE'S CHARGE STATE
*         LB(I)   = 
cbali2/7/99 
*                 -45 Omega baryon(bar)
*                 -41 cascade0(bar)
*                 -40 cascade-(bar)
clin-11/07/00:
*                 -30 K*-
*                 -17 sigma+(bar)
*                 -16 sigma0(bar)
*                 -15 sigma-(bar)
*                 -14 LAMBDA(bar)
clin-8/29/00
*                 -13 anti-N*(+1)(1535),s_11
*                 -12 anti-N*0(1535),s_11
*                 -11 anti-N*(+1)(1440),p_11
*                 -10 anti-N*0(1440), p_11
*                  -9 anti-DELTA+2
*                  -8 anti-DELTA+1
*                  -7 anti-DELTA0
*                  -6 anti-DELTA-1
*
*                  -2 antineutron 
*                  -1 antiproton
cbali2/7/99end 
*                   0 eta
*                   1 PROTON
*                   2 NUETRON
*                   3 PION-
*                   4 PION0
*                   5 PION+          
*                   6 DELTA-1
*                   7 DELTA0
*                   8 DELTA+1
*                   9 DELTA+2
*                   10 N*0(1440), p_11
*                   11 N*(+1)(1440),p_11
*                  12 N*0(1535),s_11
*                  13 N*(+1)(1535),s_11
*                  14 LAMBDA
*                   15 sigma-
*                   16 sigma0
*                   17 sigma+
*                   21 kaon-
clin-2/23/03        22 Kaon0Long (converted at the last timestep)
*                   23 KAON+
*                   24 Kaon0short (converted at the last timestep then decay)
*                   25 rho-
*                   26 rho0
*                   27 rho+
*                   28 omega meson
*                   29 phi
*                   30 K*+
* sp01/03/01
*                   31 eta-prime
*                   40 cascade-
*                   41 cascade0
*                   45 Omega baryon
* sp01/03/01 end
*                   
*                   ++  ------- SEE NOTE BOOK
*         NSTAR=1 INCLUDING N* RESORANCE
*         ELSE DELTA RESORANCE ONLY
*         NDIRCT=1 INCLUDING DIRECT PROCESS,ELSE NOT
*         DIR - PERCENTAGE OF DIRECT PION PRODUCTION PROCESS
**********************************
      PARAMETER      (MAXSTR=150001,MAXR=1,PI=3.1415926)
      parameter      (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
      PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974,aks=0.895)
      PARAMETER      (AA1=1.26,APHI=1.02,AP1=0.13496)
      parameter            (maxx=20,maxz=24)
      parameter            (rrkk=0.6,prkk=0.3,srhoks=5.,ESBIN=0.04)
      DIMENSION MASSRN(0:MAXR),RT(3,MAXSTR),PT(3,MAXSTR),ET(MAXSTR)
      DIMENSION LT(MAXSTR), PROT(MAXSTR)
      COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
      COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      COMMON   /EE/  ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      COMMON   /HH/  PROPER(MAXSTR)
cc      SAVE /HH/
      common /ff/f(-mx:mx,-my:my,-mz:mz,-mpx:mpx,-mpy:mpy,-mpz:mpzp)
cc      SAVE /ff/
      common   /gg/  dx,dy,dz,dpx,dpy,dpz
cc      SAVE /gg/
      COMMON   /INPUT/ NSTAR,NDIRCT,DIR
cc      SAVE /INPUT/
      COMMON   /NN/NNN
cc      SAVE /NN/
      COMMON   /RR/  MASSR(0:MAXR)
cc      SAVE /RR/
      common   /ss/  inout(20)
cc      SAVE /ss/
      COMMON   /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
      COMMON   /RUN/NUM
cc      SAVE /RUN/
      COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
      COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
      COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
      COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      COMMON   /PE/PROPI(MAXSTR,MAXR)
cc      SAVE /PE/
      COMMON   /KKK/TKAON(7),EKAON(7,0:2000)
cc      SAVE /KKK/
      COMMON  /KAON/    AK(3,50,36),SPECK(50,36,7),MF
cc      SAVE /KAON/
      COMMON/TABLE/ xarray(0:1000),earray(0:1000)
cc      SAVE /TABLE/
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1 px1n,py1n,pz1n,dp1n
cc      SAVE /leadng/
      COMMON/tdecay/tfdcy(MAXSTR),tfdpi(MAXSTR,MAXR),tft(MAXSTR)
cc      SAVE /tdecay/
      common /lastt/itimeh,bimp 
cc      SAVE /lastt/
c
      COMMON/ppbmas/niso(15),nstate,ppbm(15,2),thresh(15),weight(15)
cc      SAVE /ppbmas/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      COMMON/hbt/lblast(MAXSTR),xlast(4,MAXSTR),plast(4,MAXSTR),nlast
cc      SAVE /hbt/
      common/resdcy/NSAV,iksdcy
cc      SAVE /resdcy/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      COMMON/FTMAX/ftsv(MAXSTR),ftsvt(MAXSTR, MAXR)
      dimension ftpisv(MAXSTR,MAXR),fttemp(MAXSTR)
      common /dpi/em2,lb2
      common/phidcy/iphidcy,pttrig,ntrig,maxmiss,ipi0dcy
clin-5/2008:
      DIMENSION dptemp(MAXSTR)
      common /para8/ idpert,npertd,idxsec
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
c
      real zet(-45:45)
      SAVE   
      data zet /
     4     1.,0.,0.,0.,0.,
     3     1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
     2     -1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
     1     0.,0.,0.,-1.,0.,1.,0.,-1.,0.,-1.,
     s     0.,-2.,-1.,0.,1.,0.,0.,0.,0.,-1.,
     e     0.,
     s     1.,0.,-1.,0.,1.,-1.,0.,1.,2.,0.,
     1     1.,0.,1.,0.,-1.,0.,1.,0.,0.,0.,
     2     -1.,0.,1.,0.,-1.,0.,1.,0.,0.,1.,
     3     0.,0.,0.,0.,0.,0.,0.,0.,0.,-1.,
     4     0.,0.,0.,0.,-1./

clin-2/19/03 initialize n and nsav for resonance decay at each timestep
c     in order to prevent integer overflow:
      call inidcy

c OFF skip ART collisions to reproduce HJ:      
cc       if(nt.ne.ntmax) return

clin-11/07/00 rrkk is assumed to be 0.6mb(default) for mm->KKbar 
c     with m=rho or omega, estimated from Ko's paper:
c      rrkk=0.6
c prkk: cross section of pi (rho or omega) -> K* Kbar (AND) K*bar K:
c      prkk=0.3
c     cross section in mb for (rho or omega) K* -> pi K:
c      srhoks=5.
clin-11/07/00-end
c      ESBIN=0.04
      RESONA=5.
*-----------------------------------------------------------------------
*     INITIALIZATION OF COUNTING VARIABLES
      NODELT=0
      SUMSRT =0.
      LCOLL  = 0
      LBLOC  = 0
      LCNNE  = 0
      LDD  = 0
      LPP  = 0
      lpd  = 0
      lpdr=0
      lrho = 0
      lrhor=0
      lomega=0
      lomgar=0
      LPN  = 0
      LKN  = 0
      LNNK = 0
      LDDK = 0
      LNDK = 0
      lppk =0
      LCNND  = 0
      LCNDN  = 0
      LDIRT  = 0
      LDECAY = 0
      LRES   = 0
      Ldou   = 0
      LDDRHO = 0
      LNNRHO = 0
      LNNOM  = 0
      MSUM   = 0
      MASSRN(0)=0
* COM: MSUM IS USED TO COUNT THE TOTAL NO. OF PARTICLES 
*      IN PREVIOUS IRUN-1 RUNS
* KAON COUNTERS
      DO 1002 IL=1,5
         TKAON(IL)=0
         DO 1001 IS=1,2000
            EKAON(IL,IS)=0
 1001    CONTINUE
 1002 CONTINUE
c sp 12/19/00
      DO 1004 i =1,NUM
         DO 1003 j =1,MAXSTR
            PROPI(j,i) = 1.
 1003    CONTINUE
 1004 CONTINUE
      
      do 1102 i=1,maxstr
         fttemp(i)=0.
         do 1101 irun=1,maxr
            ftpisv(i,irun)=0.
 1101    continue
 1102 continue

c sp 12/19/00 end
      sp=0
* antikaon counters
      akaon=0
      sk=0
*-----------------------------------------------------------------------
*     LOOP OVER ALL PARALLEL RUNS
cbz11/17/98
c      MASS=MASSPR+MASSTA
      MASS = 0
cbz11/17/98end
      DO 1000 IRUN = 1,NUM
         NNN=0
         MSUM=MSUM+MASSR(IRUN-1)
*     LOOP OVER ALL PSEUDOPARTICLES 1 IN THE SAME RUN
         J10=2
         IF(NT.EQ.NTMAX)J10=1
c
ctest off skips the check of energy conservation after each timestep:
c         enetot=0.
c         do ip=1,MASSR(IRUN)
c            if(e(ip).ne.0.or.lb(ip).eq.10022) enetot=enetot
c     1           +sqrt(p(1,ip)**2+p(2,ip)**2+p(3,ip)**2+e(ip)**2)
c         enddo
c         write(91,*) 'A:',nt,enetot,massr(irun),bimp 

         DO 800 J1 = J10,MASSR(IRUN)
            I1  = J1 + MSUM
* E(I)=0 are for pions having been absorbed or photons which do not enter here:
clin-4/2012 option of pi0 decays:
c            IF(E(I1).EQ.0.)GO TO 800
            IF(E(I1).EQ.0.)GO TO 798
c     To include anti-(Delta,N*1440 and N*1535):
c          IF ((LB(I1) .LT. -13 .OR. LB(I1) .GT. 28)
c     1         .and.iabs(LB(I1)) .ne. 30 ) GOTO 800
clin-4/2012 option of pi0 decays:
c            IF (LB(I1) .LT. -45 .OR. LB(I1) .GT. 45) GOTO 800
            IF (LB(I1) .LT. -45 .OR. LB(I1) .GT. 45) GOTO 798
            X1  = R(1,I1)
            Y1  = R(2,I1)
            Z1  = R(3,I1)
            PX1 = P(1,I1)
            PY1 = P(2,I1)
            PZ1 = P(3,I1)
            EM1 = E(I1)
            am1= em1
            E1  = SQRT( EM1**2 + PX1**2 + PY1**2 + PZ1**2 )
            ID1 = ID(I1)
            LB1 = LB(I1)

c     generate k0short and k0long from K+ and K- at the last timestep:
            if(nt.eq.ntmax.and.(lb1.eq.21.or.lb1.eq.23)) then
               pk0=RANART(NSEED)
               if(pk0.lt.0.25) then
                  LB(I1)=22
               elseif(pk0.lt.0.50) then
                  LB(I1)=24
               endif
               LB1=LB(I1)
            endif
            
clin-8/07/02 these particles don't decay strongly, so skip decay routines:     
c            IF( (lb1.ge.-2.and.lb1.le.5) .OR. lb1.eq.31 .OR.
c     &           (iabs(lb1).ge.14.and.iabs(lb1).le.24) .OR.
c     &           (iabs(lb1).ge.40.and.iabs(lb1).le.45) .or. 
c     &           lb1.eq.31)GO TO 1 
c     only decay K0short when iksdcy=1:
            if(lb1.eq.0.or.lb1.eq.25.or.lb1.eq.26.or.lb1.eq.27
     &           .or.lb1.eq.28.or.lb1.eq.29.or.iabs(lb1).eq.30
     &           .or.(iabs(lb1).ge.6.and.iabs(lb1).le.13)
     &           .or.(iksdcy.eq.1.and.lb1.eq.24)
     &           .or.iabs(lb1).eq.16
     &           .or.(ipi0dcy.eq.1.and.nt.eq.ntmax.and.lb1.eq.4)) then
clin-4/2012-above for option of pi0 decay:
c     &           .or.iabs(lb1).eq.16) then
               continue
            else
               goto 1
            endif
* IF I1 IS A RESONANCE, CHECK WHETHER IT DECAYS DURING THIS TIME STEP
         IF(lb1.ge.25.and.lb1.le.27) then
             wid=0.151
         ELSEIF(lb1.eq.28) then
             wid=0.00841
         ELSEIF(lb1.eq.29) then
             wid=0.00443
          ELSEIF(iabs(LB1).eq.30) then
             WID=0.051
         ELSEIF(lb1.eq.0) then
             wid=1.18e-6
c     to give K0short ct0=2.676cm:
         ELSEIF(iksdcy.eq.1.and.lb1.eq.24) then
             wid=7.36e-15
clin-4/29/03 add Sigma0 decay to Lambda, ct0=2.22E-11m:
         ELSEIF(iabs(lb1).eq.16) then
             wid=8.87e-6
csp-07/25/01 test a1 resonance:
cc          ELSEIF(LB1.EQ.32) then
cc             WID=0.40
          ELSEIF(LB1.EQ.32) then
             call WIDA1(EM1,rhomp,WID,iseed)
          ELSEIF(iabs(LB1).ge.6.and.iabs(LB1).le.9) then
             WID=WIDTH(EM1)
          ELSEIF((iabs(LB1).EQ.10).OR.(iabs(LB1).EQ.11)) then
             WID=W1440(EM1)
          ELSEIF((iabs(LB1).EQ.12).OR.(iabs(LB1).EQ.13)) then
             WID=W1535(EM1)
clin-4/2012 for option of pi0 decay:
          ELSEIF(ipi0dcy.eq.1.and.nt.eq.ntmax.and.lb1.eq.4) then
             wid=7.85e-9
          ENDIF

* if it is the last time step, FORCE all resonance to strong-decay
* and go out of the loop
          if(nt.eq.ntmax)then
             pdecay=1.1
clin-5b/2008 forbid phi decay at the end of hadronic cascade:
             if(iphidcy.eq.0.and.iabs(LB1).eq.29) pdecay=0.
ctest off clin-9/2012 forbid long-time decays (eta,omega,K*,Sigma0)
c     at the end of hadronic cascade to analyze freezeout time:
c             if(LB1.eq.0.or.LB1.eq.28.or.iabs(LB1).eq.30
c     1            .or.iabs(LB1).eq.16) pdecay=0.
          else
             T0=0.19733/WID
             GFACTR=E1/EM1
             T0=T0*GFACTR
             IF(T0.GT.0.)THEN
                PDECAY=1.-EXP(-DT/T0)
             ELSE
                PDECAY=0.
             ENDIF
          endif
          XDECAY=RANART(NSEED)

cc dilepton production from rho0, omega, phi decay 
cc        if(lb1.eq.26 .or. lb1.eq.28 .or. lb1.eq.29)
cc     &   call dec_ceres(nt,ntmax,irun,i1)
cc
          IF(XDECAY.LT.PDECAY) THEN
clin-10/25/02 get rid of argument usage mismatch in rhocay():
             idecay=irun
             tfnl=nt*dt
clin-10/28/03 keep formation time of hadrons unformed at nt=ntmax-1:
             if(nt.eq.ntmax.and.ftsv(i1).gt.((ntmax-1)*dt)) 
     1            tfnl=ftsv(i1)
             xfnl=x1
             yfnl=y1
             zfnl=z1
* use PYTHIA to perform decays of eta,rho,omega,phi,K*,(K0s) and Delta:
             if(lb1.eq.0.or.lb1.eq.25.or.lb1.eq.26.or.lb1.eq.27
     &           .or.lb1.eq.28.or.lb1.eq.29.or.iabs(lb1).eq.30
     &           .or.(iabs(lb1).ge.6.and.iabs(lb1).le.9)
     &           .or.(iksdcy.eq.1.and.lb1.eq.24)
     &           .or.iabs(lb1).eq.16
     &           .or.(ipi0dcy.eq.1.and.nt.eq.ntmax.and.lb1.eq.4)) then
clin-4/2012 Above for option of pi0 decay:
c     &           .or.iabs(lb1).eq.16) then
c     previous rho decay performed in rhodecay():
c                nnn=nnn+1
c                call rhodecay(idecay,i1,nnn,iseed)
c
ctest off record decays of phi,K*,Lambda(1520) resonances:
c                if(lb1.eq.29.or.iabs(lb1).eq.30) 
c     1               write(18,112) 'decay',lb1,px1,py1,pz1,am1,nt
c
clin-4/2012 option of pi0 decays:
c                call resdec(i1,nt,nnn,wid,idecay)
                call resdec(i1,nt,nnn,wid,idecay,0)
                p(1,i1)=px1n
                p(2,i1)=py1n
                p(3,i1)=pz1n
clin-5/2008:
                dpertp(i1)=dp1n
c     add decay time to freezeout positions & time at the last timestep:
                if(nt.eq.ntmax) then
                   R(1,i1)=xfnl
                   R(2,i1)=yfnl
                   R(3,i1)=zfnl
                   tfdcy(i1)=tfnl
                endif
c
* decay number for baryon resonance or L/S decay
                if(iabs(lb1).ge.6.and.iabs(lb1).le.9) then
                   LDECAY=LDECAY+1
                endif

* for a1 decay 
c             elseif(lb1.eq.32)then
c                NNN=NNN+1
c                call a1decay(idecay,i1,nnn,iseed,rhomp)

* FOR N*(1440)
             elseif(iabs(LB1).EQ.10.OR.iabs(LB1).EQ.11) THEN
                NNN=NNN+1
                LDECAY=LDECAY+1
                PNSTAR=1.
                IF(E(I1).GT.1.22)PNSTAR=0.6
                IF(RANART(NSEED).LE.PNSTAR)THEN
* (1) DECAY TO SINGLE PION+NUCLEON
                   CALL DECAY(idecay,I1,NNN,ISEED,wid,nt)
                ELSE
* (2) DECAY TO TWO PIONS + NUCLEON
                   CALL DECAY2(idecay,I1,NNN,ISEED,wid,nt)
                   NNN=NNN+1
                ENDIF
c for N*(1535) decay
             elseif(iabs(LB1).eq.12.or.iabs(LB1).eq.13) then
                NNN=NNN+1
                CALL DECAY(idecay,I1,NNN,ISEED,wid,nt)
                LDECAY=LDECAY+1
             endif
c
*COM: AT HIGH ENERGIES WE USE VERY SHORT TIME STEPS,
*     IN ORDER TO TAKE INTO ACCOUNT THE FINITE FORMATIOM TIME, WE
*     DO NOT ALLOW PARTICLES FROM THE DECAY OF RESONANCE TO INTERACT 
*     WITH OTHERS IN THE SAME TIME STEP. CHANGE 9000 TO REVERSE THIS 
*     ASSUMPTION. EFFECTS OF THIS ASSUMPTION CAN BE STUDIED BY CHANGING 
*     THE STATEMENT OF 9000. See notebook for discussions on effects of
*     changing statement 9000.
c
c     kaons from K* decay are converted to k0short (and k0long), 
c     phi decay may produce rho, K0S or eta, N*(1535) decay may produce eta,
c     and these decay daughters need to decay again if at the last timestep:
c     (note: these daughters have been assigned to lb(i1) only, not to lpion)
c             if(nt.eq.ntmax.and.(lb1.eq.29.or.iabs(lb1).eq.30
c     1            .iabs(lb1).eq.12.or.iabs(lb1).eq.13)) then
             if(nt.eq.ntmax) then
                if(lb(i1).eq.25.or.lb(i1).eq.26.or.lb(i1).eq.27) then
                   wid=0.151
                elseif(lb(i1).eq.0) then
                   wid=1.18e-6
                elseif(lb(i1).eq.24.and.iksdcy.eq.1) then
clin-4/2012 corrected K0s decay width:
c                   wid=7.36e-17
                   wid=7.36e-15
clin-4/2012 option of pi0 decays:
                elseif(ipi0dcy.eq.1.and.lb(i1).eq.4) then
                   wid=7.85e-9
                else
                   goto 9000
                endif
                LB1=LB(I1)
                PX1=P(1,I1)
                PY1=P(2,I1)
                PZ1=P(3,I1)
                EM1=E(I1)
                E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
clin-4/2012 option of pi0 decays:
c                call resdec(i1,nt,nnn,wid,idecay)
                call resdec(i1,nt,nnn,wid,idecay,0)
                p(1,i1)=px1n
                p(2,i1)=py1n
                p(3,i1)=pz1n
                R(1,i1)=xfnl
                R(2,i1)=yfnl
                R(3,i1)=zfnl
                tfdcy(i1)=tfnl
clin-5/2008:
                dpertp(i1)=dp1n
             endif

c     Decay daughter of the above decay in lb(i1) may be a pi0:
             if(nt.eq.ntmax.and.ipi0dcy.eq.1.and.lb(i1).eq.4) then
                wid=7.85e-9
                LB1=LB(I1)
                PX1=P(1,I1)
                PY1=P(2,I1)
                PZ1=P(3,I1)
                EM1=E(I1)
                E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
                call resdec(i1,nt,nnn,wid,idecay,0)
                p(1,i1)=px1n
                p(2,i1)=py1n
                p(3,i1)=pz1n
                R(1,i1)=xfnl
                R(2,i1)=yfnl
                R(3,i1)=zfnl
                tfdcy(i1)=tfnl
                dpertp(i1)=dp1n
             endif

* negelecting the Pauli blocking at high energies
clin-4/2012 option of pi0 decays:
c 9000        go to 800
 9000        go to 798

          ENDIF
* LOOP OVER ALL PSEUDOPARTICLES 2 IN THE SAME RUN
* SAVE ALL THE COORDINATES FOR POSSIBLE CHANGE IN THE FOLLOWING COLLISION
clin-4/2012 option of pi0 decays:
c 1        if(nt.eq.ntmax)go to 800
 1        if(nt.eq.ntmax)go to 798

          X1 = R(1,I1)
          Y1 = R(2,I1)
          Z1 = R(3,I1)
c
           DO 600 J2 = 1,J1-1
            I2  = J2 + MSUM
* IF I2 IS A MESON BEING ABSORBED, THEN GO OUT OF THE LOOP
            IF(E(I2).EQ.0.) GO TO 600
clin-5/2008 in case the first particle is already destroyed:
            IF(E(I1).EQ.0.) GO TO 800
clin-4/2012 option of pi0 decays:
            IF (LB(I2) .LT. -45 .OR. LB(I2) .GT. 45) GOTO 600
clin-7/26/03 improve speed
            X2=R(1,I2)
            Y2=R(2,I2)
            Z2=R(3,I2)
            dr0max=5.
clin-9/2008 deuteron+nucleon elastic cross sections could reach ~2810mb:
            ilb1=iabs(LB(I1))
            ilb2=iabs(LB(I2))
            IF(ilb1.EQ.42.or.ilb2.EQ.42) THEN
               if((ILB1.GE.1.AND.ILB1.LE.2)
     1              .or.(ILB1.GE.6.AND.ILB1.LE.13)
     2              .or.(ILB2.GE.1.AND.ILB2.LE.2)
     3              .or.(ILB2.GE.6.AND.ILB2.LE.13)) then
                  if((lb(i1)*lb(i2)).gt.0) dr0max=10.
               endif
            ENDIF
c
            if(((X1-X2)**2+(Y1-Y2)**2+(Z1-Z2)**2).GT.dr0max**2)
     1           GO TO 600
            IF (ID(I1)*ID(I2).EQ.IAVOID) GOTO 400
            ID1=ID(I1)
            ID2 = ID(I2)
c
            ix1= nint(x1/dx)
            iy1= nint(y1/dy)
            iz1= nint(z1/dz)
            PX1=P(1,I1)
            PY1=P(2,I1)
            PZ1=P(3,I1)
            EM1=E(I1)
            AM1=EM1
            LB1=LB(I1)
            E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
            IPX1=NINT(PX1/DPX)
            IPY1=NINT(PY1/DPY)
            IPZ1=NINT(PZ1/DPZ)         
            LB2 = LB(I2)
            PX2 = P(1,I2)
            PY2 = P(2,I2)
            PZ2 = P(3,I2)
            EM2=E(I2)
            AM2=EM2
            lb1i=lb(i1)
            lb2i=lb(i2)
            px1i=P(1,I1)
            py1i=P(2,I1)
            pz1i=P(3,I1)
            em1i=E(I1)
            px2i=P(1,I2)
            py2i=P(2,I2)
            pz2i=P(3,I2)
            em2i=E(I2)
clin-2/26/03 ctest off check energy conservation after each binary search:
            eini=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
     1           +SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
            pxini=P(1,I1)+P(1,I2)
            pyini=P(2,I1)+P(2,I2)
            pzini=P(3,I1)+P(3,I2)
            nnnini=nnn
c
clin-4/30/03 initialize value:
            iblock=0
c
* TO SAVE COMPUTING TIME we do the following
* (1) make a ROUGH estimate to see whether particle i2 will collide with
* particle I1, and (2) skip the particle pairs for which collisions are 
* not modeled in the code.
* FOR MESON-BARYON AND MESON-MESON COLLISIONS, we use a maximum 
* interaction distance DELTR0=2.6
* for ppbar production from meson (pi rho omega) interactions:
c
            DELTR0=3.
        if( (iabs(lb1).ge.14.and.iabs(lb1).le.17) .or.
     &      (iabs(lb1).ge.30.and.iabs(lb1).le.45) ) DELTR0=5.0
        if( (iabs(lb2).ge.14.and.iabs(lb2).le.17) .or.
     &      (iabs(lb2).ge.30.and.iabs(lb2).le.45) ) DELTR0=5.0

            if(lb1.eq.28.and.lb2.eq.28) DELTR0=4.84
clin-10/08/00 to include pi pi -> rho rho:
            if((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.3.and.lb2.le.5)) then
               E2=SQRT(EM2**2+PX2**2+PY2**2+PZ2**2)
         spipi=(e1+e2)**2-(px1+px2)**2-(py1+py2)**2-(pz1+pz2)**2
               if(spipi.ge.(4*0.77**2)) DELTR0=3.5
            endif

c khyperon
        IF (LB1.EQ.23 .AND. (LB2.GE.14.AND.LB2.LE.17)) GOTO 3699
        IF (LB2.EQ.23 .AND. (LB1.GE.14.AND.LB1.LE.17)) GOTO 3699

* K(K*) + Kbar(K*bar) scattering including 
*     K(K*) + Kbar(K*bar) --> phi + pi(rho,omega) and pi pi(rho,omega)
       if(lb1.eq.21.and.lb2.eq.23)go to 3699
       if(lb2.eq.21.and.lb1.eq.23)go to 3699
       if(lb1.eq.30.and.lb2.eq.21)go to 3699
       if(lb2.eq.30.and.lb1.eq.21)go to 3699
       if(lb1.eq.-30.and.lb2.eq.23)go to 3699
       if(lb2.eq.-30.and.lb1.eq.23)go to 3699
       if(lb1.eq.-30.and.lb2.eq.30)go to 3699
       if(lb2.eq.-30.and.lb1.eq.30)go to 3699
c
clin-12/15/00
c     kaon+rho(omega,eta) collisions:
      if(lb1.eq.21.or.lb1.eq.23) then
         if(lb2.eq.0.or.(lb2.ge.25.and.lb2.le.28)) then
            go to 3699
         endif
      elseif(lb2.eq.21.or.lb2.eq.23) then
         if(lb1.eq.0.or.(lb1.ge.25.and.lb1.le.28)) then
            goto 3699
         endif
      endif

clin-8/14/02 K* (pi, rho, omega, eta) collisions:
      if(iabs(lb1).eq.30 .and.
     1     (lb2.eq.0.or.(lb2.ge.25.and.lb2.le.28)
     2     .or.(lb2.ge.3.and.lb2.le.5))) then
         go to 3699
      elseif(iabs(lb2).eq.30 .and.
     1        (lb1.eq.0.or.(lb1.ge.25.and.lb1.le.28)
     2        .or.(lb1.ge.3.and.lb1.le.5))) then
         goto 3699
clin-8/14/02-end
c K*/K*-bar + baryon/antibaryon collisions:
        elseif( iabs(lb1).eq.30 .and.
     1     (iabs(lb2).eq.1.or.iabs(lb2).eq.2.or.
     2     (iabs(lb2).ge.6.and.iabs(lb2).le.13)) )then
              go to 3699
           endif
         if( iabs(lb2).eq.30 .and.
     1         (iabs(lb1).eq.1.or.iabs(lb1).eq.2.or.
     2         (iabs(lb1).ge.6.and.iabs(lb1).le.13)) )then
                go to 3699
        endif                                                              
* K^+ baryons and antibaryons:
c** K+ + B-bar  --> La(Si)-bar + pi
* K^- and antibaryons, note K^- and baryons are included in newka():
* note that we fail to satisfy charge conjugation for these cross sections:
        if((lb1.eq.23.or.lb1.eq.21).and.
     1       (iabs(lb2).eq.1.or.iabs(lb2).eq.2.or.
     2       (iabs(lb2).ge.6.and.iabs(lb2).le.13))) then
           go to 3699
        elseif((lb2.eq.23.or.lb2.eq.21).and.
     1       (iabs(lb1).eq.1.or.iabs(lb1).eq.2.or.
     2       (iabs(lb1).ge.6.and.iabs(lb1).le.13))) then
           go to 3699
        endif
*
* For anti-nucleons annihilations:
* Assumptions: 
* (1) for collisions involving a p_bar or n_bar,
* we allow only collisions between a p_bar and a baryon or a baryon 
* resonance (as well as a n_bar and a baryon or a baryon resonance),
* we skip all other reactions involving a p_bar or n_bar, 
* such as collisions between p_bar (n_bar) and mesons, 
* and collisions between two p_bar's (n_bar's). 
* (2) we introduce a new parameter rppmax: the maximum interaction 
* distance to make the quick collision check,rppmax=3.57 fm 
* corresponding to a cutoff of annihilation xsection= 400mb which is
* also used consistently in the actual annihilation xsection to be 
* used in the following as given in the subroutine xppbar(srt)
        rppmax=3.57   
* anti-baryon on baryons
        if((lb1.eq.-1.or.lb1.eq.-2.or.(lb1.ge.-13.and.lb1.le.-6))
     1 .and.(lb2.eq.1.or.lb2.eq.2.or.(lb2.ge.6.and.lb2.le.13))) then
            DELTR0 = RPPMAX
            GOTO 2699
       else if((lb2.eq.-1.or.lb2.eq.-2.or.(lb2.ge.-13.and.lb2.le.-6))
     1 .and.(lb1.eq.1.or.lb1.eq.2.or.(lb1.ge.6.and.lb1.le.13))) then
            DELTR0 = RPPMAX
            GOTO 2699
         END IF

c*  ((anti) lambda, cascade, omega  should not be rejected)
        if( (iabs(lb1).ge.14.and.iabs(lb1).le.17) .or.
     &      (iabs(lb2).ge.14.and.iabs(lb2).le.17) )go to 3699
c
clin-9/2008 maximum sigma~2810mb for deuteron+nucleon elastic collisions:
         IF (iabs(LB1).EQ.42.or.iabs(LB2).EQ.42) THEN
            ilb1=iabs(LB1)
            ilb2=iabs(LB2)
            if((ILB1.GE.1.AND.ILB1.LE.2)
     1           .or.(ILB1.GE.6.AND.ILB1.LE.13)
     2           .or.(ILB2.GE.1.AND.ILB2.LE.2)
     3           .or.(ILB2.GE.6.AND.ILB2.LE.13)) then
               if((lb1*lb2).gt.0) deltr0=9.5
            endif
         ENDIF
c
        if( (iabs(lb1).ge.40.and.iabs(lb1).le.45) .or. 
     &      (iabs(lb2).ge.40.and.iabs(lb2).le.45) )go to 3699
c
c* phi channel --> elastic + inelastic scatt.  
         IF( (lb1.eq.29 .and.((lb2.ge.1.and.lb2.le.13).or.  
     &       (lb2.ge.21.and.lb2.le.28).or.iabs(lb2).eq.30)) .OR.
     &     (lb2.eq.29 .and.((lb1.ge.1.and.lb1.le.13).or.
     &       (lb1.ge.21.and.lb1.le.28).or.iabs(lb1).eq.30)) )THEN
             DELTR0=3.0
             go to 3699
        endif
c
c  La/Si, Cas, Om (bar)-meson elastic colln
* pion vs. La & Ca (bar) coll. are treated in resp. subroutines

* SKIP all other K* RESCATTERINGS
        If(iabs(lb1).eq.30.or.iabs(lb2).eq.30) go to 400
* SKIP KAON(+) RESCATTERINGS WITH particles other than pions and baryons 
         If(lb1.eq.23.and.(lb2.lt.1.or.lb2.gt.17))go to 400
         If(lb2.eq.23.and.(lb1.lt.1.or.lb1.gt.17))go to 400
c
c anti-baryon proccess: B-bar+M, N-bar+R-bar, N-bar+N-bar, R-bar+R-bar
c  R = (D,N*)
         if( ((lb1.le.-1.and.lb1.ge.-13)
     &        .and.(lb2.eq.0.or.(lb2.ge.3.and.lb2.le.5)
     &            .or.(lb2.ge.25.and.lb2.le.28))) 
     &      .OR.((lb2.le.-1.and.lb2.ge.-13)
     &         .and.(lb1.eq.0.or.(lb1.ge.3.and.lb1.le.5)
     &              .or.(lb1.ge.25.and.lb1.le.28))) ) then
         elseIF( ((LB1.eq.-1.or.lb1.eq.-2).
     &             and.(LB2.LT.-5.and.lb2.ge.-13))
     &      .OR. ((LB2.eq.-1.or.lb2.eq.-2).
     &             and.(LB1.LT.-5.and.lb1.ge.-13)) )then
         elseIF((LB1.eq.-1.or.lb1.eq.-2)
     &     .AND.(LB2.eq.-1.or.lb2.eq.-2))then
         elseIF((LB1.LT.-5.and.lb1.ge.-13).AND.
     &          (LB2.LT.-5.and.lb2.ge.-13)) then
c        elseif((lb1.lt.0).or.(lb2.lt.0)) then
c         go to 400
       endif               

 2699    CONTINUE
* for baryon-baryon collisions
         IF (LB1 .EQ. 1 .OR. LB1 .EQ. 2 .OR. (LB1 .GE. 6 .AND.
     &        LB1 .LE. 17)) THEN
            IF (LB2 .EQ. 1 .OR. LB2 .EQ. 2 .OR. (LB2 .GE. 6 .AND.
     &           LB2 .LE. 17)) THEN
               DELTR0 = 2.
            END IF
         END IF
c
 3699   RSQARE = (X1-X2)**2 + (Y1-Y2)**2 + (Z1-Z2)**2
        IF (RSQARE .GT. DELTR0**2) GO TO 400
*NOW PARTICLES ARE CLOSE ENOUGH TO EACH OTHER !
* KEEP ALL COORDINATES FOR POSSIBLE PHASE SPACE CHANGE
            ix2 = nint(x2/dx)
            iy2 = nint(y2/dy)
            iz2 = nint(z2/dz)
            ipx2 = nint(px2/dpx)
            ipy2 = nint(py2/dpy)
            ipz2 = nint(pz2/dpz)
* FIND MOMENTA OF PARTICLES IN THE CMS OF THE TWO COLLIDING PARTICLES
* AND THE CMS ENERGY SRT
            CALL CMS(I1,I2,PCX,PCY,PCZ,SRT)

clin-7/26/03 improve speed
          drmax=dr0max
          call distc0(drmax,deltr0,DT,
     1         Ifirst,PCX,PCY,PCZ,
     2         x1,y1,z1,px1,py1,pz1,em1,x2,y2,z2,px2,py2,pz2,em2)
          if(Ifirst.eq.-1) goto 400

         ISS=NINT(SRT/ESBIN)
clin-4/2008 use last bin if ISS is out of EKAON's upper bound of 2000:
         if(ISS.gt.2000) ISS=2000
*Sort collisions
c
clin-8/2008 Deuteron+Meson->B+B; 
c     meson=(pi,rho,omega,eta), B=(n,p,Delta,N*1440,N*1535):
         IF (iabs(LB1).EQ.42.or.iabs(LB2).EQ.42) THEN
            ilb1=iabs(LB1)
            ilb2=iabs(LB2)
            if(LB1.eq.0.or.(LB1.GE.3.AND.LB1.LE.5)
     1           .or.(LB1.GE.25.AND.LB1.LE.28)
     2           .or.
     3           LB2.eq.0.or.(LB2.GE.3.AND.LB2.LE.5)
     4           .or.(LB2.GE.25.AND.LB2.LE.28)) then
               GOTO 505
clin-9/2008 Deuteron+Baryon or antiDeuteron+antiBaryon elastic collisions:
            elseif(((ILB1.GE.1.AND.ILB1.LE.2)
     1              .or.(ILB1.GE.6.AND.ILB1.LE.13)
     2              .or.(ILB2.GE.1.AND.ILB2.LE.2)
     3              .or.(ILB2.GE.6.AND.ILB2.LE.13))
     4              .and.(lb1*lb2).gt.0) then
               GOTO 506
            else
               GOTO 400
            endif
         ENDIF
c
* K+ + (N,N*,D)-bar --> L/S-bar + pi
          if( ((lb1.eq.23.or.lb1.eq.30).and.
     &         (lb2.eq.-1.or.lb2.eq.-2.or.(lb2.ge.-13.and.lb2.le.-6))) 
     &         .OR.((lb2.eq.23.or.lb2.eq.30).and.
     &         (lb1.eq.-1.or.lb1.eq.-2.or.(lb1.ge.-13.and.lb1.le.-6))) )
     &         then
             bmass=0.938
             if(srt.le.(bmass+aka)) then
                pkaon=0.
             else
                pkaon=sqrt(((srt**2-(aka**2+bmass**2))
     1               /2./bmass)**2-aka**2)
             endif
clin-10/31/02 cross sections are isospin-averaged, same as those in newka
c     for K- + (N,N*,D) --> L/S + pi:
             sigela = 0.5 * (AKPEL(PKAON) + AKNEL(PKAON))
             SIGSGM = 1.5 * AKPSGM(PKAON) + AKNSGM(PKAON)
             SIG = sigela + SIGSGM + AKPLAM(PKAON)
             if(sig.gt.1.e-7) then
c     ! K+ + N-bar reactions
                icase=3
                brel=sigela/sig
                brsgm=sigsgm/sig
                brsig = sig
                nchrg = 1
                go to 3555
             endif
             go to 400
          endif
c
c
c  meson + hyperon-bar -> K+ + N-bar
          if(((lb1.ge.-17.and.lb1.le.-14).and.(lb2.ge.3.and.lb2.le.5)) 
     &         .OR.((lb2.ge.-17.and.lb2.le.-14)
     &         .and.(lb1.ge.3.and.lb1.le.5)))then
             nchrg=-100
 
C*       first classify the reactions due to total charge.
             if((lb1.eq.-15.and.(lb2.eq.5.or.lb2.eq.27)).OR.
     &            (lb2.eq.-15.and.(lb1.eq.5.or.lb1.eq.27))) then
                nchrg=-2
c     ! D-(bar)
                bmass=1.232
                go to 110
             endif
             if( (lb1.eq.-15.and.(lb2.eq.0.or.lb2.eq.4.or.lb2.eq.26.or.
     &            lb2.eq.28)).OR.(lb2.eq.-15.and.(lb1.eq.0.or.
     &            lb1.eq.4.or.lb1.eq.26.or.lb1.eq.28)).OR.
     &   ((lb1.eq.-14.or.lb1.eq.-16).and.(lb2.eq.5.or.lb2.eq.27)).OR.
     &   ((lb2.eq.-14.or.lb2.eq.-16).and.(lb1.eq.5.or.lb1.eq.27)) )then
                nchrg=-1
c     ! n-bar
                bmass=0.938
                go to 110
             endif
             if(  (lb1.eq.-15.and.(lb2.eq.3.or.lb2.eq.25)).OR.
     &            (lb2.eq.-15.and.(lb1.eq.3.or.lb1.eq.25)).OR.
     &            (lb1.eq.-17.and.(lb2.eq.5.or.lb2.eq.27)).OR.
     &            (lb2.eq.-17.and.(lb1.eq.5.or.lb1.eq.27)).OR.
     &            ((lb1.eq.-14.or.lb1.eq.-16).and.(lb2.eq.0.or.lb2.eq.4
     &            .or.lb2.eq.26.or.lb2.eq.28)).OR.
     &            ((lb2.eq.-14.or.lb2.eq.-16).and.(lb1.eq.0.or.lb1.eq.4
     &            .or.lb1.eq.26.or.lb1.eq.28)) )then
               nchrg=0
c     ! p-bar
                bmass=0.938
                go to 110
             endif
             if( (lb1.eq.-17.and.(lb2.eq.0.or.lb2.eq.4.or.lb2.eq.26.or.
     &            lb2.eq.28)).OR.(lb2.eq.-17.and.(lb1.eq.0.or.
     &            lb1.eq.4.or.lb1.eq.26.or.lb1.eq.28)).OR.
     &  ((lb1.eq.-14.or.lb1.eq.-16).and.(lb2.eq.3.or.lb2.eq.25)).OR.
     &  ((lb2.eq.-14.or.lb2.eq.-16).and.(lb1.eq.3.or.lb1.eq.25)))then
               nchrg=1
c     ! D++(bar)
                bmass=1.232
             endif
c
c 110     if(nchrg.ne.-100.and.srt.ge.(aka+bmass))then !! for elastic
 110         sig = 0.
c !! for elastic
         if(nchrg.ne.-100.and.srt.ge.(aka+bmass))then
cc110        if(nchrg.eq.-100.or.srt.lt.(aka+bmass)) go to 400
c             ! PI + La(Si)-bar => K+ + N-bar reactions
            icase=4
cc       pkaon=sqrt(((srt**2-(aka**2+bmass**2))/2./bmass)**2-aka**2)
            pkaon=sqrt(((srt**2-(aka**2+0.938**2))/2./0.938)**2-aka**2)
c ! lambda-bar + Pi
            if(lb1.eq.-14.or.lb2.eq.-14) then
               if(nchrg.ge.0) sigma0=akPlam(pkaon)
               if(nchrg.lt.0) sigma0=akNlam(pkaon)
c                ! sigma-bar + pi
            else
c !K-p or K-D++
               if(nchrg.ge.0) sigma0=akPsgm(pkaon)
c !K-n or K-D-
               if(nchrg.lt.0) sigma0=akNsgm(pkaon)
               SIGMA0 = 1.5 * AKPSGM(PKAON) + AKNSGM(PKAON)
            endif
            sig=(srt**2-(aka+bmass)**2)*(srt**2-(aka-bmass)**2)/
     &           (srt**2-(em1+em2)**2)/(srt**2-(em1-em2)**2)*sigma0
c ! K0barD++, K-D-
            if(nchrg.eq.-2.or.nchrg.eq.2) sig=2.*sig
C*     the factor 2 comes from spin of delta, which is 3/2
C*     detailed balance. copy from Page 423 of N.P. A614 1997
            IF (LB1 .EQ. -14 .OR. LB2 .EQ. -14) THEN
               SIG = 4.0 / 3.0 * SIG
            ELSE IF (NCHRG .EQ. -2 .OR. NCHRG .EQ. 2) THEN
               SIG = 8.0 / 9.0 * SIG
            ELSE
               SIG = 4.0 / 9.0 * SIG
            END IF
cc        brel=0.
cc        brsgm=0.
cc        brsig = sig
cc          if(sig.lt.1.e-7) go to 400
*-
         endif
c                ! PI + La(Si)-bar => elastic included
         icase=4
         sigela = 10.
         sig = sig + sigela
         brel= sigela/sig
         brsgm=0.
         brsig = sig
*-
         go to 3555
      endif
      
** MULTISTRANGE PARTICLE (Cas,Omega -bar) PRODUCTION - (NON)PERTURBATIVE

* K-/K*0bar + La/Si --> cascade + pi/eta
      if( ((lb1.eq.21.or.lb1.eq.-30).and.(lb2.ge.14.and.lb2.le.17)).OR.
     &  ((lb2.eq.21.or.lb2.eq.-30).and.(lb1.ge.14.and.lb1.le.17)) )then
          kp = 0
          go to 3455
        endif
c K+/K*0 + La/Si(bar) --> cascade-bar + pi/eta
      if( ((lb1.eq.23.or.lb1.eq.30).and.(lb2.le.-14.and.lb2.ge.-17)).OR.
     &  ((lb2.eq.23.or.lb2.eq.30).and.(lb1.le.-14.and.lb1.ge.-17)) )then
          kp = 1
          go to 3455
        endif
* K-/K*0bar + cascade --> omega + pi
       if( ((lb1.eq.21.or.lb1.eq.-30).and.(lb2.eq.40.or.lb2.eq.41)).OR.
     & ((lb2.eq.21.or.lb2.eq.-30).and.(lb1.eq.40.or.lb1.eq.41)) )then
          kp = 0
          go to 3455
        endif
* K+/K*0 + cascade-bar --> omega-bar + pi
       if( ((lb1.eq.23.or.lb1.eq.30).and.(lb2.eq.-40.or.lb2.eq.-41)).OR.
     &  ((lb2.eq.23.or.lb2.eq.30).and.(lb1.eq.-40.or.lb1.eq.-41)) )then
          kp = 1
          go to 3455
        endif
* Omega + Omega --> Di-Omega + photon(eta)
cc        if( lb1.eq.45.and.lb2.eq.45 ) go to 3455

c annhilation of cascade(bar), omega(bar)
         kp = 3
* K- + L/S <-- cascade(bar) + pi/eta
       if( (((lb1.ge.3.and.lb1.le.5).or.lb1.eq.0) 
     &       .and.(iabs(lb2).eq.40.or.iabs(lb2).eq.41))
     & .OR. (((lb2.ge.3.and.lb2.le.5).or.lb2.eq.0) 
     &       .and.(iabs(lb1).eq.40.or.iabs(lb1).eq.41)) )go to 3455
* K- + cascade(bar) <-- omega(bar) + pi
*         if(  (lb1.eq.0.and.iabs(lb2).eq.45)
*    &       .OR. (lb2.eq.0.and.iabs(lb1).eq.45) )go to 3455
        if( ((lb1.ge.3.and.lb1.le.5).and.iabs(lb2).eq.45)
     &  .OR.((lb2.ge.3.and.lb2.le.5).and.iabs(lb1).eq.45) )go to 3455
c

***  MULTISTRANGE PARTICLE PRODUCTION  (END)

c* K+ + La(Si) --> Meson + B
        IF (LB1.EQ.23 .AND. (LB2.GE.14.AND.LB2.LE.17)) GOTO 5699
        IF (LB2.EQ.23 .AND. (LB1.GE.14.AND.LB1.LE.17)) GOTO 5699
c* K- + La(Si)-bar --> Meson + B-bar
       IF (LB1.EQ.21 .AND. (LB2.GE.-17.AND.LB2.LE.-14)) GOTO 5699
       IF (LB2.EQ.21 .AND. (LB1.GE.-17.AND.LB1.LE.-14)) GOTO 5699

c La/Si-bar + B --> pi + K+
       IF( (((LB1.eq.1.or.LB1.eq.2).or.(LB1.ge.6.and.LB1.le.13))
     &       .AND.(LB2.GE.-17.AND.LB2.LE.-14)) .OR.
     &     (((LB2.eq.1.or.LB2.eq.2).or.(LB2.ge.6.and.LB2.le.13))
     &      .AND.(LB1.GE.-17.AND.LB1.LE.-14)) )go to 5999
c La/Si + B-bar --> pi + K-
       IF( (((LB1.eq.-1.or.LB1.eq.-2).or.(LB1.le.-6.and.LB1.ge.-13))
     &       .AND.(LB2.GE.14.AND.LB2.LE.17)) .OR.
     &     (((LB2.eq.-1.or.LB2.eq.-2).or.(LB2.le.-6.and.LB2.ge.-13))
     &       .AND.(LB1.GE.14.AND.LB1.LE.17)) )go to 5999 
*
*
* K(K*) + Kbar(K*bar) --> phi + pi(rho,omega), M + M (M=pi,rho,omega,eta)
       if(lb1.eq.21.and.lb2.eq.23) go to 8699
       if(lb2.eq.21.and.lb1.eq.23) go to 8699
       if(lb1.eq.30.and.lb2.eq.21) go to 8699
       if(lb2.eq.30.and.lb1.eq.21) go to 8699
       if(lb1.eq.-30.and.lb2.eq.23) go to 8699
       if(lb2.eq.-30.and.lb1.eq.23) go to 8699
       if(lb1.eq.-30.and.lb2.eq.30) go to 8699
       if(lb2.eq.-30.and.lb1.eq.30) go to 8699
c* (K,K*)-bar + rho(omega) --> phi +(K,K*)-bar, piK and elastic
       IF( ((lb1.eq.23.or.lb1.eq.21.or.iabs(lb1).eq.30) .and.
     &      (lb2.ge.25.and.lb2.le.28)) .OR.
     &     ((lb2.eq.23.or.lb2.eq.21.or.iabs(lb2).eq.30) .and.
     &      (lb1.ge.25.and.lb1.le.28)) ) go to 8799
c
c* K*(-bar) + pi --> phi + (K,K*)-bar
       IF( (iabs(lb1).eq.30.and.(lb2.ge.3.and.lb2.le.5)) .OR.
     &     (iabs(lb2).eq.30.and.(lb1.ge.3.and.lb1.le.5)) )go to 8799
*
c
c* phi + N --> pi+N(D),  rho+N(D),  K+ +La
c* phi + D --> pi+N(D),  rho+N(D)
       IF( (lb1.eq.29 .and.(lb2.eq.1.or.lb2.eq.2.or.
     &       (lb2.ge.6.and.lb2.le.9))) .OR.
     &     (lb2.eq.29 .and.(lb1.eq.1.or.lb1.eq.2.or.
     &       (lb1.ge.6.and.lb1.le.9))) )go to 7222
c
c* phi + (pi,rho,ome,K,K*-bar) --> K+K, K+K*, K*+K*, (pi,rho,omega)+(K,K*-bar)
       IF( (lb1.eq.29 .and.((lb2.ge.3.and.lb2.le.5).or.
     &      (lb2.ge.21.and.lb2.le.28).or.iabs(lb2).eq.30)) .OR.
     &     (lb2.eq.29 .and.((lb1.ge.3.and.lb1.le.5).or.
     &      (lb1.ge.21.and.lb1.le.28).or.iabs(lb1).eq.30)) )THEN
             go to 7444
      endif
*
c
* La/Si, Cas, Om (bar)-(rho,omega,phi) elastic colln
* pion vs. La, Ca, Omega-(bar) elastic coll. treated in resp. subroutines
      if( ((iabs(lb1).ge.14.and.iabs(lb1).le.17).or.iabs(lb1).ge.40)
     &    .and.((lb2.ge.25.and.lb2.le.29).or.lb2.eq.0) )go to 888
      if( ((iabs(lb2).ge.14.and.iabs(lb2).le.17).or.iabs(lb2).ge.40)
     &    .and.((lb1.ge.25.and.lb1.le.29).or.lb1.eq.0) )go to 888
c
c K+/K* (N,R)  OR   K-/K*- (N,R)-bar  elastic scatt
        if( ((lb1.eq.23.or.lb1.eq.30).and.(lb2.eq.1.or.lb2.eq.2.or.
     &         (lb2.ge.6.and.lb2.le.13))) .OR.
     &      ((lb2.eq.23.or.lb2.eq.30).and.(lb1.eq.1.or.lb1.eq.2.or.
     &         (lb1.ge.6.and.lb1.le.13))) ) go to 888
        if( ((lb1.eq.21.or.lb1.eq.-30).and.(lb2.eq.-1.or.lb2.eq.-2.or.
     &       (lb2.ge.-13.and.lb2.le.-6))) .OR. 
     &      ((lb2.eq.21.or.lb2.eq.-30).and.(lb1.eq.-1.or.lb1.eq.-2.or.
     &       (lb1.ge.-13.and.lb1.le.-6))) ) go to 888
c
* L/S-baryon elastic collision 
       If( ((lb1.ge.14.and.lb1.le.17).and.(lb2.ge.6.and.lb2.le.13))
     & .OR.((lb2.ge.14.and.lb2.le.17).and.(lb1.ge.6.and.lb1.le.13)) )
     &   go to 7799
       If(((lb1.le.-14.and.lb1.ge.-17).and.(lb2.le.-6.and.lb2.ge.-13))
     &.OR.((lb2.le.-14.and.lb2.ge.-17).and.(lb1.le.-6.and.lb1.ge.-13)))
     &   go to 7799
c
c skip other collns with perturbative particles or hyperon-bar
       if( iabs(lb1).ge.40 .or. iabs(lb2).ge.40
     &    .or. (lb1.le.-14.and.lb1.ge.-17) 
     &    .or. (lb2.le.-14.and.lb2.ge.-17) )go to 400
c
c
* anti-baryon on baryon resonaces 
        if((lb1.eq.-1.or.lb1.eq.-2.or.(lb1.ge.-13.and.lb1.le.-6))
     1 .and.(lb2.eq.1.or.lb2.eq.2.or.(lb2.ge.6.and.lb2.le.13))) then
            GOTO 2799
       else if((lb2.eq.-1.or.lb2.eq.-2.or.(lb2.ge.-13.and.lb2.le.-6))
     1 .and.(lb1.eq.1.or.lb1.eq.2.or.(lb1.ge.6.and.lb1.le.13))) then
            GOTO 2799
         END IF
c
clin-10/25/02 get rid of argument usage mismatch in newka():
         inewka=irun
c        call newka(icase,irun,iseed,dt,nt,
clin-5/01/03 set iblock value in art1f.f, necessary for resonance studies:
c        call newka(icase,inewka,iseed,dt,nt,
c     &                  ictrl,i1,i2,srt,pcx,pcy,pcz)
        call newka(icase,inewka,iseed,dt,nt,
     &                  ictrl,i1,i2,srt,pcx,pcy,pcz,iblock)

clin-10/25/02-end
        IF (ICTRL .EQ. 1) GOTO 400
c
* SEPARATE NUCLEON+NUCLEON( BARYON RESONANCE+ BARYON RESONANCE ELASTIC
* COLLISION), BARYON RESONANCE+NUCLEON AND BARYON-PION
* COLLISIONS INTO THREE PARTS TO CHECK IF THEY ARE GOING TO SCATTER,
* WE only allow L/S to COLLIDE elastically with a nucleon and meson
       if((iabs(lb1).ge.14.and.iabs(lb1).le.17).
     &  or.(iabs(lb2).ge.14.and.iabs(lb2).le.17))go to 400
* IF PION+PION COLLISIONS GO TO 777
* if pion+eta, eta+eta to create kaons go to 777 
       IF((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.3.and.lb2.le.5))GO TO 777
       if(lb1.eq.0.and.(lb2.ge.3.and.lb2.le.5)) go to 777
       if(lb2.eq.0.and.(lb1.ge.3.and.lb1.le.5)) go to 777
       if(lb1.eq.0.and.lb2.eq.0)go to 777
* we assume that rho and omega behave the same way as pions in 
* kaon production
* (1) rho(omega)+rho(omega)
       if( (lb1.ge.25.and.lb1.le.28).and.
     &     (lb2.ge.25.and.lb2.le.28) )goto 777
* (2) rho(omega)+pion
      If((lb1.ge.25.and.lb1.le.28).and.(lb2.ge.3.and.lb2.le.5))go to 777
      If((lb2.ge.25.and.lb2.le.28).and.(lb1.ge.3.and.lb1.le.5))go to 777
* (3) rho(omega)+eta
       if((lb1.ge.25.and.lb1.le.28).and.lb2.eq.0)go to 777
       if((lb2.ge.25.and.lb2.le.28).and.lb1.eq.0)go to 777
c
* if kaon+pion collisions go to 889
       if((lb1.eq.23.or.lb1.eq.21).and.(lb2.ge.3.and.lb2.le.5))go to 889
       if((lb2.eq.23.or.lb2.eq.21).and.(lb1.ge.3.and.lb1.le.5))go to 889
c
clin-2/06/03 skip all other (K K* Kbar K*bar) channels:
* SKIP all other K and K* RESCATTERINGS
        If(iabs(lb1).eq.30.or.iabs(lb2).eq.30) go to 400
        If(lb1.eq.21.or.lb2.eq.21) go to 400
        If(lb1.eq.23.or.lb2.eq.23) go to 400
c
* IF PION+baryon COLLISION GO TO 3
           IF( (LB1.ge.3.and.LB1.le.5) .and. 
     &         (iabs(LB2).eq.1.or.iabs(LB2).eq.2.or.
     &          (iabs(LB2).ge.6.and.iabs(LB2).le.13)) )GO TO 3
           IF( (LB2.ge.3.and.LB2.le.5) .and. 
     &         (iabs(LB1).eq.1.or.iabs(LB1).eq.2.or.
     &          (iabs(LB1).ge.6.and.iabs(LB1).le.13)) )GO TO 3
c
* IF rho(omega)+NUCLEON (baryon resonance) COLLISION GO TO 33
           IF( (LB1.ge.25.and.LB1.le.28) .and. 
     &         (iabs(LB2).eq.1.or.iabs(LB2).eq.2.or.
     &          (iabs(LB2).ge.6.and.iabs(LB2).le.13)) )GO TO 33
           IF( (LB2.ge.25.and.LB2.le.28) .and. 
     &         (iabs(LB1).eq.1.or.iabs(LB1).eq.2.or.
     &          (iabs(LB1).ge.6.and.iabs(LB1).le.13)) )GO TO 33
c
* IF ETA+NUCLEON (baryon resonance) COLLISIONS GO TO 547
           IF( LB1.eq.0 .and. 
     &         (iabs(LB2).eq.1.or.iabs(LB2).eq.2.or.
     &          (iabs(LB2).ge.6.and.iabs(LB2).le.13)) )GO TO 547
           IF( LB2.eq.0 .and. 
     &         (iabs(LB1).eq.1.or.iabs(LB1).eq.2.or.
     &          (iabs(LB1).ge.6.and.iabs(LB1).le.13)) )GO TO 547
c
* IF NUCLEON+BARYON RESONANCE COLLISION GO TO 44
            IF((LB1.eq.1.or.lb1.eq.2).
     &        AND.(LB2.GT.5.and.lb2.le.13))GOTO 44
            IF((LB2.eq.1.or.lb2.eq.2).
     &        AND.(LB1.GT.5.and.lb1.le.13))GOTO 44
            IF((LB1.eq.-1.or.lb1.eq.-2).
     &        AND.(LB2.LT.-5.and.lb2.ge.-13))GOTO 44
            IF((LB2.eq.-1.or.lb2.eq.-2).
     &        AND.(LB1.LT.-5.and.lb1.ge.-13))GOTO 44
c
* IF NUCLEON+NUCLEON COLLISION GO TO 4
       IF((LB1.eq.1.or.lb1.eq.2).AND.(LB2.eq.1.or.lb2.eq.2))GOTO 4
       IF((LB1.eq.-1.or.lb1.eq.-2).AND.(LB2.eq.-1.or.lb2.eq.-2))GOTO 4
c
* IF BARYON RESONANCE+BARYON RESONANCE COLLISION GO TO 444
            IF((LB1.GT.5.and.lb1.le.13).AND.
     &         (LB2.GT.5.and.lb2.le.13)) GOTO 444
            IF((LB1.LT.-5.and.lb1.ge.-13).AND.
     &         (LB2.LT.-5.and.lb2.ge.-13)) GOTO 444
c
* if L/S+L/S or L/s+nucleon go to 400
* otherwise, develop a model for their collisions
       if((lb1.lt.3).and.(lb2.ge.14.and.lb2.le.17))goto 400
       if((lb2.lt.3).and.(lb1.ge.14.and.lb1.le.17))goto 400
       if((lb1.ge.14.and.lb1.le.17).and.
     &  (lb2.ge.14.and.lb2.le.17))goto 400
c
* otherwise, go out of the loop
              go to 400
*
*
547           IF(LB1*LB2.EQ.0)THEN
* (1) FOR ETA+NUCLEON SYSTEM, we allow both elastic collision, 
*     i.e. N*(1535) formation and kaon production
*     the total kaon production cross section is
*     ASSUMED to be THE SAME AS PION+NUCLEON COLLISIONS
* (2) for eta+baryon resonance we only allow kaon production
           ece=(em1+em2+0.02)**2
           xkaon0=0.
           if(srt.ge.1.63.AND.SRT.LE.1.7)xkaon0=pnlka(srt)
           IF(SRT.GT.1.7)XKAON0=PNLKA(SRT)+pnska(srt)
cbz3/7/99 neutralk
            XKAON0 = 2.0 * XKAON0
cbz3/7/99 neutralk end

* Here we negelect eta+n inelastic collisions other than the 
* kaon production, therefore the total inelastic cross section
* xkaon equals to the xkaon0 (kaon production cross section)
           xkaon=xkaon0
* note here the xkaon is in unit of fm**2
            XETA=XN1535(I1,I2,0)
        If((iabs(LB(I1)).ge.6.and.iabs(LB(I1)).le.13).or.
     &     (iabs(LB(I2)).ge.6.and.iabs(LB(I2)).le.13)) xeta=0.      
            IF((XETA+xkaon).LE.1.e-06)GO TO 400
            DSE=SQRT((XETA+XKAON)/PI)
           DELTRE=DSE+0.1
        px1cm=pcx
        py1cm=pcy
        pz1cm=pcz
* CHECK IF N*(1535) resonance CAN BE FORMED
         CALL DISTCE(I1,I2,DELTRE,DSE,DT,ECE,SRT,IC,
     1   PCX,PCY,PCZ)
         IF(IC.EQ.-1) GO TO 400
         ekaon(4,iss)=ekaon(4,iss)+1
        IF(XKAON0/(XKAON+XETA).GT.RANART(NSEED))then
* kaon production, USE CREN TO CALCULATE THE MOMENTUM OF L/S K+
        CALL CREN(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)
* kaon production
       IF(IBLOCK.EQ.7) then
          LPN=LPN+1
       elseIF(IBLOCK.EQ.-7) then
       endif
c
       em1=e(i1)
       em2=e(i2)
       GO TO 440
       endif
* N*(1535) FORMATION
        resona=1.
         GO TO 98
         ENDIF
*IF PION+NUCLEON (baryon resonance) COLLISION THEN
3           CONTINUE
           px1cm=pcx
           py1cm=pcy
           pz1cm=pcz
* the total kaon production cross section for pion+baryon (resonance) is
* assumed to be the same as in pion+nucleon
           xkaon0=0.
           if(srt.ge.1.63.AND.SRT.LE.1.7)xkaon0=pnlka(srt)
           IF(SRT.GT.1.7)XKAON0=PNLKA(SRT)+pnska(srt)
            XKAON0 = 2.0 * XKAON0
c
c sp11/21/01  phi production: pi +N(D) -> phi + N(D)
         Xphi = 0.
       if( ( ((lb1.ge.1.and.lb1.le.2).or.
     &        (lb1.ge.6.and.lb1.le.9))
     &   .OR.((lb2.ge.1.and.lb2.le.2).or.
     &        (lb2.ge.6.and.lb2.le.9)) )
     &       .AND. srt.gt.1.958)
     &        call pibphi(srt,lb1,lb2,em1,em2,Xphi,xphin)
c !! in fm^2 above

* if a pion collide with a baryon resonance, 
* we only allow kaon production AND the reabsorption 
* processes: Delta+pion-->N+pion, N*+pion-->N+pion
* Later put in pion+baryon resonance elastic
* cross through forming higher resonances implicitly.
c          If(em1.gt.1.or.em2.gt.1.)go to 31
         If((iabs(LB(I1)).ge.6.and.iabs(LB(I1)).le.13).or.
     &      (iabs(LB(I2)).ge.6.and.iabs(LB(I2)).le.13)) go to 31
* For pion+nucleon collisions: 
* using the experimental pion+nucleon inelastic cross section, we assume it
* is exhausted by the Delta+pion, Delta+rho and Delta+omega production 
* and kaon production. In the following we first check whether 
* inelastic pion+n collision can happen or not, then determine in 
* crpn whether it is through pion production or through kaon production
* note that the xkaon0 is the kaon production cross section
* Note in particular that: 
* xkaon in the following is the total pion+nucleon inelastic cross section
* note here the xkaon is in unit of fm**2, xnpi is also in unit of fm**2
* FOR PION+NUCLEON SYSTEM, THE MINIMUM S IS 1.2056 the minimum srt for 
* elastic scattering, and it is 1.60 for pion production, 1.63 for LAMBDA+kaon 
* production and 1.7 FOR SIGMA+KAON
* (EC = PION MASS+NUCLEON MASS+20MEV)**2
            EC=(em1+em2+0.02)**2
           xkaon=0.
           if(srt.gt.1.23)xkaon=(pionpp(srt)+PIPP1(SRT))/2.
* pion+nucleon elastic cross section is divided into two parts:
* (1) forming D(1232)+N*(1440) +N*(1535)
* (2) cross sections forming higher resonances are calculated as
*     the difference between the total elastic and (1), this part is 
*     treated as direct process since we do not explicitLY include
*     higher resonances.
* the following is the resonance formation cross sections.
*1. PION(+)+PROTON-->DELTA++,PION(-)+NEUTRON-->DELTA(-)
           IF( (LB1*LB2.EQ.5.OR.((LB1*LB2.EQ.6).AND.
     &         (LB1.EQ.3.OR.LB2.EQ.3)))
     &    .OR. (LB1*LB2.EQ.-3.OR.((LB1*LB2.EQ.-10).AND.
     &         (LB1.EQ.5.OR.LB2.EQ.5))) )then    
              XMAX=190.
              xmaxn=0
              xmaxn1=0
              xdirct=dirct1(srt)
               go to 678
           endif
*2. PION(-)+PROTON-->DELTA0,PION(+)+NEUTRON-->DELTA+ 
*   or N*(+)(1440) or N*(+)(1535)
* note the factor 2/3 is from the isospin consideration and
* the factor 0.6 or 0.5 is the branching ratio for the resonance to decay
* into pion+nucleon
            IF( (LB1*LB2.EQ.3.OR.((LB1*LB2.EQ.10).AND.
     &          (LB1.EQ.5.OR.LB2.EQ.5)))
     &     .OR. (LB1*LB2.EQ.-5.OR.((LB1*LB2.EQ.-6).AND.
     &          (LB1.EQ.3.OR.LB2.EQ.3))) )then      
              XMAX=27.
              xmaxn=2./3.*25.*0.6
               xmaxn1=2./3.*40.*0.5
              xdirct=dirct2(srt)
               go to 678
              endif
*3. PION0+PROTON-->DELTA+,PION0+NEUTRON-->DELTA0, or N*(0)(1440) or N*(0)(1535)
            IF((LB1.EQ.4.OR.LB2.EQ.4).AND.
     &         (iabs(LB1*LB2).EQ.4.OR.iabs(LB1*LB2).EQ.8))then
              XMAX=50.
              xmaxn=1./3.*25*0.6
              xmaxn1=1/3.*40.*0.5
              xdirct=dirct3(srt)
                go to 678
              endif
678           xnpin1=0
           xnpin=0
            XNPID=XNPI(I1,I2,1,XMAX)
           if(xmaxn1.ne.0)xnpin1=XNPI(i1,i2,2,XMAXN1)
            if(xmaxn.ne.0)XNPIN=XNPI(I1,I2,0,XMAXN)
* the following 
           xres=xnpid+xnpin+xnpin1
           xnelas=xres+xdirct 
           icheck=1
           go to 34
* For pion + baryon resonance the reabsorption 
* cross section is calculated from the detailed balance
* using reab(i1,i2,srt,ictrl), ictrl=1, 2 and 3
* for pion, rho and omega + baryon resonance
31           ec=(em1+em2+0.02)**2
           xreab=reab(i1,i2,srt,1)

clin-12/02/00 to satisfy detailed balance, forbid N* absorptions:
          if((iabs(lb1).ge.10.and.iabs(lb1).le.13)
     1         .or.(iabs(lb2).ge.10.and.iabs(lb2).le.13)) XREAB = 0.

           xkaon=xkaon0+xreab
* a constant of 10 mb IS USED FOR PION + N* RESONANCE, 
        IF((iabs(LB1).GT.9.AND.iabs(LB1).LE.13) .OR.
     &      (iabs(LB2).GT.9.AND.iabs(LB2).LE.13))THEN
           Xnelas=1.0
        ELSE
           XNELAS=DPION(EM1,EM2,LB1,LB2,SRT)
        ENDIF
           icheck=2
34          IF((Xnelas+xkaon+Xphi).LE.0.000001)GO TO 400
            DS=SQRT((Xnelas+xkaon+Xphi)/PI)
csp09/20/01
c           totcr = xnelas+xkaon
c           if(srt .gt. 3.5)totcr = max1(totcr,3.)
c           DS=SQRT(totcr/PI)
csp09/20/01 end
            
           deltar=ds+0.1
         CALL DISTCE(I1,I2,DELTAR,DS,DT,EC,SRT,IC,
     1   PCX,PCY,PCZ)
         IF(IC.EQ.-1) GO TO 400
       ekaon(4,iss)=ekaon(4,iss)+1
c***
* check what kind of collision has happened
* (1) pion+baryon resonance
* if direct elastic process
        if(icheck.eq.2)then
c  !!sp11/21/01
      if(xnelas/(xnelas+xkaon+Xphi).ge.RANART(NSEED))then
c               call Crdir(PX1CM,PY1CM,PZ1CM,SRT,I1,I2)
               call Crdir(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)
              go to 440
              else
* for inelastic process, go to 96 to check
* kaon production and pion reabsorption : pion+D(N*)-->pion+N
               go to 96
                endif
              endif
*(2) pion+n
* CHECK IF inELASTIC COLLISION IS POSSIBLE FOR PION+N COLLISIONS
clin-8/17/00 typo corrected, many other occurences:
c        IF(XKAON/(XKAON+Xnelas).GT.RANART(NSEED))GO TO 95
       IF((XKAON+Xphi)/(XKAON+Xphi+Xnelas).GT.RANART(NSEED))GO TO 95

* direct process
        if(xdirct/xnelas.ge.RANART(NSEED))then
c               call Crdir(PX1CM,PY1CM,PZ1CM,SRT,I1,I2)
               call Crdir(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)
              go to 440
              endif
* now resonance formation or direct process (higher resonances)
           IF( (LB1*LB2.EQ.5.OR.((LB1*LB2.EQ.6).AND.
     &         (LB1.EQ.3.OR.LB2.EQ.3)))
     &    .OR. (LB1*LB2.EQ.-3.OR.((LB1*LB2.EQ.-10).AND.
     &         (LB1.EQ.5.OR.LB2.EQ.5))) )then    
c
* ONLY DELTA RESONANCE IS POSSIBLE, go to 99
        GO TO 99
       else
* NOW BOTH DELTA AND N* RESORANCE ARE POSSIBLE
* DETERMINE THE RESORANT STATE BY USING THE MONTRE CARLO METHOD
            XX=(XNPIN+xnpin1)/xres
            IF(RANART(NSEED).LT.XX)THEN
* N* RESONANCE IS SELECTED
* decide N*(1440) or N*(1535) formation
        xx0=xnpin/(xnpin+xnpin1)
        if(RANART(NSEED).lt.xx0)then
         RESONA=0.
* N*(1440) formation
         GO TO 97
        else
* N*(1535) formation
        resona=1.
         GO TO 98
        endif
         ELSE
* DELTA RESONANCE IS SELECTED
         GO TO 99
         ENDIF
         ENDIF
97       CONTINUE
            IF(RESONA.EQ.0.)THEN
*N*(1440) IS PRODUCED,WE DETERMINE THE CHARGE STATE OF THE PRODUCED N*
            I=I1
            IF(EM1.LT.0.6)I=I2
* (0.1) n+pion(+)-->N*(+)
           IF( (LB1*LB2.EQ.10.AND.(LB1.EQ.5.OR.LB2.EQ.5))
     &      .OR.(LB1*LB2.EQ.-6.AND.(LB1.EQ.3.OR.LB2.EQ.3)) )THEN
            LB(I)=11
           go to 303
            ENDIF
* (0.2) p+pion(0)-->N*(+)
c            IF(LB(I1)*LB(I2).EQ.4.AND.(LB(I1).EQ.1.OR.LB(I2).EQ.1))THEN
            IF(iabs(LB(I1)*LB(I2)).EQ.4.AND.
     &         (LB(I1).EQ.4.OR.LB(I2).EQ.4))THEN    
            LB(I)=11
           go to 303
            ENDIF
* (0.3) n+pion(0)-->N*(0)
c            IF(LB(I1)*LB(I2).EQ.8.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
            IF(iabs(LB(I1)*LB(I2)).EQ.8.AND.
     &        (LB(I1).EQ.4.OR.LB(I2).EQ.4))THEN    
            LB(I)=10
           go to 303
            ENDIF
* (0.4) p+pion(-)-->N*(0)
c            IF(LB(I1)*LB(I2).EQ.3)THEN
            IF( (LB(I1)*LB(I2).EQ.3)
     &      .OR.(LB(I1)*LB(I2).EQ.-5) )THEN
            LB(I)=10
            ENDIF
303         CALL DRESON(I1,I2)
            if(LB1.lt.0.or.LB2.lt.0) LB(I)=-LB(I)
            lres=lres+1
            GO TO 101
*COM: GO TO 101 TO CHANGE THE PHASE SPACE DENSITY OF THE NUCLEON
            ENDIF
98          IF(RESONA.EQ.1.)THEN
*N*(1535) IS PRODUCED, WE DETERMINE THE CHARGE STATE OF THE PRODUCED N*
            I=I1
            IF(EM1.LT.0.6)I=I2
* note: this condition applies to both eta and pion
* (0.1) n+pion(+)-->N*(+)
c            IF(LB1*LB2.EQ.10.AND.(LB1.EQ.2.OR.LB2.EQ.2))THEN
            IF( (LB1*LB2.EQ.10.AND.(LB1.EQ.5.OR.LB2.EQ.5))
     &      .OR.(LB1*LB2.EQ.-6.AND.(LB1.EQ.3.OR.LB2.EQ.3)) )THEN
            LB(I)=13
           go to 304
            ENDIF
* (0.2) p+pion(0)-->N*(+)
c            IF(LB(I1)*LB(I2).EQ.4.AND.(LB(I1).EQ.1.OR.LB(I2).EQ.1))THEN
            IF(iabs(LB(I1)*LB(I2)).EQ.4.AND.
     &           (LB(I1).EQ.4.OR.LB(I2).EQ.4))THEN 
            LB(I)=13
           go to 304
            ENDIF
* (0.3) n+pion(0)-->N*(0)
c            IF(LB(I1)*LB(I2).EQ.8.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
            IF(iabs(LB(I1)*LB(I2)).EQ.8.AND.
     &           (LB(I1).EQ.4.OR.LB(I2).EQ.4))THEN      
            LB(I)=12
           go to 304
            ENDIF
* (0.4) p+pion(-)-->N*(0)
c            IF(LB(I1)*LB(I2).EQ.3)THEN
            IF( (LB(I1)*LB(I2).EQ.3)
     &      .OR.(LB(I1)*LB(I2).EQ.-5) )THEN
            LB(I)=12
           go to 304
           endif
* (0.5) p+eta-->N*(+)(1535),n+eta-->N*(0)(1535)
           if(lb(i1)*lb(i2).eq.0)then
c            if((lb(i1).eq.1).or.(lb(i2).eq.1))then
            if(iabs(lb(i1)).eq.1.or.iabs(lb(i2)).eq.1)then
           LB(I)=13
           go to 304
           ELSE
           LB(I)=12
           ENDIF
           endif
304         CALL DRESON(I1,I2)
            if(LB1.lt.0.or.LB2.lt.0) LB(I)=-LB(I) 
            lres=lres+1
            GO TO 101
*COM: GO TO 101 TO CHANGE THE PHASE SPACE DENSITY OF THE NUCLEON
            ENDIF
*DELTA IS PRODUCED,IN THE FOLLOWING WE DETERMINE THE
*CHARGE STATE OF THE PRODUCED DELTA
99      LRES=LRES+1
        I=I1
        IF(EM1.LE.0.6)I=I2
* (1) p+pion(+)-->DELTA(++)
c        IF(LB(I1)*LB(I2).EQ.5)THEN
            IF( (LB(I1)*LB(I2).EQ.5)
     &      .OR.(LB(I1)*LB(I2).EQ.-3) )THEN
        LB(I)=9
       go to 305
        ENDIF
* (2) p+pion(0)-->delta(+)
c        IF(LB(I1)*LB(I2).EQ.4.AND.(LB(I1).EQ.1.OR.LB(I2).EQ.1))then
       IF(iabs(LB(I1)*LB(I2)).EQ.4.AND.(LB(I1).EQ.4.OR.LB(I2).EQ.4))then
        LB(I)=8
       go to 305
        ENDIF
* (3) n+pion(+)-->delta(+)
c        IF(LB(I1)*LB(I2).EQ.10.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
       IF( (LB(I1)*LB(I2).EQ.10.AND.(LB(I1).EQ.5.OR.LB(I2).EQ.5))
     & .OR.(LB(I1)*LB(I2).EQ.-6.AND.(LB(I1).EQ.3.OR.LB(I2).EQ.3)) )THEN
        LB(I)=8
       go to 305
        ENDIF
* (4) n+pion(0)-->delta(0)
c        IF(LB(I1)*LB(I2).EQ.8.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
       IF(iabs(LB(I1)*LB(I2)).EQ.8.AND.(LB(I1).EQ.4.OR.LB(I2).EQ.4))THEN
        LB(I)=7
       go to 305
        ENDIF
* (5) p+pion(-)-->delta(0)
c        IF(LB(I1)*LB(I2).EQ.3)THEN
            IF( (LB(I1)*LB(I2).EQ.3)
     &      .OR.(LB(I1)*LB(I2).EQ.-5) )THEN
        LB(I)=7
       go to 305
        ENDIF
* (6) n+pion(-)-->delta(-)
c        IF(LB(I1)*LB(I2).EQ.6.AND.(LB(I1).EQ.2.OR.LB(I2).EQ.2))THEN
       IF( (LB(I1)*LB(I2).EQ.6.AND.(LB(I1).EQ.3.OR.LB(I2).EQ.3))
     & .OR.(LB(I1)*LB(I2).EQ.-10.AND.(LB(I1).EQ.5.OR.LB(I2).EQ.5)) )THEN 
        LB(I)=6
        ENDIF
305     CALL DRESON(I1,I2)
        if(LB1.lt.0.or.LB2.lt.0) LB(I)=-LB(I) 
       GO TO 101

csp-11/08/01 K*
* FOR kaON+pion COLLISIONS, form K* (bar) or
c La/Si-bar + N <-- pi + K+
c La/Si + N-bar <-- pi + K-                                             
c phi + K <-- pi + K                                             
clin (rho,omega) + K* <-- pi + K
889       CONTINUE
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        EC=(em1+em2+0.02)**2
* the cross section is from C.M. Ko, PRC 23, 2760 (1981).
       spika=60./(1.+4.*(srt-0.895)**2/(0.05)**2)
c
cc       if(lb(i1).eq.23.or.lb(i2).eq.23)then   !! block  K- + pi->La + B-bar

        call Crkpla(PX1CM,PY1CM,PZ1CM,EC,SRT,spika,
     &                  emm1,emm2,lbp1,lbp2,I1,I2,icase,srhoks)
cc
c* only K* or K*bar formation
c       else 
c      DSkn=SQRT(spika/PI/10.)
c      dsknr=dskn+0.1
c      CALL DISTCE(I1,I2,dsknr,DSkn,DT,EC,SRT,IC,
c    1     PX1CM,PY1CM,PZ1CM)
c        IF(IC.EQ.-1) GO TO 400
c       icase = 1
c      endif
c
         if(icase .eq. 0) then
            iblock=0
            go to 400
         endif

       if(icase .eq. 1)then
             call KSRESO(I1,I2)
clin-4/30/03 give non-zero iblock for resonance selections:
             iblock = 171
ctest off for resonance (phi, K*) studies:
c             if(iabs(lb(i1)).eq.30) then
c             write(17,112) 'ks',lb(i1),p(1,i1),p(2,i1),p(3,i1),e(i1),nt
c             elseif(iabs(lb(i2)).eq.30) then
c             write(17,112) 'ks',lb(i2),p(1,i2),p(2,i2),p(3,i2),e(i2),nt
c             endif
c
              lres=lres+1
              go to 101
       elseif(icase .eq. 2)then
             iblock = 71
c
* La/Si (bar) formation                                                   

       elseif(iabs(icase).eq.5)then
             iblock = 88

       else
*
* phi formation
             iblock = 222
       endif
             LB(I1) = lbp1
             LB(I2) = lbp2
             E(I1) = emm1
             E(I2) = emm2
             em1=e(i1)
             em2=e(i2)
             ntag = 0
             go to 440
c             
33       continue
       em1=e(i1)
       em2=e(i2)
* (1) if rho or omega collide with a nucleon we allow both elastic 
*     scattering and kaon production to happen if collision conditions 
*     are satisfied.
* (2) if rho or omega collide with a baryon resonance we allow
*     kaon production, pion reabsorption: rho(omega)+D(N*)-->pion+N
*     and NO elastic scattering to happen
           xelstc=0
            if((lb1.ge.25.and.lb1.le.28).and.
     &    (iabs(lb2).eq.1.or.iabs(lb2).eq.2))
     &      xelstc=ERHON(EM1,EM2,LB1,LB2,SRT)
            if((lb2.ge.25.and.lb2.le.28).and.
     &   (iabs(lb1).eq.1.or.iabs(lb1).eq.2))
     &      xelstc=ERHON(EM1,EM2,LB1,LB2,SRT)
            ec=(em1+em2+0.02)**2
* the kaon production cross section is
           xkaon0=0
           if(srt.ge.1.63.AND.SRT.LE.1.7)xkaon0=pnlka(srt)
           IF(SRT.GT.1.7)XKAON0=PNLKA(SRT)+pnska(srt)
           if(xkaon0.lt.0)xkaon0=0

cbz3/7/99 neutralk
            XKAON0 = 2.0 * XKAON0
cbz3/7/99 neutralk end

* the total inelastic cross section for rho(omega)+N is
           xkaon=xkaon0
           ichann=0
* the total inelastic cross section for rho (omega)+D(N*) is 
* xkaon=xkaon0+reab(**) 

c sp11/21/01  phi production: rho + N(D) -> phi + N(D)
         Xphi = 0.
       if( ( (((lb1.ge.1.and.lb1.le.2).or.
     &         (lb1.ge.6.and.lb1.le.9))
     &         .and.(lb2.ge.25.and.lb2.le.27))
     &   .OR.(((lb2.ge.1.and.lb2.le.2).or.
     &         (lb2.ge.6.and.lb2.le.9))
     &        .and.(lb1.ge.25.and.lb1.le.27)) ).AND. srt.gt.1.958)
     &    call pibphi(srt,lb1,lb2,em1,em2,Xphi,xphin)
c !! in fm^2 above
c
        if((iabs(lb1).ge.6.and.lb2.ge.25).or.
     &    (lb1.ge.25.and.iabs(lb2).ge.6))then
           ichann=1
           ictrl=2
           if(lb1.eq.28.or.lb2.eq.28)ictrl=3
            xreab=reab(i1,i2,srt,ictrl)

clin-12/02/00 to satisfy detailed balance, forbid N* absorptions:
            if((iabs(lb1).ge.10.and.iabs(lb1).le.13)
     1           .or.(iabs(lb2).ge.10.and.iabs(lb2).le.13)) XREAB = 0.

        if(xreab.lt.0)xreab=1.E-06
            xkaon=xkaon0+xreab
          XELSTC=1.0
           endif
            DS=SQRT((XKAON+Xphi+xelstc)/PI)
c
csp09/20/01
c           totcr = xelstc+xkaon
c           if(srt .gt. 3.5)totcr = max1(totcr,3.)
c           DS=SQRT(totcr/PI)
csp09/20/01 end
c
        DELTAR=DS+0.1
       px1cm=pcx
       py1cm=pcy
       pz1cm=pcz
* CHECK IF the collision can happen
         CALL DISTCE(I1,I2,DELTAR,DS,DT,EC,SRT,IC,
     1   PCX,PCY,PCZ)
         IF(IC.EQ.-1) GO TO 400
        ekaon(4,iss)=ekaon(4,iss)+1
c*
* NOW rho(omega)+N or D(N*) COLLISION IS POSSIBLE
* (1) check elastic collision
       if(xelstc/(xelstc+xkaon+Xphi).gt.RANART(NSEED))then
c       call crdir(px1CM,py1CM,pz1CM,srt,I1,i2)
       call crdir(px1CM,py1CM,pz1CM,srt,I1,i2,IBLOCK)
       go to 440
       endif
* (2) check pion absorption or kaon production
        CALL CRRD(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     1  IBLOCK,xkaon0,xkaon,Xphi,xphin)

* kaon production
csp05/16/01
       IF(IBLOCK.EQ.7) then
          LPN=LPN+1
       elseIF(IBLOCK.EQ.-7) then
       endif
csp05/16/01 end
* rho obsorption
       if(iblock.eq.81) lrhor=lrhor+1
* omega obsorption
       if(iblock.eq.82) lomgar=lomgar+1
       em1=e(i1)
       em2=e(i2)
       GO TO 440
* for pion+n now using the subroutine crpn to change 
* the particle label and set the new momentum of L/S+K final state
95       continue
* NOW PION+N INELASTIC COLLISION IS POSSIBLE
* check pion production or kaon production
        CALL CRPN(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     1  IBLOCK,xkaon0,xkaon,Xphi,xphin)

* kaon production
csp05/16/01
       IF(IBLOCK.EQ.7) then
          LPN=LPN+1
       elseIF(IBLOCK.EQ.-7) then
       endif
csp05/16/01 end
* pion production
       if(iblock.eq.77) lpd=lpd+1
* rho production
       if(iblock.eq.78) lrho=lrho+1
* omega production
       if(iblock.eq.79) lomega=lomega+1
       em1=e(i1)
       em2=e(i2)
       GO TO 440
* for pion+D(N*) now using the subroutine crpd to 
* (1) check kaon production or pion reabsorption 
* (2) change the particle label and set the new 
*     momentum of L/S+K final state
96       continue
        CALL CRPD(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     1  IBLOCK,xkaon0,xkaon,Xphi,xphin)

* kaon production
csp05/16/01
       IF(IBLOCK.EQ.7) then
          LPN=LPN+1
       elseIF(IBLOCK.EQ.-7) then
       endif
csp05/16/01 end
* pion obserption
       if(iblock.eq.80) lpdr=lpdr+1
       em1=e(i1)
       em2=e(i2)
       GO TO 440
* CALCULATE KAON PRODUCTION PROBABILITY FROM PION + N COLLISIONS
C        IF(SRT.GT.1.615)THEN
C        CALL PKAON(SRT,XXp,PK)
C        TKAON(7)=TKAON(7)+PK 
C        EKAON(7,ISS)=EKAON(7,ISS)+1
c        CALL KSPEC1(SRT,PK)
C        call LK(3,srt,iseed,pk)
C        ENDIF
* negelecting the pauli blocking at high energies

101       continue
        IF(E(I2).EQ.0.)GO TO 600
        IF(E(I1).EQ.0.)GO TO 800
* IF NUCLEON+BARYON RESONANCE COLLISIONS
44      CONTINUE
* CALCULATE THE TOTAL CROSS SECTION OF NUCLEON+ BARYON RESONANCE COLLISION
* WE ASSUME THAT THE ELASTIC CROSS SECTION IS THE SAME AS NUCLEON+NUCLEON
* COM: WE USE THE PARAMETERISATION BY CUGNON FOR LOW ENERGIES
*      AND THE PARAMETERIZATIONS FROM CERN DATA BOOK FOR HIGHER 
*      ENERGIES. THE CUTOFF FOR THE TOTAL CROSS SECTION IS 55 MB 
       cutoff=em1+em2+0.02
       IF(SRT.LE.CUTOFF)GO TO 400
        IF(SRT.GT.2.245)THEN
       SIGNN=PP2(SRT)
       ELSE
        SIGNN = 35.0 / (1. + (SRT - CUTOFF) * 100.0)  +  20.0
       ENDIF 
        call XND(pcx,pcy,pcz,srt,I1,I2,xinel,
     &               sigk,xsk1,xsk2,xsk3,xsk4,xsk5)
       sig=signn+xinel
* For nucleon+baryon resonance collision, the minimum cms**2 energy is
        EC=(EM1+EM2+0.02)**2
* CHECK THE DISTENCE BETWEEN THE TWO PARTICLES
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ

clin-6/2008 Deuteron production:
        ianti=0
        if(lb(i1).lt.0 .and. lb(i2).lt.0) ianti=1
        call sbbdm(srt,sdprod,ianti,lbm,xmm,pfinal)
        sig=sig+sdprod
clin-6/2008 perturbative treatment of deuterons:
        ipdflag=0
        if(idpert.eq.1) then
           ipert1=1
           sigr0=sig
           dspert=sqrt(sigr0/pi/10.)
           dsrpert=dspert+0.1
           CALL DISTCE(I1,I2,dsrpert,dspert,DT,EC,SRT,IC,
     1          PX1CM,PY1CM,PZ1CM)
           IF(IC.EQ.-1) GO TO 363
           signn0=0.
           CALL CRND(IRUN,PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     &  IBLOCK,SIGNN0,SIGr0,sigk,xsk1,xsk2,xsk3,xsk4,xsk5,NT,ipert1)
c     &  IBLOCK,SIGNN,SIG,sigk,xsk1,xsk2,xsk3,xsk4,xsk5)
           ipdflag=1
 363       continue
           ipert1=0
        endif
        if(idpert.eq.2) ipert1=1
c
        DS=SQRT(SIG/(10.*PI))
        DELTAR=DS+0.1
        CALL DISTCE(I1,I2,DELTAR,DS,DT,EC,SRT,IC,
     1  PX1CM,PY1CM,PZ1CM)
c        IF(IC.EQ.-1)GO TO 400
        IF(IC.EQ.-1) then
           if(ipdflag.eq.1) iblock=501
           GO TO 400
        endif

        ekaon(3,iss)=ekaon(3,iss)+1
* CALCULATE KAON PRODUCTION PROBABILITY FROM NUCLEON + BARYON RESONANCE 
* COLLISIONS
        go to 361

* CHECK WHAT KIND OF COLLISION HAS HAPPENED
 361    continue 
        CALL CRND(IRUN,PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     &     IBLOCK,SIGNN,SIG,sigk,xsk1,xsk2,xsk3,xsk4,xsk5,NT,ipert1)
c     &  IBLOCK,SIGNN,SIG,sigk,xsk1,xsk2,xsk3,xsk4,xsk5)
        IF(iblock.eq.0.and.ipdflag.eq.1) iblock=501
        IF(IBLOCK.EQ.11)THEN
           LNDK=LNDK+1
           GO TO 400
c        elseIF(IBLOCK.EQ.-11) then
        elseIF(IBLOCK.EQ.-11.or.iblock.eq.501) then
           GO TO 400
        ENDIF
        if(iblock .eq. 222)then
c    !! sp12/17/01 
           GO TO 400
        ENDIF
        em1=e(i1)
        em2=e(i2)
        GO TO 440
* IF NUCLEON+NUCLEON OR BARYON RESONANCE+BARYON RESONANCE COLLISIONS
4       CONTINUE
* PREPARE THE EALSTIC CROSS SECTION FOR BARYON+BARYON COLLISIONS
* COM: WE USE THE PARAMETERISATION BY CUGNON FOR SRT LEQ 2.0 GEV
*      AND THE PARAMETERIZATIONS FROM CERN DATA BOOK FOR HIGHER 
*      ENERGIES. THE CUTOFF FOR THE TOTAL CROSS SECTION IS 55 MB 
*      WITH LOW-ENERGY-CUTOFF
        CUTOFF=em1+em2+0.14
* AT HIGH ENERGIES THE ISOSPIN DEPENDENCE IS NEGLIGIBLE
* THE TOTAL CROSS SECTION IS TAKEN AS THAT OF THE PP 
* ABOVE E_KIN=800 MEV, WE USE THE ISOSPIN INDEPENDNET XSECTION
        IF(SRT.GT.2.245)THEN
           SIG=ppt(srt)
           SIGNN=SIG-PP1(SRT)
        ELSE
* AT LOW ENERGIES THE ISOSPIN DEPENDENCE FOR NN COLLISION IS STRONG
           SIG=XPP(SRT)
           IF(ZET(LB(I1))*ZET(LB(I2)).LE.0)SIG=XNP(SRT)
           IF(ZET(LB(I1))*ZET(LB(I2)).GT.0)SIG=XPP(SRT)
           IF(ZET(LB(I1)).EQ.0.
     &          AND.ZET(LB(I2)).EQ.0)SIG=XPP(SRT)
           if((lb(i1).eq.-1.and.lb(i2).eq.-2) .or.
     &          (lb(i2).eq.-1.and.lb(i1).eq.-2))sig=xnp(srt)
*     WITH LOW-ENERGY-CUTOFF
           IF (SRT .LT. 1.897) THEN
              SIGNN = SIG
           ELSE 
              SIGNN = 35.0 / (1. + (SRT - 1.897) * 100.0)  +  20.0
           ENDIF
        ENDIF 
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
clin-5/2008 Deuteron production cross sections were not included 
c     in the previous parameterized inelastic cross section of NN collisions  
c     (SIGinel=SIG-SIGNN), so they are added here:
        ianti=0
        if(lb(i1).lt.0 .and. lb(i2).lt.0) ianti=1
        call sbbdm(srt,sdprod,ianti,lbm,xmm,pfinal)
        sig=sig+sdprod
c
clin-5/2008 perturbative treatment of deuterons:
        ipdflag=0
        if(idpert.eq.1) then
c     For idpert=1: ipert1=1 means we will first treat deuteron perturbatively,
c     then we set ipert1=0 to treat regular NN or NbarNbar collisions including
c     the regular deuteron productions.
c     ipdflag=1 means perturbative deuterons are produced here:
           ipert1=1
           EC=2.012**2
c     Use the same cross section for NN/NNBAR collisions 
c     to trigger perturbative production
           sigr0=sig
c     One can also trigger with X*sbbdm() so the weight will not be too small;
c     but make sure to limit the maximum trigger Xsec:
c           sigr0=sdprod*25.
c           if(sigr0.ge.100.) sigr0=100.
           dspert=sqrt(sigr0/pi/10.)
           dsrpert=dspert+0.1
           CALL DISTCE(I1,I2,dsrpert,dspert,DT,EC,SRT,IC,
     1          PX1CM,PY1CM,PZ1CM)
           IF(IC.EQ.-1) GO TO 365
           signn0=0.
           CALL CRNN(IRUN,PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK,
     1          NTAG,signn0,sigr0,NT,ipert1)
           ipdflag=1
 365       continue
           ipert1=0
        endif
        if(idpert.eq.2) ipert1=1
c
clin-5/2008 in case perturbative deuterons are produced for idpert=1:
c        IF(SIGNN.LE.0)GO TO 400
        IF(SIGNN.LE.0) then
           if(ipdflag.eq.1) iblock=501
           GO TO 400
        endif
c
        EC=3.59709
        ds=sqrt(sig/pi/10.)
        dsr=ds+0.1
        IF((E(I1).GE.1.).AND.(e(I2).GE.1.))EC=4.75
        CALL DISTCE(I1,I2,dsr,ds,DT,EC,SRT,IC,
     1       PX1CM,PY1CM,PZ1CM)
clin-5/2008 in case perturbative deuterons are produced above:
c        IF(IC.EQ.-1) GO TO 400
        IF(IC.EQ.-1) then
           if(ipdflag.eq.1) iblock=501
           GO TO 400
        endif
c
* CALCULATE KAON PRODUCTION PROBABILITY FROM NUCLEON+NUCLEON OR 
* RESONANCE+RESONANCE COLLISIONS
        go to 362

C CHECK WHAT KIND OF COLLISION HAS HAPPENED 
 362    ekaon(1,iss)=ekaon(1,iss)+1
        CALL CRNN(IRUN,PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK,
     1       NTAG,SIGNN,SIG,NT,ipert1)
clin-5/2008 give iblock # in case pert deuterons are produced for idpert=1:
        IF(iblock.eq.0.and.ipdflag.eq.1) iblock=501
clin-5/2008 add iblock # for deuteron formation:
c        IF(IBLOCK.EQ.4.OR.IBLOCK.Eq.9.or.iblock.ge.44.OR.IBLOCK.EQ.-9
c     &       .or.iblock.eq.222)THEN
        IF(IBLOCK.EQ.4.OR.IBLOCK.Eq.9.or.iblock.ge.44.OR.IBLOCK.EQ.-9
     &       .or.iblock.eq.222.or.iblock.eq.501)THEN
c
c     !! sp12/17/01 above
* momentum of the three particles in the final state have been calculated
* in the crnn, go out of the loop
           LCOLL=LCOLL+1
           if(iblock.eq.4)then
              LDIRT=LDIRT+1
           elseif(iblock.eq.44)then
              LDdrho=LDdrho+1
           elseif(iblock.eq.45)then
              Lnnrho=Lnnrho+1
           elseif(iblock.eq.46)then
              Lnnom=Lnnom+1
           elseif(iblock .eq. 222)then
           elseIF(IBLOCK.EQ.9) then
              LNNK=LNNK+1
           elseIF(IBLOCK.EQ.-9) then
           endif
           GO TO 400
        ENDIF

        em1=e(i1)
        em2=e(i2)
        GO TO 440
clin-8/2008 B+B->Deuteron+Meson over
c
clin-8/2008 Deuteron+Meson->B+B collisions:
 505    continue
        ianti=0
        if(lb(i1).lt.0 .or. lb(i2).lt.0) ianti=1
        call sdmbb(SRT,sdm,ianti)
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
c     minimum srt**2, note a 2.012GeV lower cutoff is used in N+N->Deuteron+pi:
        EC=2.012**2
        ds=sqrt(sdm/31.4)
        dsr=ds+0.1
        CALL DISTCE(I1,I2,dsr,ds,DT,EC,SRT,IC,PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
        CALL crdmbb(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK,
     1       NTAG,sdm,NT,ianti)
        LCOLL=LCOLL+1
        GO TO 400
clin-8/2008 Deuteron+Meson->B+B collisions over
c
clin-9/2008 Deuteron+Baryon elastic collisions:
 506    continue
        ianti=0
        if(lb(i1).lt.0 .or. lb(i2).lt.0) ianti=1
        call sdbelastic(SRT,sdb)
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
c     minimum srt**2, note a 2.012GeV lower cutoff is used in N+N->Deuteron+pi:
        EC=2.012**2
        ds=sqrt(sdb/31.4)
        dsr=ds+0.1
        CALL DISTCE(I1,I2,dsr,ds,DT,EC,SRT,IC,PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
        CALL crdbel(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK,
     1       NTAG,sdb,NT,ianti)
        LCOLL=LCOLL+1
        GO TO 400
clin-9/2008 Deuteron+Baryon elastic collisions over
c
* IF BARYON RESONANCE+BARYON RESONANCE COLLISIONS
 444    CONTINUE
* PREPARE THE EALSTIC CROSS SECTION FOR BARYON+BARYON COLLISIONS
       CUTOFF=em1+em2+0.02
* AT HIGH ENERGIES THE ISOSPIN DEPENDENCE IS NEGLIGIBLE
* THE TOTAL CROSS SECTION IS TAKEN AS THAT OF THE PP 
       IF(SRT.LE.CUTOFF)GO TO 400
        IF(SRT.GT.2.245)THEN
       SIGNN=PP2(SRT)
       ELSE
        SIGNN = 35.0 / (1. + (SRT - CUTOFF) * 100.0)  +  20.0
       ENDIF 
       IF(SIGNN.LE.0)GO TO 400
      CALL XDDIN(PCX,PCY,PCZ,SRT,I1,I2,
     &XINEL,SIGK,XSK1,XSK2,XSK3,XSK4,XSK5)
       SIG=SIGNN+XINEL
       EC=(EM1+EM2+0.02)**2
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ

clin-6/2008 Deuteron production:
        ianti=0
        if(lb(i1).lt.0 .and. lb(i2).lt.0) ianti=1
        call sbbdm(srt,sdprod,ianti,lbm,xmm,pfinal)
        sig=sig+sdprod
clin-6/2008 perturbative treatment of deuterons:
        ipdflag=0
        if(idpert.eq.1) then
           ipert1=1
           sigr0=sig
           dspert=sqrt(sigr0/pi/10.)
           dsrpert=dspert+0.1
           CALL DISTCE(I1,I2,dsrpert,dspert,DT,EC,SRT,IC,
     1          PX1CM,PY1CM,PZ1CM)
           IF(IC.EQ.-1) GO TO 367
           signn0=0.
           CALL CRDD(IRUN,PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     1          IBLOCK,NTAG,SIGNN0,SIGr0,NT,ipert1)
c     1          IBLOCK,NTAG,SIGNN,SIG)
           ipdflag=1
 367       continue
           ipert1=0
        endif
        if(idpert.eq.2) ipert1=1
c
        ds=sqrt(sig/31.4)
        dsr=ds+0.1
        CALL DISTCE(I1,I2,dsr,ds,DT,EC,SRT,IC,
     1  PX1CM,PY1CM,PZ1CM)
c        IF(IC.EQ.-1) GO TO 400
        IF(IC.EQ.-1) then
           if(ipdflag.eq.1) iblock=501
           GO TO 400
        endif

* CALCULATE KAON PRODUCTION PROBABILITY FROM NUCLEON+NUCLEON OR 
* RESONANCE+RESONANCE COLLISIONS
       go to 364

C CHECK WHAT KIND OF COLLISION HAS HAPPENED 
364       ekaon(2,iss)=ekaon(2,iss)+1
* for resonance+resonance
clin-6/2008:
        CALL CRDD(IRUN,PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     1  IBLOCK,NTAG,SIGNN,SIG,NT,ipert1)
c     1  IBLOCK,NTAG,SIGNN,SIG)
        IF(iblock.eq.0.and.ipdflag.eq.1) iblock=501
c
        IF(iabs(IBLOCK).EQ.10)THEN
* momentum of the three particles in the final state have been calculated
* in the crnn, go out of the loop
           LCOLL=LCOLL+1
           IF(IBLOCK.EQ.10)THEN
              LDDK=LDDK+1
           elseIF(IBLOCK.EQ.-10) then
           endif
           GO TO 400
        ENDIF
clin-6/2008
c        if(iblock .eq. 222)then
        if(iblock .eq. 222.or.iblock.eq.501)then
c    !! sp12/17/01 
           GO TO 400
        ENDIF
        em1=e(i1)
        em2=e(i2)
        GO TO 440
* FOR PION+PION,pion+eta, eta+eta and rho(omega)+pion(rho,omega) or eta 
777       CONTINUE
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
* energy thresh for collisions
       ec0=em1+em2+0.02
       IF(SRT.LE.ec0)GO TO 400
       ec=(em1+em2+0.02)**2
* we negelect the elastic collision between mesons except that betwen
* two pions because of the lack of information about these collisions
* However, we do let them to collide inelastically to produce kaons
clin-8/15/02       ppel=1.e-09
       ppel=20.
        ipp=1
       if(lb1.lt.3.or.lb1.gt.5.or.lb2.lt.3.or.lb2.gt.5)go to 778       
       CALL PPXS(LB1,LB2,SRT,PPSIG,spprho,IPP)
       ppel=ppsig
778       ppink=pipik(srt)

* pi+eta and eta+eta are assumed to be the same as pipik( for pi+pi -> K+K-) 
* estimated from Ko's paper:
        ppink = 2.0 * ppink
       if(lb1.ge.25.and.lb2.ge.25) ppink=rrkk

clin-2/13/03 include omega the same as rho, eta the same as pi:
c        if(((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.25.and.lb2.le.27))
c     1  .or.((lb2.ge.3.and.lb2.le.5).and.(lb1.ge.25.and.lb1.le.27)))
        if( ( (lb1.eq.0.or.(lb1.ge.3.and.lb1.le.5))
     1       .and.(lb2.ge.25.and.lb2.le.28))
     2       .or. ( (lb2.eq.0.or.(lb2.ge.3.and.lb2.le.5))
     3       .and.(lb1.ge.25.and.lb1.le.28))) then
           ppink=0.
           if(srt.ge.(aka+aks)) ppink = prkk
        endif

c pi pi <-> rho rho:
        call spprr(lb1,lb2,srt)
clin-4/03/02 pi pi <-> eta eta:
        call sppee(lb1,lb2,srt)
clin-4/03/02 pi pi <-> pi eta:
        call spppe(lb1,lb2,srt)
clin-4/03/02 rho pi <-> rho eta:
        call srpre(lb1,lb2,srt)
clin-4/03/02 omega pi <-> omega eta:
        call sopoe(lb1,lb2,srt)
clin-4/03/02 rho rho <-> eta eta:
        call srree(lb1,lb2,srt)

        ppinnb=0.
        if(srt.gt.thresh(1)) then
           call getnst(srt)
           if(lb1.ge.3.and.lb1.le.5.and.lb2.ge.3.and.lb2.le.5) then
              ppinnb=ppbbar(srt)
           elseif((lb1.ge.3.and.lb1.le.5.and.lb2.ge.25.and.lb2.le.27)
     1 .or.(lb2.ge.3.and.lb2.le.5.and.lb1.ge.25.and.lb1.le.27)) then
              ppinnb=prbbar(srt)
           elseif(lb1.ge.25.and.lb1.le.27
     1             .and.lb2.ge.25.and.lb2.le.27) then
              ppinnb=rrbbar(srt)
           elseif((lb1.ge.3.and.lb1.le.5.and.lb2.eq.28)
     1             .or.(lb2.ge.3.and.lb2.le.5.and.lb1.eq.28)) then
              ppinnb=pobbar(srt)
           elseif((lb1.ge.25.and.lb1.le.27.and.lb2.eq.28)
     1             .or.(lb2.ge.25.and.lb2.le.27.and.lb1.eq.28)) then
              ppinnb=robbar(srt)
           elseif(lb1.eq.28.and.lb2.eq.28) then
              ppinnb=oobbar(srt)
           else
              if(lb1.ne.0.and.lb2.ne.0) 
     1             write(6,*) 'missed MM lb1,lb2=',lb1,lb2
           endif
        endif
        ppin=ppink+ppinnb+pprr+ppee+pppe+rpre+xopoe+rree

* check if a collision can happen
       if((ppel+ppin).le.0.01)go to 400
       DSPP=SQRT((ppel+ppin)/31.4)
       dsppr=dspp+0.1
        CALL DISTCE(I1,I2,dsppr,DSPP,DT,EC,SRT,IC,
     1  PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
       if(ppel.eq.0)go to 400
* the collision can happen
* check what kind collision has happened
       ekaon(5,iss)=ekaon(5,iss)+1
        CALL CRPP(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     1  IBLOCK,ppel,ppin,spprho,ipp)

* rho formation, go to 400
c       if(iblock.eq.666)go to 600
       if(iblock.eq.666)go to 555
       if(iblock.eq.6)LPP=LPP+1
       if(iblock.eq.66)then
          LPPk=LPPk+1
       elseif(iblock.eq.366)then
          LPPk=LPPk+1
       elseif(iblock.eq.367)then
          LPPk=LPPk+1
       endif
       em1=e(i1)
       em2=e(i2)
       go to 440

* In this block we treat annihilations of
clin-9/28/00* an anti-nucleon and a baryon or baryon resonance  
* an anti-baryon and a baryon (including resonances)
2799        CONTINUE
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        EC=(em1+em2+0.02)**2
clin assume the same cross section (as a function of sqrt s) as for PPbar:

clin-ctest annih maximum
c        DSppb=SQRT(amin1(xppbar(srt),30.)/PI/10.)
       DSppb=SQRT(xppbar(srt)/PI/10.)
       dsppbr=dsppb+0.1
        CALL DISTCE(I1,I2,dsppbr,DSppb,DT,EC,SRT,IC,
     1  PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
        CALL Crppba(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     1  IBLOCK)
       em1=e(i1)
       em2=e(i2)
       go to 440
c
3555    PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        EC=(em1+em2+0.02)**2
       DSkk=SQRT(SIG/PI/10.)
       dskk0=dskk+0.1
        CALL DISTCE(I1,I2,dskk0,DSkk,DT,EC,SRT,IC,
     1  PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
        CALL Crlaba(PX1CM,PY1CM,PZ1CM,SRT,brel,brsgm,
     &                  I1,I2,nt,IBLOCK,nchrg,icase)
       em1=e(i1)
       em2=e(i2)
       go to 440
*
c perturbative production of cascade and omega
3455    PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        call pertur(PX1CM,PY1CM,PZ1CM,SRT,IRUN,I1,I2,nt,kp,icontp)
        if(icontp .eq. 0)then
c     inelastic collisions:
         em1 = e(i1)
         em2 = e(i2)
         iblock = 727
          go to 440
        endif
c     elastic collisions:
        if (e(i1) .eq. 0.) go to 800
        if (e(i2) .eq. 0.) go to 600
        go to 400
*
c* phi + N --> pi+N(D),  N(D,N*)+N(D,N*),  K+ +La
c* phi + D --> pi+N(D)
7222        CONTINUE
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        EC=(em1+em2+0.02)**2
        CALL XphiB(LB1, LB2, EM1, EM2, SRT,
     &             XSK1, XSK2, XSK3, XSK4, XSK5, SIGP)
       DSkk=SQRT(SIGP/PI/10.)
       dskk0=dskk+0.1
        CALL DISTCE(I1,I2,dskk0,DSkk,DT,EC,SRT,IC,
     1  PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
        CALL CRPHIB(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     &     XSK1, XSK2, XSK3, XSK4, XSK5, SIGP, IBLOCK)
       em1=e(i1)
       em2=e(i2)
       go to 440
*
c* phi + M --> K+ + K* .....
7444        CONTINUE
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        EC=(em1+em2+0.02)**2
        CALL PHIMES(I1, I2, SRT, XSK1, XSK2, XSK3, XSK4, XSK5,
     1     XSK6, XSK7, SIGPHI)
       DSkk=SQRT(SIGPHI/PI/10.)
       dskk0=dskk+0.1
        CALL DISTCE(I1,I2,dskk0,DSkk,DT,EC,SRT,IC,
     1  PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
c*---
        PZRT = p(3,i1)+p(3,i2)
        ER1 = sqrt( p(1,i1)**2+p(2,i1)**2+p(3,i1)**2+E(i1)**2 )
        ER2 = sqrt( p(1,i2)**2+p(2,i2)**2+p(3,i2)**2+E(i2)**2 )
        ERT = ER1+ER2
        yy = 0.5*log( (ERT+PZRT)/(ERT-PZRT) )
c*------
        CALL CRPHIM(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     &  XSK1, XSK2, XSK3, XSK4, XSK5, XSK6, SIGPHI, IKKG, IKKL, IBLOCK)
       em1=e(i1)
       em2=e(i2)
       go to 440
c
c lambda-N elastic xsection, Li & Ko, PRC 54(1996)1897.
 7799    CONTINUE
         PX1CM=PCX
         PY1CM=PCY
         PZ1CM=PCZ
         EC=(em1+em2+0.02)**2
         call lambar(i1,i2,srt,siglab)
        DShn=SQRT(siglab/PI/10.)
        dshnr=dshn+0.1
         CALL DISTCE(I1,I2,dshnr,DShn,DT,EC,SRT,IC,
     1    PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
         CALL Crhb(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)
        em1=e(i1)
        em2=e(i2)
        go to 440
c
c* K+ + La(Si) --> Meson + B
c* K- + La(Si)-bar --> Meson + B-bar
5699        CONTINUE
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        EC=(em1+em2+0.02)**2
        CALL XKHYPE(I1, I2, SRT, XKY1, XKY2, XKY3, XKY4, XKY5,
     &     XKY6, XKY7, XKY8, XKY9, XKY10, XKY11, XKY12, XKY13,
     &     XKY14, XKY15, XKY16, XKY17, SIGK)
       DSkk=SQRT(sigk/PI)
       dskk0=dskk+0.1
        CALL DISTCE(I1,I2,dskk0,DSkk,DT,EC,SRT,IC,
     1  PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
c
       if(lb(i1).eq.23 .or. lb(i2).eq.23)then
             IKMP = 1
        else
             IKMP = -1
        endif
        CALL Crkhyp(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     &     XKY1, XKY2, XKY3, XKY4, XKY5,
     &     XKY6, XKY7, XKY8, XKY9, XKY10, XKY11, XKY12, XKY13,
     &     XKY14, XKY15, XKY16, XKY17, SIGK, IKMP,
     1  IBLOCK)
       em1=e(i1)
       em2=e(i2)
       go to 440
c khyperon end
*
csp11/03/01 La/Si-bar + N --> pi + K+
c  La/Si + N-bar --> pi + K-
5999     CONTINUE
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        EC=(em1+em2+0.02)**2
        sigkp = 15.
c      if((lb1.ge.14.and.lb1.le.17)
c     &    .or.(lb2.ge.14.and.lb2.le.17))sigkp=10.
        DSkk=SQRT(SIGKP/PI/10.)
        dskk0=dskk+0.1
        CALL DISTCE(I1,I2,dskk0,DSkk,DT,EC,SRT,IC,
     1  PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
c
        CALL CRLAN(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)
        em1=e(i1)
        em2=e(i2)
        go to 440
c
c*
* K(K*) + K(K*) --> phi + pi(rho,omega)
8699     CONTINUE
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        EC=(em1+em2+0.02)**2
*  CALL CROSSKKPHI(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)  used for KK*->phi+rho

         CALL Crkphi(PX1CM,PY1CM,PZ1CM,EC,SRT,IBLOCK,
     &                  emm1,emm2,lbp1,lbp2,I1,I2,ikk,icase,rrkk,prkk)
         if(icase .eq. 0) then
            iblock=0
            go to 400
         endif

c*---
         if(lbp1.eq.29.or.lbp2.eq.29) then
        PZRT = p(3,i1)+p(3,i2)
        ER1 = sqrt( p(1,i1)**2+p(2,i1)**2+p(3,i1)**2+E(i1)**2 )
        ER2 = sqrt( p(1,i2)**2+p(2,i2)**2+p(3,i2)**2+E(i2)**2 )
        ERT = ER1+ER2
        yy = 0.5*log( (ERT+PZRT)/(ERT-PZRT) )
c*------
             iblock = 222
             ntag = 0
          endif

             LB(I1) = lbp1
             LB(I2) = lbp2
             E(I1) = emm1
             E(I2) = emm2
             em1=e(i1)
             em2=e(i2)
             go to 440
c*
* rho(omega) + K(K*)  --> phi + K(K*)
8799     CONTINUE
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        EC=(em1+em2+0.02)**2
*  CALL CROSSKKPHI(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,IBLOCK)  used for KK*->phi+rho
         CALL Crksph(PX1CM,PY1CM,PZ1CM,EC,SRT,
     &       emm1,emm2,lbp1,lbp2,I1,I2,ikkg,ikkl,iblock,icase,srhoks)
         if(icase .eq. 0) then
            iblock=0
            go to 400
         endif
c
         if(lbp1.eq.29.or.lbp2.eq.20) then
c*---
        PZRT = p(3,i1)+p(3,i2)
        ER1 = sqrt( p(1,i1)**2+p(2,i1)**2+p(3,i1)**2+E(i1)**2 )
        ER2 = sqrt( p(1,i2)**2+p(2,i2)**2+p(3,i2)**2+E(i2)**2 )
        ERT = ER1+ER2
        yy = 0.5*log( (ERT+PZRT)/(ERT-PZRT) )
          endif

             LB(I1) = lbp1
             LB(I2) = lbp2
             E(I1) = emm1
             E(I2) = emm2
             em1=e(i1)
             em2=e(i2)
             go to 440

* for kaon+baryon scattering, using a constant xsection of 10 mb.
888       CONTINUE
        PX1CM=PCX
        PY1CM=PCY
        PZ1CM=PCZ
        EC=(em1+em2+0.02)**2
         sig = 10.
         if(iabs(lb1).eq.14.or.iabs(lb2).eq.14 .or.
     &      iabs(lb1).eq.30.or.iabs(lb2).eq.30)sig=20.
         if(lb1.eq.29.or.lb2.eq.29)sig=5.0

       DSkn=SQRT(sig/PI/10.)
       dsknr=dskn+0.1
        CALL DISTCE(I1,I2,dsknr,DSkn,DT,EC,SRT,IC,
     1  PX1CM,PY1CM,PZ1CM)
        IF(IC.EQ.-1) GO TO 400
        CALL Crkn(PX1CM,PY1CM,PZ1CM,SRT,I1,I2,
     1  IBLOCK)
       em1=e(i1)
       em2=e(i2)
       go to 440
***

 440    CONTINUE
*                IBLOCK = 0 ; NOTHING HAS HAPPENED
*                IBLOCK = 1 ; ELASTIC N-N COLLISION
*                IBLOCK = 2 ; N + N -> N + DELTA
*                IBLOCK = 3 ; N + DELTA -> N + N
*                IBLOCK = 4 ; N + N -> d + d + PION,DIRECT PROCESS
*               IBLOCK = 5 ; D(N*)+D(N*) COLLISIONS
*                IBLOCK = 6 ; PION+PION COLLISIONS
*                iblock = 7 ; pion+nucleon-->l/s+kaon
*               iblock =77;  pion+nucleon-->delta+pion
*               iblock = 8 ; kaon+baryon rescattering
*                IBLOCK = 9 ; NN-->KAON+X
*                IBLOCK = 10; DD-->KAON+X
*               IBLOCK = 11; ND-->KAON+X
cbali2/1/99
*                
*           iblock   - 1902 annihilation-->pion(+)+pion(-)   (2 pion)
*           iblock   - 1903 annihilation-->pion(+)+rho(-)    (3 pion)
*           iblock   - 1904 annihilation-->rho(+)+rho(-)     (4 pion)
*           iblock   - 1905 annihilation-->rho(0)+omega      (5 pion)
*           iblock   - 1906 annihilation-->omega+omega       (6 pion)
cbali3/5/99
*           iblock   - 1907 K+K- to pi+pi-
cbali3/5/99 end
cbz3/9/99 khyperon
*           iblock   - 1908 K+Y -> piN
cbz3/9/99 khyperon end
cbali2/1/99end

clin-9/28/00 Processes: m(pi rho omega)+m(pi rho omega)
c     to anti-(p n D N*1 N*2)+(p n D N*1 N*2):
*           iblock   - 1801  mm -->pbar p 
*           iblock   - 18021 mm -->pbar n 
*           iblock   - 18022 mm -->nbar p 
*           iblock   - 1803  mm -->nbar n 
*           iblock   - 18041 mm -->pbar Delta 
*           iblock   - 18042 mm -->anti-Delta p
*           iblock   - 18051 mm -->nbar Delta 
*           iblock   - 18052 mm -->anti-Delta n
*           iblock   - 18061 mm -->pbar N*(1400) 
*           iblock   - 18062 mm -->anti-N*(1400) p
*           iblock   - 18071 mm -->nbar N*(1400)
*           iblock   - 18072 mm -->anti-N*(1400) n
*           iblock   - 1808  mm -->anti-Delta Delta 
*           iblock   - 18091 mm -->pbar N*(1535)
*           iblock   - 18092 mm -->anti-N*(1535) p
*           iblock   - 18101 mm -->nbar N*(1535)
*           iblock   - 18102 mm -->anti-N*(1535) n
*           iblock   - 18111 mm -->anti-Delta N*(1440)
*           iblock   - 18112 mm -->anti-N*(1440) Delta
*           iblock   - 18121 mm -->anti-Delta N*(1535)
*           iblock   - 18122 mm -->anti-N*(1535) Delta
*           iblock   - 1813  mm -->anti-N*(1440) N*(1440)
*           iblock   - 18141 mm -->anti-N*(1440) N*(1535)
*           iblock   - 18142 mm -->anti-N*(1535) N*(1440)
*           iblock   - 1815  mm -->anti-N*(1535) N*(1535)
clin-9/28/00-end

clin-10/08/00 Processes: pi pi <-> rho rho
*           iblock   - 1850  pi pi -> rho rho
*           iblock   - 1851  rho rho -> pi pi
clin-10/08/00-end

clin-08/14/02 Processes: pi pi <-> eta eta
*           iblock   - 1860  pi pi -> eta eta
*           iblock   - 1861  eta eta -> pi pi
* Processes: pi pi <-> pi eta
*           iblock   - 1870  pi pi -> pi eta
*           iblock   - 1871  pi eta -> pi pi
* Processes: rho pi <-> rho eta
*           iblock   - 1880  pi pi -> pi eta
*           iblock   - 1881  pi eta -> pi pi
* Processes: omega pi <-> omega eta
*           iblock   - 1890  pi pi -> pi eta
*           iblock   - 1891  pi eta -> pi pi
* Processes: rho rho <-> eta eta
*           iblock   - 1895  rho rho -> eta eta
*           iblock   - 1896  eta eta -> rho rho
clin-08/14/02-end

clin-11/07/00 Processes: 
*           iblock   - 366  pi rho -> K* Kbar or K*bar K
*           iblock   - 466  pi rho <- K* Kbar or K*bar K

clin-9/2008 Deuteron:
*           iblock   - 501  B+B -> Deuteron+Meson
*           iblock   - 502  Deuteron+Meson -> B+B
*           iblock   - 503  Deuteron+Baryon elastic
*           iblock   - 504  Deuteron+Meson elastic
c
                 IF(IBLOCK.EQ.0)        GOTO 400
*COM: FOR DIRECT PROCESS WE HAVE TREATED THE PAULI BLOCKING AND FIND
*     THE MOMENTUM OF PARTICLES IN THE ''LAB'' FRAME. SO GO TO 400
* A COLLISION HAS TAKEN PLACE !!
              LCOLL = LCOLL +1
* WAS COLLISION PAULI-FORBIDEN? IF YES, NTAG = -1
              NTAG = 0
*
*             LORENTZ-TRANSFORMATION INTO CMS FRAME
              E1CM    = SQRT (EM1**2 + PX1CM**2 + PY1CM**2 + PZ1CM**2)
              P1BETA  = PX1CM*BETAX + PY1CM*BETAY + PZ1CM*BETAZ
              TRANSF  = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) + E1CM )
              Pt1I1 = BETAX * TRANSF + PX1CM
              Pt2I1 = BETAY * TRANSF + PY1CM
              Pt3I1 = BETAZ * TRANSF + PZ1CM
* negelect the pauli blocking at high energies
              go to 90002

clin-10/25/02-comment out following, since there is no path to it:
c*CHECK IF PARTICLE #1 IS PAULI BLOCKED
c              CALL PAULat(I1,occup)
c              if (RANART(NSEED) .lt. occup) then
c                ntag = -1
c              else
c                ntag = 0
c              end if
clin-10/25/02-end

90002              continue
*IF PARTICLE #1 IS NOT PAULI BLOCKED
c              IF (NTAG .NE. -1) THEN
                E2CM    = SQRT (EM2**2 + PX1CM**2 + PY1CM**2 + PZ1CM**2)
                TRANSF  = GAMMA * (-GAMMA*P1BETA / (GAMMA + 1.) + E2CM)
                Pt1I2 = BETAX * TRANSF - PX1CM
                Pt2I2 = BETAY * TRANSF - PY1CM
                Pt3I2 = BETAZ * TRANSF - PZ1CM
              go to 90003

clin-10/25/02-comment out following, since there is no path to it:
c*CHECK IF PARTICLE #2 IS PAULI BLOCKED
c                CALL PAULat(I2,occup)
c                if (RANART(NSEED) .lt. occup) then
c                  ntag = -1
c                else
c                  ntag = 0
c                end if
cc              END IF
c* IF COLLISION IS BLOCKED,RESTORE THE MOMENTUM,MASSES
c* AND LABELS OF I1 AND I2
cc             IF (NTAG .EQ. -1) THEN
c                LBLOC  = LBLOC + 1
c                P(1,I1) = PX1
c                P(2,I1) = PY1
c                P(3,I1) = PZ1
c                P(1,I2) = PX2
c                P(2,I2) = PY2
c                P(3,I2) = PZ2
c                E(I1)   = EM1
c                E(I2)   = EM2
c                LB(I1)  = LB1
c                LB(I2)  = LB2
cc              ELSE
clin-10/25/02-end

90003           IF(IBLOCK.EQ.1) LCNNE=LCNNE+1
              IF(IBLOCK.EQ.5) LDD=LDD+1
                if(iblock.eq.2) LCNND=LCNND+1
              IF(IBLOCK.EQ.8) LKN=LKN+1
                   if(iblock.eq.43) Ldou=Ldou+1
c                IF(IBLOCK.EQ.2) THEN
* CALCULATE THE AVERAGE SRT FOR N + N---> N + DELTA PROCESS
C                NODELT=NODELT+1
C                SUMSRT=SUMSRT+SRT
c                ENDIF
                IF(IBLOCK.EQ.3) LCNDN=LCNDN+1
* assign final momenta to particles while keep the leadng particle
* behaviour
C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
              p(1,i1)=pt1i1
              p(2,i1)=pt2i1
              p(3,i1)=pt3i1
              p(1,i2)=pt1i2
              p(2,i2)=pt2i2
              p(3,i2)=pt3i2
C              else
C              p(1,i1)=pt1i2
C              p(2,i1)=pt2i2
C              p(3,i1)=pt3i2
C              p(1,i2)=pt1i1
C              p(2,i2)=pt2i1
C              p(3,i2)=pt3i1
C              endif
                PX1     = P(1,I1)
                PY1     = P(2,I1)
                PZ1     = P(3,I1)
                EM1     = E(I1)
                EM2     = E(I2)
                LB1     = LB(I1)
                LB2     = LB(I2)
                ID(I1)  = 2
                ID(I2)  = 2
                E1      = SQRT( EM1**2 + PX1**2 + PY1**2 + PZ1**2 )
                ID1     = ID(I1)
              go to 90004
clin-10/25/02-comment out following, since there is no path to it:
c* change phase space density FOR NUCLEONS INVOLVED :
c* NOTE THAT f is the phase space distribution function for nucleons only
c                if ((abs(ix1).le.mx) .and. (abs(iy1).le.my) .and.
c     &              (abs(iz1).le.mz)) then
c                  ipx1p = nint(p(1,i1)/dpx)
c                  ipy1p = nint(p(2,i1)/dpy)
c                  ipz1p = nint(p(3,i1)/dpz)
c                  if ((ipx1p.ne.ipx1) .or. (ipy1p.ne.ipy1) .or.
c     &                (ipz1p.ne.ipz1)) then
c                    if ((abs(ipx1).le.mpx) .and. (abs(ipy1).le.my)
c     &                .and. (ipz1.ge.-mpz) .and. (ipz1.le.mpzp)
c     &                .AND. (AM1.LT.1.))
c     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) =
c     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) - 1.
c                    if ((abs(ipx1p).le.mpx) .and. (abs(ipy1p).le.my)
c     &                .and. (ipz1p.ge.-mpz).and. (ipz1p.le.mpzp)
c     &                .AND. (EM1.LT.1.))
c     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) =
c     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) + 1.
c                  end if
c                end if
c                if ((abs(ix2).le.mx) .and. (abs(iy2).le.my) .and.
c     &              (abs(iz2).le.mz)) then
c                  ipx2p = nint(p(1,i2)/dpx)
c                  ipy2p = nint(p(2,i2)/dpy)
c                  ipz2p = nint(p(3,i2)/dpz)
c                  if ((ipx2p.ne.ipx2) .or. (ipy2p.ne.ipy2) .or.
c     &                (ipz2p.ne.ipz2)) then
c                    if ((abs(ipx2).le.mpx) .and. (abs(ipy2).le.my)
c     &                .and. (ipz2.ge.-mpz) .and. (ipz2.le.mpzp)
c     &                .AND. (AM2.LT.1.))
c     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) =
c     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) - 1.
c                    if ((abs(ipx2p).le.mpx) .and. (abs(ipy2p).le.my)
c     &                .and. (ipz2p.ge.-mpz) .and. (ipz2p.le.mpzp)
c     &                .AND. (EM2.LT.1.))
c     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) =
c     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) + 1.
c                  end if
c                end if
clin-10/25/02-end

90004              continue
            AM1=EM1
            AM2=EM2
c            END IF


  400       CONTINUE
c
clin-6/10/03 skips the info output on resonance creations:
c            goto 550
cclin-4/30/03 study phi,K*,Lambda(1520) resonances at creation:
cc     note that no decays give these particles, so don't need to consider nnn:
c            if(iblock.ne.0.and.(lb(i1).eq.29.or.iabs(lb(i1)).eq.30
c     1           .or.lb(i2).eq.29.or.iabs(lb(i2)).eq.30
c     2           .or.lb1i.eq.29.or.iabs(lb1i).eq.30
c     3           .or.lb2i.eq.29.or.iabs(lb2i).eq.30)) then
c               lb1now=lb(i1)
c               lb2now=lb(i2)
cc
c               nphi0=0
c               nksp0=0
c               nksm0=0
cc               nlar0=0
cc               nlarbar0=0
c               if(lb1i.eq.29) then
c                  nphi0=nphi0+1
c               elseif(lb1i.eq.30) then
c                  nksp0=nksp0+1
c               elseif(lb1i.eq.-30) then
c                  nksm0=nksm0+1
c               endif
c               if(lb2i.eq.29) then
c                  nphi0=nphi0+1
c               elseif(lb2i.eq.30) then
c                  nksp0=nksp0+1
c               elseif(lb2i.eq.-30) then
c                  nksm0=nksm0+1
c               endif
cc
c               nphi=0
c               nksp=0
c               nksm=0
c               nlar=0
c               nlarbar=0
c               if(lb1now.eq.29) then
c                  nphi=nphi+1
c               elseif(lb1now.eq.30) then
c                  nksp=nksp+1
c               elseif(lb1now.eq.-30) then
c                  nksm=nksm+1
c               endif
c               if(lb2now.eq.29) then
c                  nphi=nphi+1
c               elseif(lb2now.eq.30) then
c                  nksp=nksp+1
c               elseif(lb2now.eq.-30) then
c                  nksm=nksm+1
c               endif
cc     
c               if(nphi.eq.2.or.nksp.eq.2.or.nksm.eq.2) then
c                  write(91,*) '2 same resonances in one reaction!'
c                  write(91,*) nphi,nksp,nksm,iblock
c               endif
c
cc     All reactions create or destroy no more than 1 these resonance,
cc     otherwise file "fort.91" warns us:
c               do 222 ires=1,3
c                  if(ires.eq.1.and.nphi.ne.nphi0) then
c                     idr=29
c                  elseif(ires.eq.2.and.nksp.ne.nksp0) then
c                     idr=30
c                  elseif(ires.eq.3.and.nksm.ne.nksm0) then
c                     idr=-30
c                  else
c                     goto 222
c                  endif
cctest off for resonance (phi, K*) studies:
cc               if(lb1now.eq.idr) then
cc       write(17,112) 'collision',lb1now,P(1,I1),P(2,I1),P(3,I1),e(I1),nt
cc               elseif(lb2now.eq.idr) then
cc       write(17,112) 'collision',lb2now,P(1,I2),P(2,I2),P(3,I2),e(I2),nt
cc               elseif(lb1i.eq.idr) then
cc       write(18,112) 'collision',lb1i,px1i,py1i,pz1i,em1i,nt
cc               elseif(lb2i.eq.idr) then
cc       write(18,112) 'collision',lb2i,px2i,py2i,pz2i,em2i,nt
cc               endif
c 222           continue
c
c            else
c            endif
cc 112        format(a10,I4,4(1x,f9.3),1x,I4)
c
clin-2/26/03 skips the check of energy conservation after each binary search:
c 550        goto 555
c            pxfin=0
c            pyfin=0
c            pzfin=0
c            efin=0
c            if(e(i1).ne.0.or.lb(i1).eq.10022) then
c               efin=efin+SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
c               pxfin=pxfin+P(1,I1)
c               pyfin=pyfin+P(2,I1)
c               pzfin=pzfin+P(3,I1)
c            endif
c            if(e(i2).ne.0.or.lb(i2).eq.10022) then
c               efin=efin+SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
c               pxfin=pxfin+P(1,I2)
c               pyfin=pyfin+P(2,I2)
c               pzfin=pzfin+P(3,I2)
c            endif
c            if((nnn-nnnini).ge.1) then
c               do imore=nnnini+1,nnn
c                  if(EPION(imore,IRUN).ne.0) then
c                     efin=efin+SQRT(EPION(imore,IRUN)**2
c     1                    +PPION(1,imore,IRUN)**2+PPION(2,imore,IRUN)**2
c     2                    +PPION(3,imore,IRUN)**2)
c                     pxfin=pxfin+PPION(1,imore,IRUN)
c                     pyfin=pyfin+PPION(2,imore,IRUN)
c                     pzfin=pzfin+PPION(3,imore,IRUN)
c                  endif
c               enddo
c            endif
c            devio=sqrt((pxfin-pxini)**2+(pyfin-pyini)**2
c     1           +(pzfin-pzini)**2+(efin-eini)**2)
cc
c            if(devio.ge.0.1) then
c               write(92,'a20,5(1x,i6),2(1x,f8.3)') 'iblock,lb,npi=',
c     1              iblock,lb1i,lb2i,lb(i1),lb(i2),e(i1),e(i2)
c               do imore=nnnini+1,nnn
c                  if(EPION(imore,IRUN).ne.0) then
c                     write(92,'a10,2(1x,i6)') 'ipi,lbm=',
c     1                    imore,LPION(imore,IRUN)
c                  endif
c               enddo
c               write(92,'a3,4(1x,f8.3)') 'I:',eini,pxini,pyini,pzini
c               write(92,'a3,5(1x,f8.3)') 
c     1              'F:',efin,pxfin,pyfin,pzfin,devio
c            endif
c
 555        continue
ctest off only one collision for the same 2 particles in the same timestep:
c            if(iblock.ne.0) then
c               goto 800
c            endif
ctest off collisions history:
c            if(iblock.ne.0) then 
c               write(10,*) nt,i1,i2,iblock,x1,z1,x2,z2
c            endif

  600     CONTINUE

clin-4/2012 option of pi0 decays:
c     particles in lpion() may be a pi0, and when ipi0dcy=1 
c     we need to decay them at nt=ntmax after all lb(i1) decays are done:
 798      if(nt.eq.ntmax.and.ipi0dcy.eq.1
     1         .and.i1.eq.(MASSR(IRUN)+MSUM)) then
             do ipion=1,NNN
                if(LPION(ipion,IRUN).eq.4) then
                   wid=7.85e-9
                   call resdec(i1,nt,nnn,wid,idecay,ipion)
                endif
             enddo
          endif
ctest off
c          if(nt.eq.ntmax.and.i1.eq.(MASSR(IRUN)+MSUM)) then
c             do ip=1,i1
c                write(98,*) lb(ip),e(ip),ip
c             enddo
c          endif

clin-4/2012 option of pi0 decays-end

  800   CONTINUE
* RELABLE MESONS LEFT IN THIS RUN EXCLUDING THOSE BEING CREATED DURING
* THIS TIME STEP AND COUNT THE TOTAL NO. OF PARTICLES IN THIS RUN
* note that the first mass=mta+mpr particles are baryons
c        write(*,*)'I: NNN,massr ', nnn,massr(irun)
        N0=MASS+MSUM
        DO 1005 N=N0+1,MASSR(IRUN)+MSUM
cbz11/25/98
clin-2/19/03 lb>5000: keep particles with no LB codes in ART(photon,lepton,..):
c        IF(E(N).GT.0.)THEN
        IF(E(N) .GT. 0. .OR. LB(N) .GT. 5000)THEN
cbz11/25/98end
        NNN=NNN+1
        RPION(1,NNN,IRUN)=R(1,N)
        RPION(2,NNN,IRUN)=R(2,N)
        RPION(3,NNN,IRUN)=R(3,N)
clin-10/28/03:
        if(nt.eq.ntmax) then
           ftpisv(NNN,IRUN)=ftsv(N)
           tfdpi(NNN,IRUN)=tfdcy(N)
        endif
c
        PPION(1,NNN,IRUN)=P(1,N)
        PPION(2,NNN,IRUN)=P(2,N)
        PPION(3,NNN,IRUN)=P(3,N)
        EPION(NNN,IRUN)=E(N)
        LPION(NNN,IRUN)=LB(N)
c       !! sp 12/19/00
        PROPI(NNN,IRUN)=PROPER(N)
clin-5/2008:
        dppion(NNN,IRUN)=dpertp(N)
c        if(lb(n) .eq. 45)
c    &   write(*,*)'IN-1  NT,NNN,LB,P ',nt,NNN,lb(n),proper(n)
        ENDIF
 1005 CONTINUE
        MASSRN(IRUN)=NNN+MASS
c        write(*,*)'F: NNN,massrn ', nnn,massrn(irun)
1000   CONTINUE
* CALCULATE THE AVERAGE SRT FOR N + N--->N +DELTA PROCESSES
C        IF(NODELT.NE.0)THEN
C        AVSRT=SUMSRT/FLOAT(NODELT)
C        ELSE
C        AVSRT=0.
C        ENDIF
C        WRITE(1097,'(F8.2,2X,E10.3)')FLOAT(NT)*DT,AVSRT
* RELABLE ALL THE PARTICLES EXISTING AFTER THIS TIME STEP
        IA=0
        IB=0
        DO 10001 IRUN=1,NUM
        IA=IA+MASSR(IRUN-1)
        IB=IB+MASSRN(IRUN-1)
        DO 10001 IC=1,MASSRN(IRUN)
        IE=IA+IC
        IG=IB+IC
        IF(IC.LE.MASS)THEN
        RT(1,IG)=R(1,IE)
        RT(2,IG)=R(2,IE)
        RT(3,IG)=R(3,IE)
clin-10/28/03:
        if(nt.eq.ntmax) then
           fttemp(IG)=ftsv(IE)
           tft(IG)=tfdcy(IE)
        endif
c
        PT(1,IG)=P(1,IE)
        PT(2,IG)=P(2,IE)
        PT(3,IG)=P(3,IE)
        ET(IG)=E(IE)
        LT(IG)=LB(IE)
        PROT(IG)=PROPER(IE)
clin-5/2008:
        dptemp(IG)=dpertp(IE)
        ELSE
        I0=IC-MASS
        RT(1,IG)=RPION(1,I0,IRUN)
        RT(2,IG)=RPION(2,I0,IRUN)
        RT(3,IG)=RPION(3,I0,IRUN)
clin-10/28/03:
        if(nt.eq.ntmax) then
           fttemp(IG)=ftpisv(I0,IRUN)
           tft(IG)=tfdpi(I0,IRUN)
        endif
c
        PT(1,IG)=PPION(1,I0,IRUN)
        PT(2,IG)=PPION(2,I0,IRUN)
        PT(3,IG)=PPION(3,I0,IRUN)
        ET(IG)=EPION(I0,IRUN)
        LT(IG)=LPION(I0,IRUN)
        PROT(IG)=PROPI(I0,IRUN)
clin-5/2008:
        dptemp(IG)=dppion(I0,IRUN)
        ENDIF
10001   CONTINUE
c
        IL=0
clin-10/26/01-hbt:
c        DO 10002 IRUN=1,NUM
        DO 10003 IRUN=1,NUM

        MASSR(IRUN)=MASSRN(IRUN)
        IL=IL+MASSR(IRUN-1)
        DO 10002 IM=1,MASSR(IRUN)
        IN=IL+IM
        R(1,IN)=RT(1,IN)
        R(2,IN)=RT(2,IN)
        R(3,IN)=RT(3,IN)
clin-10/28/03:
        if(nt.eq.ntmax) then
           ftsv(IN)=fttemp(IN)
           tfdcy(IN)=tft(IN)
        endif
        P(1,IN)=PT(1,IN)
        P(2,IN)=PT(2,IN)
        P(3,IN)=PT(3,IN)
        E(IN)=ET(IN)
        LB(IN)=LT(IN)
        PROPER(IN)=PROT(IN)
clin-5/2008:
        dpertp(IN)=dptemp(IN)
       IF(LB(IN).LT.1.OR.LB(IN).GT.2)ID(IN)=0
10002   CONTINUE
clin-ctest off check energy conservation after each timestep
c         enetot=0.
c         do ip=1,MASSR(IRUN)
c            if(e(ip).ne.0.or.lb(ip).eq.10022) enetot=enetot
c     1           +sqrt(p(1,ip)**2+p(2,ip)**2+p(3,ip)**2+e(ip)**2)
c         enddo
c         write(91,*) 'B:',nt,enetot,massr(irun),bimp 
clin-3/2009 move to the end of a timestep to take care of freezeout spacetime:
c        call hbtout(MASSR(IRUN),nt,ntmax)
10003 CONTINUE
c
      RETURN
      END

clin-9/2012: use double precision for S in CMS(): to avoid crash 
c     (segmentation fault due to s<0, which happened at high energies 
c     such as LHC with large NTMAX for two almost-comoving hadrons
c     that have small Pt but large |Pz|):
****************************************
c            SUBROUTINE CMS(I1,I2,PX1CM,PY1CM,PZ1CM,SRT)
* PURPOSE : FIND THE MOMENTA OF PARTICLES IN THE CMS OF THE
*          TWO COLLIDING PARTICLES
* VARIABLES :
*****************************************
c            PARAMETER (MAXSTR=150001)
c            COMMON   /AA/  R(3,MAXSTR)
ccc      SAVE /AA/
c            COMMON   /BB/  P(3,MAXSTR)
ccc      SAVE /BB/
c            COMMON   /CC/  E(MAXSTR)
ccc      SAVE /CC/
c            COMMON   /BG/  BETAX,BETAY,BETAZ,GAMMA
ccc      SAVE /BG/
c            SAVE   
c            PX1=P(1,I1)
c            PY1=P(2,I1)
c            PZ1=P(3,I1)
c            PX2=P(1,I2)
c            PY2=P(2,I2)
c            PZ2=P(3,I2)
c            EM1=E(I1)
c            EM2=E(I2)
c            E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
c            E2=SQRT(EM2**2 + PX2**2 + PY2**2 + PZ2**2 )
c            S=(E1+E2)**2-(PX1+PX2)**2-(PY1+PY2)**2-(PZ1+PZ2)**2
c            SRT=SQRT(S)
c*LORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
c              ETOTAL = E1 + E2
c              BETAX  = (PX1+PX2) / ETOTAL
c              BETAY  = (PY1+PY2) / ETOTAL
c              BETAZ  = (PZ1+PZ2) / ETOTAL
c              GAMMA  = 1.0 / SQRT(1.0-BETAX**2-BETAY**2-BETAZ**2)
c*TRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
c              P1BETA = PX1*BETAX + PY1*BETAY + PZ1 * BETAZ
c              TRANSF = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) - E1 )
c              PX1CM  = BETAX * TRANSF + PX1
c              PY1CM  = BETAY * TRANSF + PY1
c              PZ1CM  = BETAZ * TRANSF + PZ1
c              RETURN
c              END
****************************************
            SUBROUTINE CMS(I1,I2,PX1CM,PY1CM,PZ1CM,SRT)
* PURPOSE : FIND THE MOMENTA OF PARTICLES IN THE CMS OF THE
*          TWO COLLIDING PARTICLES
* VARIABLES :
*****************************************
            PARAMETER (MAXSTR=150001)
            double precision px1,py1,pz1,px2,py2,pz2,em1,em2,e1,e2,
     1      s,ETOTAL,P1BETA,TRANSF,dBETAX,dBETAY,dBETAZ,dGAMMA,scheck
            COMMON   /BB/  P(3,MAXSTR)
            COMMON   /CC/  E(MAXSTR)
            COMMON   /BG/  BETAX,BETAY,BETAZ,GAMMA
            SAVE   
            PX1=dble(P(1,I1))
            PY1=dble(P(2,I1))
            PZ1=dble(P(3,I1))
            PX2=dble(P(1,I2))
            PY2=dble(P(2,I2))
            PZ2=dble(P(3,I2))
            EM1=dble(E(I1))
            EM2=dble(E(I2))
            E1=dSQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
            E2=dSQRT(EM2**2+PX2**2+PY2**2+PZ2**2)
            S=(E1+E2)**2-(PX1+PX2)**2-(PY1+PY2)**2-(PZ1+PZ2)**2
            IF(S.LE.0) S=0d0
            SRT=sngl(dSQRT(S))
*LORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
            ETOTAL = E1 + E2
            dBETAX  = (PX1+PX2) / ETOTAL
            dBETAY  = (PY1+PY2) / ETOTAL
            dBETAZ  = (PZ1+PZ2) / ETOTAL
clin-9/2012: check argument in sqrt():
            scheck=1.d0-dBETAX**2-dBETAY**2-dBETAZ**2
            if(scheck.le.0d0) then
               write(99,*) 'scheck1: ', scheck
               stop
            endif
            dGAMMA=1.d0/dSQRT(scheck)
*TRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
            P1BETA = PX1*dBETAX + PY1*dBETAY + PZ1 * dBETAZ
            TRANSF = dGAMMA * ( dGAMMA * P1BETA / (dGAMMA + 1d0) - E1 )
            PX1CM  = sngl(dBETAX * TRANSF + PX1)
            PY1CM  = sngl(dBETAY * TRANSF + PY1)
            PZ1CM  = sngl(dBETAZ * TRANSF + PZ1)
            BETAX  = sngl(dBETAX)
            BETAY  = sngl(dBETAY)
            BETAZ  = sngl(dBETAZ)
            GAMMA  = sngl(dGAMMA)
            RETURN
            END
clin-9/2012-end

***************************************
            SUBROUTINE DISTCE(I1,I2,DELTAR,DS,DT,EC,SRT
     1      ,IC,PX1CM,PY1CM,PZ1CM)
* PURPOSE : CHECK IF THE COLLISION BETWEEN TWO PARTICLES CAN HAPPEN
*           BY CHECKING
*                      (1) IF THE DISTANCE BETWEEN THEM IS SMALLER
*           THAN THE MAXIMUM DISTANCE DETERMINED FROM THE CROSS SECTION.
*                      (2) IF PARTICLE WILL PASS EACH OTHER WITHIN
*           TWO HARD CORE RADIUS.
*                      (3) IF PARTICLES WILL GET CLOSER.
* VARIABLES :
*           IC=1 COLLISION HAPPENED
*           IC=-1 COLLISION CAN NOT HAPPEN
*****************************************
            PARAMETER (MAXSTR=150001)
            COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
            COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
            COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
            COMMON   /BG/  BETAX,BETAY,BETAZ,GAMMA
            COMMON  /EE/      ID(MAXSTR),LB(MAXSTR)
cc      SAVE /BG/
            common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1           px1n,py1n,pz1n,dp1n
            common /dpi/em2,lb2
            SAVE   
            IC=0
            X1=R(1,I1)
            Y1=R(2,I1)
            Z1=R(3,I1)
            PX1=P(1,I1)
            PY1=P(2,I1)
            PZ1=P(3,I1)
            X2=R(1,I2)
            Y2=R(2,I2)
            Z2=R(3,I2)
            PX2=P(1,I2)
            PY2=P(2,I2)
            PZ2=P(3,I2)
            EM1=E(I1)
            EM2=E(I2)
            E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
c            IF (ABS(X1-X2) .GT. DELTAR) GO TO 400
c            IF (ABS(Y1-Y2) .GT. DELTAR) GO TO 400
c            IF (ABS(Z1-Z2) .GT. DELTAR) GO TO 400
            RSQARE = (X1-X2)**2 + (Y1-Y2)**2 + (Z1-Z2)**2
            IF (RSQARE .GT. DELTAR**2) GO TO 400
*NOW PARTICLES ARE CLOSE ENOUGH TO EACH OTHER !
              E2     = SQRT ( EM2**2 + PX2**2 + PY2**2 + PZ2**2 )
              S      = SRT*SRT
            IF (S .LT. EC) GO TO 400
*NOW THERE IS ENOUGH ENERGY AVAILABLE !
*LORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
* BETAX, BETAY, BETAZ AND GAMMA HAVE BEEN GIVEN IN THE SUBROUTINE CMS
*TRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
              P1BETA = PX1*BETAX + PY1*BETAY + PZ1 * BETAZ
              TRANSF = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) - E1 )
              PRCM   = SQRT (PX1CM**2 + PY1CM**2 + PZ1CM**2)
              IF (PRCM .LE. 0.00001) GO TO 400
*TRANSFORMATION OF SPATIAL DISTANCE
              DRBETA = BETAX*(X1-X2) + BETAY*(Y1-Y2) + BETAZ*(Z1-Z2)
              TRANSF = GAMMA * GAMMA * DRBETA / (GAMMA + 1)
              DXCM   = BETAX * TRANSF + X1 - X2
              DYCM   = BETAY * TRANSF + Y1 - Y2
              DZCM   = BETAZ * TRANSF + Z1 - Z2
*DETERMINING IF THIS IS THE POINT OF CLOSEST APPROACH
              DRCM   = SQRT (DXCM**2  + DYCM**2  + DZCM**2 )
              DZZ    = (PX1CM*DXCM + PY1CM*DYCM + PZ1CM*DZCM) / PRCM
              if ((drcm**2 - dzz**2) .le. 0.) then
                BBB = 0.
              else
                BBB    = SQRT (DRCM**2 - DZZ**2)
              end if
*WILL PARTICLE PASS EACH OTHER WITHIN 2 * HARD CORE RADIUS ?
              IF (BBB .GT. DS) GO TO 400
              RELVEL = PRCM * (1.0/E1 + 1.0/E2)
              DDD    = RELVEL * DT * 0.5
*WILL PARTICLES GET CLOSER ?
              IF (ABS(DDD) .LT. ABS(DZZ)) GO TO 400
              IC=1
              GO TO 500
400           IC=-1
500           CONTINUE
              RETURN
              END
****************************************
*                                                                      *
*                                                                      *
      SUBROUTINE CRNN(IRUN,PX,PY,PZ,SRT,I1,I2,IBLOCK,
     1NTAG,SIGNN,SIG,NT,ipert1)
*     PURPOSE:                                                         *
*             DEALING WITH NUCLEON-NUCLEON COLLISIONS                    *
*     NOTE   :                                                         *
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
*           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
*           IBLOCK   - THE INFORMATION BACK                            *
*                      0-> COLLISION CANNOT HAPPEN                     *
*                      1-> N-N ELASTIC COLLISION                       *
*                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
*                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
*                      4-> N+N->D+D+pion reaction
*                     43->N+N->D(N*)+D(N*) reaction
*                     44->N+N->D+D+rho reaction
*                     45->N+N->N+N+rho
*                     46->N+N->N+N+omega
*           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
*                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
*                      N12,                                            *
*                      M12=1 FOR p+n-->delta(+)+ n                     *
*                          2     p+n-->delta(0)+ p                     *
*                          3     p+p-->delta(++)+n                     *
*                          4     p+p-->delta(+)+p                      *
*                          5     n+n-->delta(0)+n                      *
*                          6     n+n-->delta(-)+p                      *
*                          7     n+p-->N*(0)(1440)+p                   *
*                          8     n+p-->N*(+)(1440)+n                   *
*                        9     p+p-->N*(+)(1535)+p                     *
*                        10    n+n-->N*(0)(1535)+n                     *
*                         11    n+p-->N*(+)(1535)+n                     *
*                        12    n+p-->N*(0)(1535)+p
*                        13    D(++)+D(-)-->N*(+)(1440)+n
*                         14    D(++)+D(-)-->N*(0)(1440)+p
*                        15    D(+)+D(0)--->N*(+)(1440)+n
*                        16    D(+)+D(0)--->N*(0)(1440)+p
*                        17    D(++)+D(0)-->N*(+)(1535)+p
*                        18    D(++)+D(-)-->N*(0)(1535)+p
*                        19    D(++)+D(-)-->N*(+)(1535)+n
*                        20    D(+)+D(+)-->N*(+)(1535)+p
*                        21    D(+)+D(0)-->N*(+)(1535)+n
*                        22    D(+)+D(0)-->N*(0)(1535)+p
*                        23    D(+)+D(-)-->N*(0)(1535)+n
*                        24    D(0)+D(0)-->N*(0)(1535)+n
*                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
*                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
*                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
*                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
*                        29    N*(+)(14)+D+-->N*(+)(15)+p
*                        30    N*(+)(14)+D0-->N*(+)(15)+n
*                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
*                        32    N*(0)(14)+D++--->N*(+)(15)+p
*                        33    N*(0)(14)+D+--->N*(+)(15)+n
*                        34    N*(0)(14)+D+--->N*(0)(15)+p
*                        35    N*(0)(14)+D0-->N*(0)(15)+n
*                        36    N*(+)(14)+D0--->N*(0)(15)+p
*                        ++    see the note book for more listing
*                     
*
*     NOTE ABOUT N*(1440) RESORANCE IN Nucleon+NUCLEON COLLISION:      * 
*     As it has been discussed in VerWest's paper,I= 1(initial isospin)*
*     channel can all be attributed to delta resorance while I= 0      *
*     channel can all be  attribured to N* resorance.Only in n+p       *
*     one can have I=0 channel so is the N*(1440) resonance            *
*                                                                      *
*                             REFERENCES:                            *    
*                    J. CUGNON ET AL., NUCL. PHYS. A352, 505 (1981)    *
*                    Y. KITAZOE ET AL., PHYS. LETT. 166B, 35 (1986)    *
*                    B. VerWest el al., PHYS. PRV. C25 (1982)1979      *
*                    Gy. Wolf  et al, Nucl Phys A517 (1990) 615;       *
*                                     Nucl phys A552 (1993) 349.       *
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,aka=0.498,AP2=0.13957,AM0=1.232,
     2  PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383,APHI=1.020)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        parameter (xmd=1.8756,npdmax=10000)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common /ff/f(-mx:mx,-my:my,-mz:mz,-mpx:mpx,-mpy:mpy,-mpz:mpzp)
cc      SAVE /ff/
        common /gg/ dx,dy,dz,dpx,dpy,dpz
cc      SAVE /gg/
        COMMON /INPUT/ NSTAR,NDIRCT,DIR
cc      SAVE /INPUT/
        COMMON /NN/NNN
cc      SAVE /NN/
        COMMON /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
        COMMON/TABLE/ xarray(0:1000),earray(0:1000)
cc      SAVE /TABLE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1 px1n,py1n,pz1n,dp1n
cc      SAVE /leadng/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      common /dpi/em2,lb2
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      common /para8/ idpert,npertd,idxsec
      dimension ppd(3,npdmax),lbpd(npdmax)
      SAVE   
*-----------------------------------------------------------------------
      n12=0
      m12=0
      IBLOCK=0
      NTAG=0
      EM1=E(I1)
      EM2=E(I2)
      PR=SQRT( PX**2 + PY**2 + PZ**2 )
      C2=PZ / PR
      X1=RANART(NSEED)
      ianti=0
      if(lb(i1).lt.0 .and. lb(i2).lt.0) ianti=1
      call sbbdm(srt,sdprod,ianti,lbm,xmm,pfinal)
clin-5/2008 Production of perturbative deuterons for idpert=1:
      if(idpert.eq.1.and.ipert1.eq.1) then
         IF (SRT .LT. 2.012) RETURN
         if((iabs(lb(i1)).eq.1.or.iabs(lb(i1)).eq.2)
     1        .and.(iabs(lb(i2)).eq.1.or.iabs(lb(i2)).eq.2)) then
            goto 108
         else
            return
         endif
      endif
c
*-----------------------------------------------------------------------
*COM: TEST FOR ELASTIC SCATTERING (EITHER N-N OR DELTA-DELTA 0R
*      N-DELTA OR N*-N* or N*-Delta)
c      IF (X1 .LE. SIGNN/SIG) THEN
      IF (X1.LE.(SIGNN/SIG)) THEN
*COM:  PARAMETRISATION IS TAKEN FROM THE CUGNON-PAPER
         AS  = ( 3.65 * (SRT - 1.8766) )**6
         A   = 6.0 * AS / (1.0 + AS)
         TA  = -2.0 * PR**2
         X   = RANART(NSEED)
clin-10/24/02        T1  = DLOG( (1-X) * DEXP(dble(A)*dble(TA)) + X )  /  A
         T1  = sngl(DLOG(dble(1.-X)*DEXP(dble(A)*dble(TA))+dble(X)))/  A
         C1  = 1.0 - T1/TA
         T1  = 2.0 * PI * RANART(NSEED)
         IBLOCK=1
         GO TO 107
      ELSE
*COM: TEST FOR INELASTIC SCATTERING
*     IF THE AVAILABLE ENERGY IS LESS THAN THE PION-MASS, NOTHING
*     CAN HAPPEN ANY MORE ==> RETURN (2.012 = 2*AVMASS + PI-MASS)
clin-5/2008: Mdeuteron+Mpi=2.0106 to 2.0152 GeV/c2, so we can still use this:
         IF (SRT .LT. 2.012) RETURN
*     calculate the N*(1535) production cross section in N+N collisions
*     note that the cross sections in this subroutine are in units of mb
*     as only ratios of the cross sections are used to determine the
*     reaction channels
       call N1535(iabs(lb(i1)),iabs(lb(i2)),srt,x1535)
*COM: HERE WE HAVE A PROCESS N+N ==> N+DELTA,OR N+N==>N+N*(144) or N*(1535)
*     OR 
* 3 pi channel : N+N==>d1+d2+PION
       SIG3=3.*(X3pi(SRT)+x33pi(srt))
* 2 pi channel : N+N==>d1+d2+d1*n*+n*n*
       SIG4=4.*X2pi(srt)
* 4 pi channel : N+N==>d1+d2+rho
       s4pi=x4pi(srt)
* N+N-->NN+rho channel
       srho=xrho(srt)
* N+N-->NN+omega
       somega=omega(srt)
* CROSS SECTION FOR KAON PRODUCTION from the four channels
* for NLK channel
       akp=0.498
       ak0=0.498
       ana=0.94
       ada=1.232
       al=1.1157
       as=1.1197
       xsk1=0
       xsk2=0
       xsk3=0
       xsk4=0
       xsk5=0
       t1nlk=ana+al+akp
       if(srt.le.t1nlk)go to 222
       XSK1=1.5*PPLPK(SRT)
* for DLK channel
       t1dlk=ada+al+akp
       t2dlk=ada+al-akp
       if(srt.le.t1dlk)go to 222
       es=srt
       pmdlk2=(es**2-t1dlk**2)*(es**2-t2dlk**2)/(4.*es**2)
       pmdlk=sqrt(pmdlk2)
       XSK3=1.5*PPLPK(srt)
* for NSK channel
       t1nsk=ana+as+akp
       t2nsk=ana+as-akp
       if(srt.le.t1nsk)go to 222
       pmnsk2=(es**2-t1nsk**2)*(es**2-t2nsk**2)/(4.*es**2)
       pmnsk=sqrt(pmnsk2)
       XSK2=1.5*(PPK1(srt)+PPK0(srt))
* for DSK channel
       t1DSk=aDa+aS+akp
       t2DSk=aDa+aS-akp
       if(srt.le.t1dsk)go to 222
       pmDSk2=(es**2-t1DSk**2)*(es**2-t2DSk**2)/(4.*es**2)
       pmDSk=sqrt(pmDSk2)
       XSK4=1.5*(PPK1(srt)+PPK0(srt))
csp11/21/01
c phi production
       if(srt.le.(2.*amn+aphi))go to 222
c  !! mb put the correct form
       xsk5 = 0.0001
csp11/21/01 end
c
* THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
 222   SIGK=XSK1+XSK2+XSK3+XSK4

cbz3/7/99 neutralk
        XSK1 = 2.0 * XSK1
        XSK2 = 2.0 * XSK2
        XSK3 = 2.0 * XSK3
        XSK4 = 2.0 * XSK4
        SIGK = 2.0 * SIGK + xsk5
cbz3/7/99 neutralk end
c
** FOR P+P or L/S+L/S COLLISION:
c       lb1=lb(i1)
c       lb2=lb(i2)
        lb1=iabs(lb(i1))
        lb2=iabs(lb(i2))
        IF((LB(I1)*LB(I2).EQ.1).or.
     &       ((lb1.le.17.and.lb1.ge.14).and.(lb2.le.17.and.lb2.ge.14)).
     &       or.((lb1.le.2).and.(lb2.le.17.and.lb2.ge.14)).
     &       or.((lb2.le.2).and.(lb1.le.17.and.lb1.ge.14)))THEN
clin-8/2008 PP->d+meson here:
           IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
           SIG1=SIGMA(SRT,1,1,0)+0.5*SIGMA(SRT,1,1,1)
           SIG2=1.5*SIGMA(SRT,1,1,1)
           SIGND=SIG1+SIG2+SIG3+SIG4+X1535+SIGK+s4pi+srho+somega
clin-5/2008:
c           IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
           IF (X1.GT.(SIGNN+SIGND+sdprod)/SIG)RETURN
           DIR=SIG3/SIGND
           IF(RANART(NSEED).LE.DIR)GO TO 106
           IF(RANART(NSEED).LE.SIGK/(SIGK+X1535+SIG4+SIG2+SIG1
     &          +s4pi+srho+somega))GO TO 306
           if(RANART(NSEED).le.s4pi/(x1535+sig4+sig2+sig1
     &          +s4pi+srho+somega))go to 307
           if(RANART(NSEED).le.srho/(x1535+sig4+sig2+sig1
     &          +srho+somega))go to 308
           if(RANART(NSEED).le.somega/(x1535+sig4+sig2+sig1
     &          +somega))go to 309
           if(RANART(NSEED).le.x1535/(sig1+sig2+sig4+x1535))then
* N*(1535) production
              N12=9
           ELSE 
              IF(RANART(NSEED).LE.SIG4/(SIG1+sig2+sig4))THEN
* DOUBLE DELTA PRODUCTION
                 N12=66
                 GO TO 1012
              else
*DELTA PRODUCTION
                 N12=3
                 IF (RANART(NSEED).GT.SIG1/(SIG1+SIG2))N12=4
              ENDIF
           endif
           GO TO 1011
        ENDIF
** FOR N+N COLLISION:
        IF(iabs(LB(I1)).EQ.2.AND.iabs(LB(I2)).EQ.2)THEN
clin-8/2008 NN->d+meson here:
           IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
           SIG1=SIGMA(SRT,1,1,0)+0.5*SIGMA(SRT,1,1,1)
           SIG2=1.5*SIGMA(SRT,1,1,1)
           SIGND=SIG1+SIG2+X1535+SIG3+SIG4+SIGK+s4pi+srho+somega
clin-5/2008:
c           IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
           IF (X1.GT.(SIGNN+SIGND+sdprod)/SIG)RETURN
           dir=sig3/signd
           IF(RANART(NSEED).LE.DIR)GO TO 106
           IF(RANART(NSEED).LE.SIGK/(SIGK+X1535+SIG4+SIG2+SIG1
     &          +s4pi+srho+somega))GO TO 306
           if(RANART(NSEED).le.s4pi/(x1535+sig4+sig2+sig1
     &          +s4pi+srho+somega))go to 307
           if(RANART(NSEED).le.srho/(x1535+sig4+sig2+sig1
     &          +srho+somega))go to 308
           if(RANART(NSEED).le.somega/(x1535+sig4+sig2+sig1
     &          +somega))go to 309
           IF(RANART(NSEED).LE.X1535/(x1535+sig1+sig2+sig4))THEN
* N*(1535) PRODUCTION
              N12=10
           ELSE 
              if(RANART(NSEED).le.sig4/(sig1+sig2+sig4))then
* double delta production
                 N12=67
                 GO TO 1013
              else
* DELTA PRODUCTION
                 N12=6
                 IF (RANART(NSEED).GT.SIG1/(SIG1+SIG2))N12=5
              ENDIF
           endif
           GO TO 1011
        ENDIF
** FOR N+P COLLISION
        IF(LB(I1)*LB(I2).EQ.2)THEN
clin-5/2008 NP->d+meson here:
           IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
           SIG1=0.5*SIGMA(SRT,1,1,1)+0.25*SIGMA(SRT,1,1,0)
           IF(NSTAR.EQ.1)THEN
              SIG2=(3./4.)*SIGMA(SRT,2,0,1)
           ELSE
              SIG2=0.
           ENDIF
           SIGND=2.*(SIG1+SIG2+X1535)+sig3+sig4+SIGK+s4pi+srho+somega
clin-5/2008:
c           IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
           IF (X1.GT.(SIGNN+SIGND+sdprod)/SIG)RETURN
           dir=sig3/signd
           IF(RANART(NSEED).LE.DIR)GO TO 106
           IF(RANART(NSEED).LE.SIGK/(SIGND-SIG3))GO TO 306
           if(RANART(NSEED).le.s4pi/(signd-sig3-sigk))go to 307
           if(RANART(NSEED).le.srho/(signd-sig3-sigk-s4pi))go to 308
           if(RANART(NSEED).le.somega/(signd-sig3-sigk-s4pi-srho))
     1          go to 309
           IF(RANART(NSEED).LT.X1535/(SIG1+SIG2+X1535+0.5*sig4))THEN
* N*(1535) PRODUCTION
              N12=11
              IF(RANART(NSEED).LE.0.5)N12=12
           ELSE 
              if(RANART(NSEED).le.sig4/(sig4+2.*(sig1+sig2)))then
* double resonance production
                 N12=68
                 GO TO 1014
              else
                 IF(RANART(NSEED).LE.SIG1/(SIG1+SIG2))THEN
* DELTA PRODUCTION
                    N12=2
                    IF(RANART(NSEED).GE.0.5)N12=1
                 ELSE
* N*(1440) PRODUCTION
                    N12=8
                    IF(RANART(NSEED).GE.0.5)N12=7
                 ENDIF
              ENDIF
           ENDIF
        endif
 1011   iblock=2
        CONTINUE
*PARAMETRIZATION OF THE SHAPE OF THE DELTA RESONANCE ACCORDING
*     TO kitazoe's or J.D.JACKSON'S MASS FORMULA AND BREIT WIGNER
*     FORMULA FOR N* RESORANCE
*     DETERMINE DELTA MASS VIA REJECTION METHOD.
          DMAX = SRT - AVMASS-0.005
          DMAX = SRT - AVMASS-0.005
          DMIN = 1.078
                   IF(N12.LT.7)THEN
* Delta(1232) production
          IF(DMAX.LT.1.232) THEN
          FM=FDE(DMAX,SRT,0.)
          ELSE

clin-10/25/02 get rid of argument usage mismatch in FDE():
             xdmass=1.232
c          FM=FDE(1.232,SRT,1.)
          FM=FDE(xdmass,SRT,1.)
clin-10/25/02-end

          ENDIF
          IF(FM.EQ.0.)FM=1.E-09
          NTRY1=0
10        DM = RANART(NSEED) * (DMAX-DMIN) + DMIN
          NTRY1=NTRY1+1
          IF((RANART(NSEED) .GT. FDE(DM,SRT,1.)/FM).AND.
     1    (NTRY1.LE.30)) GOTO 10

clin-2/26/03 limit the Delta mass below a certain value 
c     (here taken as its central value + 2* B-W fullwidth):
          if(dm.gt.1.47) goto 10

              GO TO 13
              ENDIF
                   IF((n12.eq.7).or.(n12.eq.8))THEN
* N*(1440) production
          IF(DMAX.LT.1.44) THEN
          FM=FNS(DMAX,SRT,0.)
          ELSE

clin-10/25/02 get rid of argument usage mismatch in FNS():
             xdmass=1.44
c          FM=FNS(1.44,SRT,1.)
          FM=FNS(xdmass,SRT,1.)
clin-10/25/02-end

          ENDIF
          IF(FM.EQ.0.)FM=1.E-09
          NTRY2=0
11        DM=RANART(NSEED)*(DMAX-DMIN)+DMIN
          NTRY2=NTRY2+1
          IF((RANART(NSEED).GT.FNS(DM,SRT,1.)/FM).AND.
     1    (NTRY2.LE.10)) GO TO 11

clin-2/26/03 limit the N* mass below a certain value 
c     (here taken as its central value + 2* B-W fullwidth):
          if(dm.gt.2.14) goto 11

              GO TO 13
              ENDIF
                    IF(n12.ge.17)then
* N*(1535) production
          IF(DMAX.LT.1.535) THEN
          FM=FD5(DMAX,SRT,0.)
          ELSE

clin-10/25/02 get rid of argument usage mismatch in FNS():
             xdmass=1.535
c          FM=FD5(1.535,SRT,1.)
          FM=FD5(xdmass,SRT,1.)
clin-10/25/02-end

          ENDIF
          IF(FM.EQ.0.)FM=1.E-09
          NTRY1=0
12        DM = RANART(NSEED) * (DMAX-DMIN) + DMIN
          NTRY1=NTRY1+1
          IF((RANART(NSEED) .GT. FD5(DM,SRT,1.)/FM).AND.
     1    (NTRY1.LE.10)) GOTO 12

clin-2/26/03 limit the N* mass below a certain value 
c     (here taken as its central value + 2* B-W fullwidth):
          if(dm.gt.1.84) goto 12

         GO TO 13
             ENDIF
* CALCULATE THE MASSES OF BARYON RESONANCES IN THE DOUBLE RESONANCE
* PRODUCTION PROCESS AND RELABLE THE PARTICLES
1012       iblock=43
       call Rmasdd(srt,1.232,1.232,1.08,
     &  1.08,ISEED,1,dm1,dm2)
       call Rmasdd(srt,1.232,1.44,1.08,
     &  1.08,ISEED,3,dm1n,dm2n)
       IF(N12.EQ.66)THEN
*(1) PP-->DOUBLE RESONANCES
* DETERMINE THE FINAL STATE
       XFINAL=RANART(NSEED)
       IF(XFINAL.LE.0.25)THEN
* (1.1) D+++D0 
       LB(I1)=9
       LB(I2)=7
       e(i1)=dm1
       e(i2)=dm2
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       IF((XFINAL.gt.0.25).and.(xfinal.le.0.5))THEN
* (1.2) D++D+
       LB(I1)=8
       LB(I2)=8
       e(i1)=dm1
       e(i2)=dm2
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       IF((XFINAL.gt.0.5).and.(xfinal.le.0.75))THEN
* (1.3) D+++N*0 
       LB(I1)=9
       LB(I2)=10
       e(i1)=dm1n
       e(i2)=dm2n
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       IF(XFINAL.gt.0.75)then
* (1.4) D++N*+ 
       LB(I1)=8
       LB(I2)=11
       e(i1)=dm1n
       e(i2)=dm2n
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       ENDIF
1013       iblock=43
       call Rmasdd(srt,1.232,1.232,1.08,
     &  1.08,ISEED,1,dm1,dm2)
       call Rmasdd(srt,1.232,1.44,1.08,
     &  1.08,ISEED,3,dm1n,dm2n)
       IF(N12.EQ.67)THEN
*(2) NN-->DOUBLE RESONANCES
* DETERMINE THE FINAL STATE
       XFINAL=RANART(NSEED)
       IF(XFINAL.LE.0.25)THEN
* (2.1) D0+D0 
       LB(I1)=7
       LB(I2)=7
       e(i1)=dm1
       e(i2)=dm2
       GO TO 200
* go to 200 to set the new momentum
        ENDIF
       IF((XFINAL.gt.0.25).and.(xfinal.le.0.5))THEN
* (2.2) D++D+
       LB(I1)=6
       LB(I2)=8
       e(i1)=dm1
       e(i2)=dm2
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       IF((XFINAL.gt.0.5).and.(xfinal.le.0.75))THEN
* (2.3) D0+N*0 
       LB(I1)=7
       LB(I2)=10
       e(i1)=dm1n
       e(i2)=dm2n
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       IF(XFINAL.gt.0.75)then
* (2.4) D++N*+ 
       LB(I1)=8
       LB(I2)=11
       e(i1)=dm1n
       e(i2)=dm2n
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       ENDIF
1014       iblock=43
       call Rmasdd(srt,1.232,1.232,1.08,
     &  1.08,ISEED,1,dm1,dm2)
       call Rmasdd(srt,1.232,1.44,1.08,
     &  1.08,ISEED,3,dm1n,dm2n)
       IF(N12.EQ.68)THEN
*(3) NP-->DOUBLE RESONANCES
* DETERMINE THE FINAL STATE
       XFINAL=RANART(NSEED)
       IF(XFINAL.LE.0.25)THEN
* (3.1) D0+D+ 
       LB(I1)=7
       LB(I2)=8
       e(i1)=dm1
       e(i2)=dm2
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       IF((XFINAL.gt.0.25).and.(xfinal.le.0.5))THEN
* (3.2) D+++D-
       LB(I1)=9
       LB(I2)=6
       e(i1)=dm1
       e(i2)=dm2
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       IF((XFINAL.gt.0.5).and.(xfinal.le.0.75))THEN
* (3.3) D0+N*+ 
       LB(I1)=7
       LB(I2)=11
       e(i1)=dm1n
       e(i2)=dm2n
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       IF(XFINAL.gt.0.75)then
* (3.4) D++N*0
       LB(I1)=8
       LB(I2)=10
       e(i1)=dm1n
       e(i2)=dm2n
       GO TO 200
* go to 200 to set the new momentum
       ENDIF
       ENDIF
13       CONTINUE
*-------------------------------------------------------
* RELABLE BARYON I1 AND I2
*1. p+n-->delta(+)+n
          IF(N12.EQ.1)THEN
          IF(iabs(LB(I1)).EQ.1)THEN
          LB(I2)=2
          LB(I1)=8
          E(I1)=DM
          ELSE
          LB(I1)=2
          LB(I2)=8
          E(I2)=DM
          ENDIF
         GO TO 200
          ENDIF
*2 p+n-->delta(0)+p
          IF(N12.EQ.2)THEN
          IF(iabs(LB(I1)).EQ.2)THEN
          LB(I2)=1
          LB(I1)=7
          E(I1)=DM
          ELSE
          LB(I1)=1
          LB(I2)=7
          E(I2)=DM
          ENDIF
         GO TO 200
          ENDIF
*3 p+p-->delta(++)+n
          IF(N12.EQ.3)THEN
          LB(I1)=9
          E(I1)=DM
          LB(I2)=2
          E(I2)=AMN
         GO TO 200
          ENDIF
*4 p+p-->delta(+)+p
          IF(N12.EQ.4)THEN
          LB(I2)=1
          LB(I1)=8
          E(I1)=DM
         GO TO 200
          ENDIF
*5 n+n--> delta(0)+n
          IF(N12.EQ.5)THEN
          LB(I2)=2
          LB(I1)=7
          E(I1)=DM
         GO TO 200
          ENDIF
*6 n+n--> delta(-)+p
          IF(N12.EQ.6)THEN
          LB(I1)=6
          E(I1)=DM
          LB(I2)=1
          E(I2)=AMP
         GO TO 200
          ENDIF
*7 n+p--> N*(0)+p
          IF(N12.EQ.7)THEN
          IF(iabs(LB(I1)).EQ.1)THEN
          LB(I1)=1
          LB(I2)=10
          E(I2)=DM
          ELSE
          LB(I2)=1
          LB(I1)=10
          E(I1)=DM
          ENDIF
         GO TO 200
          ENDIF
*8 n+p--> N*(+)+n
          IF(N12.EQ.8)THEN
          IF(iabs(LB(I1)).EQ.1)THEN
          LB(I2)=2
          LB(I1)=11
          E(I1)=DM
          ELSE
          LB(I1)=2
          LB(I2)=11
          E(I2)=DM
          ENDIF
         GO TO 200
          ENDIF
*9 p+p--> N*(+)(1535)+p
          IF(N12.EQ.9)THEN
          IF(RANART(NSEED).le.0.5)THEN
          LB(I2)=1
          LB(I1)=13
          E(I1)=DM
          ELSE
          LB(I1)=1
          LB(I2)=13
          E(I2)=DM
          ENDIF
         GO TO 200
          ENDIF
*10 n+n--> N*(0)(1535)+n
          IF(N12.EQ.10)THEN
          IF(RANART(NSEED).le.0.5)THEN
          LB(I2)=2
          LB(I1)=12
          E(I1)=DM
          ELSE
          LB(I1)=2
          LB(I2)=12
          E(I2)=DM
          ENDIF
         GO TO 200
          ENDIF
*11 n+p--> N*(+)(1535)+n
          IF(N12.EQ.11)THEN
          IF(iabs(LB(I1)).EQ.2)THEN
          LB(I1)=2
          LB(I2)=13
          E(I2)=DM
          ELSE
          LB(I2)=2
          LB(I1)=13
          E(I1)=DM
          ENDIF
         GO TO 200
          ENDIF
*12 n+p--> N*(0)(1535)+p
          IF(N12.EQ.12)THEN
          IF(iabs(LB(I1)).EQ.1)THEN
          LB(I1)=1
          LB(I2)=12
          E(I2)=DM
          ELSE
          LB(I2)=1
          LB(I1)=12
          E(I1)=DM
          ENDIF
          ENDIF
         endif
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
200       EM1=E(I1)
          EM2=E(I2)
          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)
              if(srt.le.2.14)C1= 1.0 - 2.0 * RANART(NSEED)
         if(srt.gt.2.14.and.srt.le.2.4)c1=ang(srt,iseed)
         if(srt.gt.2.4)then

clin-10/25/02 get rid of argument usage mismatch in PTR():
             xptr=0.33*pr
c         cc1=ptr(0.33*pr,iseed)
             cc1=ptr(xptr,iseed)
clin-10/25/02-end

clin-9/2012: check argument in sqrt():
             scheck=pr**2-cc1**2
             if(scheck.lt.0) then
                write(99,*) 'scheck2: ', scheck
                scheck=0.
             endif
             c1=sqrt(scheck)/pr
c             c1=sqrt(pr**2-cc1**2)/pr

         endif
          T1   = 2.0 * PI * RANART(NSEED)
       if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
         lb(i1) = -lb(i1)
         lb(i2) = -lb(i2)
       endif
          GO TO 107
*FOR THE NN-->D1+D2+PI PROCESS, FIND MOMENTUM OF THE FINAL TWO
*DELTAS AND PION IN THE NUCLEUS-NUCLEUS CMS.
106     CONTINUE
           NTRY1=0
123        CALL DDP2(SRT,ISEED,PX3,PY3,PZ3,DM3,PX4,PY4,PZ4,DM4,
     &  PPX,PPY,PPZ,icou1)
       NTRY1=NTRY1+1
       if((icou1.lt.0).AND.(NTRY1.LE.40))GO TO 123
C       if(icou1.lt.0)return
* ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
       CALL ROTATE(PX,PY,PZ,PX3,PY3,PZ3)
       CALL ROTATE(PX,PY,PZ,PX4,PY4,PZ4)
       CALL ROTATE(PX,PY,PZ,PPX,PPY,PPZ)
                NNN=NNN+1
* DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
* (1) FOR P+P
              XDIR=RANART(NSEED)
                IF(LB(I1)*LB(I2).EQ.1)THEN
                IF(XDIR.Le.0.2)then
* (1.1)P+P-->D+++D0+PION(0)
                LPION(NNN,IRUN)=4
                EPION(NNN,IRUN)=AP1
              LB(I1)=9
              LB(I2)=7
       GO TO 205
                ENDIF
* (1.2)P+P -->D++D+PION(0)
                IF((XDIR.LE.0.4).AND.(XDIR.GT.0.2))THEN
                LPION(NNN,IRUN)=4
                EPION(NNN,IRUN)=AP1
                LB(I1)=8
                LB(I2)=8
       GO TO 205
              ENDIF 
* (1.3)P+P-->D+++D+PION(-)
                IF((XDIR.LE.0.6).AND.(XDIR.GT.0.4))THEN
                LPION(NNN,IRUN)=3
                EPION(NNN,IRUN)=AP2
                LB(I1)=9
                LB(I2)=8
       GO TO 205
              ENDIF 
                IF((XDIR.LE.0.8).AND.(XDIR.GT.0.6))THEN
                LPION(NNN,IRUN)=5
                EPION(NNN,IRUN)=AP2
                LB(I1)=9
                LB(I2)=6
       GO TO 205
              ENDIF 
                IF(XDIR.GT.0.8)THEN
                LPION(NNN,IRUN)=5
                EPION(NNN,IRUN)=AP2
                LB(I1)=7
                LB(I2)=8
       GO TO 205
              ENDIF 
               ENDIF
* (2)FOR N+N
                IF(iabs(LB(I1)).EQ.2.AND.iabs(LB(I2)).EQ.2)THEN
                IF(XDIR.Le.0.2)then
* (2.1)N+N-->D++D-+PION(0)
                LPION(NNN,IRUN)=4
                EPION(NNN,IRUN)=AP1
              LB(I1)=6
              LB(I2)=7
       GO TO 205
                ENDIF
* (2.2)N+N -->D+++D-+PION(-)
                IF((XDIR.LE.0.4).AND.(XDIR.GT.0.2))THEN
                LPION(NNN,IRUN)=3
                EPION(NNN,IRUN)=AP2
                LB(I1)=6
                LB(I2)=9
       GO TO 205
              ENDIF 
* (2.3)P+P-->D0+D-+PION(+)
                IF((XDIR.GT.0.4).AND.(XDIR.LE.0.6))THEN
                LPION(NNN,IRUN)=5
                EPION(NNN,IRUN)=AP2
                LB(I1)=9
                LB(I2)=8
       GO TO 205
              ENDIF 
* (2.4)P+P-->D0+D0+PION(0)
                IF((XDIR.GT.0.6).AND.(XDIR.LE.0.8))THEN
                LPION(NNN,IRUN)=4
                EPION(NNN,IRUN)=AP1
                LB(I1)=7
                LB(I2)=7
       GO TO 205
              ENDIF 
* (2.5)P+P-->D0+D++PION(-)
                IF(XDIR.GT.0.8)THEN
                LPION(NNN,IRUN)=3
                EPION(NNN,IRUN)=AP2
                LB(I1)=7
                LB(I2)=8
       GO TO 205
              ENDIF 
              ENDIF
* (3)FOR N+P
                IF(LB(I1)*LB(I2).EQ.2)THEN
                IF(XDIR.Le.0.17)then
* (3.1)N+P-->D+++D-+PION(0)
                LPION(NNN,IRUN)=4
                EPION(NNN,IRUN)=AP1
              LB(I1)=6
              LB(I2)=9
       GO TO 205
                ENDIF
* (3.2)N+P -->D+++D0+PION(-)
                IF((XDIR.LE.0.34).AND.(XDIR.GT.0.17))THEN
                LPION(NNN,IRUN)=3
                EPION(NNN,IRUN)=AP2
                LB(I1)=7
                LB(I2)=9
       GO TO 205
              ENDIF 
* (3.3)N+P-->D++D-+PION(+)
                IF((XDIR.GT.0.34).AND.(XDIR.LE.0.51))THEN
                LPION(NNN,IRUN)=5
                EPION(NNN,IRUN)=AP2
                LB(I1)=7
                LB(I2)=8
       GO TO 205
              ENDIF 
* (3.4)N+P-->D++D++PION(-)
                IF((XDIR.GT.0.51).AND.(XDIR.LE.0.68))THEN
                LPION(NNN,IRUN)=3
                EPION(NNN,IRUN)=AP2
                LB(I1)=8
                LB(I2)=8
       GO TO 205
              ENDIF 
* (3.5)N+P-->D0+D++PION(0)
                IF((XDIR.GT.0.68).AND.(XDIR.LE.0.85))THEN
                LPION(NNN,IRUN)=4
                EPION(NNN,IRUN)=AP2
                LB(I1)=7
                LB(I2)=8
       GO TO 205
              ENDIF 
* (3.6)N+P-->D0+D0+PION(+)
                IF(XDIR.GT.0.85)THEN
                LPION(NNN,IRUN)=5
                EPION(NNN,IRUN)=AP2
                LB(I1)=7
                LB(I2)=7
              ENDIF 
                ENDIF
* FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
* NUCLEUS CMS. FRAME 
*             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
205           E1CM    = SQRT (dm3**2 + PX3**2 + PY3**2 + PZ3**2)
              P1BETA  = PX3*BETAX + PY3*BETAY + PZ3*BETAZ
              TRANSF  = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) + E1CM )
              Pt1i1 = BETAX * TRANSF + PX3
              Pt2i1 = BETAY * TRANSF + PY3
              Pt3i1 = BETAZ * TRANSF + PZ3
             Eti1   = DM3
c
             if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
               lb(i1) = -lb(i1)
               lb(i2) = -lb(i2)
                if(LPION(NNN,IRUN) .eq. 3)then
                  LPION(NNN,IRUN)=5
                elseif(LPION(NNN,IRUN) .eq. 5)then
                  LPION(NNN,IRUN)=3
                endif
               endif
c
             lb1=lb(i1)
* FOR DELTA2
                E2CM    = SQRT (dm4**2 + PX4**2 + PY4**2 + PZ4**2)
                P2BETA  = PX4*BETAX+PY4*BETAY+PZ4*BETAZ
                TRANSF  = GAMMA * (GAMMA*P2BETA / (GAMMA + 1.) + E2CM)
                Pt1I2 = BETAX * TRANSF + PX4
                Pt2I2 = BETAY * TRANSF + PY4
                Pt3I2 = BETAZ * TRANSF + PZ4
              EtI2   = DM4
              lb2=lb(i2)
* assign delta1 and delta2 to i1 or i2 to keep the leadng particle
* behaviour
C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
              p(1,i1)=pt1i1
              p(2,i1)=pt2i1
              p(3,i1)=pt3i1
              e(i1)=eti1
              lb(i1)=lb1
              p(1,i2)=pt1i2
              p(2,i2)=pt2i2
              p(3,i2)=pt3i2
              e(i2)=eti2
              lb(i2)=lb2
                PX1     = P(1,I1)
                PY1     = P(2,I1)
                PZ1     = P(3,I1)
              EM1       = E(I1)
                ID(I1)  = 2
                ID(I2)  = 2
                ID1     = ID(I1)
                IBLOCK=4
* GET PION'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
                EPCM=SQRT(EPION(NNN,IRUN)**2+PPX**2+PPY**2+PPZ**2)
                PPBETA=PPX*BETAX+PPY*BETAY+PPZ*BETAZ
                TRANSF=GAMMA*(GAMMA*PPBETA/(GAMMA+1.)+EPCM)
                PPION(1,NNN,IRUN)=BETAX*TRANSF+PPX
                PPION(2,NNN,IRUN)=BETAY*TRANSF+PPY
                PPION(3,NNN,IRUN)=BETAZ*TRANSF+PPZ
clin-5/2008:
                dppion(nnn,irun)=dpertp(i1)*dpertp(i2)
clin-5/2008 do not allow smearing in position of produced particles 
c     to avoid immediate reinteraction with the particle I1, I2 or themselves:
c2002        X01 = 1.0 - 2.0 * RANART(NSEED)
c            Y01 = 1.0 - 2.0 * RANART(NSEED)
c            Z01 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2002
c                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
c                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
c                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
                RPION(1,NNN,IRUN)=R(1,I1)
                RPION(2,NNN,IRUN)=R(2,I1)
                RPION(3,NNN,IRUN)=R(3,I1)
c
              go to 90005
clin-5/2008 N+N->Deuteron+pi:
*     FIND MOMENTUM OF THE FINAL PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
 108       CONTINUE
           if(idpert.eq.1.and.ipert1.eq.1.and.npertd.ge.1) then
c     For idpert=1: we produce npertd pert deuterons:
              ndloop=npertd
           elseif(idpert.eq.2.and.npertd.ge.1) then
c     For idpert=2: we first save information for npertd pert deuterons;
c     at the last ndloop we create the regular deuteron+pi 
c     and those pert deuterons:
              ndloop=npertd+1
           else
c     Just create the regular deuteron+pi:
              ndloop=1
           endif
c
           dprob1=sdprod/sig/float(npertd)
           do idloop=1,ndloop
              CALL bbdangle(pxd,pyd,pzd,nt,ipert1,ianti,idloop,pfinal,
     1 dprob1,lbm)
              CALL ROTATE(PX,PY,PZ,PXd,PYd,PZd)
*     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL STATE 
*     FROM THE NN CMS FRAME INTO THE GLOBAL CMS FRAME:
*     For the Deuteron:
              xmass=xmd
              E1dCM=SQRT(xmass**2+PXd**2+PYd**2+PZd**2)
              P1dBETA=PXd*BETAX+PYd*BETAY+PZd*BETAZ
              TRANSF=GAMMA*(GAMMA*P1dBETA/(GAMMA+1.)+E1dCM)
              pxi1=BETAX*TRANSF+PXd
              pyi1=BETAY*TRANSF+PYd
              pzi1=BETAZ*TRANSF+PZd
              if(ianti.eq.0)then
                 lbd=42
              else
                 lbd=-42
              endif
              if(idpert.eq.1.and.ipert1.eq.1.and.npertd.ge.1) then
cccc  Perturbative production for idpert=1:
                 nnn=nnn+1
                 PPION(1,NNN,IRUN)=pxi1
                 PPION(2,NNN,IRUN)=pyi1
                 PPION(3,NNN,IRUN)=pzi1
                 EPION(NNN,IRUN)=xmd
                 LPION(NNN,IRUN)=lbd
                 RPION(1,NNN,IRUN)=R(1,I1)
                 RPION(2,NNN,IRUN)=R(2,I1)
                 RPION(3,NNN,IRUN)=R(3,I1)
clin-5/2008 assign the perturbative probability:
                 dppion(NNN,IRUN)=sdprod/sig/float(npertd)
              elseif(idpert.eq.2.and.idloop.le.npertd) then
clin-5/2008 For idpert=2, we produce NPERTD perturbative (anti)deuterons 
c     only when a regular (anti)deuteron+pi is produced in NN collisions.
c     First save the info for the perturbative deuterons:
                 ppd(1,idloop)=pxi1
                 ppd(2,idloop)=pyi1
                 ppd(3,idloop)=pzi1
                 lbpd(idloop)=lbd
              else
cccc  Regular production:
c     For the regular pion: do LORENTZ-TRANSFORMATION:
                 E(i1)=xmm
                 E2piCM=SQRT(xmm**2+PXd**2+PYd**2+PZd**2)
                 P2piBETA=-PXd*BETAX-PYd*BETAY-PZd*BETAZ
                 TRANSF=GAMMA*(GAMMA*P2piBETA/(GAMMA+1.)+E2piCM)
                 pxi2=BETAX*TRANSF-PXd
                 pyi2=BETAY*TRANSF-PYd
                 pzi2=BETAZ*TRANSF-PZd
                 p(1,i1)=pxi2
                 p(2,i1)=pyi2
                 p(3,i1)=pzi2
c     Remove regular pion to check the equivalence 
c     between the perturbative and regular deuteron results:
c                 E(i1)=0.
c
                 LB(I1)=lbm
                 PX1=P(1,I1)
                 PY1=P(2,I1)
                 PZ1=P(3,I1)
                 EM1=E(I1)
                 ID(I1)=2
                 ID1=ID(I1)
                 E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
                 lb1=lb(i1)
c     For the regular deuteron:
                 p(1,i2)=pxi1
                 p(2,i2)=pyi1
                 p(3,i2)=pzi1
                 lb(i2)=lbd
                 lb2=lb(i2)
                 E(i2)=xmd
                 EtI2=E(I2)
                 ID(I2)=2
c     For idpert=2: create the perturbative deuterons:
                 if(idpert.eq.2.and.idloop.eq.ndloop) then
                    do ipertd=1,npertd
                       nnn=nnn+1
                       PPION(1,NNN,IRUN)=ppd(1,ipertd)
                       PPION(2,NNN,IRUN)=ppd(2,ipertd)
                       PPION(3,NNN,IRUN)=ppd(3,ipertd)
                       EPION(NNN,IRUN)=xmd
                       LPION(NNN,IRUN)=lbpd(ipertd)
                       RPION(1,NNN,IRUN)=R(1,I1)
                       RPION(2,NNN,IRUN)=R(2,I1)
                       RPION(3,NNN,IRUN)=R(3,I1)
clin-5/2008 assign the perturbative probability:
                       dppion(NNN,IRUN)=1./float(npertd)
                    enddo
                 endif
              endif
           enddo
           IBLOCK=501
           go to 90005
clin-5/2008 N+N->Deuteron+pi over
* FOR THE NN-->KAON+X PROCESS, FIND MOMENTUM OF THE FINAL PARTICLES IN 
* THE NUCLEUS-NUCLEUS CMS.
306     CONTINUE
csp11/21/01 phi production
              if(XSK5/sigK.gt.RANART(NSEED))then
              pz1=p(3,i1)
              pz2=p(3,i2)
                LB(I1) = 1 + int(2 * RANART(NSEED))
                LB(I2) = 1 + int(2 * RANART(NSEED))
              nnn=nnn+1
                LPION(NNN,IRUN)=29
                EPION(NNN,IRUN)=APHI
                iblock = 222
              GO TO 208
               ENDIF
c
                 IBLOCK=9
                 if(ianti .eq. 1)iblock=-9
c
              pz1=p(3,i1)
              pz2=p(3,i2)
* DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
              nnn=nnn+1
                LPION(NNN,IRUN)=23
                EPION(NNN,IRUN)=Aka
              if(srt.le.2.63)then
* only lambda production is possible
* (1.1)P+P-->p+L+kaon+
              ic=1
                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              GO TO 208
                ENDIF
       if(srt.le.2.74.and.srt.gt.2.63)then
* both Lambda and sigma production are possible
              if(XSK1/(XSK1+XSK2).gt.RANART(NSEED))then
* lambda production
              ic=1
                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              else
* sigma production
                LB(I1) = 1 + int(2 * RANART(NSEED))
                LB(I2) = 15 + int(3 * RANART(NSEED))
              ic=2
              endif
              GO TO 208
       endif
       if(srt.le.2.77.and.srt.gt.2.74)then
* then pp-->Delta lamda kaon can happen
              if(xsk1/(xsk1+xsk2+xsk3).
     1          gt.RANART(NSEED))then
* * (1.1)P+P-->p+L+kaon+
              ic=1
                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              go to 208
              else
              if(xsk2/(xsk2+xsk3).gt.RANART(NSEED))then
* pp-->psk
              ic=2
                LB(I1) = 1 + int(2 * RANART(NSEED))
                LB(I2) = 15 + int(3 * RANART(NSEED))
              else
* pp-->D+l+k        
              ic=3
                LB(I1) = 6 + int(4 * RANART(NSEED))
              lb(i2)=14
              endif
              GO TO 208
              endif
       endif
       if(srt.gt.2.77)then
* all four channels are possible
              if(xsk1/(xsk1+xsk2+xsk3+xsk4).gt.RANART(NSEED))then
* p lambda k production
              ic=1
                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              go to 208
       else
          if(xsk3/(xsk2+xsk3+xsk4).gt.RANART(NSEED))then
* delta l K production
              ic=3
                LB(I1) = 6 + int(4 * RANART(NSEED))
              lb(i2)=14
              go to 208
          else
              if(xsk2/(xsk2+xsk4).gt.RANART(NSEED))then
* n sigma k production
                   LB(I1) = 1 + int(2 * RANART(NSEED))
                   LB(I2) = 15 + int(3 * RANART(NSEED))
              ic=2
              else
              ic=4
                LB(I1) = 6 + int(4 * RANART(NSEED))
                LB(I2) = 15 + int(3 * RANART(NSEED))
              endif
              go to 208
          endif
       endif
       endif
208             continue
         if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
          lb(i1) = - lb(i1)
          lb(i2) = - lb(i2)
          if(LPION(NNN,IRUN) .eq. 23)LPION(NNN,IRUN)=21
         endif
* KEEP ALL COORDINATES OF PARTICLE 2 FOR POSSIBLE PHASE SPACE CHANGE
           NTRY1=0
127        CALL BBKAON(ic,SRT,PX3,PY3,PZ3,DM3,PX4,PY4,PZ4,DM4,
     &  PPX,PPY,PPZ,icou1)
       NTRY1=NTRY1+1
       if((icou1.lt.0).AND.(NTRY1.LE.20))GO TO 127
c       if(icou1.lt.0)return
* ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
       CALL ROTATE(PX,PY,PZ,PX3,PY3,PZ3)
       CALL ROTATE(PX,PY,PZ,PX4,PY4,PZ4)
       CALL ROTATE(PX,PY,PZ,PPX,PPY,PPZ)
* FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
* NUCLEUS CMS. FRAME 
* (1) for the necleon/delta
*             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
              E1CM    = SQRT (dm3**2 + PX3**2 + PY3**2 + PZ3**2)
              P1BETA  = PX3*BETAX + PY3*BETAY + PZ3*BETAZ
              TRANSF  = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) + E1CM )
              Pt1i1 = BETAX * TRANSF + PX3
              Pt2i1 = BETAY * TRANSF + PY3
              Pt3i1 = BETAZ * TRANSF + PZ3
             Eti1   = DM3
             lbi1=lb(i1)
* (2) for the lambda/sigma
                E2CM    = SQRT (dm4**2 + PX4**2 + PY4**2 + PZ4**2)
                P2BETA  = PX4*BETAX+PY4*BETAY+PZ4*BETAZ
                TRANSF  = GAMMA * (GAMMA*P2BETA / (GAMMA + 1.) + E2CM)
                Pt1I2 = BETAX * TRANSF + PX4
                Pt2I2 = BETAY * TRANSF + PY4
                Pt3I2 = BETAZ * TRANSF + PZ4
              EtI2   = DM4
              lbi2=lb(i2)
* GET the kaon'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
                EPCM=SQRT(aka**2+PPX**2+PPY**2+PPZ**2)
                PPBETA=PPX*BETAX+PPY*BETAY+PPZ*BETAZ
                TRANSF=GAMMA*(GAMMA*PPBETA/(GAMMA+1.)+EPCM)
                PPION(1,NNN,IRUN)=BETAX*TRANSF+PPX
                PPION(2,NNN,IRUN)=BETAY*TRANSF+PPY
                PPION(3,NNN,IRUN)=BETAZ*TRANSF+PPZ
clin-5/2008
                dppion(nnn,irun)=dpertp(i1)*dpertp(i2)
clin-5/2008
c2003        X01 = 1.0 - 2.0 * RANART(NSEED)
c            Y01 = 1.0 - 2.0 * RANART(NSEED)
c            Z01 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2003
c                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
c                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
c                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
                RPION(1,NNN,IRUN)=R(1,I1)
                RPION(2,NNN,IRUN)=R(2,I1)
                RPION(3,NNN,IRUN)=R(3,I1)
c
* assign the nucleon/delta and lambda/sigma to i1 or i2 to keep the 
* leadng particle behaviour
C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
              p(1,i1)=pt1i1
              p(2,i1)=pt2i1
              p(3,i1)=pt3i1
              e(i1)=eti1
              lb(i1)=lbi1
              p(1,i2)=pt1i2
              p(2,i2)=pt2i2
              p(3,i2)=pt3i2
              e(i2)=eti2
              lb(i2)=lbi2
                PX1     = P(1,I1)
                PY1     = P(2,I1)
                PZ1     = P(3,I1)
              EM1       = E(I1)
                ID(I1)  = 2
                ID(I2)  = 2
                ID1     = ID(I1)
              go to 90005
* FOR THE NN-->Delta+Delta+rho PROCESS, FIND MOMENTUM OF THE FINAL 
* PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
307     CONTINUE
           NTRY1=0
125        CALL DDrho(SRT,ISEED,PX3,PY3,PZ3,DM3,PX4,PY4,PZ4,DM4,
     &  PPX,PPY,PPZ,amrho,icou1)
       NTRY1=NTRY1+1
       if((icou1.lt.0).AND.(NTRY1.LE.20))GO TO 125
C       if(icou1.lt.0)return
* ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
       CALL ROTATE(PX,PY,PZ,PX3,PY3,PZ3)
       CALL ROTATE(PX,PY,PZ,PX4,PY4,PZ4)
       CALL ROTATE(PX,PY,PZ,PPX,PPY,PPZ)
                NNN=NNN+1
              arho=amrho
* DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
* (1) FOR P+P
              XDIR=RANART(NSEED)
                IF(LB(I1)*LB(I2).EQ.1)THEN
                IF(XDIR.Le.0.2)then
* (1.1)P+P-->D+++D0+rho(0)
                LPION(NNN,IRUN)=26
                EPION(NNN,IRUN)=Arho
              LB(I1)=9
              LB(I2)=7
       GO TO 2051
                ENDIF
* (1.2)P+P -->D++D+rho(0)
                IF((XDIR.LE.0.4).AND.(XDIR.GT.0.2))THEN
                LPION(NNN,IRUN)=26
                EPION(NNN,IRUN)=Arho
                LB(I1)=8
                LB(I2)=8
       GO TO 2051
              ENDIF 
* (1.3)P+P-->D+++D+arho(-)
                IF((XDIR.LE.0.6).AND.(XDIR.GT.0.4))THEN
                LPION(NNN,IRUN)=25
                EPION(NNN,IRUN)=Arho
                LB(I1)=9
                LB(I2)=8
       GO TO 2051
              ENDIF 
                IF((XDIR.LE.0.8).AND.(XDIR.GT.0.6))THEN
                LPION(NNN,IRUN)=27
                EPION(NNN,IRUN)=Arho
                LB(I1)=9
                LB(I2)=6
       GO TO 2051
              ENDIF 
                IF(XDIR.GT.0.8)THEN
                LPION(NNN,IRUN)=27
                EPION(NNN,IRUN)=Arho
                LB(I1)=7
                LB(I2)=8
       GO TO 2051
              ENDIF 
               ENDIF
* (2)FOR N+N
                IF(iabs(LB(I1)).EQ.2.AND.iabs(LB(I2)).EQ.2)THEN
                IF(XDIR.Le.0.2)then
* (2.1)N+N-->D++D-+rho(0)
                LPION(NNN,IRUN)=26
                EPION(NNN,IRUN)=Arho
              LB(I1)=6
              LB(I2)=7
       GO TO 2051
                ENDIF
* (2.2)N+N -->D+++D-+rho(-)
                IF((XDIR.LE.0.4).AND.(XDIR.GT.0.2))THEN
                LPION(NNN,IRUN)=25
                EPION(NNN,IRUN)=Arho
                LB(I1)=6
                LB(I2)=9
       GO TO 2051
              ENDIF 
* (2.3)P+P-->D0+D-+rho(+)
                IF((XDIR.GT.0.4).AND.(XDIR.LE.0.6))THEN
                LPION(NNN,IRUN)=27
                EPION(NNN,IRUN)=Arho
                LB(I1)=9
                LB(I2)=8
       GO TO 2051
              ENDIF 
* (2.4)P+P-->D0+D0+rho(0)
                IF((XDIR.GT.0.6).AND.(XDIR.LE.0.8))THEN
                LPION(NNN,IRUN)=26
                EPION(NNN,IRUN)=Arho
                LB(I1)=7
                LB(I2)=7
       GO TO 2051
              ENDIF 
* (2.5)P+P-->D0+D++rho(-)
                IF(XDIR.GT.0.8)THEN
                LPION(NNN,IRUN)=25
                EPION(NNN,IRUN)=Arho
                LB(I1)=7
                LB(I2)=8
       GO TO 2051
              ENDIF 
              ENDIF
* (3)FOR N+P
                IF(LB(I1)*LB(I2).EQ.2)THEN
                IF(XDIR.Le.0.17)then
* (3.1)N+P-->D+++D-+rho(0)
                LPION(NNN,IRUN)=25
                EPION(NNN,IRUN)=Arho
              LB(I1)=6
              LB(I2)=9
       GO TO 2051
                ENDIF
* (3.2)N+P -->D+++D0+rho(-)
                IF((XDIR.LE.0.34).AND.(XDIR.GT.0.17))THEN
                LPION(NNN,IRUN)=25
                EPION(NNN,IRUN)=Arho
                LB(I1)=7
                LB(I2)=9
       GO TO 2051
              ENDIF 
* (3.3)N+P-->D++D-+rho(+)
                IF((XDIR.GT.0.34).AND.(XDIR.LE.0.51))THEN
                LPION(NNN,IRUN)=27
                EPION(NNN,IRUN)=Arho
                LB(I1)=7
                LB(I2)=8
       GO TO 2051
              ENDIF 
* (3.4)N+P-->D++D++rho(-)
                IF((XDIR.GT.0.51).AND.(XDIR.LE.0.68))THEN
                LPION(NNN,IRUN)=25
                EPION(NNN,IRUN)=Arho
                LB(I1)=8
                LB(I2)=8
       GO TO 2051
              ENDIF 
* (3.5)N+P-->D0+D++rho(0)
                IF((XDIR.GT.0.68).AND.(XDIR.LE.0.85))THEN
                LPION(NNN,IRUN)=26
                EPION(NNN,IRUN)=Arho
                LB(I1)=7
                LB(I2)=8
       GO TO 2051
              ENDIF 
* (3.6)N+P-->D0+D0+rho(+)
                IF(XDIR.GT.0.85)THEN
                LPION(NNN,IRUN)=27
                EPION(NNN,IRUN)=Arho
                LB(I1)=7
                LB(I2)=7
              ENDIF 
                ENDIF
* FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
* NUCLEUS CMS. FRAME 
*             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
2051          E1CM    = SQRT (dm3**2 + PX3**2 + PY3**2 + PZ3**2)
              P1BETA  = PX3*BETAX + PY3*BETAY + PZ3*BETAZ
              TRANSF  = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) + E1CM )
              Pt1i1 = BETAX * TRANSF + PX3
              Pt2i1 = BETAY * TRANSF + PY3
              Pt3i1 = BETAZ * TRANSF + PZ3
             Eti1   = DM3
c
             if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
               lb(i1) = -lb(i1)
               lb(i2) = -lb(i2)
                if(LPION(NNN,IRUN) .eq. 25)then
                  LPION(NNN,IRUN)=27
                elseif(LPION(NNN,IRUN) .eq. 27)then
                  LPION(NNN,IRUN)=25
                endif
               endif
c
             lb1=lb(i1)
* FOR DELTA2
                E2CM    = SQRT (dm4**2 + PX4**2 + PY4**2 + PZ4**2)
                P2BETA  = PX4*BETAX+PY4*BETAY+PZ4*BETAZ
                TRANSF  = GAMMA * (GAMMA*P2BETA / (GAMMA + 1.) + E2CM)
                Pt1I2 = BETAX * TRANSF + PX4
                Pt2I2 = BETAY * TRANSF + PY4
                Pt3I2 = BETAZ * TRANSF + PZ4
              EtI2   = DM4
              lb2=lb(i2)
* assign delta1 and delta2 to i1 or i2 to keep the leadng particle
* behaviour
C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
              p(1,i1)=pt1i1
              p(2,i1)=pt2i1
              p(3,i1)=pt3i1
              e(i1)=eti1
              lb(i1)=lb1
              p(1,i2)=pt1i2
              p(2,i2)=pt2i2
              p(3,i2)=pt3i2
              e(i2)=eti2
              lb(i2)=lb2
                PX1     = P(1,I1)
                PY1     = P(2,I1)
                PZ1     = P(3,I1)
              EM1       = E(I1)
                ID(I1)  = 2
                ID(I2)  = 2
                ID1     = ID(I1)
                IBLOCK=44
* GET rho'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
                EPCM=SQRT(EPION(NNN,IRUN)**2+PPX**2+PPY**2+PPZ**2)
                PPBETA=PPX*BETAX+PPY*BETAY+PPZ*BETAZ
                TRANSF=GAMMA*(GAMMA*PPBETA/(GAMMA+1.)+EPCM)
                PPION(1,NNN,IRUN)=BETAX*TRANSF+PPX
                PPION(2,NNN,IRUN)=BETAY*TRANSF+PPY
                PPION(3,NNN,IRUN)=BETAZ*TRANSF+PPZ
clin-5/2008:
                dppion(nnn,irun)=dpertp(i1)*dpertp(i2)
clin-5/2008:
c2004        X01 = 1.0 - 2.0 * RANART(NSEED)
c            Y01 = 1.0 - 2.0 * RANART(NSEED)
c            Z01 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2004
c                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
c                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
c                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
                RPION(1,NNN,IRUN)=R(1,I1)
                RPION(2,NNN,IRUN)=R(2,I1)
                RPION(3,NNN,IRUN)=R(3,I1)
c
              go to 90005
* FOR THE NN-->N+N+rho PROCESS, FIND MOMENTUM OF THE FINAL 
* PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
308     CONTINUE
           NTRY1=0
126        CALL pprho(SRT,ISEED,PX3,PY3,PZ3,DM3,PX4,PY4,PZ4,DM4,
     &  PPX,PPY,PPZ,amrho,icou1)
       NTRY1=NTRY1+1
       if((icou1.lt.0).AND.(NTRY1.LE.20))GO TO 126
C       if(icou1.lt.0)return
* ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
       CALL ROTATE(PX,PY,PZ,PX3,PY3,PZ3)
       CALL ROTATE(PX,PY,PZ,PX4,PY4,PZ4)
       CALL ROTATE(PX,PY,PZ,PPX,PPY,PPZ)
                NNN=NNN+1
              arho=amrho
* DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
* (1) FOR P+P
              XDIR=RANART(NSEED)
                IF(LB(I1)*LB(I2).EQ.1)THEN
                IF(XDIR.Le.0.5)then
* (1.1)P+P-->P+P+rho(0)
                LPION(NNN,IRUN)=26
                EPION(NNN,IRUN)=Arho
              LB(I1)=1
              LB(I2)=1
       GO TO 2052
                Else
* (1.2)P+P -->p+n+rho(+)
                LPION(NNN,IRUN)=27
                EPION(NNN,IRUN)=Arho
                LB(I1)=1
                LB(I2)=2
       GO TO 2052
              ENDIF 
              endif
* (2)FOR N+N
                IF(iabs(LB(I1)).EQ.2.AND.iabs(LB(I2)).EQ.2)THEN
                IF(XDIR.Le.0.5)then
* (2.1)N+N-->N+N+rho(0)
                LPION(NNN,IRUN)=26
                EPION(NNN,IRUN)=Arho
              LB(I1)=2
              LB(I2)=2
       GO TO 2052
                Else
* (2.2)N+N -->N+P+rho(-)
                LPION(NNN,IRUN)=25
                EPION(NNN,IRUN)=Arho
                LB(I1)=1
                LB(I2)=2
       GO TO 2052
              ENDIF 
              endif
* (3)FOR N+P
                IF(LB(I1)*LB(I2).EQ.2)THEN
                IF(XDIR.Le.0.33)then
* (3.1)N+P-->N+P+rho(0)
                LPION(NNN,IRUN)=26
                EPION(NNN,IRUN)=Arho
              LB(I1)=1
              LB(I2)=2
       GO TO 2052
* (3.2)N+P -->P+P+rho(-)
                else IF((XDIR.LE.0.67).AND.(XDIR.GT.0.34))THEN
                LPION(NNN,IRUN)=25
                EPION(NNN,IRUN)=Arho
                LB(I1)=1
                LB(I2)=1
       GO TO 2052
              Else 
* (3.3)N+P-->N+N+rho(+)
                LPION(NNN,IRUN)=27
                EPION(NNN,IRUN)=Arho
                LB(I1)=2
                LB(I2)=2
       GO TO 2052
              ENDIF 
              endif
* FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
* NUCLEUS CMS. FRAME 
*             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
2052          E1CM    = SQRT (dm3**2 + PX3**2 + PY3**2 + PZ3**2)
              P1BETA  = PX3*BETAX + PY3*BETAY + PZ3*BETAZ
              TRANSF  = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) + E1CM )
              Pt1i1 = BETAX * TRANSF + PX3
              Pt2i1 = BETAY * TRANSF + PY3
              Pt3i1 = BETAZ * TRANSF + PZ3
             Eti1   = DM3
c
              if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
               lb(i1) = -lb(i1)
               lb(i2) = -lb(i2)
                if(LPION(NNN,IRUN) .eq. 25)then
                  LPION(NNN,IRUN)=27
                elseif(LPION(NNN,IRUN) .eq. 27)then
                  LPION(NNN,IRUN)=25
                endif
               endif
c
             lb1=lb(i1)
* FOR p2
                E2CM    = SQRT (dm4**2 + PX4**2 + PY4**2 + PZ4**2)
                P2BETA  = PX4*BETAX+PY4*BETAY+PZ4*BETAZ
                TRANSF  = GAMMA * (GAMMA*P2BETA / (GAMMA + 1.) + E2CM)
                Pt1I2 = BETAX * TRANSF + PX4
                Pt2I2 = BETAY * TRANSF + PY4
                Pt3I2 = BETAZ * TRANSF + PZ4
              EtI2   = DM4
              lb2=lb(i2)
* assign p1 and p2 to i1 or i2 to keep the leadng particle
* behaviour
C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
              p(1,i1)=pt1i1
              p(2,i1)=pt2i1
              p(3,i1)=pt3i1
              e(i1)=eti1
              lb(i1)=lb1
              p(1,i2)=pt1i2
              p(2,i2)=pt2i2
              p(3,i2)=pt3i2
              e(i2)=eti2
              lb(i2)=lb2
                PX1     = P(1,I1)
                PY1     = P(2,I1)
                PZ1     = P(3,I1)
              EM1       = E(I1)
                ID(I1)  = 2
                ID(I2)  = 2
                ID1     = ID(I1)
                IBLOCK=45
* GET rho'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
                EPCM=SQRT(EPION(NNN,IRUN)**2+PPX**2+PPY**2+PPZ**2)
                PPBETA=PPX*BETAX+PPY*BETAY+PPZ*BETAZ
                TRANSF=GAMMA*(GAMMA*PPBETA/(GAMMA+1.)+EPCM)
                PPION(1,NNN,IRUN)=BETAX*TRANSF+PPX
                PPION(2,NNN,IRUN)=BETAY*TRANSF+PPY
                PPION(3,NNN,IRUN)=BETAZ*TRANSF+PPZ
clin-5/2008:
                dppion(nnn,irun)=dpertp(i1)*dpertp(i2)
clin-5/2008:
c2005        X01 = 1.0 - 2.0 * RANART(NSEED)
c            Y01 = 1.0 - 2.0 * RANART(NSEED)
c            Z01 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2005
c                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
c                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
c                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
                RPION(1,NNN,IRUN)=R(1,I1)
                RPION(2,NNN,IRUN)=R(2,I1)
                RPION(3,NNN,IRUN)=R(3,I1)
c
              go to 90005
* FOR THE NN-->p+p+omega PROCESS, FIND MOMENTUM OF THE FINAL 
* PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
309     CONTINUE
           NTRY1=0
138        CALL ppomga(SRT,ISEED,PX3,PY3,PZ3,DM3,PX4,PY4,PZ4,DM4,
     &  PPX,PPY,PPZ,icou1)
       NTRY1=NTRY1+1
       if((icou1.lt.0).AND.(NTRY1.LE.20))GO TO 138
C       if(icou1.lt.0)return
* ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
       CALL ROTATE(PX,PY,PZ,PX3,PY3,PZ3)
       CALL ROTATE(PX,PY,PZ,PX4,PY4,PZ4)
       CALL ROTATE(PX,PY,PZ,PPX,PPY,PPZ)
                NNN=NNN+1
              aomega=0.782
* DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
* (1) FOR P+P
                IF(LB(I1)*LB(I2).EQ.1)THEN
* (1.1)P+P-->P+P+omega(0)
                LPION(NNN,IRUN)=28
                EPION(NNN,IRUN)=Aomega
              LB(I1)=1
              LB(I2)=1
       GO TO 2053
                ENDIF
* (2)FOR N+N
                IF(iabs(LB(I1)).EQ.2.AND.iabs(LB(I2)).EQ.2)THEN
* (2.1)N+N-->N+N+omega(0)
                LPION(NNN,IRUN)=28
                EPION(NNN,IRUN)=Aomega
              LB(I1)=2
              LB(I2)=2
       GO TO 2053
                ENDIF
* (3)FOR N+P
                IF(LB(I1)*LB(I2).EQ.2)THEN
* (3.1)N+P-->N+P+omega(0)
                LPION(NNN,IRUN)=28
                EPION(NNN,IRUN)=Aomega
              LB(I1)=1
              LB(I2)=2
       GO TO 2053
                ENDIF
* FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
* NUCLEUS CMS. FRAME 
*             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
2053          E1CM    = SQRT (dm3**2 + PX3**2 + PY3**2 + PZ3**2)
              P1BETA  = PX3*BETAX + PY3*BETAY + PZ3*BETAZ
              TRANSF  = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) + E1CM )
              Pt1i1 = BETAX * TRANSF + PX3
              Pt2i1 = BETAY * TRANSF + PY3
              Pt3i1 = BETAZ * TRANSF + PZ3
             Eti1   = DM3
              if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
               lb(i1) = -lb(i1)
               lb(i2) = -lb(i2)
               endif
             lb1=lb(i1)
* FOR DELTA2
                E2CM    = SQRT (dm4**2 + PX4**2 + PY4**2 + PZ4**2)
                P2BETA  = PX4*BETAX+PY4*BETAY+PZ4*BETAZ
                TRANSF  = GAMMA * (GAMMA*P2BETA / (GAMMA + 1.) + E2CM)
                Pt1I2 = BETAX * TRANSF + PX4
                Pt2I2 = BETAY * TRANSF + PY4
                Pt3I2 = BETAZ * TRANSF + PZ4
              EtI2   = DM4
                lb2=lb(i2)
* assign delta1 and delta2 to i1 or i2 to keep the leadng particle
* behaviour
C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
              p(1,i1)=pt1i1
              p(2,i1)=pt2i1
              p(3,i1)=pt3i1
              e(i1)=eti1
              lb(i1)=lb1
              p(1,i2)=pt1i2
              p(2,i2)=pt2i2
              p(3,i2)=pt3i2
              e(i2)=eti2
              lb(i2)=lb2
                PX1     = P(1,I1)
                PY1     = P(2,I1)
                PZ1     = P(3,I1)
              EM1       = E(I1)
                ID(I1)  = 2
                ID(I2)  = 2
                ID1     = ID(I1)
                IBLOCK=46
* GET omega'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
                EPCM=SQRT(EPION(NNN,IRUN)**2+PPX**2+PPY**2+PPZ**2)
                PPBETA=PPX*BETAX+PPY*BETAY+PPZ*BETAZ
                TRANSF=GAMMA*(GAMMA*PPBETA/(GAMMA+1.)+EPCM)
                PPION(1,NNN,IRUN)=BETAX*TRANSF+PPX
                PPION(2,NNN,IRUN)=BETAY*TRANSF+PPY
                PPION(3,NNN,IRUN)=BETAZ*TRANSF+PPZ
clin-5/2008:
                dppion(nnn,irun)=dpertp(i1)*dpertp(i2)
clin-5/2008:
c2006        X01 = 1.0 - 2.0 * RANART(NSEED)
c            Y01 = 1.0 - 2.0 * RANART(NSEED)
c            Z01 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2006
c                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
c                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
c                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
                    RPION(1,NNN,IRUN)=R(1,I1)
                    RPION(2,NNN,IRUN)=R(2,I1)
                    RPION(3,NNN,IRUN)=R(3,I1)
c
              go to 90005
* change phase space density FOR NUCLEONS AFTER THE PROCESS

clin-10/25/02-comment out following, since there is no path to it:
clin-8/16/02 used before set
c     IX1,IY1,IZ1,IPX1,IPY1,IPZ1, IX2,IY2,IZ2,IPX2,IPY2,IPZ2:
c                if ((abs(ix1).le.mx) .and. (abs(iy1).le.my) .and.
c     &              (abs(iz1).le.mz)) then
c                  ipx1p = nint(p(1,i1)/dpx)
c                  ipy1p = nint(p(2,i1)/dpy)
c                  ipz1p = nint(p(3,i1)/dpz)
c                  if ((ipx1p.ne.ipx1) .or. (ipy1p.ne.ipy1) .or.
c     &                (ipz1p.ne.ipz1)) then
c                    if ((abs(ipx1).le.mpx) .and. (abs(ipy1).le.my)
c     &                .and. (ipz1.ge.-mpz) .and. (ipz1.le.mpzp))
c     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) =
c     &                f(ix1,iy1,iz1,ipx1,ipy1,ipz1) - 1.
c                    if ((abs(ipx1p).le.mpx) .and. (abs(ipy1p).le.my)
c     &                .and. (ipz1p.ge.-mpz).and. (ipz1p.le.mpzp))
c     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) =
c     &                f(ix1,iy1,iz1,ipx1p,ipy1p,ipz1p) + 1.
c                  end if
c                end if
c                if ((abs(ix2).le.mx) .and. (abs(iy2).le.my) .and.
c     &              (abs(iz2).le.mz)) then
c                  ipx2p = nint(p(1,i2)/dpx)
c                  ipy2p = nint(p(2,i2)/dpy)
c                  ipz2p = nint(p(3,i2)/dpz)
c                  if ((ipx2p.ne.ipx2) .or. (ipy2p.ne.ipy2) .or.
c     &                (ipz2p.ne.ipz2)) then
c                    if ((abs(ipx2).le.mpx) .and. (abs(ipy2).le.my)
c     &                .and. (ipz2.ge.-mpz) .and. (ipz2.le.mpzp))
c     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) =
c     &                f(ix2,iy2,iz2,ipx2,ipy2,ipz2) - 1.
c                    if ((abs(ipx2p).le.mpx) .and. (abs(ipy2p).le.my)
c     &                .and. (ipz2p.ge.-mpz) .and. (ipz2p.le.mpzp))
c     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) =
c     &                f(ix2,iy2,iz2,ipx2p,ipy2p,ipz2p) + 1.
c                  end if
c                end if
clin-10/25/02-end

90005       continue
       RETURN
*-----------------------------------------------------------------------
*COM: SET THE NEW MOMENTUM COORDINATES
107     IF(PX .EQ. 0.0 .AND. PY .EQ. 0.0) THEN
        T2 = 0.0
      ELSE
        T2=ATAN2(PY,PX)
      END IF
      S1   = 1.0 - C1**2 
       IF(S1.LE.0)S1=0
       S1=SQRT(S1)

clin-9/2012: check argument in sqrt():
       scheck=1.0 - C2**2
       if(scheck.lt.0) then
          write(99,*) 'scheck3: ', scheck
          scheck=0.
       endif
       S2=SQRT(scheck)
c       S2  =  SQRT( 1.0 - C2**2 )

      CT1  = COS(T1)
      ST1  = SIN(T1)
      CT2  = COS(T2)
      ST2  = SIN(T2)
      PZ   = PR * ( C1*C2 - S1*S2*CT1 )
      SS   = C2 * S1 * CT1  +  S2 * C1
      PX   = PR * ( SS*CT2 - S1*ST1*ST2 )
      PY   = PR * ( SS*ST2 + S1*ST1*CT2 )
      RETURN
      END
clin-5/2008 CRNN over

**********************************
**********************************
*                                                                      *
*                                                                      *
c
      SUBROUTINE CRPP(PX,PY,PZ,SRT,I1,I2,IBLOCK,
     &ppel,ppin,spprho,ipp)
*     PURPOSE:                                                         *
*             DEALING WITH PION-PION COLLISIONS                        *
*     NOTE   :                                                         *
*           VALID ONLY FOR PION-PION-DISTANCES LESS THAN 2.5 FM        *
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                     6-> Meson+Meson elastic
*                     66-> Meson+meson-->K+K-
**********************************
      PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1     AMP=0.93828,AP1=0.13496,
     2 AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
      PARAMETER      (AKA=0.498,aks=0.895)
      parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
      COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
      COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
      COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
      COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

      lb1i=lb(i1)
      lb2i=lb(i2)

       PX0=PX
       PY0=PY
       PZ0=PZ
        iblock=1
*-----------------------------------------------------------------------
* check Meson+Meson inelastic collisions
clin-9/28/00
c        if((srt.gt.1.).and.(ppin/(ppin+ppel).gt.RANART(NSEED)))then
c        iblock=66
c        e(i1)=0.498
c        e(i2)=0.498
c        lb(i1)=21
c        lb(i2)=23
c        go to 10
clin-11/07/00
c        if(srt.gt.1.and.(ppin/(ppin+ppel)).gt.RANART(NSEED)) then
clin-4/03/02
        if(srt.gt.(2*aka).and.(ppin/(ppin+ppel)).gt.RANART(NSEED)) then
c        if(ppin/(ppin+ppel).gt.RANART(NSEED)) then
clin-10/08/00

           ranpi=RANART(NSEED)
           if((pprr/ppin).ge.ranpi) then

c     1) pi pi <-> rho rho:
              call pi2ro2(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)

clin-4/03/02 eta equilibration:
           elseif((pprr+ppee)/ppin.ge.ranpi) then
c     4) pi pi <-> eta eta:
              call pi2et2(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
           elseif(((pprr+ppee+pppe)/ppin).ge.ranpi) then
c     5) pi pi <-> pi eta:
              call pi3eta(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
           elseif(((pprr+ppee+pppe+rpre)/ppin).ge.ranpi) then
c     6) rho pi <-> pi eta:
              call rpiret(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
           elseif(((pprr+ppee+pppe+rpre+xopoe)/ppin).ge.ranpi) then
c     7) omega pi <-> omega eta:
              call opioet(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
           elseif(((pprr+ppee+pppe+rpre+xopoe+rree)
     1             /ppin).ge.ranpi) then
c     8) rho rho <-> eta eta:
              call ro2et2(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
clin-4/03/02-end

c     2) BBbar production:
           elseif(((pprr+ppee+pppe+rpre+xopoe+rree+ppinnb)/ppin)
     1             .ge.ranpi) then

              call bbarfs(lbb1,lbb2,ei1,ei2,iblock,iseed)
c     3) KKbar production:
           else
              iblock=66
              ei1=aka
              ei2=aka
              lbb1=21
              lbb2=23
clin-11/07/00 pi rho -> K* Kbar and K*bar K productions:
              lb1=lb(i1)
              lb2=lb(i2)
clin-2/13/03 include omega the same as rho, eta the same as pi:
c        if(((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.25.and.lb2.le.27))
c     1  .or.((lb2.ge.3.and.lb2.le.5).and.(lb1.ge.25.and.lb1.le.27)))
        if( ( (lb1.eq.0.or.(lb1.ge.3.and.lb1.le.5))
     1       .and.(lb2.ge.25.and.lb2.le.28))
     2       .or. ( (lb2.eq.0.or.(lb2.ge.3.and.lb2.le.5))
     3       .and.(lb1.ge.25.and.lb1.le.28))) then
           ei1=aks
           ei2=aka
           if(RANART(NSEED).ge.0.5) then
              iblock=366
              lbb1=30
              lbb2=21
           else
              iblock=367
              lbb1=-30
              lbb2=23
           endif
        endif
clin-11/07/00-end
           endif
clin-ppbar-8/25/00
           e(i1)=ei1
           e(i2)=ei2
           lb(i1)=lbb1
           lb(i2)=lbb2
clin-10/08/00-end

       else
cbzdbg10/15/99
c.....for meson+meson elastic srt.le.2Mk, if not pi+pi collision return
         if ((lb(i1).lt.3.or.lb(i1).gt.5).and.
     &        (lb(i2).lt.3.or.lb(i2).gt.5)) return
cbzdbg10/15/99 end

* check Meson+Meson elastic collisions
        IBLOCK=6
* direct process
       if(ipp.eq.1.or.ipp.eq.4.or.ipp.eq.6)go to 10
       if(spprho/ppel.gt.RANART(NSEED))go to 20
       endif
10      NTAG=0
        EM1=E(I1)
        EM2=E(I2)

*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
          S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
* for isotropic distribution no need to ROTATE THE MOMENTUM

* ROTATE IT 
      CALL ROTATE(PX0,PY0,PZ0,PX,PY,PZ) 

      RETURN
20       continue
       iblock=666
* treat rho formation in pion+pion collisions
* calculate the mass and momentum of rho in the nucleus-nucleus frame
       call rhores(i1,i2)
       if(ipp.eq.2)lb(i1)=27
       if(ipp.eq.3)lb(i1)=26
       if(ipp.eq.5)lb(i1)=25
       return       
      END
**********************************
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE CRND(IRUN,PX,PY,PZ,SRT,I1,I2,IBLOCK,
     &SIGNN,SIG,sigk,xsk1,xsk2,xsk3,xsk4,xsk5,NT,ipert1)
*     PURPOSE:                                                         *
*             DEALING WITH NUCLEON-BARYON RESONANCE COLLISIONS         *
*     NOTE   :                                                         *
*           VALID ONLY FOR BARYON-BARYON-DISTANCES LESS THAN 1.32 FM   *
*           (1.32 = 2 * HARD-CORE-RADIUS [HRC] )                       *
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
*           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
*           IBLOCK   - THE INFORMATION BACK                            *
*                      0-> COLLISION CANNOT HAPPEN                     *
*                      1-> N-N ELASTIC COLLISION                       *
*                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
*                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
*                      4-> N+N->N+N+PION,DIRTCT PROCESS                *
*           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
*                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
*                      N12,                                            *
*                      M12=1 FOR p+n-->delta(+)+ n                     *
*                          2     p+n-->delta(0)+ p                     *
*                          3     p+p-->delta(++)+n                     *
*                          4     p+p-->delta(+)+p                      *
*                          5     n+n-->delta(0)+n                      *
*                          6     n+n-->delta(-)+p                      *
*                          7     n+p-->N*(0)(1440)+p                   *
*                          8     n+p-->N*(+)(1440)+n                   *
*                        9     p+p-->N*(+)(1535)+p                     *
*                        10    n+n-->N*(0)(1535)+n                     *
*                         11    n+p-->N*(+)(1535)+n                     *
*                        12    n+p-->N*(0)(1535)+p
*                        13    D(++)+D(-)-->N*(+)(1440)+n
*                         14    D(++)+D(-)-->N*(0)(1440)+p
*                        15    D(+)+D(0)--->N*(+)(1440)+n
*                        16    D(+)+D(0)--->N*(0)(1440)+p
*                        17    D(++)+D(0)-->N*(+)(1535)+p
*                        18    D(++)+D(-)-->N*(0)(1535)+p
*                        19    D(++)+D(-)-->N*(+)(1535)+n
*                        20    D(+)+D(+)-->N*(+)(1535)+p
*                        21    D(+)+D(0)-->N*(+)(1535)+n
*                        22    D(+)+D(0)-->N*(0)(1535)+p
*                        23    D(+)+D(-)-->N*(0)(1535)+n
*                        24    D(0)+D(0)-->N*(0)(1535)+n
*                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
*                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
*                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
*                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
*                        29    N*(+)(14)+D+-->N*(+)(15)+p
*                        30    N*(+)(14)+D0-->N*(+)(15)+n
*                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
*                        32    N*(0)(14)+D++--->N*(+)(15)+p
*                        33    N*(0)(14)+D+--->N*(+)(15)+n
*                        34    N*(0)(14)+D+--->N*(0)(15)+p
*                        35    N*(0)(14)+D0-->N*(0)(15)+n
*                        36    N*(+)(14)+D0--->N*(0)(15)+p
*                        ++    see the note book for more listing
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AKA=0.498,APHI=1.020,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        parameter (xmd=1.8756,npdmax=10000)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common /ff/f(-mx:mx,-my:my,-mz:mz,-mpx:mpx,-mpy:mpy,-mpz:mpzp)
cc      SAVE /ff/
        common /gg/ dx,dy,dz,dpx,dpy,dpz
cc      SAVE /gg/
        COMMON /INPUT/ NSTAR,NDIRCT,DIR
cc      SAVE /INPUT/
        COMMON /NN/NNN
cc      SAVE /NN/
        COMMON /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1 px1n,py1n,pz1n,dp1n
cc      SAVE /leadng/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      common /dpi/em2,lb2
      common /para8/ idpert,npertd,idxsec
      dimension ppd(3,npdmax),lbpd(npdmax)
      SAVE   
*-----------------------------------------------------------------------
       n12=0
       m12=0
        IBLOCK=0
        NTAG=0
        EM1=E(I1)
        EM2=E(I2)
        PR  = SQRT( PX**2 + PY**2 + PZ**2 )
        C2  = PZ / PR
        X1  = RANART(NSEED)
        ianti=0
        if(lb(i1).lt.0 .and. lb(i2).lt.0)ianti=1

clin-6/2008 Production of perturbative deuterons for idpert=1:
      call sbbdm(srt,sdprod,ianti,lbm,xmm,pfinal)
      if(idpert.eq.1.and.ipert1.eq.1) then
         IF (SRT .LT. 2.012) RETURN
         if((iabs(lb(i1)).eq.1.or.iabs(lb(i1)).eq.2)
     1        .and.(iabs(lb(i2)).ge.6.and.iabs(lb(i2)).le.13)) then
            goto 108
         elseif((iabs(lb(i2)).eq.1.or.iabs(lb(i2)).eq.2)
     1           .and.(iabs(lb(i1)).ge.6.and.iabs(lb(i1)).le.13)) then
            goto 108
         else
            return
         endif
      endif
*-----------------------------------------------------------------------
*COM: TEST FOR ELASTIC SCATTERING (EITHER N-N OR DELTA-DELTA 0R
*      N-DELTA OR N*-N* or N*-Delta)
      IF (X1 .LE. SIGNN/SIG) THEN
*COM:  PARAMETRISATION IS TAKEN FROM THE CUGNON-PAPER
        AS  = ( 3.65 * (SRT - 1.8766) )**6
        A   = 6.0 * AS / (1.0 + AS)
        TA  = -2.0 * PR**2
        X   = RANART(NSEED)
clin-10/24/02        T1  = ALOG( (1-X) * DEXP(dble(A)*dble(TA)) + X )  /  A
        T1  = sngl(DLOG(dble(1.-X)*DEXP(dble(A)*dble(TA))+dble(X)))/  A
        C1  = 1.0 - T1/TA
        T1  = 2.0 * PI * RANART(NSEED)
        IBLOCK=1
       GO TO 107
      ELSE
*COM: TEST FOR INELASTIC SCATTERING
*     IF THE AVAILABLE ENERGY IS LESS THAN THE PION-MASS, NOTHING
*     CAN HAPPEN ANY MORE ==> RETURN (2.04 = 2*AVMASS + PI-MASS+0.02)
        IF (SRT .LT. 2.04) RETURN
clin-6/2008 add d+meson production for n*N*(0)(1440) and p*N*(+)(1440) channels
c     (they did not have any inelastic reactions before):
        if(((iabs(LB(I1)).EQ.2.or.iabs(LB(I2)).EQ.2).AND.
     1       (LB(I1)*LB(I2)).EQ.20).or.(LB(I1)*LB(I2)).EQ.13) then
           IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
        ENDIF
c
* Resonance absorption or Delta + N-->N*(1440), N*(1535)
* COM: TEST FOR DELTA OR N* ABSORPTION
*      IN THE PROCESS DELTA+N-->NN, N*+N-->NN
        PRF=SQRT(0.25*SRT**2-AVMASS**2)
        IF(EM1.GT.1.)THEN
        DELTAM=EM1
        ELSE
        DELTAM=EM2
        ENDIF
        RENOM=DELTAM*PRF**2/DENOM(SRT,1.)/PR
        RENOMN=DELTAM*PRF**2/DENOM(SRT,2.)/PR
        RENOM1=DELTAM*PRF**2/DENOM(SRT,-1.)/PR
* avoid the inelastic collisions between n+delta- -->N+N 
*       and p+delta++ -->N+N due to charge conservation,
*       but they can scatter to produce kaons 
       if((iabs(lb(i1)).eq.2).and.(iabs(lb(i2)).eq.6)) renom=0.
       if((iabs(lb(i2)).eq.2).and.(iabs(lb(i1)).eq.6)) renom=0.
       if((iabs(lb(i1)).eq.1).and.(iabs(lb(i2)).eq.9)) renom=0.
       if((iabs(lb(i2)).eq.1).and.(iabs(lb(i1)).eq.9)) renom=0.
       Call M1535(iabs(lb(i1)),iabs(lb(i2)),srt,x1535)
        X1440=(3./4.)*SIGMA(SRT,2,0,1)
* CROSS SECTION FOR KAON PRODUCTION from the four channels
* for NLK channel
* avoid the inelastic collisions between n+delta- -->N+N 
*       and p+delta++ -->N+N due to charge conservation,
*       but they can scatter to produce kaons 
       if(((iabs(lb(i1)).eq.2).and.(iabs(lb(i2)).eq.6)).OR. 
     &         ((iabs(lb(i2)).eq.2).and.(iabs(lb(i1)).eq.6)).OR.
     &         ((iabs(lb(i1)).eq.1).and.(iabs(lb(i2)).eq.9)).OR.
     &         ((iabs(lb(i2)).eq.1).and.(iabs(lb(i1)).eq.9)))THEN
clin-6/2008
          IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c          IF((SIGK+SIGNN)/SIG.GE.X1)GO TO 306
          IF((SIGK+SIGNN+sdprod)/SIG.GE.X1)GO TO 306
c
       ENDIF
* WE DETERMINE THE REACTION CHANNELS IN THE FOLLOWING
* FOR n+delta(++)-->p+p or n+delta(++)-->n+N*(+)(1440),n+N*(+)(1535)
* REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN, 
        IF(LB(I1)*LB(I2).EQ.18.AND.
     &  (iabs(LB(I1)).EQ.2.OR.iabs(LB(I2)).EQ.2))then
        SIGND=SIGMA(SRT,1,1,0)+0.5*SIGMA(SRT,1,1,1)
        SIGDN=0.25*SIGND*RENOM
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF(X1.GT.(SIGNN+SIGDN+X1440+X1535+SIGK)/SIG)RETURN
        IF(X1.GT.(SIGNN+SIGDN+X1440+X1535+SIGK+sdprod)/SIG)RETURN
c
       IF(SIGK/(SIGK+SIGDN+X1440+X1535).GT.RANART(NSEED))GO TO 306
* REABSORPTION:
       IF(RANART(NSEED).LT.SIGDN/(SIGDN+X1440+X1535))THEN
        M12=3
       GO TO 206
       ELSE
* N* PRODUCTION
              IF(RANART(NSEED).LT.X1440/(X1440+X1535))THEN
* N*(1440)
              M12=37
              ELSE
* N*(1535)       M12=38
clin-2/26/03 why is the above commented out? leads to M12=0 but 
c     particle mass is changed after 204 (causes energy violation).
c     replace by elastic process (return):
                   return

              ENDIF
       GO TO 204
       ENDIF
        ENDIF
* FOR p+delta(-)-->n+n or p+delta(-)-->n+N*(0)(1440),n+N*(0)(1535)
* REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN, 
        IF(LB(I1)*LB(I2).EQ.6.AND.
     &   ((iabs(LB(I1)).EQ.1).OR.(iabs(LB(I2)).EQ.1)))then
        SIGND=SIGMA(SRT,1,1,0)+0.5*SIGMA(SRT,1,1,1)
        SIGDN=0.25*SIGND*RENOM
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF (X1.GT.(SIGNN+SIGDN+X1440+X1535+SIGK)/SIG)RETURN
        IF (X1.GT.(SIGNN+SIGDN+X1440+X1535+SIGK+sdprod)/SIG)RETURN
c
       IF(SIGK/(SIGK+SIGDN+X1440+X1535).GT.RANART(NSEED))GO TO 306
* REABSORPTION:
       IF(RANART(NSEED).LT.SIGDN/(SIGDN+X1440+X1535))THEN
        M12=6
       GO TO 206
       ELSE
* N* PRODUCTION
              IF(RANART(NSEED).LT.X1440/(X1440+X1535))THEN
* N*(1440)
              M12=47
              ELSE
* N*(1535)       M12=48
clin-2/26/03 causes energy violation, replace by elastic process (return):
                   return

              ENDIF
       GO TO 204
       ENDIF
        ENDIF
* FOR p+delta(+)-->p+p, N*(+)(144)+p, N*(+)(1535)+p
        IF(LB(I1)*LB(I2).EQ.8.AND.
     &   (iabs(LB(I1)).EQ.1.OR.iabs(LB(I2)).EQ.1))THEN
        SIGND=1.5*SIGMA(SRT,1,1,1)
        SIGDN=0.25*SIGND*RENOM
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF(X1.GT.(SIGNN+SIGDN+x1440+x1535+SIGK)/SIG)RETURN
        IF(X1.GT.(SIGNN+SIGDN+x1440+x1535+SIGK+sdprod)/SIG)RETURN
c
       IF(SIGK/(SIGK+SIGDN+X1440+X1535).GT.RANART(NSEED))GO TO 306
       IF(RANART(NSEED).LT.SIGDN/(SIGDN+X1440+X1535))THEN
        M12=4
       GO TO 206
       ELSE
              IF(RANART(NSEED).LT.X1440/(X1440+X1535))THEN
* N*(144)
              M12=39
              ELSE
              M12=40
              ENDIF
              GO TO 204
       ENDIF
        ENDIF
* FOR n+delta(0)-->n+n, N*(0)(144)+n, N*(0)(1535)+n
        IF(LB(I1)*LB(I2).EQ.14.AND.
     &   (iabs(LB(I1)).EQ.2.OR.iabs(LB(I2)).EQ.2))THEN
        SIGND=1.5*SIGMA(SRT,1,1,1)
        SIGDN=0.25*SIGND*RENOM
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF(X1.GT.(SIGNN+SIGDN+x1440+x1535+SIGK)/SIG)RETURN
        IF(X1.GT.(SIGNN+SIGDN+x1440+x1535+SIGK+sdprod)/SIG)RETURN
c
       IF(SIGK/(SIGK+SIGDN+X1440+X1535).GT.RANART(NSEED))GO TO 306
       IF(RANART(NSEED).LT.SIGDN/(SIGDN+X1440+X1535))THEN
        M12=5
       GO TO 206
       ELSE
              IF(RANART(NSEED).LT.X1440/(X1440+X1535))THEN
* N*(144)
              M12=48
              ELSE
              M12=49
              ENDIF
              GO TO 204
       ENDIF
        ENDIF
* FOR n+delta(+)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
*                       N*(+)(1535)+n,N*(0)(1535)+p
        IF(LB(I1)*LB(I2).EQ.16.AND.
     &   (iabs(LB(I1)).EQ.2.OR.iabs(LB(I2)).EQ.2))THEN
        SIGND=0.5*SIGMA(SRT,1,1,1)+0.25*SIGMA(SRT,1,1,0)
        SIGDN=0.5*SIGND*RENOM
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF(X1.GT.(SIGNN+SIGDN+2.*x1440+2.*x1535+SIGK)/SIG)RETURN
        IF(X1.GT.(SIGNN+SIGDN+2.*x1440+2.*x1535+SIGK+sdprod)/SIG)RETURN
c
       IF(SIGK/(SIGK+SIGDN+2*X1440+2*X1535).GT.RANART(NSEED))GO TO 306
       IF(RANART(NSEED).LT.SIGDN/(SIGDN+2.*X1440+2.*X1535))THEN
        M12=1
       GO TO 206
       ELSE
              IF(RANART(NSEED).LT.X1440/(X1440+X1535))THEN
              M12=41
              IF(RANART(NSEED).LE.0.5)M12=43
              ELSE
              M12=42
              IF(RANART(NSEED).LE.0.5)M12=44
              ENDIF
              GO TO 204
       ENDIF
        ENDIF
* FOR p+delta(0)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
*                       N*(+)(1535)+n,N*(0)(1535)+p
        IF(LB(I1)*LB(I2).EQ.7)THEN
        SIGND=0.5*SIGMA(SRT,1,1,1)+0.25*SIGMA(SRT,1,1,0)
        SIGDN=0.5*SIGND*RENOM
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF(X1.GT.(SIGNN+SIGDN+2.*x1440+2.*x1535+SIGK)/SIG)RETURN
        IF(X1.GT.(SIGNN+SIGDN+2.*x1440+2.*x1535+SIGK+sdprod)/SIG)RETURN
c
       IF(SIGK/(SIGK+SIGDN+2*X1440+2*X1535).GT.RANART(NSEED))GO TO 306
       IF(RANART(NSEED).LT.SIGDN/(SIGDN+2.*X1440+2.*X1535))THEN
        M12=2
       GO TO 206
       ELSE
              IF(RANART(NSEED).LT.X1440/(X1440+X1535))THEN
              M12=50
              IF(RANART(NSEED).LE.0.5)M12=51
              ELSE
              M12=52
              IF(RANART(NSEED).LE.0.5)M12=53
              ENDIF
              GO TO 204
       ENDIF
        ENDIF
* FOR p+N*(0)(14)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
* OR  P+N*(0)(14)-->D(+)+N, D(0)+P, 
        IF(LB(I1)*LB(I2).EQ.10.AND.
     &  (iabs(LB(I1)).EQ.1.OR.iabs(LB(I2)).EQ.1))then
        SIGND=(3./4.)*SIGMA(SRT,2,0,1)
        SIGDN=SIGND*RENOMN
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF(X1.GT.(SIGNN+SIGDN+X1535+SIGK)/SIG)RETURN
        IF(X1.GT.(SIGNN+SIGDN+X1535+SIGK+sdprod)/SIG)RETURN
c
       IF(SIGK/(SIGK+SIGDN+X1535).GT.RANART(NSEED))GO TO 306
       IF(RANART(NSEED).LT.SIGDN/(SIGDN+X1535))THEN
        M12=7
        GO TO 206
       ELSE
       M12=54
       IF(RANART(NSEED).LE.0.5)M12=55
       ENDIF
       GO TO 204
        ENDIF
* FOR n+N*(+)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
        IF(LB(I1)*LB(I2).EQ.22.AND.
     &   (iabs(LB(I1)).EQ.2.OR.iabs(LB(I2)).EQ.2))then
        SIGND=(3./4.)*SIGMA(SRT,2,0,1)
        SIGDN=SIGND*RENOMN
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF(X1.GT.(SIGNN+SIGDN+X1535+SIGK)/SIG)RETURN
        IF(X1.GT.(SIGNN+SIGDN+X1535+SIGK+sdprod)/SIG)RETURN
c
       IF(SIGK/(SIGK+SIGDN+X1535).GT.RANART(NSEED))GO TO 306
       IF(RANART(NSEED).LT.SIGDN/(SIGDN+X1535))THEN
        M12=8
        GO TO 206
       ELSE
       M12=56
       IF(RANART(NSEED).LE.0.5)M12=57
       ENDIF
       GO TO 204
        ENDIF
* FOR N*(1535)+N-->N+N COLLISIONS
        IF((iabs(LB(I1)).EQ.12).OR.(iabs(LB(I1)).EQ.13).OR.
     1  (iabs(LB(I2)).EQ.12).OR.(iabs(LB(I2)).EQ.13))THEN
        SIGND=X1535
        SIGDN=SIGND*RENOM1
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF(X1.GT.(SIGNN+SIGDN+SIGK)/SIG)RETURN
        IF(X1.GT.(SIGNN+SIGDN+SIGK+sdprod)/SIG)RETURN
c
       IF(SIGK/(SIGK+SIGDN).GT.RANART(NSEED))GO TO 306
        IF(LB(I1)*LB(I2).EQ.24)M12=10
        IF(LB(I1)*LB(I2).EQ.12)M12=12
        IF(LB(I1)*LB(I2).EQ.26)M12=11
       IF(LB(I1)*LB(I2).EQ.13)M12=9
       GO TO 206
        ENDIF
204       CONTINUE
* (1) GENERATE THE MASS FOR THE N*(1440) AND N*(1535)
* (2) CALCULATE THE FINAL MOMENTUM OF THE n+N* SYSTEM
* (3) RELABLE THE FINAL STATE PARTICLES
*PARAMETRIZATION OF THE SHAPE OF THE N* RESONANCE ACCORDING
*     TO kitazoe's or J.D.JACKSON'S MASS FORMULA AND BREIT WIGNER
*     FORMULA FOR N* RESORANCE
*     DETERMINE DELTA MASS VIA REJECTION METHOD.
          DMAX = SRT - AVMASS-0.005
          DMIN = 1.078
          IF((M12.eq.37).or.(M12.eq.39).or.
     1    (M12.eQ.41).OR.(M12.eQ.43).OR.(M12.EQ.46).
     2     OR.(M12.EQ.48).OR.(M12.EQ.50).OR.(M12.EQ.51))then
* N*(1440) production
          IF(DMAX.LT.1.44) THEN
          FM=FNS(DMAX,SRT,0.)
          ELSE

clin-10/25/02 get rid of argument usage mismatch in FNS():
             xdmass=1.44
c          FM=FNS(1.44,SRT,1.)
          FM=FNS(xdmass,SRT,1.)
clin-10/25/02-end

          ENDIF
          IF(FM.EQ.0.)FM=1.E-09
          NTRY2=0
11        DM=RANART(NSEED)*(DMAX-DMIN)+DMIN
          NTRY2=NTRY2+1
          IF((RANART(NSEED).GT.FNS(DM,SRT,1.)/FM).AND.
     1    (NTRY2.LE.10)) GO TO 11

clin-2/26/03 limit the N* mass below a certain value 
c     (here taken as its central value + 2* B-W fullwidth):
          if(dm.gt.2.14) goto 11

              GO TO 13
              ELSE
* N*(1535) production
          IF(DMAX.LT.1.535) THEN
          FM=FD5(DMAX,SRT,0.)
          ELSE

clin-10/25/02 get rid of argument usage mismatch in FNS():
             xdmass=1.535
c          FM=FD5(1.535,SRT,1.)
          FM=FD5(xdmass,SRT,1.)
clin-10/25/02-end

          ENDIF
          IF(FM.EQ.0.)FM=1.E-09
          NTRY1=0
12        DM = RANART(NSEED) * (DMAX-DMIN) + DMIN
          NTRY1=NTRY1+1
          IF((RANART(NSEED) .GT. FD5(DM,SRT,1.)/FM).AND.
     1    (NTRY1.LE.10)) GOTO 12

clin-2/26/03 limit the N* mass below a certain value 
c     (here taken as its central value + 2* B-W fullwidth):
          if(dm.gt.1.84) goto 12

             ENDIF
13       CONTINUE
* (2) DETERMINE THE FINAL MOMENTUM
       PRF=0.
       PF2=((SRT**2-DM**2+AVMASS**2)/(2.*SRT))**2-AVMASS**2
       IF(PF2.GT.0.)PRF=SQRT(PF2)
* (3) RELABLE FINAL STATE PARTICLES
* 37 D(++)+n-->N*(+)(14)+p
          IF(M12.EQ.37)THEN
          IF(iabs(LB(I1)).EQ.9)THEN
          LB(I1)=1
          E(I1)=AMP
         LB(I2)=11
         E(I2)=DM
          ELSE
          LB(I2)=1
          E(I2)=AMP
         LB(I1)=11
         E(I1)=DM
          ENDIF
         GO TO 207
          ENDIF
* 38 D(++)+n-->N*(+)(15)+p
          IF(M12.EQ.38)THEN
          IF(iabs(LB(I1)).EQ.9)THEN
          LB(I1)=1
          E(I1)=AMP
         LB(I2)=13
         E(I2)=DM
          ELSE
          LB(I2)=1
          E(I2)=AMP
         LB(I1)=13
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 39 D(+)+P-->N*(+)(14)+p
          IF(M12.EQ.39)THEN
          IF(iabs(LB(I1)).EQ.8)THEN
          LB(I1)=1
          E(I1)=AMP
         LB(I2)=11
         E(I2)=DM
          ELSE
          LB(I2)=1
          E(I2)=AMP
         LB(I1)=11
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 40 D(+)+P-->N*(+)(15)+p
          IF(M12.EQ.40)THEN
          IF(iabs(LB(I1)).EQ.8)THEN
          LB(I1)=1
          E(I1)=AMP
         LB(I2)=13
         E(I2)=DM
          ELSE
          LB(I2)=1
          E(I2)=AMP
         LB(I1)=13
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 41 D(+)+N-->N*(+)(14)+N
          IF(M12.EQ.41)THEN
          IF(iabs(LB(I1)).EQ.8)THEN
          LB(I1)=2
          E(I1)=AMN
         LB(I2)=11
         E(I2)=DM
          ELSE
          LB(I2)=2
          E(I2)=AMN
         LB(I1)=11
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 42 D(+)+N-->N*(+)(15)+N
          IF(M12.EQ.42)THEN
          IF(iabs(LB(I1)).EQ.8)THEN
          LB(I1)=2
          E(I1)=AMN
         LB(I2)=13
         E(I2)=DM
          ELSE
          LB(I2)=2
          E(I2)=AMN
         LB(I1)=13
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 43 D(+)+N-->N*(0)(14)+P
          IF(M12.EQ.43)THEN
          IF(iabs(LB(I1)).EQ.8)THEN
          LB(I1)=1
          E(I1)=AMP
         LB(I2)=10
         E(I2)=DM
          ELSE
          LB(I2)=1
          E(I2)=AMP
         LB(I1)=10
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 44 D(+)+N-->N*(0)(15)+P
          IF(M12.EQ.44)THEN
          IF(iabs(LB(I1)).EQ.8)THEN
          LB(I1)=1
          E(I1)=AMP
         LB(I2)=12
         E(I2)=DM
          ELSE
          LB(I2)=1
          E(I2)=AMP
         LB(I1)=12
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 46 D(-)+P-->N*(0)(14)+N
          IF(M12.EQ.46)THEN
          IF(iabs(LB(I1)).EQ.6)THEN
          LB(I1)=2
          E(I1)=AMN
         LB(I2)=10
         E(I2)=DM
          ELSE
          LB(I2)=2
          E(I2)=AMN
         LB(I1)=10
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 47 D(-)+P-->N*(0)(15)+N
          IF(M12.EQ.47)THEN
          IF(iabs(LB(I1)).EQ.6)THEN
          LB(I1)=2
          E(I1)=AMN
         LB(I2)=12
         E(I2)=DM
          ELSE
          LB(I2)=2
          E(I2)=AMN
         LB(I1)=12
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 48 D(0)+N-->N*(0)(14)+N
          IF(M12.EQ.48)THEN
          IF(iabs(LB(I1)).EQ.7)THEN
          LB(I1)=2
          E(I1)=AMN
         LB(I2)=11
         E(I2)=DM
          ELSE
          LB(I2)=2
          E(I2)=AMN
         LB(I1)=11
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 49 D(0)+N-->N*(0)(15)+N
          IF(M12.EQ.49)THEN
          IF(iabs(LB(I1)).EQ.7)THEN
          LB(I1)=2
          E(I1)=AMN
         LB(I2)=12
         E(I2)=DM
          ELSE
          LB(I2)=2
          E(I2)=AMN
         LB(I1)=12
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 50 D(0)+P-->N*(0)(14)+P
          IF(M12.EQ.50)THEN
          IF(iabs(LB(I1)).EQ.7)THEN
          LB(I1)=1
          E(I1)=AMP
         LB(I2)=10
         E(I2)=DM
          ELSE
          LB(I2)=1
          E(I2)=AMP
         LB(I1)=10
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 51 D(0)+P-->N*(+)(14)+N
          IF(M12.EQ.51)THEN
          IF(iabs(LB(I1)).EQ.7)THEN
          LB(I1)=2
          E(I1)=AMN
         LB(I2)=11
         E(I2)=DM
          ELSE
          LB(I2)=2
          E(I2)=AMN
         LB(I1)=11
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 52 D(0)+P-->N*(0)(15)+P
          IF(M12.EQ.52)THEN
          IF(iabs(LB(I1)).EQ.7)THEN
          LB(I1)=1
          E(I1)=AMP
         LB(I2)=12
         E(I2)=DM
          ELSE
          LB(I2)=1
          E(I2)=AMP
         LB(I1)=12
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 53 D(0)+P-->N*(+)(15)+N
          IF(M12.EQ.53)THEN
          IF(iabs(LB(I1)).EQ.7)THEN
          LB(I1)=2
          E(I1)=AMN
         LB(I2)=13
         E(I2)=DM
          ELSE
          LB(I2)=2
          E(I2)=AMN
         LB(I1)=13
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 54 N*(0)(14)+P-->N*(+)(15)+N
          IF(M12.EQ.54)THEN
          IF(iabs(LB(I1)).EQ.10)THEN
          LB(I1)=2
          E(I1)=AMN
         LB(I2)=13
         E(I2)=DM
          ELSE
          LB(I2)=2
          E(I2)=AMN
         LB(I1)=13
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 55 N*(0)(14)+P-->N*(0)(15)+P
          IF(M12.EQ.55)THEN
          IF(iabs(LB(I1)).EQ.10)THEN
          LB(I1)=1
          E(I1)=AMP
         LB(I2)=12
         E(I2)=DM
          ELSE
          LB(I2)=1
          E(I2)=AMP
         LB(I1)=12
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 56 N*(+)(14)+N-->N*(+)(15)+N
          IF(M12.EQ.56)THEN
          IF(iabs(LB(I1)).EQ.11)THEN
          LB(I1)=2
          E(I1)=AMN
         LB(I2)=13
         E(I2)=DM
          ELSE
          LB(I2)=2
          E(I2)=AMN
         LB(I1)=13
         E(I1)=DM
          ENDIF
         GO TO 207
         ENDIF
* 57 N*(+)(14)+N-->N*(0)(15)+P
          IF(M12.EQ.57)THEN
          IF(iabs(LB(I1)).EQ.11)THEN
          LB(I1)=1
          E(I1)=AMP
         LB(I2)=12
         E(I2)=DM
          ELSE
          LB(I2)=1
          E(I2)=AMP
         LB(I1)=12
         E(I1)=DM
          ENDIF
         ENDIF
          GO TO 207
*------------------------------------------------
* RELABLE NUCLEONS AFTER DELTA OR N* BEING ABSORBED
*(1) n+delta(+)-->n+p
206       IF(M12.EQ.1)THEN
          IF(iabs(LB(I1)).EQ.8)THEN
          LB(I2)=2
          LB(I1)=1
          E(I1)=AMP
          ELSE
          LB(I1)=2
          LB(I2)=1
          E(I2)=AMP
          ENDIF
         GO TO 207
          ENDIF
*(2) p+delta(0)-->p+n
          IF(M12.EQ.2)THEN
          IF(iabs(LB(I1)).EQ.7)THEN
          LB(I2)=1
          LB(I1)=2
          E(I1)=AMN
          ELSE
          LB(I1)=1
          LB(I2)=2
          E(I2)=AMN
          ENDIF
         GO TO 207
          ENDIF
*(3) n+delta(++)-->p+p
          IF(M12.EQ.3)THEN
          LB(I1)=1
          LB(I2)=1
          E(I1)=AMP
          E(I2)=AMP
         GO TO 207
          ENDIF
*(4) p+delta(+)-->p+p
          IF(M12.EQ.4)THEN
          LB(I1)=1
          LB(I2)=1
          E(I1)=AMP
          E(I2)=AMP
         GO TO 207
          ENDIF
*(5) n+delta(0)-->n+n
          IF(M12.EQ.5)THEN
          LB(I1)=2
          LB(I2)=2
          E(I1)=AMN
          E(I2)=AMN
         GO TO 207
          ENDIF
*(6) p+delta(-)-->n+n
          IF(M12.EQ.6)THEN
          LB(I1)=2
          LB(I2)=2
          E(I1)=AMN
          E(I2)=AMN
         GO TO 207
          ENDIF
*(7) p+N*(0)-->n+p
          IF(M12.EQ.7)THEN
          IF(iabs(LB(I1)).EQ.1)THEN
          LB(I1)=1
          LB(I2)=2
          E(I1)=AMP
          E(I2)=AMN
          ELSE
          LB(I1)=2
          LB(I2)=1
          E(I1)=AMN
          E(I2)=AMP
          ENDIF
         GO TO 207
          ENDIF
*(8) n+N*(+)-->n+p
          IF(M12.EQ.8)THEN
          IF(iabs(LB(I1)).EQ.2)THEN
          LB(I1)=2
          LB(I2)=1
          E(I1)=AMN
          E(I2)=AMP
          ELSE
          LB(I1)=1
          LB(I2)=2
          E(I1)=AMP
          E(I2)=AMN
          ENDIF
         GO TO 207
          ENDIF
clin-6/2008
c*(9) N*(+)p-->pp
*(9) N*(+)(1535) p-->pp
          IF(M12.EQ.9)THEN
          LB(I1)=1
          LB(I2)=1
          E(I1)=AMP
          E(I2)=AMP
         GO TO 207
         ENDIF
*(12) N*(0)P-->nP
          IF(M12.EQ.12)THEN
          LB(I1)=2
          LB(I2)=1
          E(I1)=AMN
          E(I2)=AMP
         GO TO 207
         ENDIF
*(11) N*(+)n-->nP
          IF(M12.EQ.11)THEN
          LB(I1)=2
          LB(I2)=1
          E(I1)=AMN
          E(I2)=AMP
         GO TO 207
         ENDIF
clin-6/2008
c*(12) N*(0)p-->Np
*(12) N*(0)(1535) p-->Np
          IF(M12.EQ.12)THEN
          LB(I1)=1
          LB(I2)=2
          E(I1)=AMP
          E(I2)=AMN
         ENDIF
*----------------------------------------------
207       PR   = PRF
          C1   = 1.0 - 2.0 * RANART(NSEED)
              if(srt.le.2.14)C1= 1.0 - 2.0 * RANART(NSEED)
         if(srt.gt.2.14.and.srt.le.2.4)c1=ang(srt,iseed)
         if(srt.gt.2.4)then

clin-10/25/02 get rid of argument usage mismatch in PTR():
             xptr=0.33*pr
c         cc1=ptr(0.33*pr,iseed)
         cc1=ptr(xptr,iseed)
clin-10/25/02-end

clin-9/2012: check argument in sqrt():
         scheck=pr**2-cc1**2
         if(scheck.lt.0) then
            write(99,*) 'scheck4: ', scheck
            scheck=0.
         endif
         c1=sqrt(scheck)/pr
c         c1=sqrt(pr**2-cc1**2)/pr

         endif
          T1   = 2.0 * PI * RANART(NSEED)
          IBLOCK=3
      ENDIF
      if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
         lb(i1) = -lb(i1)
         lb(i2) = -lb(i2)
      endif

*-----------------------------------------------------------------------
*COM: SET THE NEW MOMENTUM COORDINATES
 107  IF(PX .EQ. 0.0 .AND. PY .EQ. 0.0) THEN
         T2 = 0.0
      ELSE
         T2=ATAN2(PY,PX)
      END IF

clin-9/2012: check argument in sqrt():
      scheck=1.0 - C1**2
      if(scheck.lt.0) then
         write(99,*) 'scheck5: ', scheck
         scheck=0.
      endif
      S1=SQRT(scheck)
c      S1   = SQRT( 1.0 - C1**2 )

clin-9/2012: check argument in sqrt():
      scheck=1.0 - C2**2
      if(scheck.lt.0) then
         write(99,*) 'scheck6: ', scheck
         scheck=0.
      endif
      S2=SQRT(scheck)
c      S2  =  SQRT( 1.0 - C2**2 )

      CT1  = COS(T1)
      ST1  = SIN(T1)
      CT2  = COS(T2)
      ST2  = SIN(T2)
      PZ   = PR * ( C1*C2 - S1*S2*CT1 )
      SS   = C2 * S1 * CT1  +  S2 * C1
      PX   = PR * ( SS*CT2 - S1*ST1*ST2 )
      PY   = PR * ( SS*ST2 + S1*ST1*CT2 )
      RETURN
* FOR THE NN-->KAON+X PROCESS, FIND MOMENTUM OF THE FINAL PARTICLES IN 
* THE NUCLEUS-NUCLEUS CMS.
306     CONTINUE
csp11/21/01 phi production
              if(XSK5/sigK.gt.RANART(NSEED))then
              pz1=p(3,i1)
              pz2=p(3,i2)
                LB(I1) = 1 + int(2 * RANART(NSEED))
                LB(I2) = 1 + int(2 * RANART(NSEED))
              nnn=nnn+1
                LPION(NNN,IRUN)=29
                EPION(NNN,IRUN)=APHI
                iblock = 222
              GO TO 208
               ENDIF
csp11/21/01 end
                IBLOCK=11
                if(ianti .eq. 1)iblock=-11
c
              pz1=p(3,i1)
              pz2=p(3,i2)
* DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
              nnn=nnn+1
                LPION(NNN,IRUN)=23
                EPION(NNN,IRUN)=Aka
              if(srt.le.2.63)then
* only lambda production is possible
* (1.1)P+P-->p+L+kaon+
              ic=1

                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              GO TO 208
                ENDIF
       if(srt.le.2.74.and.srt.gt.2.63)then
* both Lambda and sigma production are possible
              if(XSK1/(XSK1+XSK2).gt.RANART(NSEED))then
* lambda production
              ic=1

                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              else
* sigma production

                   LB(I1) = 1 + int(2 * RANART(NSEED))
                   LB(I2) = 15 + int(3 * RANART(NSEED))
              ic=2
              endif
              GO TO 208
       endif
       if(srt.le.2.77.and.srt.gt.2.74)then
* then pp-->Delta lamda kaon can happen
              if(xsk1/(xsk1+xsk2+xsk3).
     1          gt.RANART(NSEED))then
* * (1.1)P+P-->p+L+kaon+
              ic=1

                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              go to 208
              else
              if(xsk2/(xsk2+xsk3).gt.RANART(NSEED))then
* pp-->psk
              ic=2

                LB(I1) = 1 + int(2 * RANART(NSEED))
                LB(I2) = 15 + int(3 * RANART(NSEED))

              else
* pp-->D+l+k        
              ic=3

                LB(I1) = 6 + int(4 * RANART(NSEED))
              lb(i2)=14
              endif
              GO TO 208
              endif
       endif
       if(srt.gt.2.77)then
* all four channels are possible
              if(xsk1/(xsk1+xsk2+xsk3+xsk4).gt.RANART(NSEED))then
* p lambda k production
              ic=1

                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              go to 208
       else
          if(xsk3/(xsk2+xsk3+xsk4).gt.RANART(NSEED))then
* delta l K production
              ic=3

                LB(I1) = 6 + int(4 * RANART(NSEED))
              lb(i2)=14
              go to 208
          else
              if(xsk2/(xsk2+xsk4).gt.RANART(NSEED))then
* n sigma k production

                   LB(I1) = 1 + int(2 * RANART(NSEED))
                   LB(I2) = 15 + int(3 * RANART(NSEED))

              ic=2
              else
              ic=4

                LB(I1) = 6 + int(4 * RANART(NSEED))
                LB(I2) = 15 + int(3 * RANART(NSEED))

              endif
              go to 208
          endif
       endif
       endif
208             continue
         if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
          lb(i1) = - lb(i1)
          lb(i2) = - lb(i2)
          if(LPION(NNN,IRUN) .eq. 23)LPION(NNN,IRUN)=21
         endif
       lbi1=lb(i1)
       lbi2=lb(i2)
* KEEP ALL COORDINATES OF PARTICLE 2 FOR POSSIBLE PHASE SPACE CHANGE
           NTRY1=0
128        CALL BBKAON(ic,SRT,PX3,PY3,PZ3,DM3,PX4,PY4,PZ4,DM4,
     &  PPX,PPY,PPZ,icou1)
       NTRY1=NTRY1+1
       if((icou1.lt.0).AND.(NTRY1.LE.20))GO TO 128
c       if(icou1.lt.0)return
* ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
       CALL ROTATE(PX,PY,PZ,PX3,PY3,PZ3)
       CALL ROTATE(PX,PY,PZ,PX4,PY4,PZ4)
       CALL ROTATE(PX,PY,PZ,PPX,PPY,PPZ)
* FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
* NUCLEUS CMS. FRAME 
* (1) for the necleon/delta
*             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
              E1CM    = SQRT (dm3**2 + PX3**2 + PY3**2 + PZ3**2)
              P1BETA  = PX3*BETAX + PY3*BETAY + PZ3*BETAZ
              TRANSF  = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) + E1CM )
              Pt1i1 = BETAX * TRANSF + PX3
              Pt2i1 = BETAY * TRANSF + PY3
              Pt3i1 = BETAZ * TRANSF + PZ3
             Eti1   = DM3
* (2) for the lambda/sigma
                E2CM    = SQRT (dm4**2 + PX4**2 + PY4**2 + PZ4**2)
                P2BETA  = PX4*BETAX+PY4*BETAY+PZ4*BETAZ
                TRANSF  = GAMMA * (GAMMA*P2BETA / (GAMMA + 1.) + E2CM)
                Pt1I2 = BETAX * TRANSF + PX4
                Pt2I2 = BETAY * TRANSF + PY4
                Pt3I2 = BETAZ * TRANSF + PZ4
              EtI2   = DM4
* GET the kaon'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
                EPCM=SQRT(aka**2+PPX**2+PPY**2+PPZ**2)
                PPBETA=PPX*BETAX+PPY*BETAY+PPZ*BETAZ
                TRANSF=GAMMA*(GAMMA*PPBETA/(GAMMA+1.)+EPCM)
                PPION(1,NNN,IRUN)=BETAX*TRANSF+PPX
                PPION(2,NNN,IRUN)=BETAY*TRANSF+PPY
                PPION(3,NNN,IRUN)=BETAZ*TRANSF+PPZ
clin-5/2008:
                dppion(nnn,irun)=dpertp(i1)*dpertp(i2)
clin-5/2008:
c2008        X01 = 1.0 - 2.0 * RANART(NSEED)
c            Y01 = 1.0 - 2.0 * RANART(NSEED)
c            Z01 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2008
c                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
c                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
c                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
                    RPION(1,NNN,IRUN)=R(1,I1)
                    RPION(2,NNN,IRUN)=R(2,I1)
                    RPION(3,NNN,IRUN)=R(3,I1)
c
* assign the nucleon/delta and lambda/sigma to i1 or i2 to keep the 
* leadng particle behaviour
C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
              p(1,i1)=pt1i1
              p(2,i1)=pt2i1
              p(3,i1)=pt3i1
              e(i1)=eti1
              lb(i1)=lbi1
              p(1,i2)=pt1i2
              p(2,i2)=pt2i2
              p(3,i2)=pt3i2
              e(i2)=eti2
              lb(i2)=lbi2
                PX1     = P(1,I1)
                PY1     = P(2,I1)
                PZ1     = P(3,I1)
              EM1       = E(I1)
                ID(I1)  = 2
                ID(I2)  = 2
                ID1     = ID(I1)
                if(LPION(NNN,IRUN) .ne. 29) IBLOCK=11
        LB1=LB(I1)
        LB2=LB(I2)
        AM1=EM1
       am2=em2
        E1= SQRT( EM1**2 + PX1**2 + PY1**2 + PZ1**2 )
       RETURN

clin-6/2008 N+D->Deuteron+pi:
*     FIND MOMENTUM OF THE FINAL PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
 108   CONTINUE
           if(idpert.eq.1.and.ipert1.eq.1.and.npertd.ge.1) then
c     For idpert=1: we produce npertd pert deuterons:
              ndloop=npertd
           elseif(idpert.eq.2.and.npertd.ge.1) then
c     For idpert=2: we first save information for npertd pert deuterons;
c     at the last ndloop we create the regular deuteron+pi 
c     and those pert deuterons:
              ndloop=npertd+1
           else
c     Just create the regular deuteron+pi:
              ndloop=1
           endif
c
           dprob1=sdprod/sig/float(npertd)
           do idloop=1,ndloop
              CALL bbdangle(pxd,pyd,pzd,nt,ipert1,ianti,idloop,pfinal,
     1 dprob1,lbm)
              CALL ROTATE(PX,PY,PZ,PXd,PYd,PZd)
*     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL STATE 
*     FROM THE NN CMS FRAME INTO THE GLOBAL CMS FRAME:
*     For the Deuteron:
              xmass=xmd
              E1dCM=SQRT(xmass**2+PXd**2+PYd**2+PZd**2)
              P1dBETA=PXd*BETAX+PYd*BETAY+PZd*BETAZ
              TRANSF=GAMMA*(GAMMA*P1dBETA/(GAMMA+1.)+E1dCM)
              pxi1=BETAX*TRANSF+PXd
              pyi1=BETAY*TRANSF+PYd
              pzi1=BETAZ*TRANSF+PZd
              if(ianti.eq.0)then
                 lbd=42
              else
                 lbd=-42
              endif
              if(idpert.eq.1.and.ipert1.eq.1.and.npertd.ge.1) then
cccc  Perturbative production for idpert=1:
                 nnn=nnn+1
                 PPION(1,NNN,IRUN)=pxi1
                 PPION(2,NNN,IRUN)=pyi1
                 PPION(3,NNN,IRUN)=pzi1
                 EPION(NNN,IRUN)=xmd
                 LPION(NNN,IRUN)=lbd
                 RPION(1,NNN,IRUN)=R(1,I1)
                 RPION(2,NNN,IRUN)=R(2,I1)
                 RPION(3,NNN,IRUN)=R(3,I1)
clin-6/2008 assign the perturbative probability:
                 dppion(NNN,IRUN)=sdprod/sig/float(npertd)
              elseif(idpert.eq.2.and.idloop.le.npertd) then
clin-6/2008 For idpert=2, we produce NPERTD perturbative (anti)deuterons 
c     only when a regular (anti)deuteron+pi is produced in NN collisions.
c     First save the info for the perturbative deuterons:
                 ppd(1,idloop)=pxi1
                 ppd(2,idloop)=pyi1
                 ppd(3,idloop)=pzi1
                 lbpd(idloop)=lbd
              else
cccc  Regular production:
c     For the regular pion: do LORENTZ-TRANSFORMATION:
                 E(i1)=xmm
                 E2piCM=SQRT(xmm**2+PXd**2+PYd**2+PZd**2)
                 P2piBETA=-PXd*BETAX-PYd*BETAY-PZd*BETAZ
                 TRANSF=GAMMA*(GAMMA*P2piBETA/(GAMMA+1.)+E2piCM)
                 pxi2=BETAX*TRANSF-PXd
                 pyi2=BETAY*TRANSF-PYd
                 pzi2=BETAZ*TRANSF-PZd
                 p(1,i1)=pxi2
                 p(2,i1)=pyi2
                 p(3,i1)=pzi2
c     Remove regular pion to check the equivalence 
c     between the perturbative and regular deuteron results:
c                 E(i1)=0.
c
                 LB(I1)=lbm
                 PX1=P(1,I1)
                 PY1=P(2,I1)
                 PZ1=P(3,I1)
                 EM1=E(I1)
                 ID(I1)=2
                 ID1=ID(I1)
                 E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
                 lb1=lb(i1)
c     For the regular deuteron:
                 p(1,i2)=pxi1
                 p(2,i2)=pyi1
                 p(3,i2)=pzi1
                 lb(i2)=lbd
                 lb2=lb(i2)
                 E(i2)=xmd
                 EtI2=E(I2)
                 ID(I2)=2
c     For idpert=2: create the perturbative deuterons:
                 if(idpert.eq.2.and.idloop.eq.ndloop) then
                    do ipertd=1,npertd
                       nnn=nnn+1
                       PPION(1,NNN,IRUN)=ppd(1,ipertd)
                       PPION(2,NNN,IRUN)=ppd(2,ipertd)
                       PPION(3,NNN,IRUN)=ppd(3,ipertd)
                       EPION(NNN,IRUN)=xmd
                       LPION(NNN,IRUN)=lbpd(ipertd)
                       RPION(1,NNN,IRUN)=R(1,I1)
                       RPION(2,NNN,IRUN)=R(2,I1)
                       RPION(3,NNN,IRUN)=R(3,I1)
clin-6/2008 assign the perturbative probability:
                       dppion(NNN,IRUN)=1./float(npertd)
                    enddo
                 endif
              endif
           enddo
           IBLOCK=501
           return
clin-6/2008 N+D->Deuteron+pi over

      END
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE CRDD(IRUN,PX,PY,PZ,SRT,I1,I2,IBLOCK,
     1NTAG,SIGNN,SIG,NT,ipert1)
c     1NTAG,SIGNN,SIG)
*     PURPOSE:                                                         *
*             DEALING WITH BARYON RESONANCE-BARYON RESONANCE COLLISIONS*
*     NOTE   :                                                         *
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
*           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
*           IBLOCK   - THE INFORMATION BACK                            *
*                      0-> COLLISION CANNOT HAPPEN                     *
*                      1-> N-N ELASTIC COLLISION                       *
*                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
*                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
*                      4-> N+N->N+N+PION,DIRTCT PROCESS                *
*                     5-> DELTA(N*)+DELTA(N*)   TOTAL   COLLISIONS    *
*           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
*                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
*                      N12,                                            *
*                      M12=1 FOR p+n-->delta(+)+ n                     *
*                          2     p+n-->delta(0)+ p                     *
*                          3     p+p-->delta(++)+n                     *
*                          4     p+p-->delta(+)+p                      *
*                          5     n+n-->delta(0)+n                      *
*                          6     n+n-->delta(-)+p                      *
*                          7     n+p-->N*(0)(1440)+p                   *
*                          8     n+p-->N*(+)(1440)+n                   *
*                        9     p+p-->N*(+)(1535)+p                     *
*                        10    n+n-->N*(0)(1535)+n                     *
*                         11    n+p-->N*(+)(1535)+n                     *
*                        12    n+p-->N*(0)(1535)+p
*                        13    D(++)+D(-)-->N*(+)(1440)+n
*                         14    D(++)+D(-)-->N*(0)(1440)+p
*                        15    D(+)+D(0)--->N*(+)(1440)+n
*                        16    D(+)+D(0)--->N*(0)(1440)+p
*                        17    D(++)+D(0)-->N*(+)(1535)+p
*                        18    D(++)+D(-)-->N*(0)(1535)+p
*                        19    D(++)+D(-)-->N*(+)(1535)+n
*                        20    D(+)+D(+)-->N*(+)(1535)+p
*                        21    D(+)+D(0)-->N*(+)(1535)+n
*                        22    D(+)+D(0)-->N*(0)(1535)+p
*                        23    D(+)+D(-)-->N*(0)(1535)+n
*                        24    D(0)+D(0)-->N*(0)(1535)+n
*                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
*                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
*                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
*                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
*                        29    N*(+)(14)+D+-->N*(+)(15)+p
*                        30    N*(+)(14)+D0-->N*(+)(15)+n
*                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
*                        32    N*(0)(14)+D++--->N*(+)(15)+p
*                        33    N*(0)(14)+D+--->N*(+)(15)+n
*                        34    N*(0)(14)+D+--->N*(0)(15)+p
*                        35    N*(0)(14)+D0-->N*(0)(15)+n
*                        36    N*(+)(14)+D0--->N*(0)(15)+p
*                        +++
*               AND MORE CHANNELS AS LISTED IN THE NOTE BOOK      
*
* NOTE ABOUT N*(1440) RESORANCE:                                       *
*     As it has been discussed in VerWest's paper,I= 1 (initial isospin)
*     channel can all be attributed to delta resorance while I= 0      *
*     channel can all be  attribured to N* resorance.Only in n+p       *
*     one can have I=0 channel so is the N*(1440) resorance            *
* REFERENCES:    J. CUGNON ET AL., NUCL. PHYS. A352, 505 (1981)        *
*                    Y. KITAZOE ET AL., PHYS. LETT. 166B, 35 (1986)    *
*                    B. VerWest el al., PHYS. PRV. C25 (1982)1979      *
*                    Gy. Wolf  et al, Nucl Phys A517 (1990) 615        *
*                    CUTOFF = 2 * AVMASS + 20 MEV                      *
*                                                                      *
*       for N*(1535) we use the parameterization by Gy. Wolf et al     *
*       Nucl phys A552 (1993) 349, added May 18, 1994                  *
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AKA=0.498,APHI=1.020,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        parameter (xmd=1.8756,npdmax=10000)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common /ff/f(-mx:mx,-my:my,-mz:mz,-mpx:mpx,-mpy:mpy,-mpz:mpzp)
cc      SAVE /ff/
        common /gg/ dx,dy,dz,dpx,dpy,dpz
cc      SAVE /gg/
        COMMON /INPUT/ NSTAR,NDIRCT,DIR
cc      SAVE /INPUT/
        COMMON /NN/NNN
cc      SAVE /NN/
        COMMON /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1 px1n,py1n,pz1n,dp1n
cc      SAVE /leadng/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      common /dpi/em2,lb2
      common /para8/ idpert,npertd,idxsec
      dimension ppd(3,npdmax),lbpd(npdmax)
      SAVE   
*-----------------------------------------------------------------------
       n12=0
       m12=0
        IBLOCK=0
        NTAG=0
        EM1=E(I1)
        EM2=E(I2)
      PR  = SQRT( PX**2 + PY**2 + PZ**2 )
      C2  = PZ / PR
      IF(PX .EQ. 0.0 .AND. PY .EQ. 0.0) THEN
        T2 = 0.0
      ELSE
        T2=ATAN2(PY,PX)
      END IF
      X1  = RANART(NSEED)
      ianti=0
      if(lb(i1).lt.0 .and. lb(i2).lt.0)ianti=1

clin-6/2008 Production of perturbative deuterons for idpert=1:
      call sbbdm(srt,sdprod,ianti,lbm,xmm,pfinal)
      if(idpert.eq.1.and.ipert1.eq.1) then
         IF (SRT .LT. 2.012) RETURN
         if((iabs(lb(i1)).ge.6.and.iabs(lb(i1)).le.13)
     1        .and.(iabs(lb(i2)).ge.6.and.iabs(lb(i2)).le.13)) then
            goto 108
         else
            return
         endif
      endif
      
*-----------------------------------------------------------------------
*COM: TEST FOR ELASTIC SCATTERING (EITHER N-N OR DELTA-DELTA 0R
*      N-DELTA OR N*-N* or N*-Delta)
      IF (X1 .LE. SIGNN/SIG) THEN
*COM:  PARAMETRISATION IS TAKEN FROM THE CUGNON-PAPER
        AS  = ( 3.65 * (SRT - 1.8766) )**6
        A   = 6.0 * AS / (1.0 + AS)
        TA  = -2.0 * PR**2
        X   = RANART(NSEED)
clin-10/24/02        T1  = DLOG( (1-X) * DEXP(dble(A)*dble(TA)) + X )  /  A
        T1  = sngl(DLOG(dble(1.-X)*DEXP(dble(A)*dble(TA))+dble(X)))/  A
        C1  = 1.0 - T1/TA
        T1  = 2.0 * PI * RANART(NSEED)
        IBLOCK=20
       GO TO 107
      ELSE
*COM: TEST FOR INELASTIC SCATTERING
*     IF THE AVAILABLE ENERGY IS LESS THAN THE PION-MASS, NOTHING
*     CAN HAPPEN ANY MORE ==> RETURN (2.15 = 2*AVMASS +2*PI-MASS)
        IF (SRT .LT. 2.15) RETURN
*     IF THERE WERE 2 N*(1535) AND THEY DIDN'T SCATT. ELAST., 
*     ALLOW THEM TO PRODUCE KAONS. NO OTHER INELASTIC CHANNELS
*     ARE KNOWN
C       if((lb(i1).ge.12).and.(lb(i2).ge.12))return
*     ALL the inelastic collisions between N*(1535) and Delta as well
*     as N*(1440) TO PRODUCE KAONS, NO OTHER CHANNELS ARE KNOWN
C       if((lb(i1).ge.12).and.(lb(i2).ge.3))return
C       if((lb(i2).ge.12).and.(lb(i1).ge.3))return
*     calculate the N*(1535) production cross section in I1+I2 collisions
       call N1535(iabs(lb(i1)),iabs(lb(i2)),srt,X1535)

* for Delta+Delta-->N*(1440 OR 1535)+N AND N*(1440)+N*(1440)-->N*(1535)+X 
*     AND DELTA+N*(1440)-->N*(1535)+X
* WE ASSUME THEY HAVE THE SAME CROSS SECTIONS as CORRESPONDING N+N COLLISION):
* FOR D++D0, D+D+,D+D-,D0D0,N*+N*+,N*0N*0,N*(+)D+,N*(+)D(-),N*(0)D(0)
* N*(1535) production, kaon production and reabsorption through 
* D(N*)+D(N*)-->NN are ALLOWED.
* CROSS SECTION FOR KAON PRODUCTION from the four channels are
* for NLK channel
       akp=0.498
       ak0=0.498
       ana=0.938
       ada=1.232
       al=1.1157
       as=1.1197
       xsk1=0
       xsk2=0
       xsk3=0
       xsk4=0
       xsk5=0
       t1nlk=ana+al+akp
       if(srt.le.t1nlk)go to 222
       XSK1=1.5*PPLPK(SRT)
* for DLK channel
       t1dlk=ada+al+akp
       t2dlk=ada+al-akp
       if(srt.le.t1dlk)go to 222
       es=srt
       pmdlk2=(es**2-t1dlk**2)*(es**2-t2dlk**2)/(4.*es**2)
       pmdlk=sqrt(pmdlk2)
       XSK3=1.5*PPLPK(srt)
* for NSK channel
       t1nsk=ana+as+akp
       t2nsk=ana+as-akp
       if(srt.le.t1nsk)go to 222
       pmnsk2=(es**2-t1nsk**2)*(es**2-t2nsk**2)/(4.*es**2)
       pmnsk=sqrt(pmnsk2)
       XSK2=1.5*(PPK1(srt)+PPK0(srt))
* for DSK channel
       t1DSk=aDa+aS+akp
       t2DSk=aDa+aS-akp
       if(srt.le.t1dsk)go to 222
       pmDSk2=(es**2-t1DSk**2)*(es**2-t2DSk**2)/(4.*es**2)
       pmDSk=sqrt(pmDSk2)
       XSK4=1.5*(PPK1(srt)+PPK0(srt))
csp11/21/01
c phi production
       if(srt.le.(2.*amn+aphi))go to 222
c  !! mb put the correct form
         xsk5 = 0.0001
csp11/21/01 end
* THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
222       SIGK=XSK1+XSK2+XSK3+XSK4

cbz3/7/99 neutralk
        XSK1 = 2.0 * XSK1
        XSK2 = 2.0 * XSK2
        XSK3 = 2.0 * XSK3
        XSK4 = 2.0 * XSK4
        SIGK = 2.0 * SIGK + xsk5
cbz3/7/99 neutralk end

* The reabsorption cross section for the process
* D(N*)D(N*)-->NN is
       s2d=reab2d(i1,i2,srt)

cbz3/16/99 pion
        S2D = 0.
cbz3/16/99 pion end

*(1) N*(1535)+D(N*(1440)) reactions
*    we allow kaon production and reabsorption only
       if(((iabs(lb(i1)).ge.12).and.(iabs(lb(i2)).ge.12)).OR.
     &       ((iabs(lb(i1)).ge.12).and.(iabs(lb(i2)).ge.6)).OR.
     &       ((iabs(lb(i2)).ge.12).and.(iabs(lb(i1)).ge.6)))THEN
       signd=sigk+s2d
clin-6/2008
       IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c       if(x1.gt.(signd+signn)/sig)return
       if(x1.gt.(signd+signn+sdprod)/sig)return
c
* if kaon production
clin-6/2008
c       IF(SIGK/SIG.GE.RANART(NSEED))GO TO 306
       IF((SIGK+sdprod)/SIG.GE.RANART(NSEED))GO TO 306
c
* if reabsorption
       go to 1012
       ENDIF
       IDD=iabs(LB(I1)*LB(I2))
* channels have the same charge as pp 
        IF((IDD.EQ.63).OR.(IDD.EQ.64).OR.(IDD.EQ.48).
     1  OR.(IDD.EQ.49).OR.(IDD.EQ.11*11).OR.(IDD.EQ.10*10).
     2  OR.(IDD.EQ.88).OR.(IDD.EQ.66).
     3  OR.(IDD.EQ.90).OR.(IDD.EQ.70))THEN
        SIGND=X1535+SIGK+s2d
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF (X1.GT.(SIGNN+SIGND)/SIG)RETURN
        IF (X1.GT.(SIGNN+SIGND+sdprod)/SIG)RETURN
c
* if kaon production
       IF(SIGK/SIGND.GT.RANART(NSEED))GO TO 306
* if reabsorption
       if(s2d/(x1535+s2d).gt.RANART(NSEED))go to 1012
* if N*(1535) production
       IF(IDD.EQ.63)N12=17
       IF(IDD.EQ.64)N12=20
       IF(IDD.EQ.48)N12=23
       IF(IDD.EQ.49)N12=24
       IF(IDD.EQ.121)N12=25
       IF(IDD.EQ.100)N12=26
       IF(IDD.EQ.88)N12=29
       IF(IDD.EQ.66)N12=31
       IF(IDD.EQ.90)N12=32
       IF(IDD.EQ.70)N12=35
       GO TO 1011
        ENDIF
* IN DELTA+N*(1440) and N*(1440)+N*(1440) COLLISIONS, 
* N*(1535), kaon production and reabsorption are ALLOWED
* IN N*(1440)+N*(1440) COLLISIONS, ONLY N*(1535) IS ALLOWED
       IF((IDD.EQ.110).OR.(IDD.EQ.77).OR.(IDD.EQ.80))THEN
clin-6/2008
          IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c       IF(X1.GT.(SIGNN+X1535+SIGK+s2d)/SIG)RETURN
          IF(X1.GT.(SIGNN+X1535+SIGK+s2d+sdprod)/SIG)RETURN
c
       IF(SIGK/(X1535+SIGK+s2d).GT.RANART(NSEED))GO TO 306
       if(s2d/(x1535+s2d).gt.RANART(NSEED))go to 1012
       IF(IDD.EQ.77)N12=30
       IF((IDD.EQ.77).AND.(RANART(NSEED).LE.0.5))N12=36
       IF(IDD.EQ.80)N12=34
       IF((IDD.EQ.80).AND.(RANART(NSEED).LE.0.5))N12=35
       IF(IDD.EQ.110)N12=27
       IF((IDD.EQ.110).AND.(RANART(NSEED).LE.0.5))N12=28
       GO TO 1011
        ENDIF
       IF((IDD.EQ.54).OR.(IDD.EQ.56))THEN
* LIKE FOR N+P COLLISION, 
* IN DELTA+DELTA COLLISIONS BOTH N*(1440) AND N*(1535) CAN BE PRODUCED
        SIG2=(3./4.)*SIGMA(SRT,2,0,1)
        SIGND=2.*(SIG2+X1535)+SIGK+s2d
clin-6/2008
        IF(X1.LE.((SIGNN+sdprod)/SIG)) GO TO 108
c        IF(X1.GT.(SIGNN+SIGND)/SIG)RETURN
        IF(X1.GT.(SIGNN+SIGND+sdprod)/SIG)RETURN
c
       IF(SIGK/SIGND.GT.RANART(NSEED))GO TO 306
       if(s2d/(2.*(sig2+x1535)+s2d).gt.RANART(NSEED))go to 1012
       IF(RANART(NSEED).LT.X1535/(SIG2+X1535))THEN
* N*(1535) PRODUCTION
       IF(IDD.EQ.54)N12=18
       IF((IDD.EQ.54).AND.(RANART(NSEED).LE.0.5))N12=19
       IF(IDD.EQ.56)N12=21
       IF((IDD.EQ.56).AND.(RANART(NSEED).LE.0.5))N12=22
               ELSE 
* N*(144) PRODUCTION
       IF(IDD.EQ.54)N12=13
       IF((IDD.EQ.54).AND.(RANART(NSEED).LE.0.5))N12=14
       IF(IDD.EQ.56)N12=15
       IF((IDD.EQ.56).AND.(RANART(NSEED).LE.0.5))N12=16
              ENDIF
       ENDIF
1011       CONTINUE
       iblock=5
*PARAMETRIZATION OF THE SHAPE OF THE N*(1440) AND N*(1535) 
* RESONANCE ACCORDING
*     TO kitazoe's or J.D.JACKSON'S MASS FORMULA AND BREIT WIGNER
*     FORMULA FOR N* RESORANCE
*     DETERMINE DELTA MASS VIA REJECTION METHOD.
          DMAX = SRT - AVMASS-0.005
          DMIN = 1.078
          IF((n12.ge.13).and.(n12.le.16))then
* N*(1440) production
          IF(DMAX.LT.1.44) THEN
          FM=FNS(DMAX,SRT,0.)
          ELSE

clin-10/25/02 get rid of argument usage mismatch in FNS():
             xdmass=1.44
c          FM=FNS(1.44,SRT,1.)
          FM=FNS(xdmass,SRT,1.)
clin-10/25/02-end

          ENDIF
          IF(FM.EQ.0.)FM=1.E-09
          NTRY2=0
11        DM=RANART(NSEED)*(DMAX-DMIN)+DMIN
          NTRY2=NTRY2+1
          IF((RANART(NSEED).GT.FNS(DM,SRT,1.)/FM).AND.
     1    (NTRY2.LE.10)) GO TO 11

clin-2/26/03 limit the N* mass below a certain value 
c     (here taken as its central value + 2* B-W fullwidth):
          if(dm.gt.2.14) goto 11

              GO TO 13
              ENDIF
                    IF((n12.ge.17).AND.(N12.LE.36))then
* N*(1535) production
          IF(DMAX.LT.1.535) THEN
          FM=FD5(DMAX,SRT,0.)
          ELSE

clin-10/25/02 get rid of argument usage mismatch in FNS():
             xdmass=1.535
c          FM=FD5(1.535,SRT,1.)
          FM=FD5(xdmass,SRT,1.)
clin-10/25/02-end

          ENDIF
          IF(FM.EQ.0.)FM=1.E-09
          NTRY1=0
12        DM = RANART(NSEED) * (DMAX-DMIN) + DMIN
          NTRY1=NTRY1+1
          IF((RANART(NSEED) .GT. FD5(DM,SRT,1.)/FM).AND.
     1    (NTRY1.LE.10)) GOTO 12

clin-2/26/03 limit the N* mass below a certain value 
c     (here taken as its central value + 2* B-W fullwidth):
          if(dm.gt.1.84) goto 12

             ENDIF
13       CONTINUE
*-------------------------------------------------------
* RELABLE BARYON I1 AND I2
*13 D(++)+D(-)--> N*(+)(14)+n
          IF(N12.EQ.13)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=11
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=11
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*14 D(++)+D(-)--> N*(0)(14)+P
          IF(N12.EQ.14)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=10
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=10
          E(I1)=DM
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
*15 D(+)+D(0)--> N*(+)(14)+n
          IF(N12.EQ.15)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=11
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=11
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*16 D(+)+D(0)--> N*(0)(14)+P
          IF(N12.EQ.16)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=10
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=10
          E(I1)=DM
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
*17 D(++)+D(0)--> N*(+)(14)+P
          IF(N12.EQ.17)THEN
          LB(I2)=13
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
         go to 200
          ENDIF
*18 D(++)+D(-)--> N*(0)(15)+P
          IF(N12.EQ.18)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=12
          E(I1)=DM
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
*19 D(++)+D(-)--> N*(+)(15)+N
          IF(N12.EQ.19)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=13
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=13
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*20 D(+)+D(+)--> N*(+)(15)+P
          IF(N12.EQ.20)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=13
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=13
          E(I1)=DM
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
*21 D(+)+D(0)--> N*(+)(15)+N
          IF(N12.EQ.21)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=13
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=13
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*22 D(+)+D(0)--> N*(0)(15)+P
          IF(N12.EQ.22)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=12
          E(I1)=DM
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
*23 D(+)+D(-)--> N*(0)(15)+N
          IF(N12.EQ.23)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=12
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*24 D(0)+D(0)--> N*(0)(15)+N
          IF(N12.EQ.24)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
         go to 200
          ENDIF
*25 N*(+)+N*(+)--> N*(0)(15)+P
          IF(N12.EQ.25)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
         go to 200
          ENDIF
*26 N*(0)+N*(0)--> N*(0)(15)+N
          IF(N12.EQ.26)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
         go to 200
          ENDIF
*27 N*(+)+N*(0)--> N*(+)(15)+N
          IF(N12.EQ.27)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=13
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=13
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*28 N*(+)+N*(0)--> N*(0)(15)+P
          IF(N12.EQ.28)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=12
          E(I1)=DM
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
*27 N*(+)+N*(0)--> N*(+)(15)+N
          IF(N12.EQ.27)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=13
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=13
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*29 N*(+)+D(+)--> N*(+)(15)+P
          IF(N12.EQ.29)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=13
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=13
          E(I1)=DM
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
*30 N*(+)+D(0)--> N*(+)(15)+N
          IF(N12.EQ.30)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=13
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=13
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*31 N*(+)+D(-)--> N*(0)(15)+N
          IF(N12.EQ.31)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=12
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*32 N*(0)+D(++)--> N*(+)(15)+P
          IF(N12.EQ.32)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=13
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=13
          E(I1)=DM
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
*33 N*(0)+D(+)--> N*(+)(15)+N
          IF(N12.EQ.33)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=13
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=13
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*34 N*(0)+D(+)--> N*(0)(15)+P
          IF(N12.EQ.34)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=12
          E(I1)=DM
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
*35 N*(0)+D(0)--> N*(0)(15)+N
          IF(N12.EQ.35)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=12
          E(I1)=DM
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*36 N*(+)+D(0)--> N*(0)(15)+P
          IF(N12.EQ.36)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=12
          E(I2)=DM
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=12
          E(I1)=DM
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
1012         continue
         iblock=55
         lb1=lb(i1)
         lb2=lb(i2)
         ich=iabs(lb1*lb2)
*-------------------------------------------------------
* RELABLE BARYON I1 AND I2 in the reabsorption processes
*37 D(++)+D(-)--> n+p
          IF(ich.EQ.9*6)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=1
          E(I2)=amp
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=1
          E(I1)=amp
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*38 D(+)+D(0)--> n+p
          IF(ich.EQ.8*7)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=1
          E(I2)=amp
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=1
          E(I1)=amp
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*39 D(++)+D(0)--> p+p
          IF(ich.EQ.9*7)THEN
          LB(I2)=1
          E(I2)=amp
         LB(I1)=1
         E(I1)=AMP
         go to 200
          ENDIF
*40 D(+)+D(+)--> p+p
          IF(ich.EQ.8*8)THEN
          LB(I2)=1
          E(I2)=amp
         LB(I1)=1
         E(I1)=AMP
          go to 200
          ENDIF
*41 D(+)+D(-)--> n+n
          IF(ich.EQ.8*6)THEN
          LB(I2)=2
          E(I2)=amn
         LB(I1)=2
         E(I1)=AMN
          go to 200
          ENDIF
*42 D(0)+D(0)--> n+n
          IF(ich.EQ.6*6)THEN
          LB(I2)=2
          E(I2)=amn
         LB(I1)=2
         E(I1)=AMN
         go to 200
          ENDIF
*43 N*(+)+N*(+)--> p+p
          IF(ich.EQ.11*11.or.ich.eq.13*13.or.ich.eq.11*13)THEN
          LB(I2)=1
          E(I2)=amp
         LB(I1)=1
         E(I1)=AMP
         go to 200
          ENDIF
*44 N*(0)(1440)+N*(0)--> n+n
          IF(ich.EQ.10*10.or.ich.eq.12*12.or.ich.eq.10*12)THEN
          LB(I2)=2
          E(I2)=amn
         LB(I1)=2
         E(I1)=AMN
         go to 200
          ENDIF
*45 N*(+)+N*(0)--> n+p
          IF(ich.EQ.10*11.or.ich.eq.12*13.or.ich.
     &    eq.10*13.or.ich.eq.11*12)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=1
          E(I2)=amp
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=1
          E(I1)=amp
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*46 N*(+)+D(+)--> p+p
          IF(ich.eq.11*8.or.ich.eq.13*8)THEN
          LB(I2)=1
          E(I2)=amp
         LB(I1)=1
         E(I1)=AMP
          go to 200
          ENDIF
*47 N*(+)+D(0)--> n+p
          IF(ich.EQ.11*7.or.ich.eq.13*7)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=1
          E(I2)=amp
         LB(I1)=2
         E(I1)=AMN
          ELSE
          LB(I1)=1
          E(I1)=amp
         LB(I2)=2
         E(I2)=AMN
          ENDIF
         go to 200
          ENDIF
*48 N*(+)+D(-)--> n+n
          IF(ich.EQ.11*6.or.ich.eq.13*6)THEN
          LB(I2)=2
          E(I2)=amn
         LB(I1)=2
         E(I1)=AMN
          go to 200
          ENDIF
*49 N*(0)+D(++)--> p+p
          IF(ich.EQ.10*9.or.ich.eq.12*9)THEN
          LB(I2)=1
          E(I2)=amp
         LB(I1)=1
         E(I1)=AMP
         go to 200
          ENDIF
*50 N*(0)+D(0)--> n+n
          IF(ich.EQ.10*7.or.ich.eq.12*7)THEN
          LB(I2)=2
          E(I2)=amn
         LB(I1)=2
         E(I1)=AMN
          go to 200
          ENDIF
*51 N*(0)+D(+)--> n+p
          IF(ich.EQ.10*8.or.ich.eq.12*8)THEN
          IF(RANART(NSEED).LE.0.5)THEN
          LB(I2)=2
          E(I2)=amn
         LB(I1)=1
         E(I1)=AMP
          ELSE
          LB(I1)=2
          E(I1)=amn
         LB(I2)=1
         E(I2)=AMP
          ENDIF
         go to 200
          ENDIF
         lb(i1)=1
         e(i1)=amp
         lb(i2)=2
         e(i2)=amn
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
* resonance production or absorption in resonance+resonance collisions is
* assumed to have the same pt distribution as pp
200       EM1=E(I1)
          EM2=E(I2)
          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)
             if(srt.le.2.14)C1= 1.0 - 2.0 * RANART(NSEED)
         if(srt.gt.2.14.and.srt.le.2.4)c1=ang(srt,iseed)       
         if(srt.gt.2.4)then

clin-10/25/02 get rid of argument usage mismatch in PTR():
             xptr=0.33*pr
c         cc1=ptr(0.33*pr,iseed)
         cc1=ptr(xptr,iseed)
clin-10/25/02-end

clin-9/2012: check argument in sqrt():
         scheck=pr**2-cc1**2
         if(scheck.lt.0) then
            write(99,*) 'scheck7: ', scheck
            scheck=0.
         endif
         c1=sqrt(scheck)/pr
c         c1=sqrt(pr**2-cc1**2)/pr

         endif
          T1   = 2.0 * PI * RANART(NSEED)
       if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
         lb(i1) = -lb(i1)
         lb(i2) = -lb(i2)
       endif
         ENDIF
*COM: SET THE NEW MOMENTUM COORDINATES

clin-9/2012: check argument in sqrt():
 107     scheck=1.0 - C1**2
         if(scheck.lt.0) then
            write(99,*) 'scheck8: ', scheck
            scheck=0.
         endif
         S1=SQRT(scheck)
c107   S1   = SQRT( 1.0 - C1**2 )

clin-9/2012: check argument in sqrt():
      scheck=1.0 - C2**2
      if(scheck.lt.0) then
         write(99,*) 'scheck9: ', scheck
         scheck=0.
      endif
      S2=SQRT(scheck)
c      S2  =  SQRT( 1.0 - C2**2 )

      CT1  = COS(T1)
      ST1  = SIN(T1)
      CT2  = COS(T2)
      ST2  = SIN(T2)
      PZ   = PR * ( C1*C2 - S1*S2*CT1 )
      SS   = C2 * S1 * CT1  +  S2 * C1
      PX   = PR * ( SS*CT2 - S1*ST1*ST2 )
      PY   = PR * ( SS*ST2 + S1*ST1*CT2 )
      RETURN
* FOR THE DD-->KAON+X PROCESS, FIND MOMENTUM OF THE FINAL PARTICLES IN 
* THE NUCLEUS-NUCLEUS CMS.
306     CONTINUE
csp11/21/01 phi production
              if(XSK5/sigK.gt.RANART(NSEED))then
              pz1=p(3,i1)
              pz2=p(3,i2)
                LB(I1) = 1 + int(2 * RANART(NSEED))
                LB(I2) = 1 + int(2 * RANART(NSEED))
              nnn=nnn+1
                LPION(NNN,IRUN)=29
                EPION(NNN,IRUN)=APHI
                iblock = 222
              GO TO 208
               ENDIF
              iblock=10
                if(ianti .eq. 1)iblock=-10
              pz1=p(3,i1)
              pz2=p(3,i2)
* DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
              nnn=nnn+1
                LPION(NNN,IRUN)=23
                EPION(NNN,IRUN)=Aka
              if(srt.le.2.63)then
* only lambda production is possible
* (1.1)P+P-->p+L+kaon+
              ic=1
                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              GO TO 208
                ENDIF
       if(srt.le.2.74.and.srt.gt.2.63)then
* both Lambda and sigma production are possible
              if(XSK1/(XSK1+XSK2).gt.RANART(NSEED))then
* lambda production
              ic=1
                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              else
* sigma production
                LB(I1) = 1 + int(2 * RANART(NSEED))
                LB(I2) = 15 + int(3 * RANART(NSEED))
              ic=2
              endif
              GO TO 208
       endif
       if(srt.le.2.77.and.srt.gt.2.74)then
* then pp-->Delta lamda kaon can happen
              if(xsk1/(xsk1+xsk2+xsk3).gt.RANART(NSEED))then
* * (1.1)P+P-->p+L+kaon+
              ic=1
                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              go to 208
              else
              if(xsk2/(xsk2+xsk3).gt.RANART(NSEED))then
* pp-->psk
              ic=2
                LB(I1) = 1 + int(2 * RANART(NSEED))
                LB(I2) = 15 + int(3 * RANART(NSEED))
              else
* pp-->D+l+k        
              ic=3
                LB(I1) = 6 + int(4 * RANART(NSEED))
              lb(i2)=14
              endif
              GO TO 208
              endif
       endif
       if(srt.gt.2.77)then
* all four channels are possible
              if(xsk1/(xsk1+xsk2+xsk3+xsk4).gt.RANART(NSEED))then
* p lambda k production
              ic=1
                LB(I1) = 1 + int(2 * RANART(NSEED))
              LB(I2)=14
              go to 208
       else
          if(xsk3/(xsk2+xsk3+xsk4).gt.RANART(NSEED))then
* delta l K production
              ic=3
                LB(I1) = 6 + int(4 * RANART(NSEED))
              lb(i2)=14
              go to 208
          else
              if(xsk2/(xsk2+xsk4).gt.RANART(NSEED))then
* n sigma k production
                LB(I1) = 1 + int(2 * RANART(NSEED))
                LB(I2) = 15 + int(3 * RANART(NSEED))
              ic=2
              else
* D sigma K
              ic=4
                LB(I1) = 6 + int(4 * RANART(NSEED))
                LB(I2) = 15 + int(3 * RANART(NSEED))
              endif
              go to 208
          endif
       endif
       endif
208             continue
         if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
          lb(i1) = - lb(i1)
          lb(i2) = - lb(i2)
          if(LPION(NNN,IRUN) .eq. 23)LPION(NNN,IRUN)=21
         endif
       lbi1=lb(i1)
       lbi2=lb(i2)
* KEEP ALL COORDINATES OF PARTICLE 2 FOR POSSIBLE PHASE SPACE CHANGE
           NTRY1=0
129        CALL BBKAON(ic,SRT,PX3,PY3,PZ3,DM3,PX4,PY4,PZ4,DM4,
     &  PPX,PPY,PPZ,icou1)
       NTRY1=NTRY1+1
       if((icou1.lt.0).AND.(NTRY1.LE.20))GO TO 129
c       if(icou1.lt.0)return
* ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
       CALL ROTATE(PX,PY,PZ,PX3,PY3,PZ3)
       CALL ROTATE(PX,PY,PZ,PX4,PY4,PZ4)
       CALL ROTATE(PX,PY,PZ,PPX,PPY,PPZ)
* FIND THE MOMENTUM OF PARTICLES IN THE FINAL STATE IN THE NUCLEUS-
* NUCLEUS CMS. FRAME 
* (1) for the necleon/delta
*             LORENTZ-TRANSFORMATION INTO LAB FRAME FOR DELTA1
              E1CM    = SQRT (dm3**2 + PX3**2 + PY3**2 + PZ3**2)
              P1BETA  = PX3*BETAX + PY3*BETAY + PZ3*BETAZ
              TRANSF  = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) + E1CM )
              Pt1i1 = BETAX * TRANSF + PX3
              Pt2i1 = BETAY * TRANSF + PY3
              Pt3i1 = BETAZ * TRANSF + PZ3
             Eti1   = DM3
* (2) for the lambda/sigma
                E2CM    = SQRT (dm4**2 + PX4**2 + PY4**2 + PZ4**2)
                P2BETA  = PX4*BETAX+PY4*BETAY+PZ4*BETAZ
                TRANSF  = GAMMA * (GAMMA*P2BETA / (GAMMA + 1.) + E2CM)
                Pt1I2 = BETAX * TRANSF + PX4
                Pt2I2 = BETAY * TRANSF + PY4
                Pt3I2 = BETAZ * TRANSF + PZ4
              EtI2   = DM4
* GET the kaon'S MOMENTUM AND COORDINATES IN NUCLEUS-NUCLEUS CMS. FRAME
                EPCM=SQRT(aka**2+PPX**2+PPY**2+PPZ**2)
                PPBETA=PPX*BETAX+PPY*BETAY+PPZ*BETAZ
                TRANSF=GAMMA*(GAMMA*PPBETA/(GAMMA+1.)+EPCM)
                PPION(1,NNN,IRUN)=BETAX*TRANSF+PPX
                PPION(2,NNN,IRUN)=BETAY*TRANSF+PPY
                PPION(3,NNN,IRUN)=BETAZ*TRANSF+PPZ
clin-5/2008:
                dppion(nnn,irun)=dpertp(i1)*dpertp(i2)
clin-5/2008:
c2007        X01 = 1.0 - 2.0 * RANART(NSEED)
c            Y01 = 1.0 - 2.0 * RANART(NSEED)
c            Z01 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2007
c                RPION(1,NNN,IRUN)=R(1,I1)+0.5*x01
c                RPION(2,NNN,IRUN)=R(2,I1)+0.5*y01
c                RPION(3,NNN,IRUN)=R(3,I1)+0.5*z01
                    RPION(1,NNN,IRUN)=R(1,I1)
                    RPION(2,NNN,IRUN)=R(2,I1)
                    RPION(3,NNN,IRUN)=R(3,I1)
c
* assign the nucleon/delta and lambda/sigma to i1 or i2 to keep the 
* leadng particle behaviour
C              if((pt1i1*px1+pt2i1*py1+pt3i1*pz1).gt.0)then
              p(1,i1)=pt1i1
              p(2,i1)=pt2i1
              p(3,i1)=pt3i1
              e(i1)=eti1
              lb(i1)=lbi1
              p(1,i2)=pt1i2
              p(2,i2)=pt2i2
              p(3,i2)=pt3i2
              e(i2)=eti2
              lb(i2)=lbi2
                PX1     = P(1,I1)
                PY1     = P(2,I1)
                PZ1     = P(3,I1)
              EM1       = E(I1)
                ID(I1)  = 2
                ID(I2)  = 2
                ID1     = ID(I1)
        LB1=LB(I1)
        LB2=LB(I2)
        AM1=EM1
       am2=em2
        E1= SQRT( EM1**2 + PX1**2 + PY1**2 + PZ1**2 )
       RETURN

clin-6/2008 D+D->Deuteron+pi:
*     FIND MOMENTUM OF THE FINAL PARTICLES IN THE NUCLEUS-NUCLEUS CMS.
 108   CONTINUE
           if(idpert.eq.1.and.ipert1.eq.1.and.npertd.ge.1) then
c     For idpert=1: we produce npertd pert deuterons:
              ndloop=npertd
           elseif(idpert.eq.2.and.npertd.ge.1) then
c     For idpert=2: we first save information for npertd pert deuterons;
c     at the last ndloop we create the regular deuteron+pi 
c     and those pert deuterons:
              ndloop=npertd+1
           else
c     Just create the regular deuteron+pi:
              ndloop=1
           endif
c
           dprob1=sdprod/sig/float(npertd)
           do idloop=1,ndloop
              CALL bbdangle(pxd,pyd,pzd,nt,ipert1,ianti,idloop,pfinal,
     1 dprob1,lbm)
              CALL ROTATE(PX,PY,PZ,PXd,PYd,PZd)
*     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL STATE 
*     FROM THE NN CMS FRAME INTO THE GLOBAL CMS FRAME:
*     For the Deuteron:
              xmass=xmd
              E1dCM=SQRT(xmass**2+PXd**2+PYd**2+PZd**2)
              P1dBETA=PXd*BETAX+PYd*BETAY+PZd*BETAZ
              TRANSF=GAMMA*(GAMMA*P1dBETA/(GAMMA+1.)+E1dCM)
              pxi1=BETAX*TRANSF+PXd
              pyi1=BETAY*TRANSF+PYd
              pzi1=BETAZ*TRANSF+PZd
              if(ianti.eq.0)then
                 lbd=42
              else
                 lbd=-42
              endif
              if(idpert.eq.1.and.ipert1.eq.1.and.npertd.ge.1) then
cccc  Perturbative production for idpert=1:
                 nnn=nnn+1
                 PPION(1,NNN,IRUN)=pxi1
                 PPION(2,NNN,IRUN)=pyi1
                 PPION(3,NNN,IRUN)=pzi1
                 EPION(NNN,IRUN)=xmd
                 LPION(NNN,IRUN)=lbd
                 RPION(1,NNN,IRUN)=R(1,I1)
                 RPION(2,NNN,IRUN)=R(2,I1)
                 RPION(3,NNN,IRUN)=R(3,I1)
clin-6/2008 assign the perturbative probability:
                 dppion(NNN,IRUN)=sdprod/sig/float(npertd)
              elseif(idpert.eq.2.and.idloop.le.npertd) then
clin-6/2008 For idpert=2, we produce NPERTD perturbative (anti)deuterons 
c     only when a regular (anti)deuteron+pi is produced in NN collisions.
c     First save the info for the perturbative deuterons:
                 ppd(1,idloop)=pxi1
                 ppd(2,idloop)=pyi1
                 ppd(3,idloop)=pzi1
                 lbpd(idloop)=lbd
              else
cccc  Regular production:
c     For the regular pion: do LORENTZ-TRANSFORMATION:
                 E(i1)=xmm
                 E2piCM=SQRT(xmm**2+PXd**2+PYd**2+PZd**2)
                 P2piBETA=-PXd*BETAX-PYd*BETAY-PZd*BETAZ
                 TRANSF=GAMMA*(GAMMA*P2piBETA/(GAMMA+1.)+E2piCM)
                 pxi2=BETAX*TRANSF-PXd
                 pyi2=BETAY*TRANSF-PYd
                 pzi2=BETAZ*TRANSF-PZd
                 p(1,i1)=pxi2
                 p(2,i1)=pyi2
                 p(3,i1)=pzi2
c     Remove regular pion to check the equivalence 
c     between the perturbative and regular deuteron results:
c                 E(i1)=0.
c
                 LB(I1)=lbm
                 PX1=P(1,I1)
                 PY1=P(2,I1)
                 PZ1=P(3,I1)
                 EM1=E(I1)
                 ID(I1)=2
                 ID1=ID(I1)
                 E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
                 lb1=lb(i1)
c     For the regular deuteron:
                 p(1,i2)=pxi1
                 p(2,i2)=pyi1
                 p(3,i2)=pzi1
                 lb(i2)=lbd
                 lb2=lb(i2)
                 E(i2)=xmd
                 EtI2=E(I2)
                 ID(I2)=2
c     For idpert=2: create the perturbative deuterons:
                 if(idpert.eq.2.and.idloop.eq.ndloop) then
                    do ipertd=1,npertd
                       nnn=nnn+1
                       PPION(1,NNN,IRUN)=ppd(1,ipertd)
                       PPION(2,NNN,IRUN)=ppd(2,ipertd)
                       PPION(3,NNN,IRUN)=ppd(3,ipertd)
                       EPION(NNN,IRUN)=xmd
                       LPION(NNN,IRUN)=lbpd(ipertd)
                       RPION(1,NNN,IRUN)=R(1,I1)
                       RPION(2,NNN,IRUN)=R(2,I1)
                       RPION(3,NNN,IRUN)=R(3,I1)
clin-6/2008 assign the perturbative probability:
                       dppion(NNN,IRUN)=1./float(npertd)
                    enddo
                 endif
              endif
           enddo
           IBLOCK=501
           return
clin-6/2008 D+D->Deuteron+pi over

        END
**********************************
**********************************
*                                                                      *
      SUBROUTINE INIT(MINNUM,MAXNUM,NUM,RADIUS,X0,Z0,P0,
     &                GAMMA,ISEED,MASS,IOPT)
*                                                                      *
*       PURPOSE:     PROVIDING INITIAL CONDITIONS FOR PHASE-SPACE      *
*                    DISTRIBUTION OF TESTPARTICLES                     *
*       VARIABLES:   (ALL INPUT)                                       *
*         MINNUM  - FIRST TESTPARTICLE TREATED IN ONE RUN    (INTEGER) *
*         MAXNUM  - LAST TESTPARTICLE TREATED IN ONE RUN     (INTEGER) *
*         NUM     - NUMBER OF TESTPARTICLES PER NUCLEON      (INTEGER) *
*         RADIUS  - RADIUS OF NUCLEUS "FM"                      (REAL) *
*         X0,Z0   - DISPLACEMENT OF CENTER OF NUCLEUS IN X,Z-          *
*                   DIRECTION "FM"                              (REAL) *
*         P0      - MOMENTUM-BOOST IN C.M. FRAME "GEV/C"        (REAL) *
*         GAMMA   - RELATIVISTIC GAMMA-FACTOR                   (REAL) *
*         ISEED   - SEED FOR RANDOM-NUMBER GENERATOR         (INTEGER) *
*         MASS    - TOTAL MASS OF THE SYSTEM                 (INTEGER) *
*         IOPT    - OPTION FOR DIFFERENT OCCUPATION OF MOMENTUM        *
*                   SPACE                                    (INTEGER) *
*                                                                      *
**********************************
      PARAMETER     (MAXSTR=150001,  AMU   = 0.9383)
      PARAMETER     (MAXX   =   20,  MAXZ  =    24)
      PARAMETER     (PI=3.1415926)
*
      REAL              PTOT(3)
      COMMON  /AA/      R(3,MAXSTR)
cc      SAVE /AA/
      COMMON  /BB/      P(3,MAXSTR)
cc      SAVE /BB/
      COMMON  /CC/      E(MAXSTR)
cc      SAVE /CC/
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      COMMON  /EE/      ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      common  /ss/      inout(20)
cc      SAVE /ss/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
*----------------------------------------------------------------------
*     PREPARATION FOR LORENTZ-TRANSFORMATIONS
*
      IF (P0 .NE. 0.) THEN
        SIGN = P0 / ABS(P0)
      ELSE
        SIGN = 0.
      END IF

clin-9/2012: check argument in sqrt():
      scheck=GAMMA**2-1.
      if(scheck.lt.0) then
         write(99,*) 'scheck10: ', scheck
         scheck=0.
      endif
      BETA=SIGN*SQRT(scheck)/GAMMA
c      BETA = SIGN * SQRT(GAMMA**2-1.)/GAMMA

*-----------------------------------------------------------------------
*     TARGET-ID = 1 AND PROJECTILE-ID = -1
*
      IF (MINNUM .EQ. 1) THEN
        IDNUM = 1
      ELSE
        IDNUM = -1
      END IF
*-----------------------------------------------------------------------
*     IDENTIFICATION OF TESTPARTICLES AND ASSIGMENT OF RESTMASS
*
*     LOOP OVER ALL PARALLEL RUNS:
      DO 400 IRUN = 1,NUM
        DO 100 I = MINNUM+(IRUN-1)*MASS,MAXNUM+(IRUN-1)*MASS
          ID(I) = IDNUM
          E(I)  = AMU
  100   CONTINUE
*-----------------------------------------------------------------------
*       OCCUPATION OF COORDINATE-SPACE
*
        DO 300 I = MINNUM+(IRUN-1)*MASS,MAXNUM+(IRUN-1)*MASS
  200     CONTINUE
            X = 1.0 - 2.0 * RANART(NSEED)
            Y = 1.0 - 2.0 * RANART(NSEED)
            Z = 1.0 - 2.0 * RANART(NSEED)
          IF ((X*X+Y*Y+Z*Z) .GT. 1.0) GOTO 200
          R(1,I) = X * RADIUS
          R(2,I) = Y * RADIUS
          R(3,I) = Z * RADIUS
  300   CONTINUE
  400 CONTINUE
*=======================================================================
      IF (IOPT .NE. 3) THEN
*-----
*     OPTION 1: USE WOODS-SAXON PARAMETRIZATION FOR DENSITY AND
*-----          CALCULATE LOCAL FERMI-MOMENTUM
*
        RHOW0  = 0.168
        DO 1000 IRUN = 1,NUM
          DO 600 I = MINNUM+(IRUN-1)*MASS,MAXNUM+(IRUN-1)*MASS
  500       CONTINUE
              PX = 1.0 - 2.0 * RANART(NSEED)
              PY = 1.0 - 2.0 * RANART(NSEED)
              PZ = 1.0 - 2.0 * RANART(NSEED)
            IF (PX*PX+PY*PY+PZ*PZ .GT. 1.0) GOTO 500
            RDIST  = SQRT( R(1,I)**2 + R(2,I)**2 + R(3,I)**2 )
            RHOWS  = RHOW0 / (  1.0 + EXP( (RDIST-RADIUS) / 0.55 )  )
            PFERMI = 0.197 * (1.5 * PI*PI * RHOWS)**(1./3.)
*-----
*     OPTION 2: NUCLEAR MATTER CASE
            IF(IOPT.EQ.2) PFERMI=0.27
           if(iopt.eq.4) pfermi=0.
*-----
            P(1,I) = PFERMI * PX
            P(2,I) = PFERMI * PY
            P(3,I) = PFERMI * PZ
  600     CONTINUE
*
*         SET TOTAL MOMENTUM TO 0 IN REST FRAME AND BOOST
*
          DO 700 IDIR = 1,3
            PTOT(IDIR) = 0.0
  700     CONTINUE
          NPART = 0
          DO 900 I = MINNUM+(IRUN-1)*MASS,MAXNUM+(IRUN-1)*MASS
            NPART = NPART + 1
            DO 800 IDIR = 1,3
              PTOT(IDIR) = PTOT(IDIR) + P(IDIR,I)
  800       CONTINUE
  900     CONTINUE
          DO 950 I = MINNUM+(IRUN-1)*MASS,MAXNUM+(IRUN-1)*MASS
            DO 925 IDIR = 1,3
              P(IDIR,I) = P(IDIR,I) - PTOT(IDIR) / FLOAT(NPART)
  925       CONTINUE
*           BOOST
            IF ((IOPT .EQ. 1).or.(iopt.eq.2)) THEN
              EPART = SQRT(P(1,I)**2+P(2,I)**2+P(3,I)**2+AMU**2)
              P(3,I) = GAMMA*(P(3,I) + BETA*EPART)
            ELSE
              P(3,I) = P(3,I) + P0
            END IF
  950     CONTINUE
 1000   CONTINUE
*-----
      ELSE
*-----
*     OPTION 3: GIVE ALL NUCLEONS JUST A Z-MOMENTUM ACCORDING TO
*               THE BOOST OF THE NUCLEI
*
        DO 1200 IRUN = 1,NUM
          DO 1100 I = MINNUM+(IRUN-1)*MASS,MAXNUM+(IRUN-1)*MASS
            P(1,I) = 0.0
            P(2,I) = 0.0
            P(3,I) = P0
 1100     CONTINUE
 1200   CONTINUE
*-----
      END IF
*=======================================================================
*     PUT PARTICLES IN THEIR POSITION IN COORDINATE-SPACE
*     (SHIFT AND RELATIVISTIC CONTRACTION)
*
      DO 1400 IRUN = 1,NUM
        DO 1300 I = MINNUM+(IRUN-1)*MASS,MAXNUM+(IRUN-1)*MASS
          R(1,I) = R(1,I) + X0
* two nuclei in touch after contraction
          R(3,I) = (R(3,I)+Z0)/ GAMMA 
* two nuclei in touch before contraction
c          R(3,I) = R(3,I) / GAMMA + Z0
 1300   CONTINUE
 1400 CONTINUE
*
      RETURN
      END
**********************************
*                                                                      *
      SUBROUTINE DENS(IPOT,MASS,NUM,NESC)
*                                                                      *
*       PURPOSE:     CALCULATION OF LOCAL BARYON, MESON AND ENERGY     * 
*                    DENSITY FROM SPATIAL DISTRIBUTION OF TESTPARTICLES*
*                                                                      *
*       VARIABLES (ALL INPUT, ALL INTEGER)                             *
*         MASS    -  MASS NUMBER OF THE SYSTEM                         *
*         NUM     -  NUMBER OF TESTPARTICLES PER NUCLEON               *
*                                                                      *
*         NESC    -  NUMBER OF ESCAPED PARTICLES      (INTEGER,OUTPUT) *
*                                                                      *
**********************************
      PARAMETER     (MAXSTR= 150001,MAXR=1)
      PARAMETER     (MAXX   =    20,  MAXZ  =    24)
*
      dimension pxl(-maxx:maxx,-maxx:maxx,-maxz:maxz),
     1          pyl(-maxx:maxx,-maxx:maxx,-maxz:maxz),
     2          pzl(-maxx:maxx,-maxx:maxx,-maxz:maxz)
      COMMON  /AA/      R(3,MAXSTR)
cc      SAVE /AA/
      COMMON  /BB/      P(3,MAXSTR)
cc      SAVE /BB/
      COMMON  /CC/      E(MAXSTR)
cc      SAVE /CC/
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      COMMON  /DDpi/    piRHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DDpi/
      COMMON  /EE/      ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      common  /ss/  inout(20)
cc      SAVE /ss/
      COMMON  /RR/  MASSR(0:MAXR)
cc      SAVE /RR/
      common  /tt/  PEL(-maxx:maxx,-maxx:maxx,-maxz:maxz)
     &,rxy(-maxx:maxx,-maxx:maxx,-maxz:maxz)
cc      SAVE /tt/
      common  /bbb/ bxx(-maxx:maxx,-maxx:maxx,-maxz:maxz),
     &byy(-maxx:maxx,-maxx:maxx,-maxz:maxz),
     &bzz(-maxx:maxx,-maxx:maxx,-maxz:maxz)
*
      real zet(-45:45)
      SAVE   
      data zet /
     4     1.,0.,0.,0.,0.,
     3     1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
     2     -1.,0.,0.,0.,0.,0.,0.,0.,0.,0.,
     1     0.,0.,0.,-1.,0.,1.,0.,-1.,0.,-1.,
     s     0.,-2.,-1.,0.,1.,0.,0.,0.,0.,-1.,
     e     0.,
     s     1.,0.,-1.,0.,1.,-1.,0.,1.,2.,0.,
     1     1.,0.,1.,0.,-1.,0.,1.,0.,0.,0.,
     2     -1.,0.,1.,0.,-1.,0.,1.,0.,0.,1.,
     3     0.,0.,0.,0.,0.,0.,0.,0.,0.,-1.,
     4     0.,0.,0.,0.,-1./

      DO 300 IZ = -MAXZ,MAXZ
        DO 200 IY = -MAXX,MAXX
          DO 100 IX = -MAXX,MAXX
            RHO(IX,IY,IZ) = 0.0
            RHOn(IX,IY,IZ) = 0.0
            RHOp(IX,IY,IZ) = 0.0
            piRHO(IX,IY,IZ) = 0.0
           pxl(ix,iy,iz) = 0.0
           pyl(ix,iy,iz) = 0.0
           pzl(ix,iy,iz) = 0.0
           pel(ix,iy,iz) = 0.0
           bxx(ix,iy,iz) = 0.0
           byy(ix,iy,iz) = 0.0
           bzz(ix,iy,iz) = 0.0
  100     CONTINUE
  200   CONTINUE
  300 CONTINUE
*
      NESC  = 0
      BIG   = 1.0 / ( 3.0 * FLOAT(NUM) )
      SMALL = 1.0 / ( 9.0 * FLOAT(NUM) )
*
      MSUM=0
      DO 400 IRUN = 1,NUM
      MSUM=MSUM+MASSR(IRUN-1)
      DO 400 J=1,MASSr(irun)
      I=J+MSUM
        IX = NINT( R(1,I) )
        IY = NINT( R(2,I) )
        IZ = NINT( R(3,I) )
        IF( IX .LE. -MAXX .OR. IX .GE. MAXX .OR.
     &      IY .LE. -MAXX .OR. IY .GE. MAXX .OR.
     &      IZ .LE. -MAXZ .OR. IZ .GE. MAXZ )    THEN
          NESC = NESC + 1
        ELSE
c
csp01/04/02 include baryon density
          if(j.gt.mass)go to 30
c         if( (lb(i).eq.1.or.lb(i).eq.2) .or.
c    &    (lb(i).ge.6.and.lb(i).le.17) )then                       
* (1) baryon density
          RHO(IX,  IY,  IZ  ) = RHO(IX,  IY,  IZ  ) + BIG
          RHO(IX+1,IY,  IZ  ) = RHO(IX+1,IY,  IZ  ) + SMALL
          RHO(IX-1,IY,  IZ  ) = RHO(IX-1,IY,  IZ  ) + SMALL
          RHO(IX,  IY+1,IZ  ) = RHO(IX,  IY+1,IZ  ) + SMALL
          RHO(IX,  IY-1,IZ  ) = RHO(IX,  IY-1,IZ  ) + SMALL
          RHO(IX,  IY,  IZ+1) = RHO(IX,  IY,  IZ+1) + SMALL
          RHO(IX,  IY,  IZ-1) = RHO(IX,  IY,  IZ-1) + SMALL
* (2) CALCULATE THE PROTON DENSITY
         IF(ZET(LB(I)).NE.0)THEN
          RHOP(IX,  IY,  IZ  ) = RHOP(IX,  IY,  IZ  ) + BIG
          RHOP(IX+1,IY,  IZ  ) = RHOP(IX+1,IY,  IZ  ) + SMALL
          RHOP(IX-1,IY,  IZ  ) = RHOP(IX-1,IY,  IZ  ) + SMALL
          RHOP(IX,  IY+1,IZ  ) = RHOP(IX,  IY+1,IZ  ) + SMALL
          RHOP(IX,  IY-1,IZ  ) = RHOP(IX,  IY-1,IZ  ) + SMALL
          RHOP(IX,  IY,  IZ+1) = RHOP(IX,  IY,  IZ+1) + SMALL
          RHOP(IX,  IY,  IZ-1) = RHOP(IX,  IY,  IZ-1) + SMALL
         go to 40
         ENDIF
* (3) CALCULATE THE NEUTRON DENSITY
         IF(ZET(LB(I)).EQ.0)THEN
          RHON(IX,  IY,  IZ  ) = RHON(IX,  IY,  IZ  ) + BIG
          RHON(IX+1,IY,  IZ  ) = RHON(IX+1,IY,  IZ  ) + SMALL
          RHON(IX-1,IY,  IZ  ) = RHON(IX-1,IY,  IZ  ) + SMALL
          RHON(IX,  IY+1,IZ  ) = RHON(IX,  IY+1,IZ  ) + SMALL
          RHON(IX,  IY-1,IZ  ) = RHON(IX,  IY-1,IZ  ) + SMALL
          RHON(IX,  IY,  IZ+1) = RHON(IX,  IY,  IZ+1) + SMALL
          RHON(IX,  IY,  IZ-1) = RHON(IX,  IY,  IZ-1) + SMALL
         go to 40
          END IF
c           else    !! sp01/04/02
* (4) meson density       
30              piRHO(IX,  IY,  IZ  ) = piRHO(IX,  IY,  IZ  ) + BIG
          piRHO(IX+1,IY,  IZ  ) = piRHO(IX+1,IY,  IZ  ) + SMALL
          piRHO(IX-1,IY,  IZ  ) = piRHO(IX-1,IY,  IZ  ) + SMALL
          piRHO(IX,  IY+1,IZ  ) = piRHO(IX,  IY+1,IZ  ) + SMALL
          piRHO(IX,  IY-1,IZ  ) = piRHO(IX,  IY-1,IZ  ) + SMALL
          piRHO(IX,  IY,  IZ+1) = piRHO(IX,  IY,  IZ+1) + SMALL
          piRHO(IX,  IY,  IZ-1) = piRHO(IX,  IY,  IZ-1) + SMALL
c           endif    !! sp01/04/02
* to calculate the Gamma factor in each cell
*(1) PX
40       pxl(ix,iy,iz)=pxl(ix,iy,iz)+p(1,I)*BIG
       pxl(ix+1,iy,iz)=pxl(ix+1,iy,iz)+p(1,I)*SMALL
       pxl(ix-1,iy,iz)=pxl(ix-1,iy,iz)+p(1,I)*SMALL
       pxl(ix,iy+1,iz)=pxl(ix,iy+1,iz)+p(1,I)*SMALL
       pxl(ix,iy-1,iz)=pxl(ix,iy-1,iz)+p(1,I)*SMALL
       pxl(ix,iy,iz+1)=pxl(ix,iy,iz+1)+p(1,I)*SMALL
       pxl(ix,iy,iz-1)=pxl(ix,iy,iz-1)+p(1,I)*SMALL
*(2) PY
       pYl(ix,iy,iz)=pYl(ix,iy,iz)+p(2,I)*BIG
       pYl(ix+1,iy,iz)=pYl(ix+1,iy,iz)+p(2,I)*SMALL
       pYl(ix-1,iy,iz)=pYl(ix-1,iy,iz)+p(2,I)*SMALL
       pYl(ix,iy+1,iz)=pYl(ix,iy+1,iz)+p(2,I)*SMALL
       pYl(ix,iy-1,iz)=pYl(ix,iy-1,iz)+p(2,I)*SMALL
       pYl(ix,iy,iz+1)=pYl(ix,iy,iz+1)+p(2,I)*SMALL
       pYl(ix,iy,iz-1)=pYl(ix,iy,iz-1)+p(2,I)*SMALL
* (3) PZ
       pZl(ix,iy,iz)=pZl(ix,iy,iz)+p(3,I)*BIG
       pZl(ix+1,iy,iz)=pZl(ix+1,iy,iz)+p(3,I)*SMALL
       pZl(ix-1,iy,iz)=pZl(ix-1,iy,iz)+p(3,I)*SMALL
       pZl(ix,iy+1,iz)=pZl(ix,iy+1,iz)+p(3,I)*SMALL
       pZl(ix,iy-1,iz)=pZl(ix,iy-1,iz)+p(3,I)*SMALL
       pZl(ix,iy,iz+1)=pZl(ix,iy,iz+1)+p(3,I)*SMALL
       pZl(ix,iy,iz-1)=pZl(ix,iy,iz-1)+p(3,I)*SMALL
* (4) ENERGY
       pel(ix,iy,iz)=pel(ix,iy,iz)
     1     +sqrt(e(I)**2+p(1,i)**2+p(2,I)**2+p(3,I)**2)*BIG
       pel(ix+1,iy,iz)=pel(ix+1,iy,iz)
     1     +sqrt(e(I)**2+p(1,i)**2+p(2,I)**2+p(3,I)**2)*SMALL
       pel(ix-1,iy,iz)=pel(ix-1,iy,iz)
     1     +sqrt(e(I)**2+p(1,i)**2+p(2,I)**2+p(3,I)**2)*SMALL
       pel(ix,iy+1,iz)=pel(ix,iy+1,iz)
     1     +sqrt(e(I)**2+p(1,i)**2+p(2,I)**2+p(3,I)**2)*SMALL
       pel(ix,iy-1,iz)=pel(ix,iy-1,iz)
     1     +sqrt(e(I)**2+p(1,i)**2+p(2,I)**2+p(3,I)**2)*SMALL
       pel(ix,iy,iz+1)=pel(ix,iy,iz+1)
     1     +sqrt(e(I)**2+p(1,i)**2+p(2,I)**2+p(3,I)**2)*SMALL
       pel(ix,iy,iz-1)=pel(ix,iy,iz-1)
     1     +sqrt(e(I)**2+p(1,i)**2+p(2,I)**2+p(3,I)**2)*SMALL
        END IF
  400 CONTINUE
*
      DO 301 IZ = -MAXZ,MAXZ
        DO 201 IY = -MAXX,MAXX
          DO 101 IX = -MAXX,MAXX
      IF((RHO(IX,IY,IZ).EQ.0).OR.(PEL(IX,IY,IZ).EQ.0))
     1GO TO 101
      SMASS2=PEL(IX,IY,IZ)**2-PXL(IX,IY,IZ)**2
     1-PYL(IX,IY,IZ)**2-PZL(IX,IY,IZ)**2
       IF(SMASS2.LE.0)SMASS2=1.E-06
       SMASS=SQRT(SMASS2)
           IF(SMASS.EQ.0.)SMASS=1.e-06
           GAMMA=PEL(IX,IY,IZ)/SMASS
           if(gamma.eq.0)go to 101
       bxx(ix,iy,iz)=pxl(ix,iy,iz)/pel(ix,iy,iz)                  
       byy(ix,iy,iz)=pyl(ix,iy,iz)/pel(ix,iy,iz)       
       bzz(ix,iy,iz)=pzl(ix,iy,iz)/pel(ix,iy,iz)                  
            RHO(IX,IY,IZ) = RHO(IX,IY,IZ)/GAMMA
            RHOn(IX,IY,IZ) = RHOn(IX,IY,IZ)/GAMMA
            RHOp(IX,IY,IZ) = RHOp(IX,IY,IZ)/GAMMA
            piRHO(IX,IY,IZ) = piRHO(IX,IY,IZ)/GAMMA
            pEL(IX,IY,IZ) = pEL(IX,IY,IZ)/(GAMMA**2)
           rho0=0.163
           IF(IPOT.EQ.0)THEN
           U=0
           GO TO 70
           ENDIF
           IF(IPOT.EQ.1.or.ipot.eq.6)THEN
           A=-0.1236
           B=0.0704
           S=2
           GO TO 60
           ENDIF
           IF(IPOT.EQ.2.or.ipot.eq.7)THEN
           A=-0.218
           B=0.164
           S=4./3.
           ENDIF
           IF(IPOT.EQ.3)THEN
           a=-0.3581
           b=0.3048
           S=1.167
           GO TO 60
           ENDIF
           IF(IPOT.EQ.4)THEN
           denr=rho(ix,iy,iz)/rho0         
           b=0.3048
           S=1.167
           if(denr.le.4.or.denr.gt.7)then
           a=-0.3581
           else
           a=-b*denr**(1./6.)-2.*0.036/3.*denr**(-0.333)
           endif
           GO TO 60
           ENDIF
60           U = 0.5*A*RHO(IX,IY,IZ)**2/RHO0 
     1        + B/(1+S) * (RHO(IX,IY,IZ)/RHO0)**S*RHO(IX,IY,IZ)  
70           PEL(IX,IY,IZ)=PEL(IX,IY,IZ)+U
  101     CONTINUE
  201   CONTINUE
  301 CONTINUE
      RETURN
      END

**********************************
*                                                                      *
      SUBROUTINE GRADU(IOPT,IX,IY,IZ,GRADX,GRADY,GRADZ)
*                                                                      *
*       PURPOSE:     DETERMINE GRAD(U(RHO(X,Y,Z)))                     *
*       VARIABLES:                                                     *
*         IOPT                - METHOD FOR EVALUATING THE GRADIENT     *
*                                                      (INTEGER,INPUT) *
*         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT) *
*         GRADX, GRADY, GRADZ - GRADIENT OF U            (REAL,OUTPUT) *
*                                                                      *
**********************************
      PARAMETER         (MAXX =    20,  MAXZ =   24)
      PARAMETER         (RHO0 = 0.167)
*
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                  RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                  RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      common  /ss/      inout(20)
cc      SAVE /ss/
      common  /tt/  PEL(-maxx:maxx,-maxx:maxx,-maxz:maxz)
     &,rxy(-maxx:maxx,-maxx:maxx,-maxz:maxz)
cc      SAVE /tt/
      SAVE   
*
      RXPLUS   = RHO(IX+1,IY,  IZ  ) / RHO0
      RXMINS   = RHO(IX-1,IY,  IZ  ) / RHO0
      RYPLUS   = RHO(IX,  IY+1,IZ  ) / RHO0
      RYMINS   = RHO(IX,  IY-1,IZ  ) / RHO0
      RZPLUS   = RHO(IX,  IY,  IZ+1) / RHO0
      RZMINS   = RHO(IX,  IY,  IZ-1) / RHO0
      den0     = RHO(IX,  IY,  IZ) / RHO0
      ene0     = pel(IX,  IY,  IZ) 
*-----------------------------------------------------------------------
      GOTO (1,2,3,4,5) IOPT
       if(iopt.eq.6)go to 6
       if(iopt.eq.7)go to 7
*
    1 CONTINUE
*       POTENTIAL USED IN 1) (STIFF):
*       U = -.124 * RHO/RHO0 + .0705 (RHO/RHO0)**2 GEV
*
           GRADX  = -0.062 * (RXPLUS - RXMINS) + 0.03525 * (RXPLUS**2 -
     &                                                      RXMINS**2)
           GRADY  = -0.062 * (RYPLUS - RYMINS) + 0.03525 * (RYPLUS**2 -
     &                                                      RYMINS**2)
           GRADZ  = -0.062 * (RZPLUS - RZMINS) + 0.03525 * (RZPLUS**2 -
     &                                                      RZMINS**2)
           RETURN
*
    2 CONTINUE
*       POTENTIAL USED IN 2):
*       U = -.218 * RHO/RHO0 + .164 (RHO/RHO0)**(4/3) GEV
*
           EXPNT = 1.3333333
           GRADX = -0.109 * (RXPLUS - RXMINS) 
     &     + 0.082 * (RXPLUS**EXPNT-RXMINS**EXPNT)
           GRADY = -0.109 * (RYPLUS - RYMINS) 
     &     + 0.082 * (RYPLUS**EXPNT-RYMINS**EXPNT)
           GRADZ = -0.109 * (RZPLUS - RZMINS) 
     &     + 0.082 * (RZPLUS**EXPNT-RZMINS**EXPNT)
           RETURN
*
    3 CONTINUE
*       POTENTIAL USED IN 3) (SOFT):
*       U = -.356 * RHO/RHO0 + .303 * (RHO/RHO0)**(7/6)  GEV
*
           EXPNT = 1.1666667
          acoef = 0.178
           GRADX = -acoef * (RXPLUS - RXMINS) 
     &     + 0.1515 * (RXPLUS**EXPNT-RXMINS**EXPNT)
           GRADY = -acoef * (RYPLUS - RYMINS) 
     &     + 0.1515 * (RYPLUS**EXPNT-RYMINS**EXPNT)
           GRADZ = -acoef * (RZPLUS - RZMINS) 
     &     + 0.1515 * (RZPLUS**EXPNT-RZMINS**EXPNT)
                 RETURN
*
*
    4   CONTINUE
*       POTENTIAL USED IN 4) (super-soft in the mixed phase of 4 < rho/rho <7):
*       U1 = -.356 * RHO/RHO0 + .303 * (RHO/RHO0)**(7/6)  GEV
*       normal phase, soft eos of iopt=3
*       U2 = -.02 * (RHO/RHO0)**(2/3) -0.0253 * (RHO/RHO0)**(7/6)  GEV
*
       eh=4.
       eqgp=7.
           acoef=0.178
           EXPNT = 1.1666667
       denr=rho(ix,iy,iz)/rho0
       if(denr.le.eh.or.denr.ge.eqgp)then
           GRADX = -acoef * (RXPLUS - RXMINS) 
     &     + 0.1515 * (RXPLUS**EXPNT-RXMINS**EXPNT)
           GRADY = -acoef * (RYPLUS - RYMINS) 
     &     + 0.1515 * (RYPLUS**EXPNT-RYMINS**EXPNT)
           GRADZ = -acoef * (RZPLUS - RZMINS) 
     &     + 0.1515 * (RZPLUS**EXPNT-RZMINS**EXPNT)
       else
          acoef1=0.178
          acoef2=0.0
          expnt2=2./3.
           GRADX =-acoef1* (RXPLUS**EXPNT-RXMINS**EXPNT)
     &                 -acoef2* (RXPLUS**expnt2 - RXMINS**expnt2) 
           GRADy =-acoef1* (RyPLUS**EXPNT-RyMINS**EXPNT)
     &                 -acoef2* (RyPLUS**expnt2 - RyMINS**expnt2) 
           GRADz =-acoef1* (RzPLUS**EXPNT-RzMINS**EXPNT)
     &                 -acoef2* (RzPLUS**expnt2 - RzMINS**expnt2) 
       endif
       return
*     
    5   CONTINUE
*       POTENTIAL USED IN 5) (SUPER STIFF):
*       U = -.10322 * RHO/RHO0 + .04956 * (RHO/RHO0)**(2.77)  GEV
*
           EXPNT = 2.77
           GRADX = -0.0516 * (RXPLUS - RXMINS) 
     &     + 0.02498 * (RXPLUS**EXPNT-RXMINS**EXPNT)
           GRADY = -0.0516 * (RYPLUS - RYMINS) 
     &     + 0.02498 * (RYPLUS**EXPNT-RYMINS**EXPNT)
           GRADZ = -0.0516 * (RZPLUS - RZMINS) 
     &     + 0.02498 * (RZPLUS**EXPNT-RZMINS**EXPNT)
           RETURN
*
    6 CONTINUE
*       POTENTIAL USED IN 6) (STIFF-qgp):
*       U = -.124 * RHO/RHO0 + .0705 (RHO/RHO0)**2 GEV
*
       if(ene0.le.0.5)then
           GRADX  = -0.062 * (RXPLUS - RXMINS) + 0.03525 * (RXPLUS**2 -
     &                                                      RXMINS**2)
           GRADY  = -0.062 * (RYPLUS - RYMINS) + 0.03525 * (RYPLUS**2 -
     &                                                      RYMINS**2)
           GRADZ  = -0.062 * (RZPLUS - RZMINS) + 0.03525 * (RZPLUS**2 -
     &                                                      RZMINS**2)
           RETURN
       endif
       if(ene0.gt.0.5.and.ene0.le.1.5)then
*       U=c1-ef*rho/rho0**2/3
       ef=36./1000.
           GRADX  = -0.5*ef* (RXPLUS**0.67-RXMINS**0.67)
           GRADy  = -0.5*ef* (RyPLUS**0.67-RyMINS**0.67)
           GRADz  = -0.5*ef* (RzPLUS**0.67-RzMINS**0.67)
           RETURN
       endif
       if(ene0.gt.1.5)then
* U=800*(rho/rho0)**1/3.-Ef*(rho/rho0)**2/3.-c2
       ef=36./1000.
       cf0=0.8
        GRADX  =0.5*cf0*(rxplus**0.333-rxmins**0.333) 
     &         -0.5*ef* (RXPLUS**0.67-RXMINS**0.67)
        GRADy  =0.5*cf0*(ryplus**0.333-rymins**0.333) 
     &         -0.5*ef* (RyPLUS**0.67-RyMINS**0.67)
        GRADz  =0.5*cf0*(rzplus**0.333-rzmins**0.333) 
     &         -0.5*ef* (RzPLUS**0.67-RzMINS**0.67)
           RETURN
       endif
*
    7 CONTINUE
*       POTENTIAL USED IN 7) (Soft-qgp):
       if(den0.le.4.5)then
*       POTENTIAL USED is the same as IN 3) (SOFT):
*       U = -.356 * RHO/RHO0 + .303 * (RHO/RHO0)**(7/6)  GEV
*
           EXPNT = 1.1666667
          acoef = 0.178
           GRADX = -acoef * (RXPLUS - RXMINS) 
     &     + 0.1515 * (RXPLUS**EXPNT-RXMINS**EXPNT)
           GRADY = -acoef * (RYPLUS - RYMINS) 
     &     + 0.1515 * (RYPLUS**EXPNT-RYMINS**EXPNT)
           GRADZ = -acoef * (RZPLUS - RZMINS) 
     &     + 0.1515 * (RZPLUS**EXPNT-RZMINS**EXPNT)
       return
       endif
       if(den0.gt.4.5.and.den0.le.5.1)then
*       U=c1-ef*rho/rho0**2/3
       ef=36./1000.
           GRADX  = -0.5*ef* (RXPLUS**0.67-RXMINS**0.67)
           GRADy  = -0.5*ef* (RyPLUS**0.67-RyMINS**0.67)
           GRADz  = -0.5*ef* (RzPLUS**0.67-RzMINS**0.67)
           RETURN
       endif
       if(den0.gt.5.1)then
* U=800*(rho/rho0)**1/3.-Ef*(rho/rho0)**2/3.-c2
       ef=36./1000.
       cf0=0.8
        GRADX  =0.5*cf0*(rxplus**0.333-rxmins**0.333) 
     &         -0.5*ef* (RXPLUS**0.67-RXMINS**0.67)
        GRADy  =0.5*cf0*(ryplus**0.333-rymins**0.333) 
     &         -0.5*ef* (RyPLUS**0.67-RyMINS**0.67)
        GRADz  =0.5*cf0*(rzplus**0.333-rzmins**0.333) 
     &         -0.5*ef* (RzPLUS**0.67-RzMINS**0.67)
           RETURN
       endif
        END
**********************************
*                                                                      *
      SUBROUTINE GRADUK(IX,IY,IZ,GRADXk,GRADYk,GRADZk)
*                                                                      *
*       PURPOSE:     DETERMINE the baryon density gradient for         *
*                    proporgating kaons in a mean field caused by      *
*                    surrounding baryons                               * 
*       VARIABLES:                                                     *
*         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT) *
*         GRADXk, GRADYk, GRADZk                       (REAL,OUTPUT)   *
*                                                                      *
**********************************
      PARAMETER         (MAXX =    20,  MAXZ =   24)
      PARAMETER         (RHO0 = 0.168)
*
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                  RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                  RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      common  /ss/      inout(20)
cc      SAVE /ss/
      SAVE   
*
      RXPLUS   = RHO(IX+1,IY,  IZ  ) 
      RXMINS   = RHO(IX-1,IY,  IZ  ) 
      RYPLUS   = RHO(IX,  IY+1,IZ  ) 
      RYMINS   = RHO(IX,  IY-1,IZ  ) 
      RZPLUS   = RHO(IX,  IY,  IZ+1) 
      RZMINS   = RHO(IX,  IY,  IZ-1) 
           GRADXk  = (RXPLUS - RXMINS)/2. 
           GRADYk  = (RYPLUS - RYMINS)/2.
           GRADZk  = (RZPLUS - RZMINS)/2.
           RETURN
           END
*-----------------------------------------------------------------------
      SUBROUTINE GRADUP(IX,IY,IZ,GRADXP,GRADYP,GRADZP)
*                                                                      *
*       PURPOSE:     DETERMINE THE GRADIENT OF THE PROTON DENSITY      *
*       VARIABLES:                                                     *
*                                                                           *
*         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT) *
*         GRADXP, GRADYP, GRADZP - GRADIENT OF THE PROTON              *
*                                  DENSITY(REAL,OUTPUT)                *
*                                                                      *
**********************************
      PARAMETER         (MAXX =    20,  MAXZ =   24)
      PARAMETER         (RHO0 = 0.168)
*
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      common  /ss/      inout(20)
cc      SAVE /ss/
      SAVE   
*
      RXPLUS   = RHOP(IX+1,IY,  IZ  ) / RHO0
      RXMINS   = RHOP(IX-1,IY,  IZ  ) / RHO0
      RYPLUS   = RHOP(IX,  IY+1,IZ  ) / RHO0
      RYMINS   = RHOP(IX,  IY-1,IZ  ) / RHO0
      RZPLUS   = RHOP(IX,  IY,  IZ+1) / RHO0
      RZMINS   = RHOP(IX,  IY,  IZ-1) / RHO0
*-----------------------------------------------------------------------
*
           GRADXP  = (RXPLUS - RXMINS)/2. 
           GRADYP  = (RYPLUS - RYMINS)/2.
           GRADZP  = (RZPLUS - RZMINS)/2.
           RETURN
      END
*-----------------------------------------------------------------------
      SUBROUTINE GRADUN(IX,IY,IZ,GRADXN,GRADYN,GRADZN)
*                                                                      *
*       PURPOSE:     DETERMINE THE GRADIENT OF THE NEUTRON DENSITY     *
*       VARIABLES:                                                     *
*                                                                           *
*         IX, IY, IZ          - COORDINATES OF POINT   (INTEGER,INPUT) *
*         GRADXN, GRADYN, GRADZN - GRADIENT OF THE NEUTRON             *
*                                  DENSITY(REAL,OUTPUT)                *
*                                                                      *
**********************************
      PARAMETER         (MAXX =    20,  MAXZ =   24)
      PARAMETER         (RHO0 = 0.168)
*
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      common  /ss/      inout(20)
cc      SAVE /ss/
      SAVE   
*
      RXPLUS   = RHON(IX+1,IY,  IZ  ) / RHO0
      RXMINS   = RHON(IX-1,IY,  IZ  ) / RHO0
      RYPLUS   = RHON(IX,  IY+1,IZ  ) / RHO0
      RYMINS   = RHON(IX,  IY-1,IZ  ) / RHO0
      RZPLUS   = RHON(IX,  IY,  IZ+1) / RHO0
      RZMINS   = RHON(IX,  IY,  IZ-1) / RHO0
*-----------------------------------------------------------------------
*
           GRADXN  = (RXPLUS - RXMINS)/2. 
           GRADYN  = (RYPLUS - RYMINS)/2.
           GRADZN  = (RZPLUS - RZMINS)/2.
           RETURN
      END

*-----------------------------------------------------------------------------
*FUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
*KITAZOE'S FORMULA
        REAL FUNCTION FDE(DMASS,SRT,CON)
      SAVE   
        AMN=0.938869
        AVPI=0.13803333
        AM0=1.232
        FD=4.*(AM0**2)*WIDTH(DMASS)/((DMASS**2-1.232**2)**2
     1  +AM0**2*WIDTH(DMASS)**2)
        IF(CON.EQ.1.)THEN
        P11=(SRT**2+DMASS**2-AMN**2)**2
     1  /(4.*SRT**2)-DMASS**2
       if(p11.le.0)p11=1.E-06
       p1=sqrt(p11)
        ELSE
        DMASS=AMN+AVPI
        P11=(SRT**2+DMASS**2-AMN**2)**2
     1  /(4.*SRT**2)-DMASS**2
       if(p11.le.0)p11=1.E-06
       p1=sqrt(p11)
        ENDIF
        FDE=FD*P1*DMASS
        RETURN
        END
*-------------------------------------------------------------
*FUNCTION FDE(DMASS) GIVES N*(1535) MASS DISTRIBUTION BY USING OF
*KITAZOE'S FORMULA
        REAL FUNCTION FD5(DMASS,SRT,CON)
      SAVE   
        AMN=0.938869
        AVPI=0.13803333
        AM0=1.535
        FD=4.*(AM0**2)*W1535(DMASS)/((DMASS**2-1.535**2)**2
     1  +AM0**2*W1535(DMASS)**2)
        IF(CON.EQ.1.)THEN

clin-9/2012: check argument in sqrt():
           scheck=(SRT**2+DMASS**2-AMN**2)**2/(4.*SRT**2)-DMASS**2
           if(scheck.lt.0) then
              write(99,*) 'scheck11: ', scheck
              scheck=0.
           endif
           P1=SQRT(scheck)
c           P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
c     1          /(4.*SRT**2)-DMASS**2)

        ELSE
        DMASS=AMN+AVPI

clin-9/2012: check argument in sqrt():
        scheck=(SRT**2+DMASS**2-AMN**2)**2/(4.*SRT**2)-DMASS**2
        if(scheck.lt.0) then
           write(99,*) 'scheck12: ', scheck
           scheck=0.
        endif
        P1=SQRT(scheck)
c        P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
c     1  /(4.*SRT**2)-DMASS**2)

        ENDIF
        FD5=FD*P1*DMASS
        RETURN
        END
*--------------------------------------------------------------------------
*FUNCTION FNS(DMASS) GIVES N* MASS DISTRIBUTION 
c     BY USING OF BREIT-WIGNER FORMULA
        REAL FUNCTION FNS(DMASS,SRT,CON)
      SAVE   
        WIDTH=0.2
        AMN=0.938869
        AVPI=0.13803333
        AN0=1.43
        FN=4.*(AN0**2)*WIDTH/((DMASS**2-1.44**2)**2+AN0**2*WIDTH**2)
        IF(CON.EQ.1.)THEN

clin-9/2012: check argument in sqrt():
           scheck=(SRT**2+DMASS**2-AMN**2)**2/(4.*SRT**2)-DMASS**2
           if(scheck.lt.0) then
              write(99,*) 'scheck13: ', scheck
              scheck=0.
           endif
           P1=SQRT(scheck)
c        P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
c     1  /(4.*SRT**2)-DMASS**2)

        ELSE
        DMASS=AMN+AVPI
clin-9/2012: check argument in sqrt():
        scheck=(SRT**2+DMASS**2-AMN**2)**2/(4.*SRT**2)-DMASS**2
        if(scheck.lt.0) then
           write(99,*) 'scheck14: ', scheck
           scheck=0.
        endif
        P1=SQRT(scheck)
c        P1=SQRT((SRT**2+DMASS**2-AMN**2)**2
c     1  /(4.*SRT**2)-DMASS**2)

        ENDIF
        FNS=FN*P1*DMASS
        RETURN
        END
*-----------------------------------------------------------------------------
*-----------------------------------------------------------------------------
* PURPOSE:1. SORT N*(1440) and N*(1535) 2-body DECAY PRODUCTS
*         2. DETERMINE THE MOMENTUM AND COORDINATES OF NUCLEON AND PION
*            AFTER THE DELTA OR N* DECAYING
* DATE   : JAN. 24,1990, MODIFIED ON MAY 17, 1994 TO INCLUDE ETA 
        SUBROUTINE DECAY(IRUN,I,NNN,ISEED,wid,nt)
        PARAMETER (MAXSTR=150001,MAXR=1,
     1  AMN=0.939457,ETAM=0.5475,AMP=0.93828,AP1=0.13496,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
        COMMON /INPUT2/ ILAB, MANYB, NTMAX, ICOLL, INSYS, IPOT, MODE, 
     &       IMOMEN, NFREQ, ICFLOW, ICRHO, ICOU, KPOTEN, KMUL
cc      SAVE /INPUT2/
      COMMON/RNDF77/NSEED
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
cc      SAVE /RNDF77/
      SAVE   
        lbanti=LB(I)
c
        DM=E(I)
*1. FOR N*+(1440) DECAY
        IF(iabs(LB(I)).EQ.11)THEN
           X3=RANART(NSEED)
           IF(X3.GT.(1./3.))THEN
              LB(I)=2
              NLAB=2
              LPION(NNN,IRUN)=5
              EPION(NNN,IRUN)=AP2
           ELSE
              LB(I)=1
              NLAB=1
              LPION(NNN,IRUN)=4
              EPION(NNN,IRUN)=AP1
           ENDIF
*2. FOR N*0(1440) DECAY
        ELSEIF(iabs(LB(I)).EQ.10)THEN
           X4=RANART(NSEED)
           IF(X4.GT.(1./3.))THEN
              LB(I)=1
              NLAB=1
              LPION(NNN,IRUN)=3
              EPION(NNN,IRUN)=AP2
           ELSE
              LB(I)=2
              NALB=2
              LPION(NNN,IRUN)=4
              EPION(NNN,IRUN)=AP1
           ENDIF
* N*(1535) CAN DECAY TO A PION OR AN ETA IF DM > 1.49 GeV
*3 N*(0)(1535) DECAY
        ELSEIF(iabs(LB(I)).EQ.12)THEN
           CTRL=0.65
           IF(DM.lE.1.49)ctrl=-1.
           X5=RANART(NSEED)
           IF(X5.GE.ctrl)THEN
* DECAY TO PION+NUCLEON
              X6=RANART(NSEED)
              IF(X6.GT.(1./3.))THEN
                 LB(I)=1
                 NLAB=1
                 LPION(NNN,IRUN)=3
                 EPION(NNN,IRUN)=AP2
              ELSE
                 LB(I)=2
                 NALB=2
                 LPION(NNN,IRUN)=4
                 EPION(NNN,IRUN)=AP1
              ENDIF
           ELSE
* DECAY TO ETA+NEUTRON
              LB(I)=2
              NLAB=2
              LPION(NNN,IRUN)=0
              EPION(NNN,IRUN)=ETAM
           ENDIF
*4. FOR N*+(1535) DECAY
        ELSEIF(iabs(LB(I)).EQ.13)THEN
           CTRL=0.65
           IF(DM.lE.1.49)ctrl=-1.
           X5=RANART(NSEED)
           IF(X5.GE.ctrl)THEN
* DECAY TO PION+NUCLEON
              X8=RANART(NSEED)
              IF(X8.GT.(1./3.))THEN
                 LB(I)=2
                 NLAB=2
                 LPION(NNN,IRUN)=5
                 EPION(NNN,IRUN)=AP2
              ELSE
                 LB(I)=1
                 NLAB=1
                 LPION(NNN,IRUN)=4
                 EPION(NNN,IRUN)=AP1
              ENDIF
           ELSE
* DECAY TO ETA+NUCLEON
              LB(I)=1
              NLAB=1
              LPION(NNN,IRUN)=0
              EPION(NNN,IRUN)=ETAM
           ENDIF
        ENDIF
c
        CALL DKINE(IRUN,I,NNN,NLAB,ISEED,wid,nt)
c
c     anti-particle ID for anti-N* decays:
        if(lbanti.lt.0) then
           lbi=LB(I)
           if(lbi.eq.1.or.lbi.eq.2) then
              lbi=-lbi
           elseif(lbi.eq.3) then
              lbi=5
           elseif(lbi.eq.5) then
              lbi=3
           endif
           LB(I)=lbi
c
           lbi=LPION(NNN,IRUN)
           if(lbi.eq.3) then
              lbi=5
           elseif(lbi.eq.5) then
              lbi=3
           elseif(lbi.eq.1.or.lbi.eq.2) then
              lbi=-lbi
           endif
           LPION(NNN,IRUN)=lbi
        endif
c
        if(nt.eq.ntmax) then
c     at the last timestep, assign rho or eta (decay daughter) 
c     to lb(i1) only (not to lpion) in order to decay them again:
           lbm=LPION(NNN,IRUN)
           if(lbm.eq.0.or.lbm.eq.25
     1          .or.lbm.eq.26.or.lbm.eq.27) then
c     switch rho or eta with baryon, positions are the same (no change needed):
              lbsave=lbm
              xmsave=EPION(NNN,IRUN)
              pxsave=PPION(1,NNN,IRUN)
              pysave=PPION(2,NNN,IRUN)
              pzsave=PPION(3,NNN,IRUN)
clin-5/2008:
              dpsave=dppion(NNN,IRUN)
              LPION(NNN,IRUN)=LB(I)
              EPION(NNN,IRUN)=E(I)
              PPION(1,NNN,IRUN)=P(1,I)
              PPION(2,NNN,IRUN)=P(2,I)
              PPION(3,NNN,IRUN)=P(3,I)
clin-5/2008:
              dppion(NNN,IRUN)=dpertp(I)
              LB(I)=lbsave
              E(I)=xmsave
              P(1,I)=pxsave
              P(2,I)=pysave
              P(3,I)=pzsave
clin-5/2008:
              dpertp(I)=dpsave
           endif
        endif

       RETURN
       END

*-------------------------------------------------------------------
*-------------------------------------------------------------------
* PURPOSE:
*         CALCULATE THE MOMENTUM OF NUCLEON AND PION (OR ETA) 
*         IN THE LAB. FRAME AFTER DELTA OR N* DECAY
* DATE   : JAN. 24,1990, MODIFIED ON MAY 17, 1994 TO INCLUDE ETA PRODUCTION
        SUBROUTINE DKINE(IRUN,I,NNN,NLAB,ISEED,wid,nt)
        PARAMETER (hbarc=0.19733)
        PARAMETER (MAXSTR=150001,MAXR=1,
     1  AMN=0.939457,AMP=0.93828,ETAM=0.5475,
     2  AP1=0.13496,AP2=0.13957,AM0=1.232,PI=3.1415926)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1 px1n,py1n,pz1n,dp1n
cc      SAVE /leadng/
        COMMON/tdecay/tfdcy(MAXSTR),tfdpi(MAXSTR,MAXR),tft(MAXSTR)
cc      SAVE /tdecay/
        COMMON /INPUT2/ ILAB, MANYB, NTMAX, ICOLL, INSYS, IPOT, MODE, 
     &       IMOMEN, NFREQ, ICFLOW, ICRHO, ICOU, KPOTEN, KMUL
cc      SAVE /INPUT2/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
        EXTERNAL IARFLV, INVFLV
      SAVE   
* READ IN THE COORDINATES OF DELTA OR N* UNDERGOING DECAY
        PX=P(1,I)
        PY=P(2,I)
        PZ=P(3,I)
        RX=R(1,I)
        RY=R(2,I)
        RZ=R(3,I)
        DM=E(I)
        EDELTA=SQRT(DM**2+PX**2+PY**2+PZ**2)
        PM=EPION(NNN,IRUN)
        AM=AMP
        IF(NLAB.EQ.2)AM=AMN
* FIND OUT THE MOMENTUM AND ENERGY OF PION AND NUCLEON IN DELTA REST FRAME
* THE MAGNITUDE OF MOMENTUM IS DETERMINED BY ENERGY CONSERVATION ,THE FORMULA
* CAN BE FOUND ON PAGE 716,W BAUER P.R.C40,1989
* THE DIRECTION OF THE MOMENTUM IS ASSUMED ISOTROPIC. NOTE THAT P(PION)=-P(N)
        Q2=((DM**2-AM**2+PM**2)/(2.*DM))**2-PM**2
        IF(Q2.LE.0.)Q2=1.e-09
        Q=SQRT(Q2)
11      QX=1.-2.*RANART(NSEED)
        QY=1.-2.*RANART(NSEED)
        QZ=1.-2.*RANART(NSEED)
        QS=QX**2+QY**2+QZ**2
        IF(QS.GT.1.) GO TO 11
        PXP=Q*QX/SQRT(QS)
        PYP=Q*QY/SQRT(QS)
        PZP=Q*QZ/SQRT(QS)
        EP=SQRT(Q**2+PM**2)
        PXN=-PXP
        PYN=-PYP
        PZN=-PZP
        EN=SQRT(Q**2+AM**2)
* TRANSFORM INTO THE LAB. FRAME. THE GENERAL LORENTZ TRANSFORMATION CAN
* BE FOUND ON PAGE 34 OF R. HAGEDORN " RELATIVISTIC KINEMATICS"
        GD=EDELTA/DM
        FGD=GD/(1.+GD)
        BDX=PX/EDELTA
        BDY=PY/EDELTA
        BDZ=PZ/EDELTA
        BPP=BDX*PXP+BDY*PYP+BDZ*PZP
        BPN=BDX*PXN+BDY*PYN+BDZ*PZN
        P(1,I)=PXN+BDX*GD*(FGD*BPN+EN)
        P(2,I)=PYN+BDY*GD*(FGD*BPN+EN)
        P(3,I)=PZN+BDZ*GD*(FGD*BPN+EN)
        E(I)=AM
* WE ASSUME THAT THE SPACIAL COORDINATE OF THE NUCLEON
* IS THAT OF THE DELTA
        PPION(1,NNN,IRUN)=PXP+BDX*GD*(FGD*BPP+EP)
        PPION(2,NNN,IRUN)=PYP+BDY*GD*(FGD*BPP+EP)
        PPION(3,NNN,IRUN)=PZP+BDZ*GD*(FGD*BPP+EP)
clin-5/2008:
        dppion(NNN,IRUN)=dpertp(I)
* WE ASSUME THE PION OR ETA COMING FROM DELTA DECAY IS LOCATED ON THE SPHERE
* OF RADIUS 0.5FM AROUND DELTA, THIS POINT NEED TO BE CHECKED 
* AND OTHER CRIERTION MAY BE TRIED
clin-2/20/03 no additional smearing for position of decay daughters:
c200         X0 = 1.0 - 2.0 * RANART(NSEED)
c            Y0 = 1.0 - 2.0 * RANART(NSEED)
c            Z0 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X0*X0+Y0*Y0+Z0*Z0) .GT. 1.0) GOTO 200
c        RPION(1,NNN,IRUN)=R(1,I)+0.5*x0
c        RPION(2,NNN,IRUN)=R(2,I)+0.5*y0
c        RPION(3,NNN,IRUN)=R(3,I)+0.5*z0
        RPION(1,NNN,IRUN)=R(1,I)
        RPION(2,NNN,IRUN)=R(2,I)
        RPION(3,NNN,IRUN)=R(3,I)
c
        devio=SQRT(EPION(NNN,IRUN)**2+PPION(1,NNN,IRUN)**2
     1       +PPION(2,NNN,IRUN)**2+PPION(3,NNN,IRUN)**2)
     2       +SQRT(E(I)**2+P(1,I)**2+P(2,I)**2+P(3,I)**2)-e1
c        if(abs(devio).gt.0.02) write(93,*) 'decay(): nt=',nt,devio,lb1

c     add decay time to daughter's formation time at the last timestep:
        if(nt.eq.ntmax) then
           tau0=hbarc/wid
           taudcy=tau0*(-1.)*alog(1.-RANART(NSEED))
c     lorentz boost:
           taudcy=taudcy*e1/em1
           tfnl=tfnl+taudcy
           xfnl=xfnl+px1/e1*taudcy
           yfnl=yfnl+py1/e1*taudcy
           zfnl=zfnl+pz1/e1*taudcy
           R(1,I)=xfnl
           R(2,I)=yfnl
           R(3,I)=zfnl
           tfdcy(I)=tfnl
           RPION(1,NNN,IRUN)=xfnl
           RPION(2,NNN,IRUN)=yfnl
           RPION(3,NNN,IRUN)=zfnl
           tfdpi(NNN,IRUN)=tfnl
        endif

 200    format(a30,2(1x,e10.4))
 210    format(i6,5(1x,f8.3))
 220    format(a2,i5,5(1x,f8.3))

        RETURN
        END

*-----------------------------------------------------------------------------
*-----------------------------------------------------------------------------
* PURPOSE:1. N*-->N+PION+PION  DECAY PRODUCTS
*         2. DETERMINE THE MOMENTUM AND COORDINATES OF NUCLEON AND PION
*            AFTER THE DELTA OR N* DECAYING
* DATE   : NOV.7,1994
*----------------------------------------------------------------------------
        SUBROUTINE DECAY2(IRUN,I,NNN,ISEED,wid,nt)
        PARAMETER (MAXSTR=150001,MAXR=1,
     1  AMN=0.939457,ETAM=0.5475,AMP=0.93828,AP1=0.13496,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

        lbanti=LB(I)
c
        DM=E(I)
* DETERMINE THE DECAY PRODUCTS
* FOR N*+(1440) DECAY
        IF(iabs(LB(I)).EQ.11)THEN
           X3=RANART(NSEED)
           IF(X3.LT.(1./3))THEN
              LB(I)=2
              NLAB=2
              LPION(NNN,IRUN)=5
              EPION(NNN,IRUN)=AP2
              LPION(NNN+1,IRUN)=4
              EPION(NNN+1,IRUN)=AP1
           ELSEIF(X3.LT.2./3.AND.X3.GT.1./3.)THEN
              LB(I)=1
              NLAB=1
              LPION(NNN,IRUN)=5
              EPION(NNN,IRUN)=AP2
              LPION(NNN+1,IRUN)=3
              EPION(NNN+1,IRUN)=AP2
           ELSE
              LB(I)=1
              NLAB=1
              LPION(NNN,IRUN)=4
              EPION(NNN,IRUN)=AP1
              LPION(NNN+1,IRUN)=4
              EPION(NNN+1,IRUN)=AP1
           ENDIF
* FOR N*0(1440) DECAY
        ELSEIF(iabs(LB(I)).EQ.10)THEN
           X3=RANART(NSEED)
           IF(X3.LT.(1./3))THEN
              LB(I)=2
              NLAB=2
              LPION(NNN,IRUN)=4
              EPION(NNN,IRUN)=AP1
              LPION(NNN+1,IRUN)=4
              EPION(NNN+1,IRUN)=AP1
           ELSEIF(X3.LT.2./3.AND.X3.GT.1./3.)THEN
              LB(I)=1
              NLAB=1
              LPION(NNN,IRUN)=3
              EPION(NNN,IRUN)=AP2
              LPION(NNN+1,IRUN)=4
              EPION(NNN+1,IRUN)=AP1
           ELSE
              LB(I)=2
              NLAB=2
              LPION(NNN,IRUN)=5
              EPION(NNN,IRUN)=AP2
              LPION(NNN+1,IRUN)=3
              EPION(NNN+1,IRUN)=AP2
           ENDIF
        ENDIF

        CALL DKINE2(IRUN,I,NNN,NLAB,ISEED,wid,nt)
c
c     anti-particle ID for anti-N* decays:
        if(lbanti.lt.0) then
           lbi=LB(I)
           if(lbi.eq.1.or.lbi.eq.2) then
              lbi=-lbi
           elseif(lbi.eq.3) then
              lbi=5
           elseif(lbi.eq.5) then
              lbi=3
           endif
           LB(I)=lbi
c
           lbi=LPION(NNN,IRUN)
           if(lbi.eq.3) then
              lbi=5
           elseif(lbi.eq.5) then
              lbi=3
           elseif(lbi.eq.1.or.lbi.eq.2) then
              lbi=-lbi
           endif
           LPION(NNN,IRUN)=lbi
c
           lbi=LPION(NNN+1,IRUN)
           if(lbi.eq.3) then
              lbi=5
           elseif(lbi.eq.5) then
              lbi=3
           elseif(lbi.eq.1.or.lbi.eq.2) then
              lbi=-lbi
           endif
           LPION(NNN+1,IRUN)=lbi
        endif
c
       RETURN
       END
*-------------------------------------------------------------------
*--------------------------------------------------------------------------
*         CALCULATE THE MOMENTUM OF NUCLEON AND PION (OR ETA) 
*         IN THE LAB. FRAME AFTER DELTA OR N* DECAY
* DATE   : JAN. 24,1990, MODIFIED ON MAY 17, 1994 TO INCLUDE ETA PRODUCTION
*--------------------------------------------------------------------------
        SUBROUTINE DKINE2(IRUN,I,NNN,NLAB,ISEED,wid,nt)
        PARAMETER (hbarc=0.19733)
        PARAMETER (MAXSTR=150001,MAXR=1,
     1  AMN=0.939457,AMP=0.93828,ETAM=0.5475,
     2  AP1=0.13496,AP2=0.13957,AM0=1.232,PI=3.1415926)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1 px1n,py1n,pz1n,dp1n
cc      SAVE /leadng/
        COMMON/tdecay/tfdcy(MAXSTR),tfdpi(MAXSTR,MAXR),tft(MAXSTR)
cc      SAVE /tdecay/
        COMMON /INPUT2/ ILAB, MANYB, NTMAX, ICOLL, INSYS, IPOT, MODE, 
     &       IMOMEN, NFREQ, ICFLOW, ICRHO, ICOU, KPOTEN, KMUL
cc      SAVE /INPUT2/
        EXTERNAL IARFLV, INVFLV
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      SAVE   

* READ IN THE COORDINATES OF THE N*(1440) UNDERGOING DECAY
        PX=P(1,I)
        PY=P(2,I)
        PZ=P(3,I)
        RX=R(1,I)
        RY=R(2,I)
        RZ=R(3,I)
        DM=E(I)
        EDELTA=SQRT(DM**2+PX**2+PY**2+PZ**2)
        PM1=EPION(NNN,IRUN)
        PM2=EPION(NNN+1,IRUN)
        AM=AMN
       IF(NLAB.EQ.1)AM=AMP
* THE MAXIMUM MOMENTUM OF THE NUCLEON FROM THE DECAY OF A N*
       PMAX2=(DM**2-(AM+PM1+PM2)**2)*(DM**2-(AM-PM1-PM2)**2)/4/DM**2

clin-9/2012: check argument in sqrt():
       scheck=PMAX2
       if(scheck.lt.0) then
          write(99,*) 'scheck15: ', scheck
          scheck=0.
       endif
       PMAX=SQRT(scheck)
c       PMAX=SQRT(PMAX2)

* GENERATE THE MOMENTUM OF THE NUCLEON IN THE N* REST FRAME
       CSS=1.-2.*RANART(NSEED)
       SSS=SQRT(1-CSS**2)
       FAI=2*PI*RANART(NSEED)
       PX0=PMAX*SSS*COS(FAI)
       PY0=PMAX*SSS*SIN(FAI)
       PZ0=PMAX*CSS
       EP0=SQRT(PX0**2+PY0**2+PZ0**2+AM**2)
clin-5/23/01 bug: P0 for pion0 is equal to PMAX, leaving pion+ and pion- 
c     without no relative momentum, thus producing them with equal momenta, 
* BETA AND GAMMA OF THE CMS OF PION+-PION-
       BETAX=-PX0/(DM-EP0)
       BETAY=-PY0/(DM-EP0)
       BETAZ=-PZ0/(DM-EP0)

clin-9/2012: check argument in sqrt():
       scheck=1-BETAX**2-BETAY**2-BETAZ**2
       if(scheck.le.0) then
          write(99,*) 'scheck16: ', scheck
          stop
       endif
       GD1=1./SQRT(scheck)
c       GD1=1./SQRT(1-BETAX**2-BETAY**2-BETAZ**2)

       FGD1=GD1/(1+GD1)
* GENERATE THE MOMENTA OF PIONS IN THE CMS OF PION+PION-
        Q2=((DM-EP0)/(2.*GD1))**2-PM1**2
        IF(Q2.LE.0.)Q2=1.E-09
        Q=SQRT(Q2)
11      QX=1.-2.*RANART(NSEED)
        QY=1.-2.*RANART(NSEED)
        QZ=1.-2.*RANART(NSEED)
        QS=QX**2+QY**2+QZ**2
        IF(QS.GT.1.) GO TO 11
        PXP=Q*QX/SQRT(QS)
        PYP=Q*QY/SQRT(QS)
        PZP=Q*QZ/SQRT(QS)
        EP=SQRT(Q**2+PM1**2)
        PXN=-PXP
        PYN=-PYP
        PZN=-PZP
        EN=SQRT(Q**2+PM2**2)
* TRANSFORM THE MOMENTA OF PION+PION- INTO THE N* REST FRAME
        BPP1=BETAX*PXP+BETAY*PYP+BETAZ*PZP
        BPN1=BETAX*PXN+BETAY*PYN+BETAZ*PZN
* FOR PION-
        P1M=PXN+BETAX*GD1*(FGD1*BPN1+EN)
        P2M=PYN+BETAY*GD1*(FGD1*BPN1+EN)
        P3M=PZN+BETAZ*GD1*(FGD1*BPN1+EN)
       EPN=SQRT(P1M**2+P2M**2+P3M**2+PM2**2)
* FOR PION+
        P1P=PXP+BETAX*GD1*(FGD1*BPP1+EP)
        P2P=PYP+BETAY*GD1*(FGD1*BPP1+EP)
        P3P=PZP+BETAZ*GD1*(FGD1*BPP1+EP)
       EPP=SQRT(P1P**2+P2P**2+P3P**2+PM1**2)
* TRANSFORM MOMENTA OF THE THREE PIONS INTO THE 
* THE NUCLEUS-NUCLEUS CENTER OF MASS  FRAME. 
* THE GENERAL LORENTZ TRANSFORMATION CAN
* BE FOUND ON PAGE 34 OF R. HAGEDORN " RELATIVISTIC KINEMATICS"
        GD=EDELTA/DM
        FGD=GD/(1.+GD)
        BDX=PX/EDELTA
        BDY=PY/EDELTA
        BDZ=PZ/EDELTA
       BP0=BDX*PX0+BDY*PY0+BDZ*PZ0
        BPP=BDX*P1P+BDY*P2P+BDZ*P3P
        BPN=BDX*P1M+BDY*P2M+BDZ*P3M
* FOR THE NUCLEON
        P(1,I)=PX0+BDX*GD*(FGD*BP0+EP0)
        P(2,I)=PY0+BDY*GD*(FGD*BP0+EP0)
        P(3,I)=PZ0+BDZ*GD*(FGD*BP0+EP0)
       E(I)=am
       ID(I)=0
       enucl=sqrt(p(1,i)**2+p(2,i)**2+p(3,i)**2+e(i)**2)
* WE ASSUME THAT THE SPACIAL COORDINATE OF THE PION0
* IS in a sphere of radius 0.5 fm around N*
* FOR PION+
        PPION(1,NNN,IRUN)=P1P+BDX*GD*(FGD*BPP+EPP)
        PPION(2,NNN,IRUN)=P2P+BDY*GD*(FGD*BPP+EPP)
        PPION(3,NNN,IRUN)=P3P+BDZ*GD*(FGD*BPP+EPP)
       epion1=sqrt(ppion(1,nnn,irun)**2
     &  +ppion(2,nnn,irun)**2+ppion(3,nnn,irun)**2
     &  +epion(nnn,irun)**2)
clin-2/20/03 no additional smearing for position of decay daughters:
c200         X0 = 1.0 - 2.0 * RANART(NSEED)
c            Y0 = 1.0 - 2.0 * RANART(NSEED)
c            Z0 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X0*X0+Y0*Y0+Z0*Z0) .GT. 1.0) GOTO 200
c        RPION(1,NNN,IRUN)=R(1,I)+0.5*x0
c        RPION(2,NNN,IRUN)=R(2,I)+0.5*y0
c        RPION(3,NNN,IRUN)=R(3,I)+0.5*z0
        RPION(1,NNN,IRUN)=R(1,I)
        RPION(2,NNN,IRUN)=R(2,I)
        RPION(3,NNN,IRUN)=R(3,I)
* FOR PION-
        PPION(1,NNN+1,IRUN)=P1M+BDX*GD*(FGD*BPN+EPN)
        PPION(2,NNN+1,IRUN)=P2M+BDY*GD*(FGD*BPN+EPN)
        PPION(3,NNN+1,IRUN)=P3M+BDZ*GD*(FGD*BPN+EPN)
clin-5/2008:
        dppion(NNN,IRUN)=dpertp(I)
        dppion(NNN+1,IRUN)=dpertp(I)
c
       epion2=sqrt(ppion(1,nnn+1,irun)**2
     &  +ppion(2,nnn+1,irun)**2+ppion(3,nnn+1,irun)**2
     &  +epion(nnn+1,irun)**2)
clin-2/20/03 no additional smearing for position of decay daughters:
c300         X0 = 1.0 - 2.0 * RANART(NSEED)
c            Y0 = 1.0 - 2.0 * RANART(NSEED)
c            Z0 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X0*X0+Y0*Y0+Z0*Z0) .GT. 1.0) GOTO 300
c        RPION(1,NNN+1,IRUN)=R(1,I)+0.5*x0
c        RPION(2,NNN+1,IRUN)=R(2,I)+0.5*y0
c        RPION(3,NNN+1,IRUN)=R(3,I)+0.5*z0
        RPION(1,NNN+1,IRUN)=R(1,I)
        RPION(2,NNN+1,IRUN)=R(2,I)
        RPION(3,NNN+1,IRUN)=R(3,I)
c
* check energy conservation in the decay
c       efinal=enucl+epion1+epion2
c       DEEE=(EDELTA-EFINAL)/EDELTA
c       IF(ABS(DEEE).GE.1.E-03)write(6,*)1,edelta,efinal

        devio=SQRT(EPION(NNN,IRUN)**2+PPION(1,NNN,IRUN)**2
     1       +PPION(2,NNN,IRUN)**2+PPION(3,NNN,IRUN)**2)
     2       +SQRT(E(I)**2+P(1,I)**2+P(2,I)**2+P(3,I)**2)
     3       +SQRT(EPION(NNN+1,IRUN)**2+PPION(1,NNN+1,IRUN)**2
     4       +PPION(2,NNN+1,IRUN)**2+PPION(3,NNN+1,IRUN)**2)-e1
c        if(abs(devio).gt.0.02) write(93,*) 'decay2(): nt=',nt,devio,lb1

c     add decay time to daughter's formation time at the last timestep:
        if(nt.eq.ntmax) then
           tau0=hbarc/wid
           taudcy=tau0*(-1.)*alog(1.-RANART(NSEED))
c     lorentz boost:
           taudcy=taudcy*e1/em1
           tfnl=tfnl+taudcy
           xfnl=xfnl+px1/e1*taudcy
           yfnl=yfnl+py1/e1*taudcy
           zfnl=zfnl+pz1/e1*taudcy
           R(1,I)=xfnl
           R(2,I)=yfnl
           R(3,I)=zfnl
           tfdcy(I)=tfnl
           RPION(1,NNN,IRUN)=xfnl
           RPION(2,NNN,IRUN)=yfnl
           RPION(3,NNN,IRUN)=zfnl
           tfdpi(NNN,IRUN)=tfnl
           RPION(1,NNN+1,IRUN)=xfnl
           RPION(2,NNN+1,IRUN)=yfnl
           RPION(3,NNN+1,IRUN)=zfnl
           tfdpi(NNN+1,IRUN)=tfnl
        endif

 200    format(a30,2(1x,e10.4))
 210    format(i6,5(1x,f8.3))
 220    format(a2,i5,5(1x,f8.3))

        RETURN
        END
*---------------------------------------------------------------------------
*---------------------------------------------------------------------------
* PURPOSE : CALCULATE THE MASS AND MOMENTUM OF BARYON RESONANCE 
*           AFTER PION OR ETA BEING ABSORBED BY A NUCLEON
* NOTE    : 
*           
* DATE    : JAN.29,1990
        SUBROUTINE DRESON(I1,I2)
        PARAMETER (MAXSTR=150001,MAXR=1,
     1  AMN=0.939457,AMP=0.93828,
     2  AP1=0.13496,AP2=0.13957,AM0=1.232,PI=3.1415926)
clin-9/2012: improve precision for argument in sqrt():
        double precision e10,e20,scheck,p1,p2,p3
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      SAVE   
* 1. DETERMINE THE MOMENTUM COMPONENT OF DELTA/N* IN THE LAB. FRAME
clin-9/2012: improve precision for argument in sqrt():
c        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
c        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
        E10=dSQRT(dble(E(I1))**2+dble(P(1,I1))**2
     1     +dble(P(2,I1))**2+dble(P(3,I1))**2)
        E20=dSQRT(dble(E(I2))**2+dble(P(1,I2))**2
     1       +dble(P(2,I2))**2+dble(P(3,I2))**2)
        p1=dble(P(1,I1))+dble(P(1,I2))
        p2=dble(P(2,I1))+dble(P(2,I2))
        p3=dble(P(3,I1))+dble(P(3,I2))

        IF(iabs(LB(I2)) .EQ. 1 .OR. iabs(LB(I2)) .EQ. 2 .OR.
     &     (iabs(LB(I2)) .GE. 6 .AND. iabs(LB(I2)) .LE. 17)) THEN
        E(I1)=0.
        I=I2
        ELSE
        E(I2)=0.
        I=I1
        ENDIF
        P(1,I)=P(1,I1)+P(1,I2)
        P(2,I)=P(2,I1)+P(2,I2)
        P(3,I)=P(3,I1)+P(3,I2)
* 2. DETERMINE THE MASS OF DELTA/N* BY USING THE REACTION KINEMATICS

clin-9/2012: check argument in sqrt():
        scheck=(E10+E20)**2-p1**2-p2**2-p3**2
        if(scheck.lt.0) then
           write(99,*) 'scheck17: ', scheck
           write(99,*) 'scheck17', scheck,E10,E20,P(1,I),P(2,I),P(3,I)
           write(99,*) 'scheck17-1',E(I1),P(1,I1),P(2,I1),P(3,I1)
           write(99,*) 'scheck17-2',E(I2),P(1,I2),P(2,I2),P(3,I2)
           scheck=0.d0
        endif
        DM=SQRT(sngl(scheck))
c        DM=SQRT((E10+E20)**2-P(1,I)**2-P(2,I)**2-P(3,I)**2)

        E(I)=DM
        RETURN
        END
*---------------------------------------------------------------------------
* PURPOSE : CALCULATE THE MASS AND MOMENTUM OF RHO RESONANCE 
*           AFTER PION + PION COLLISION
* DATE    : NOV. 30,1994
        SUBROUTINE RHORES(I1,I2)
        PARAMETER (MAXSTR=150001,MAXR=1,
     1  AMN=0.939457,AMP=0.93828,
     2  AP1=0.13496,AP2=0.13957,AM0=1.232,PI=3.1415926)
clin-9/2012: improve precision for argument in sqrt():
        double precision e10,e20,scheck,p1,p2,p3
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      SAVE   
* 1. DETERMINE THE MOMENTUM COMPONENT OF THE RHO IN THE CMS OF NN FRAME
*    WE LET I1 TO BE THE RHO AND ABSORB I2
clin-9/2012: improve precision for argument in sqrt():
c        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
c        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
        E10=dSQRT(dble(E(I1))**2+dble(P(1,I1))**2
     1     +dble(P(2,I1))**2+dble(P(3,I1))**2)
        E20=dSQRT(dble(E(I2))**2+dble(P(1,I2))**2
     1       +dble(P(2,I2))**2+dble(P(3,I2))**2)
        p1=dble(P(1,I1))+dble(P(1,I2))
        p2=dble(P(2,I1))+dble(P(2,I2))
        p3=dble(P(3,I1))+dble(P(3,I2))

        P(1,I1)=P(1,I1)+P(1,I2)
        P(2,I1)=P(2,I1)+P(2,I2)
        P(3,I1)=P(3,I1)+P(3,I2)
* 2. DETERMINE THE MASS OF THE RHO BY USING THE REACTION KINEMATICS

clin-9/2012: check argument in sqrt():
        scheck=(E10+E20)**2-p1**2-p2**2-p3**2
        if(scheck.lt.0) then
           write(99,*) 'scheck18: ', scheck
           scheck=0.d0
        endif
        DM=SQRT(sngl(scheck))
c        DM=SQRT((E10+E20)**2-P(1,I1)**2-P(2,I1)**2-P(3,I1)**2)

        E(I1)=DM
       E(I2)=0
        RETURN
        END
*---------------------------------------------------------------------------
* PURPOSE : CALCULATE THE PION+NUCLEON CROSS SECTION ACCORDING TO THE
*           BREIT-WIGNER FORMULA/(p*)**2
* VARIABLE : LA = 1 FOR DELTA RESONANCE
*            LA = 0 FOR N*(1440) RESONANCE
*            LA = 2 FRO N*(1535) RESONANCE
* DATE    : JAN.29,1990
        REAL FUNCTION XNPI(I1,I2,LA,XMAX)
        PARAMETER (MAXSTR=150001,MAXR=1,
     1  AMN=0.939457,AMP=0.93828,
     2  AP1=0.13496,AP2=0.13957,AM0=1.232,PI=3.1415926)
clin-9/2012: improve precision for argument in sqrt():
        double precision e10,e20,scheck,p1,p2,p3
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      SAVE   
        AVMASS=0.5*(AMN+AMP)
        AVPI=(2.*AP2+AP1)/3.
* 1. DETERMINE THE MOMENTUM COMPONENT OF DELTA IN THE LAB. FRAME
clin-9/2012: improve precision for argument in sqrt():
c        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
c        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
        E10=dSQRT(dble(E(I1))**2+dble(P(1,I1))**2
     1     +dble(P(2,I1))**2+dble(P(3,I1))**2)
        E20=dSQRT(dble(E(I2))**2+dble(P(1,I2))**2
     1       +dble(P(2,I2))**2+dble(P(3,I2))**2)
c        P1=P(1,I1)+P(1,I2)
c        P2=P(2,I1)+P(2,I2)
c        P3=P(3,I1)+P(3,I2)
        p1=dble(P(1,I1))+dble(P(1,I2))
        p2=dble(P(2,I1))+dble(P(2,I2))
        p3=dble(P(3,I1))+dble(P(3,I2))

* 2. DETERMINE THE MASS OF DELTA BY USING OF THE REACTION KINEMATICS

clin-9/2012: check argument in sqrt():
        scheck=(E10+E20)**2-p1**2-p2**2-p3**2
        if(scheck.lt.0) then
           write(99,*) 'scheck19: ', scheck
           scheck=0.d0
        endif
        DM=SQRT(sngl(scheck))
c        DM=SQRT((E10+E20)**2-P1**2-P2**2-P3**2)

        IF(DM.LE.1.1) THEN
        XNPI=1.e-09
        RETURN
        ENDIF
* 3. DETERMINE THE PION+NUCLEON CROSS SECTION ACCORDING TO THE
*    BREIT-WIGNER FORMULA IN UNIT OF FM**2
        IF(LA.EQ.1)THEN
        GAM=WIDTH(DM)
        F1=0.25*GAM**2/(0.25*GAM**2+(DM-1.232)**2)
        PDELT2=0.051622
        GO TO 10
       ENDIF
       IF(LA.EQ.0)THEN
        GAM=W1440(DM)
        F1=0.25*GAM**2/(0.25*GAM**2+(DM-1.440)**2)
        PDELT2=0.157897
       GO TO 10
        ENDIF
       IF(LA.EQ.2)THEN
        GAM=W1535(DM)
        F1=0.25*GAM**2/(0.25*GAM**2+(DM-1.535)**2)
        PDELT2=0.2181
        ENDIF
10      PSTAR2=((DM**2-AVMASS**2+AVPI**2)/(2.*DM))**2-AVPI**2
        IF(PSTAR2.LE.0.)THEN
        XNPI=1.e-09
        ELSE
* give the cross section in unit of fm**2
        XNPI=F1*(PDELT2/PSTAR2)*XMAX/10.
        ENDIF
        RETURN
        END
*------------------------------------------------------------------------------
*****************************************
        REAL FUNCTION SIGMA(SRT,ID,IOI,IOF)
*PURPOSE : THIS IS THE PROGRAM TO CALCULATE THE ISOSPIN DECOMPOSED CROSS
*       SECTION BY USING OF B.J.VerWEST AND R.A.ARNDT'S PARAMETERIZATION
*REFERENCE: PHYS. REV. C25(1982)1979
*QUANTITIES: IOI -- INITIAL ISOSPIN OF THE TWO NUCLEON SYSTEM
*            IOF -- FINAL   ISOSPIN -------------------------
*            ID -- =1 FOR DELTA RESORANCE
*                  =2 FOR N*    RESORANCE
*DATE : MAY 15,1990
*****************************************
        PARAMETER (AMU=0.9383,AMP=0.1384,PI=3.1415926,HC=0.19733)
      SAVE   
        IF(ID.EQ.1)THEN
        AMASS0=1.22
        T0 =0.12
        ELSE
        AMASS0=1.43
        T0 =0.2
        ENDIF
        IF((IOI.EQ.1).AND.(IOF.EQ.1))THEN
        ALFA=3.772
        BETA=1.262
        AM0=1.188
        T=0.09902
        ENDIF
        IF((IOI.EQ.1).AND.(IOF.EQ.0))THEN
        ALFA=15.28
        BETA=0.
        AM0=1.245
        T=0.1374
        ENDIF
        IF((IOI.EQ.0).AND.(IOF.EQ.1))THEN
        ALFA=146.3
        BETA=0.
        AM0=1.472
        T=0.02649
        ENDIF
        ZPLUS=(SRT-AMU-AMASS0)*2./T0
        ZMINUS=(AMU+AMP-AMASS0)*2./T0
        deln=ATAN(ZPLUS)-ATAN(ZMINUS)
       if(deln.eq.0)deln=1.E-06
        AMASS=AMASS0+(T0/4.)*ALOG((1.+ZPLUS**2)/(1.+ZMINUS**2))
     1  /deln
        S=SRT**2
        P2=S/4.-AMU**2
        S0=(AMU+AM0)**2
        P02=S0/4.-AMU**2
        P0=SQRT(P02)
        PR2=(S-(AMU-AMASS)**2)*(S-(AMU+AMASS)**2)/(4.*S)
        IF(PR2.GT.1.E-06)THEN
        PR=SQRT(PR2)
        ELSE
        PR=0.
        SIGMA=1.E-06
        RETURN
        ENDIF
        SS=AMASS**2
        Q2=(SS-(AMU-AMP)**2)*(SS-(AMU+AMP)**2)/(4.*SS)
        IF(Q2.GT.1.E-06)THEN
        Q=SQRT(Q2)
        ELSE
        Q=0.
        SIGMA=1.E-06
        RETURN
        ENDIF
        SS0=AM0**2
        Q02=(SS0-(AMU-AMP)**2)*(SS0-(AMU+AMP)**2)/(4.*SS0)

clin-9/2012: check argument in sqrt():
        scheck=Q02
        if(scheck.lt.0) then
           write(99,*) 'scheck20: ', scheck
           scheck=0.
        endif
        Q0=SQRT(scheck)
c        Q0=SQRT(Q02)

        SIGMA=PI*(HC)**2/(2.*P2)*ALFA*(PR/P0)**BETA*AM0**2*T**2
     1  *(Q/Q0)**3/((SS-AM0**2)**2+AM0**2*T**2)
        SIGMA=SIGMA*10.
       IF(SIGMA.EQ.0)SIGMA=1.E-06
        RETURN
        END

*****************************
        REAL FUNCTION DENOM(SRT,CON)
* NOTE: CON=1 FOR DELTA RESONANCE, CON=2 FOR N*(1440) RESONANCE
*       con=-1 for N*(1535)
* PURPOSE : CALCULATE THE INTEGRAL IN THE DETAILED BALANCE
*
* DATE : NOV. 15, 1991
*******************************
        PARAMETER (AP1=0.13496,
     1  AP2=0.13957,PI=3.1415926,AVMASS=0.9383)
      SAVE   
        AVPI=(AP1+2.*AP2)/3.
        AM0=1.232
        AMN=AVMASS
        AMP=AVPI
        AMAX=SRT-AVMASS
        AMIN=AVMASS+AVPI
        NMAX=200
        DMASS=(AMAX-AMIN)/FLOAT(NMAX)
        SUM=0.
        DO 10 I=1,NMAX+1
        DM=AMIN+FLOAT(I-1)*DMASS
        IF(CON.EQ.1.)THEN
        Q2=((DM**2-AMN**2+AMP**2)/(2.*DM))**2-AMP**2
           IF(Q2.GT.0.)THEN
           Q=SQRT(Q2)
           ELSE
           Q=1.E-06
           ENDIF
        TQ=0.47*(Q**3)/(AMP**2*(1.+0.6*(Q/AMP)**2))
        ELSE if(con.eq.2)then
        TQ=0.2
        AM0=1.44
       else if(con.eq.-1.)then
       tq=0.1
       am0=1.535
        ENDIF
        A1=4.*TQ*AM0**2/(AM0**2*TQ**2+(DM**2-AM0**2)**2)
        S=SRT**2
        P0=(S+DM**2-AMN**2)**2/(4.*S)-DM**2
        IF(P0.LE.0.)THEN
        P1=1.E-06
        ELSE
        P1=SQRT(P0)
        ENDIF
        F=DM*A1*P1
        IF((I.EQ.1).OR.(I.EQ.(NMAX+1)))THEN
        SUM=SUM+F*0.5
        ELSE
        SUM=SUM+F
        ENDIF
10      CONTINUE
        DENOM=SUM*DMASS/(2.*PI)
        RETURN
        END
**********************************
* subroutine : ang.FOR
* PURPOSE : Calculate the angular distribution of Delta production process 
* DATE    : Nov. 19, 1992
* REFERENCE: G. WOLF ET. AL., NUCL. PHYS. A517 (1990) 615
* Note: this function applies when srt is larger than 2.14 GeV,
* for less energetic reactions, we assume the angular distribution
* is isotropic.
***********************************
       real function ang(srt,iseed)
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
c        if(srt.le.2.14)then
c       b1s=0.5
c       b2s=0.
c      endif
      if((srt.gt.2.14).and.(srt.le.2.4))then
       b1s=29.03-23.75*srt+4.865*srt**2
         b2s=-30.33+25.53*srt-5.301*srt**2
      endif
      if(srt.gt.2.4)then
       b1s=0.06
         b2s=0.4
      endif
        x=RANART(NSEED)
       p=b1s/b2s
       q=(2.*x-1.)*(b1s+b2s)/b2s
       IF((-q/2.+sqrt((q/2.)**2+(p/3.)**3)).GE.0.)THEN
       ang1=(-q/2.+sqrt((q/2.)**2+(p/3.)**3))**(1./3.)
       ELSE
       ang1=-(q/2.-sqrt((q/2.)**2+(p/3.)**3))**(1./3.)
       ENDIF
       IF((-q/2.-sqrt((q/2.)**2+(p/3.)**3).GE.0.))THEN
       ang2=(-q/2.-sqrt((q/2.)**2+(p/3.)**3))**(1./3.)
       ELSE
       ang2=-(q/2.+sqrt((q/2.)**2+(p/3.)**3))**(1./3.)
       ENDIF
       ANG=ANG1+ANG2
       return
       end
*--------------------------------------------------------------------------
*****subprogram * kaon production from pi+B collisions *******************
      real function PNLKA(srt)
      SAVE   
* units: fm**2
***********************************C
      ala=1.116
      aka=0.498
      ana=0.939
      t1=ala+aka      
      if(srt.le.t1) THEN
      Pnlka=0
      Else
      IF(SRT.LT.1.7)sbbk=(0.9/0.091)*(SRT-T1)
      IF(SRT.GE.1.7)sbbk=0.09/(SRT-1.6)
      Pnlka=0.25*sbbk
* give the cross section in units of fm**2
       pnlka=pnlka/10.
      endif     
      return
      end
*-------------------------------------------------------------------------
*****subprogram * kaon production from pi+B collisions *******************
      real function PNSKA(srt)
      SAVE   
***********************************
       if(srt.gt.3.0)then
       pnska=0
       return
       endif
      ala=1.116
      aka=0.498
      ana=0.939
      asa=1.197
      t1=asa+aka      
      if(srt.le.t1) THEN
      Pnska=0
       return
      Endif
      IF(SRT.LT.1.9)SBB1=(0.7/0.218)*(SRT-T1)
      IF(SRT.GE.1.9)SBB1=0.14/(SRT-1.7)
      sbb2=0.
       if(srt.gT.1.682)sbb2=0.5*(1.-0.75*(srt-1.682))
       pnska=0.25*(sbb1+sbb2)
* give the cross section in fm**2
       pnska=pnska/10.
      return
      end

********************************
*
*       Kaon momentum distribution in baryon-baryon-->N lamda K process
*
*       NOTE: dsima/dp is prototional to (1-p/p_max)(p/p_max)^2
*              we use rejection method to generate kaon momentum
*
*       Variables: Fkaon = F(p)/F_max
*                 srt   = cms energy of the colliding pair, 
*                          used to calculate the P_max
*       Date: Feb. 8, 1994
*
*       Reference: C. M. Ko et al.  
******************************** 
       Real function fkaon(p,pmax)
      SAVE   
       fmax=0.148
       if(pmax.eq.0.)pmax=0.000001
       fkaon=(1.-p/pmax)*(p/pmax)**2
       if(fkaon.gt.fmax)fkaon=fmax
       fkaon=fkaon/fmax
       return
       end

*************************
* cross section for N*(1535) production in ND OR NN* collisions
* VARIABLES:
* LB1,LB2 ARE THE LABLES OF THE TWO COLLIDING PARTICLES
* SRT IS THE CMS ENERGY
* X1535 IS THE N*(1535) PRODUCTION CROSS SECTION
* NOTE THAT THE N*(1535) PRODUCTION CROSS SECTION IS 2 TIMES THE ETA 
* PRODUCTION CROSS SECTION
* DATE: MAY 18, 1994
* ***********************
       Subroutine M1535(LB1,LB2,SRT,X1535)
      SAVE   
       S0=2.424
       x1535=0.
       IF(SRT.LE.S0)RETURN
       SIGMA=2.*0.102*(SRT-S0)/(0.058+(SRT-S0)**2)
* I N*(1535) PRODUCTION IN NUCLEON-DELTA COLLISIONS
*(1) nD(++)->pN*(+)(1535), pD(-)->nN*(0)(1535),pD(+)-->N*(+)p
cbz11/25/98
c       IF((LB1*LB2.EQ.18).OR.(LB1*LB2.EQ.6).
c     1  or.(lb1*lb2).eq.8)then
       IF((LB1*LB2.EQ.18.AND.(LB1.EQ.2.OR.LB2.EQ.2)).OR.
     &     (LB1*LB2.EQ.6.AND.(LB1.EQ.1.OR.LB2.EQ.1)).or.
     &     (lb1*lb2.eq.8.AND.(LB1.EQ.1.OR.LB2.EQ.1)))then
cbz11/25/98end
       X1535=SIGMA
       return
       ENDIF
*(2) pD(0)->pN*(0)(1535),pD(0)->nN*(+)(1535)
       IF(LB1*LB2.EQ.7)THEN
       X1535=3.*SIGMA
       RETURN
       ENDIF 
* II N*(1535) PRODUCTION IN N*(1440)+NUCLEON REACTIONS
*(3) N*(+)(1440)p->N*(0+)(1535)p, N*(0)(1440)n->N*(0)(1535)
cbz11/25/98
c       IF((LB1*LB2.EQ.11).OR.(LB1*LB2.EQ.20))THEN
       IF((LB1*LB2.EQ.11).OR.
     &     (LB1*LB2.EQ.20.AND.(LB1.EQ.2.OR.LB2.EQ.2)))THEN
cbz11/25/98end
       X1535=SIGMA
       RETURN
       ENDIF
*(4) N*(0)(1440)p->N*(0+) or N*(+)(1440)n->N*(0+)(1535)
cbz11/25/98
c       IF((LB1*LB2.EQ.10).OR.(LB1*LB2.EQ.22))X1535=3.*SIGMA
       IF((LB1*LB2.EQ.10.AND.(LB1.EQ.1.OR.LB2.EQ.1)).OR.
     &     (LB1*LB2.EQ.22.AND.(LB1.EQ.2.OR.LB2.EQ.2)))
     &     X1535=3.*SIGMA
cbz11/25/98end
       RETURN
       END
*************************
* cross section for N*(1535) production in NN collisions
* VARIABLES:
* LB1,LB2 ARE THE LABLES OF THE TWO COLLIDING PARTICLES
* SRT IS THE CMS ENERGY
* X1535 IS THE N*(1535) PRODUCTION CROSS SECTION
* NOTE THAT THE N*(1535) PRODUCTION CROSS SECTION IS 2 TIMES THE ETA 
* PRODUCTION CROSS SECTION
* DATE: MAY 18, 1994
* ***********************
       Subroutine N1535(LB1,LB2,SRT,X1535)
      SAVE   
       S0=2.424
       x1535=0.
       IF(SRT.LE.S0)RETURN
       SIGMA=2.*0.102*(SRT-S0)/(0.058+(SRT-S0)**2)
* I N*(1535) PRODUCTION IN NUCLEON-NUCLEON COLLISIONS
*(1) pp->pN*(+)(1535), nn->nN*(0)(1535)
cbdbg11/25/98
c       IF((LB1*LB2.EQ.1).OR.(LB1*LB2.EQ.4))then
       IF((LB1*LB2.EQ.1).OR.
     &     (LB1.EQ.2.AND.LB2.EQ.2))then
cbz11/25/98end
       X1535=SIGMA
       return
       endif
*(2) pn->pN*(0)(1535),pn->nN*(+)(1535)
       IF(LB1*LB2.EQ.2)then
       X1535=3.*SIGMA
       return
       endif 
* III N*(1535) PRODUCTION IN DELTA+DELTA REACTIONS
* (5) D(++)+D(0), D(+)+D(+),D(+)+D(-),D(0)+D(0)
cbz11/25/98
c       IF((LB1*LB2.EQ.63).OR.(LB1*LB2.EQ.64).OR.(LB1*LB2.EQ.48).
c     1  OR.(LB1*LB2.EQ.49))then
       IF((LB1*LB2.EQ.63.AND.(LB1.EQ.7.OR.LB2.EQ.7)).OR.
     &     (LB1*LB2.EQ.64.AND.(LB1.EQ.8.OR.LB2.EQ.8)).OR.
     &     (LB1*LB2.EQ.48.AND.(LB1.EQ.6.OR.LB2.EQ.6)).OR.
     &     (LB1*LB2.EQ.49.AND.(LB1.EQ.7.OR.LB2.EQ.7)))then
cbz11/25/98end
       X1535=SIGMA
       return
       endif
* (6) D(++)+D(-),D(+)+D(0)
cbz11/25/98
c       IF((LB1*LB2.EQ.54).OR.(LB1*LB2.EQ.56))then
       IF((LB1*LB2.EQ.54.AND.(LB1.EQ.6.OR.LB2.EQ.6)).OR.
     &     (LB1*LB2.EQ.56.AND.(LB1.EQ.7.OR.LB2.EQ.7)))then
cbz11/25/98end
       X1535=3.*SIGMA
       return
       endif
* IV N*(1535) PRODUCTION IN N*(1440)+N*(1440) REACTIONS
cbz11/25/98
c       IF((LB1*LB2.EQ.100).OR.(LB1*LB2.EQ.11*11))X1535=SIGMA
       IF((LB1.EQ.10.AND.LB2.EQ.10).OR.
     &     (LB1.EQ.11.AND.LB2.EQ.11))X1535=SIGMA
c       IF(LB1*LB2.EQ.110)X1535=3.*SIGMA
       IF(LB1*LB2.EQ.110.AND.(LB1.EQ.10.OR.LB2.EQ.10))X1535=3.*SIGMA
cbdbg11/25/98end
       RETURN
       END
************************************       
* FUNCTION WA1(DMASS) GIVES THE A1 DECAY WIDTH

        subroutine WIDA1(DMASS,rhomp,wa1,iseed)
      SAVE   
c
        PIMASS=0.137265
        coupa = 14.8
c
       RHOMAX = DMASS-PIMASS-0.02
       IF(RHOMAX.LE.0)then
         rhomp=0.
c   !! no decay
         wa1=-10.
        endif
        icount = 0
711       rhomp=RHOMAS(RHOMAX,ISEED)
      icount=icount+1
      if(dmass.le.(pimass+rhomp)) then
       if(icount.le.100) then
        goto 711
       else
         rhomp=0.
c   !! no decay
         wa1=-10.
        return
       endif
      endif
      qqp2=(dmass**2-(rhomp+pimass)**2)*(dmass**2-(rhomp-pimass)**2)
      qqp=sqrt(qqp2)/(2.0*dmass)
      epi=sqrt(pimass**2+qqp**2)
      erho=sqrt(rhomp**2+qqp**2)
      epirho=2.0*(epi*erho+qqp**2)**2+rhomp**2*epi**2
      wa1=coupa**2*qqp*epirho/(24.0*3.1416*dmass**2)
       return
       end
************************************       
* FUNCTION W1535(DMASS) GIVES THE N*(1535) DECAY WIDTH 
c     FOR A GIVEN N*(1535) MASS
* HERE THE FORMULA GIVEN BY KITAZOE IS USED
        REAL FUNCTION W1535(DMASS)
      SAVE   
        AVMASS=0.938868
        PIMASS=0.137265
           AUX = 0.25*(DMASS**2-AVMASS**2-PIMASS**2)**2
     &           -(AVMASS*PIMASS)**2
            IF (AUX .GT. 0.) THEN
              QAVAIL = SQRT(AUX / DMASS**2)
            ELSE
              QAVAIL = 1.E-06
            END IF
            W1535 = 0.15* QAVAIL/0.467
c       W1535=0.15
        RETURN
        END
************************************       
* FUNCTION W1440(DMASS) GIVES THE N*(1440) DECAY WIDTH 
c     FOR A GIVEN N*(1535) MASS
* HERE THE FORMULA GIVEN BY KITAZOE IS USED
        REAL FUNCTION W1440(DMASS)
      SAVE   
        AVMASS=0.938868
        PIMASS=0.137265
           AUX = 0.25*(DMASS**2-AVMASS**2-PIMASS**2)**2
     &           -(AVMASS*PIMASS)**2
            IF (AUX .GT. 0.) THEN
              QAVAIL = SQRT(AUX)/DMASS
            ELSE
              QAVAIL = 1.E-06
            END IF
c              w1440=0.2 
           W1440 = 0.2* (QAVAIL/0.397)**3
        RETURN
        END
****************
* PURPOSE : CALCULATE THE PION(ETA)+NUCLEON CROSS SECTION 
*           ACCORDING TO THE BREIT-WIGNER FORMULA, 
*           NOTE THAT N*(1535) IS S_11
* VARIABLE : LA = 1 FOR PI+N
*            LA = 0 FOR ETA+N
* DATE    : MAY 16, 1994
****************
        REAL FUNCTION XN1535(I1,I2,LA)
        PARAMETER (MAXSTR=150001,MAXR=1,
     1  AMN=0.939457,AMP=0.93828,ETAM=0.5475,
     2  AP1=0.13496,AP2=0.13957,AM0=1.232,PI=3.1415926)
clin-9/2012: improve precision for argument in sqrt():
        double precision e10,e20,scheck,p1,p2,p3
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      SAVE   
        AVMASS=0.5*(AMN+AMP)
        AVPI=(2.*AP2+AP1)/3.
* 1. DETERMINE THE MOMENTUM COMPONENT OF N*(1535) IN THE LAB. FRAME
clin-9/2012: improve precision for argument in sqrt():
c        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
c        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
        E10=dSQRT(dble(E(I1))**2+dble(P(1,I1))**2
     1     +dble(P(2,I1))**2+dble(P(3,I1))**2)
        E20=dSQRT(dble(E(I2))**2+dble(P(1,I2))**2
     1       +dble(P(2,I2))**2+dble(P(3,I2))**2)
c        P1=P(1,I1)+P(1,I2)
c        P2=P(2,I1)+P(2,I2)
c        P3=P(3,I1)+P(3,I2)
        p1=dble(P(1,I1))+dble(P(1,I2))
        p2=dble(P(2,I1))+dble(P(2,I2))
        p3=dble(P(3,I1))+dble(P(3,I2))

* 2. DETERMINE THE MASS OF DELTA BY USING OF THE REACTION KINEMATICS

clin-9/2012: check argument in sqrt():
        scheck=(E10+E20)**2-p1**2-p2**2-p3**2
        if(scheck.lt.0) then
           write(99,*) 'scheck21: ', scheck
           scheck=0.d0
        endif
        DM=SQRT(sngl(scheck))
c        DM=SQRT((E10+E20)**2-P1**2-P2**2-P3**2)

        IF(DM.LE.1.1) THEN
        XN1535=1.E-06
        RETURN
        ENDIF
* 3. DETERMINE THE PION(ETA)+NUCLEON->N*(1535) CROSS SECTION ACCORDING TO THE
*    BREIT-WIGNER FORMULA IN UNIT OF FM**2
        GAM=W1535(DM)
       GAM0=0.15
        F1=0.25*GAM0**2/(0.25*GAM**2+(DM-1.535)**2)
        IF(LA.EQ.1)THEN
       XMAX=11.3
        ELSE
       XMAX=74.
        ENDIF
        XN1535=F1*XMAX/10.
        RETURN
        END
***************************8
*FUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
*KITAZOE'S FORMULA
        REAL FUNCTION FDELTA(DMASS)
      SAVE   
        AMN=0.938869
        AVPI=0.13803333
        AM0=1.232
        FD=0.25*WIDTH(DMASS)**2/((DMASS-1.232)**2
     1  +0.25*WIDTH(DMASS)**2)
        FDELTA=FD
        RETURN
        END
* FUNCTION WIDTH(DMASS) GIVES THE DELTA DECAY WIDTH FOR A GIVEN DELTA MASS
* HERE THE FORMULA GIVEN BY KITAZOE IS USED
        REAL FUNCTION WIDTH(DMASS)
      SAVE   
        AVMASS=0.938868
        PIMASS=0.137265
           AUX = 0.25*(DMASS**2-AVMASS**2-PIMASS**2)**2
     &           -(AVMASS*PIMASS)**2
            IF (AUX .GT. 0.) THEN
              QAVAIL = SQRT(AUX / DMASS**2)
            ELSE
              QAVAIL = 1.E-06
            END IF
            WIDTH = 0.47 * QAVAIL**3 /
     &              (PIMASS**2 * (1.+0.6*(QAVAIL/PIMASS)**2))
c       width=0.115
        RETURN
        END
************************************       
        SUBROUTINE ddp2(SRT,ISEED,PX,PY,PZ,DM1,PNX,
     &  PNY,PNZ,DM2,PPX,PPY,PPZ,icou1)
* PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
* THE PROCESS N+N--->D1+D2+PION
*       DATE : July 25, 1994
* Generate the masses and momentum for particles in the NN-->DDpi process
* for a given center of mass energy srt, the momenta are given in the center
* of mass of the NN
*****************************************
        COMMON/TABLE/ xarray(0:1000),earray(0:1000)
cc      SAVE /TABLE/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
       icou1=0
       pi=3.1415926
        AMN=938.925/1000.
        AMP=137.265/1000.
* (1) GENGRATE THE MASS OF DELTA1 AND DELTA2 USING
       srt1=srt-amp-0.02
       ntrym=0
8       call Rmasdd(srt1,1.232,1.232,1.08,
     &  1.08,ISEED,1,dm1,dm2)
       ntrym=ntrym+1
* CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM 
* FOR ONE OF THE RESONANCES
       V=0.43
       W=-0.84
* (2) Generate the transverse momentum
*     OF DELTA1
* (2.1) estimate the maximum transverse momentum
       PTMAX2=(SRT**2-(DM1+DM2+AMP)**2)*
     1  (SRT**2-(DM1-AMP-DM2)**2)/4./SRT**2
       if(ptmax2.le.0)go to 8
       PTMAX=SQRT(PTMAX2)*1./3.
7       PT=PTR(PTMAX,ISEED)       
* (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
       PZMAX2=(SRT**2-(DM1+DM2+AMP)**2)*
     1  (SRT**2-(DM1-AMP-DM2)**2)/4./SRT**2-PT**2
       IF((PZMAX2.LT.0.).and.ntrym.le.100)then 
       go to 7
       else
       pzmax2=1.E-09
       endif
       PZMAX=SQRT(PZMAX2)
       XMAX=2.*PZMAX/SRT
* (3.2) THE GENERATED X IS
* THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
       ntryx=0
       fmax00=1.056
       x00=0.26
       if(abs(xmax).gt.0.26)then
       f00=fmax00
       else
       f00=1.+v*abs(xmax)+w*xmax**2
       endif
9       X=XMAX*(1.-2.*RANART(NSEED))
       ntryx=ntryx+1
       xratio=(1.+V*ABS(X)+W*X**2)/f00       
clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9       
       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9       
* (3.5) THE PZ IS
       PZ=0.5*SRT*X
* The x and y components of the deltA1
       fai=2.*pi*RANART(NSEED)
       Px=pt*cos(fai)
       Py=pt*sin(fai)
* find the momentum of delta2 and pion
* the energy of the delta1
       ek=sqrt(dm1**2+PT**2+Pz**2)
* (1) Generate the momentum of the delta2 in the cms of delta2 and pion
*     the energy of the cms of DP
        eln=srt-ek
       IF(ELN.lE.0)then
       icou1=-1
       return
       endif
* beta and gamma of the cms of delta2+pion
       bx=-Px/eln
       by=-Py/eln
       bz=-Pz/eln

clin-9/2012: check argument in sqrt():
       scheck=1.-bx**2-by**2-bz**2
       if(scheck.le.0) then
          write(99,*) 'scheck22: ', scheck
          stop
       endif
       ga=1./sqrt(scheck)
c       ga=1./sqrt(1.-bx**2-by**2-bz**2)

* the momentum of delta2 and pion in their cms frame
       elnc=eln/ga 
       pn2=((elnc**2+dm2**2-amp**2)/(2.*elnc))**2-dm2**2
       if(pn2.le.0)then
       icou1=-1
       return
       endif
       pn=sqrt(pn2)

clin-10/25/02 get rid of argument usage mismatch in PTR():
        xptr=0.33*PN
c       PNT=PTR(0.33*PN,ISEED)
       PNT=PTR(xptr,ISEED)
clin-10/25/02-end

       fain=2.*pi*RANART(NSEED)
       pnx=pnT*cos(fain)
       pny=pnT*sin(fain)
       SIG=1
       IF(X.GT.0)SIG=-1

clin-9/2012: check argument in sqrt():
       scheck=pn**2-PNT**2
       if(scheck.lt.0) then
          write(99,*) 'scheck23: ', scheck
          scheck=0.
       endif
       pnz=SIG*SQRT(scheck)
c       pnz=SIG*SQRT(pn**2-PNT**2)

       en=sqrt(dm2**2+pnx**2+pny**2+pnz**2)
* (2) the momentum for the pion
       ppx=-pnx
       ppy=-pny
       ppz=-pnz
       ep=sqrt(amp**2+ppx**2+ppy**2+ppz**2)
* (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
        PBETA  = PnX*BX + PnY*By+ PnZ*Bz
              TRANS0  = GA * ( GA * PBETA / (GA + 1.) + En )
              Pnx = BX * TRANS0 + PnX
              Pny = BY * TRANS0 + PnY
              Pnz = BZ * TRANS0 + PnZ
* (4) for the pion, LORENTZ-TRANSFORMATION INTO nn cms FRAME
             if(ep.eq.0.)ep=1.E-09
              PBETA  = PPX*BX + PPY*By+ PPZ*Bz
              TRANS0  = GA * ( GA * PBETA / (GA + 1.) + EP )
              PPx = BX * TRANS0 + PPX
              PPy = BY * TRANS0 + PPY
              PPz = BZ * TRANS0 + PPZ
       return
       end
****************************************
        SUBROUTINE ddrho(SRT,ISEED,PX,PY,PZ,DM1,PNX,
     &  PNY,PNZ,DM2,PPX,PPY,PPZ,amp,icou1)
* PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
* THE PROCESS N+N--->D1+D2+rho
*       DATE : Nov.5, 1994
* Generate the masses and momentum for particles in the NN-->DDrho process
* for a given center of mass energy srt, the momenta are given in the center
* of mass of the NN
*****************************************
        COMMON/TABLE/ xarray(0:1000),earray(0:1000)
cc      SAVE /TABLE/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
       icou1=0
       pi=3.1415926
        AMN=938.925/1000.
        AMP=770./1000.
* (1) GENGRATE THE MASS OF DELTA1 AND DELTA2 USING
       srt1=srt-amp-0.02
       ntrym=0
8       call Rmasdd(srt1,1.232,1.232,1.08,
     &  1.08,ISEED,1,dm1,dm2)
       ntrym=ntrym+1
* GENERATE THE MASS FOR THE RHO
       RHOMAX = SRT-DM1-DM2-0.02
       IF(RHOMAX.LE.0.and.ntrym.le.20)go to 8
       AMP=RHOMAS(RHOMAX,ISEED)
* CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM 
* FOR ONE OF THE RESONANCES
       V=0.43
       W=-0.84
* (2) Generate the transverse momentum
*     OF DELTA1
* (2.1) estimate the maximum transverse momentum
       PTMAX2=(SRT**2-(DM1+DM2+AMP)**2)*
     1  (SRT**2-(DM1-AMP-DM2)**2)/4./SRT**2

clin-9/2012: check argument in sqrt():
       scheck=PTMAX2
       if(scheck.lt.0) then
          write(99,*) 'scheck24: ', scheck
          scheck=0.
       endif
       PTMAX=SQRT(scheck)*1./3.
c       PTMAX=SQRT(PTMAX2)*1./3.

7       PT=PTR(PTMAX,ISEED)
* (3) GENGRATE THE LONGITUDINAL MOMENTUM FOR DM1
*     USING THE GIVEN DISTRIBUTION
* (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
       PZMAX2=(SRT**2-(DM1+DM2+AMP)**2)*
     1  (SRT**2-(DM1-AMP-DM2)**2)/4./SRT**2-PT**2
       IF((PZMAX2.LT.0.).and.ntrym.le.100)then 
       go to 7
       else
       pzmax2=1.E-06
       endif
       PZMAX=SQRT(PZMAX2)
       XMAX=2.*PZMAX/SRT
* (3.2) THE GENERATED X IS
* THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
       ntryx=0
       fmax00=1.056
       x00=0.26
       if(abs(xmax).gt.0.26)then
       f00=fmax00
       else
       f00=1.+v*abs(xmax)+w*xmax**2
       endif
9       X=XMAX*(1.-2.*RANART(NSEED))
       ntryx=ntryx+1
       xratio=(1.+V*ABS(X)+W*X**2)/f00       
clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9       
       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9       
* (3.5) THE PZ IS
       PZ=0.5*SRT*X
* The x and y components of the delta1
       fai=2.*pi*RANART(NSEED)
       Px=pt*cos(fai)
       Py=pt*sin(fai)
* find the momentum of delta2 and rho
* the energy of the delta1
       ek=sqrt(dm1**2+PT**2+Pz**2)
* (1) Generate the momentum of the delta2 in the cms of delta2 and rho
*     the energy of the cms of Drho
        eln=srt-ek
       IF(ELN.lE.0)then
       icou1=-1
       return
       endif
* beta and gamma of the cms of delta2 and rho
       bx=-Px/eln
       by=-Py/eln
       bz=-Pz/eln

clin-9/2012: check argument in sqrt():
       scheck=1.-bx**2-by**2-bz**2
       if(scheck.le.0) then
          write(99,*) 'scheck25: ', scheck
          stop
       endif
       ga=1./sqrt(scheck)
c       ga=1./sqrt(1.-bx**2-by**2-bz**2)

       elnc=eln/ga
       pn2=((elnc**2+dm2**2-amp**2)/(2.*elnc))**2-dm2**2
       if(pn2.le.0)then
       icou1=-1
       return
       endif
       pn=sqrt(pn2)

clin-10/25/02 get rid of argument usage mismatch in PTR():
        xptr=0.33*PN
c       PNT=PTR(0.33*PN,ISEED)
       PNT=PTR(xptr,ISEED)
clin-10/25/02-end

       fain=2.*pi*RANART(NSEED)
       pnx=pnT*cos(fain)
       pny=pnT*sin(fain)
       SIG=1
       IF(X.GT.0)SIG=-1

clin-9/2012: check argument in sqrt():
       scheck=pn**2-PNT**2
       if(scheck.lt.0) then
          write(99,*) 'scheck26: ', scheck
          scheck=0.
       endif
       pnz=SIG*SQRT(scheck)
c       pnz=SIG*SQRT(pn**2-PNT**2)

       en=sqrt(dm2**2+pnx**2+pny**2+pnz**2)
* (2) the momentum for the rho
       ppx=-pnx
       ppy=-pny
       ppz=-pnz
       ep=sqrt(amp**2+ppx**2+ppy**2+ppz**2)
* (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
        PBETA  = PnX*BX + PnY*By+ PnZ*Bz
              TRANS0  = GA * ( GA * PBETA / (GA + 1.) + En )
              Pnx = BX * TRANS0 + PnX
              Pny = BY * TRANS0 + PnY
              Pnz = BZ * TRANS0 + PnZ
* (4) for the rho, LORENTZ-TRANSFORMATION INTO nn cms FRAME
             if(ep.eq.0.)ep=1.e-09
              PBETA  = PPX*BX + PPY*By+ PPZ*Bz
              TRANS0  = GA * ( GA * PBETA / (GA + 1.) + EP )
              PPx = BX * TRANS0 + PPX
              PPy = BY * TRANS0 + PPY
              PPz = BZ * TRANS0 + PPZ
       return
       end
****************************************
        SUBROUTINE pprho(SRT,ISEED,PX,PY,PZ,DM1,PNX,
     &  PNY,PNZ,DM2,PPX,PPY,PPZ,amp,icou1)
* PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
* THE PROCESS N+N--->N1+N2+rho
*       DATE : Nov.5, 1994
* Generate the masses and momentum for particles in the NN--> process
* for a given center of mass energy srt, the momenta are given in the center
* of mass of the NN
*****************************************
        COMMON/TABLE/ xarray(0:1000),earray(0:1000)
cc      SAVE /TABLE/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
        ntrym=0
       icou1=0
       pi=3.1415926
        AMN=938.925/1000.
*        AMP=770./1000.
       DM1=amn
       DM2=amn
* GENERATE THE MASS FOR THE RHO
       RHOMAX=SRT-DM1-DM2-0.02
       IF(RHOMAX.LE.0)THEN
       ICOU=-1
       RETURN
       ENDIF
       AMP=RHOMAS(RHOMAX,ISEED)
* CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM 
* FOR ONE OF THE nucleons
       V=0.43
       W=-0.84
* (2) Generate the transverse momentum
*     OF p1
* (2.1) estimate the maximum transverse momentum
       PTMAX2=(SRT**2-(DM1+DM2+AMP)**2)*
     1  (SRT**2-(DM1-AMP-DM2)**2)/4./SRT**2

clin-9/2012: check argument in sqrt():
       scheck=PTMAX2
       if(scheck.lt.0) then
          write(99,*) 'scheck27: ', scheck
          scheck=0.
       endif
       PTMAX=SQRT(scheck)*1./3.
c       PTMAX=SQRT(PTMAX2)*1./3.

7       PT=PTR(PTMAX,ISEED)
* (3) GENGRATE THE LONGITUDINAL MOMENTUM FOR DM1
*     USING THE GIVEN DISTRIBUTION
* (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
       PZMAX2=(SRT**2-(DM1+DM2+AMP)**2)*
     1  (SRT**2-(DM1-AMP-DM2)**2)/4./SRT**2-PT**2
       NTRYM=NTRYM+1
       IF((PZMAX2.LT.0.).and.ntrym.le.100)then 
       go to 7
       else
       pzmax2=1.E-06
       endif
       PZMAX=SQRT(PZMAX2)
       XMAX=2.*PZMAX/SRT
* (3.2) THE GENERATED X IS
* THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
       ntryx=0
       fmax00=1.056
       x00=0.26
       if(abs(xmax).gt.0.26)then
       f00=fmax00
       else
       f00=1.+v*abs(xmax)+w*xmax**2
       endif
9       X=XMAX*(1.-2.*RANART(NSEED))
       ntryx=ntryx+1
       xratio=(1.+V*ABS(X)+W*X**2)/f00       
clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9       
       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9       
* (3.5) THE PZ IS
       PZ=0.5*SRT*X
* The x and y components of the delta1
       fai=2.*pi*RANART(NSEED)
       Px=pt*cos(fai)
       Py=pt*sin(fai)
* find the momentum of delta2 and rho
* the energy of the delta1
       ek=sqrt(dm1**2+PT**2+Pz**2)
* (1) Generate the momentum of the delta2 in the cms of delta2 and rho
*     the energy of the cms of Drho
        eln=srt-ek
       IF(ELN.lE.0)then
       icou1=-1
       return
       endif
* beta and gamma of the cms of the two partciles
       bx=-Px/eln
       by=-Py/eln
       bz=-Pz/eln

clin-9/2012: check argument in sqrt():
       scheck=1.-bx**2-by**2-bz**2
       if(scheck.le.0) then
          write(99,*) 'scheck28: ', scheck
          stop
       endif
       ga=1./sqrt(scheck)
c       ga=1./sqrt(1.-bx**2-by**2-bz**2)

        elnc=eln/ga
       pn2=((elnc**2+dm2**2-amp**2)/(2.*elnc))**2-dm2**2
       if(pn2.le.0)then
       icou1=-1
       return
       endif
       pn=sqrt(pn2)

clin-10/25/02 get rid of argument usage mismatch in PTR():
        xptr=0.33*PN
c       PNT=PTR(0.33*PN,ISEED)
       PNT=PTR(xptr,ISEED)
clin-10/25/02-end

       fain=2.*pi*RANART(NSEED)
       pnx=pnT*cos(fain)
       pny=pnT*sin(fain)
       SIG=1
       IF(X.GT.0)SIG=-1

clin-9/2012: check argument in sqrt():
       scheck=pn**2-PNT**2
       if(scheck.lt.0) then
          write(99,*) 'scheck29: ', scheck
          scheck=0.
       endif
       pnz=SIG*SQRT(scheck)
c       pnz=SIG*SQRT(pn**2-PNT**2)

       en=sqrt(dm2**2+pnx**2+pny**2+pnz**2)
* (2) the momentum for the rho
       ppx=-pnx
       ppy=-pny
       ppz=-pnz
       ep=sqrt(amp**2+ppx**2+ppy**2+ppz**2)
* (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
        PBETA  = PnX*BX + PnY*By+ PnZ*Bz
              TRANS0  = GA * ( GA * PBETA / (GA + 1.) + En )
              Pnx = BX * TRANS0 + PnX
              Pny = BY * TRANS0 + PnY
              Pnz = BZ * TRANS0 + PnZ
* (4) for the rho, LORENTZ-TRANSFORMATION INTO nn cms FRAME
             if(ep.eq.0.)ep=1.e-09
              PBETA  = PPX*BX + PPY*By+ PPZ*Bz
              TRANS0  = GA * ( GA * PBETA / (GA + 1.) + EP )
              PPx = BX * TRANS0 + PPX
              PPy = BY * TRANS0 + PPY
              PPz = BZ * TRANS0 + PPZ
       return
       end
***************************8
****************************************
        SUBROUTINE ppomga(SRT,ISEED,PX,PY,PZ,DM1,PNX,
     &  PNY,PNZ,DM2,PPX,PPY,PPZ,icou1)
* PURPOSE : CALCULATE MOMENTUM OF PARTICLES IN THE FINAL SATAT FROM
* THE PROCESS N+N--->N1+N2+OMEGA
*       DATE : Nov.5, 1994
* Generate the masses and momentum for particles in the NN--> process
* for a given center of mass energy srt, the momenta are given in the center
* of mass of the NN
*****************************************
        COMMON/TABLE/ xarray(0:1000),earray(0:1000)
cc      SAVE /TABLE/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
        ntrym=0
       icou1=0
       pi=3.1415926
        AMN=938.925/1000.
        AMP=782./1000.
       DM1=amn
       DM2=amn
* CONSTANTS FOR GENERATING THE LONGITUDINAL MOMENTUM 
* FOR ONE OF THE nucleons
       V=0.43
       W=-0.84
* (2) Generate the transverse momentum
*     OF p1
* (2.1) estimate the maximum transverse momentum
       PTMAX2=(SRT**2-(DM1+DM2+AMP)**2)*
     1  (SRT**2-(DM1-AMP-DM2)**2)/4./SRT**2

clin-9/2012: check argument in sqrt():
       scheck=PTMAX2
       if(scheck.lt.0) then
          write(99,*) 'scheck30: ', scheck
          scheck=0.
       endif
       PTMAX=SQRT(scheck)*1./3.
c       PTMAX=SQRT(PTMAX2)*1./3.

7       PT=PTR(PTMAX,ISEED)
* (3) GENGRATE THE LONGITUDINAL MOMENTUM FOR DM1
*     USING THE GIVEN DISTRIBUTION
* (3.1) THE MAXIMUM LONGITUDINAL MOMENTUM IS
       PZMAX2=(SRT**2-(DM1+DM2+AMP)**2)*
     1  (SRT**2-(DM1-AMP-DM2)**2)/4./SRT**2-PT**2
       NTRYM=NTRYM+1
       IF((PZMAX2.LT.0.).and.ntrym.le.100)then 
       go to 7
       else
       pzmax2=1.E-09
       endif
       PZMAX=SQRT(PZMAX2)
       XMAX=2.*PZMAX/SRT
* (3.2) THE GENERATED X IS
* THE DSTRIBUTION HAS A MAXIMUM AT X0=-V/(2*w), f(X0)=1.056
       ntryx=0
       fmax00=1.056
       x00=0.26
       if(abs(xmax).gt.0.26)then
       f00=fmax00
       else
       f00=1.+v*abs(xmax)+w*xmax**2
       endif
9       X=XMAX*(1.-2.*RANART(NSEED))
       ntryx=ntryx+1
       xratio=(1.+V*ABS(X)+W*X**2)/f00       
clin-8/17/00       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9       
       IF(xratio.LT.RANART(NSEED).and.ntryx.le.50)GO TO 9       
* (3.5) THE PZ IS
       PZ=0.5*SRT*X
* The x and y components of the delta1
       fai=2.*pi*RANART(NSEED)
       Px=pt*cos(fai)
       Py=pt*sin(fai)
* find the momentum of delta2 and rho
* the energy of the delta1
       ek=sqrt(dm1**2+PT**2+Pz**2)
* (1) Generate the momentum of the delta2 in the cms of delta2 and rho
*     the energy of the cms of Drho
        eln=srt-ek
       IF(ELN.lE.0)then
       icou1=-1
       return
       endif
       bx=-Px/eln
       by=-Py/eln
       bz=-Pz/eln

clin-9/2012: check argument in sqrt():
       scheck=1.-bx**2-by**2-bz**2
       if(scheck.le.0) then
          write(99,*) 'scheck31: ', scheck
          stop
       endif
       ga=1./sqrt(scheck)
c       ga=1./sqrt(1.-bx**2-by**2-bz**2)

       elnc=eln/ga
       pn2=((elnc**2+dm2**2-amp**2)/(2.*elnc))**2-dm2**2
       if(pn2.le.0)then
       icou1=-1
       return
       endif
       pn=sqrt(pn2)

clin-10/25/02 get rid of argument usage mismatch in PTR():
        xptr=0.33*PN
c       PNT=PTR(0.33*PN,ISEED)
       PNT=PTR(xptr,ISEED)
clin-10/25/02-end

       fain=2.*pi*RANART(NSEED)
       pnx=pnT*cos(fain)
       pny=pnT*sin(fain)
       SIG=1
       IF(X.GT.0)SIG=-1

clin-9/2012: check argument in sqrt():
       scheck=pn**2-PNT**2
       if(scheck.lt.0) then
          write(99,*) 'scheck32: ', scheck
          scheck=0.
       endif
       pnz=SIG*SQRT(scheck)
c       pnz=SIG*SQRT(pn**2-PNT**2)

       en=sqrt(dm2**2+pnx**2+pny**2+pnz**2)
* (2) the momentum for the rho
       ppx=-pnx
       ppy=-pny
       ppz=-pnz
       ep=sqrt(amp**2+ppx**2+ppy**2+ppz**2)
* (3) for the delta2, LORENTZ-TRANSFORMATION INTO nn cms FRAME
        PBETA  = PnX*BX + PnY*By+ PnZ*Bz
              TRANS0  = GA * ( GA * PBETA / (GA + 1.) + En )
              Pnx = BX * TRANS0 + PnX
              Pny = BY * TRANS0 + PnY
              Pnz = BZ * TRANS0 + PnZ
* (4) for the rho, LORENTZ-TRANSFORMATION INTO nn cms FRAME
             if(ep.eq.0.)ep=1.E-09
              PBETA  = PPX*BX + PPY*By+ PPZ*Bz
              TRANS0  = GA * ( GA * PBETA / (GA + 1.) + EP )
              PPx = BX * TRANS0 + PPX
              PPy = BY * TRANS0 + PPY
              PPz = BZ * TRANS0 + PPZ
       return
       end
***************************8
***************************8
*   DELTA MASS GENERATOR
       REAL FUNCTION RMASS(DMAX,ISEED)
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
* THE MINIMUM MASS FOR DELTA
          DMIN = 1.078
* Delta(1232) production
          IF(DMAX.LT.1.232) THEN
          FM=FDELTA(DMAX)
          ELSE
          FM=1.
          ENDIF
          IF(FM.EQ.0.)FM=1.E-06
          NTRY1=0
10        DM = RANART(NSEED) * (DMAX-DMIN) + DMIN
          NTRY1=NTRY1+1
          IF((RANART(NSEED) .GT. FDELTA(DM)/FM).AND.
     1    (NTRY1.LE.10)) GOTO 10
clin-2/26/03 sometimes Delta mass can reach very high values (e.g. 15.GeV),
c     thus violating the thresh of the collision which produces it 
c     and leads to large violation of energy conservation. 
c     To limit the above, limit the Delta mass below a certain value 
c     (here taken as its central value + 2* B-W fullwidth):
          if(dm.gt.1.47) goto 10

       RMASS=DM
       RETURN
       END

*------------------------------------------------------------------
* THE Breit Wigner FORMULA
        REAL FUNCTION FRHO(DMASS)
      SAVE   
        AM0=0.77
       WID=0.153
        FD=0.25*wid**2/((DMASS-AM0)**2+0.25*WID**2)
        FRHO=FD
        RETURN
        END
***************************8
*   RHO MASS GENERATOR
       REAL FUNCTION RHOMAS(DMAX,ISEED)
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
* THE MINIMUM MASS FOR DELTA
          DMIN = 0.28
* RHO(770) production
          IF(DMAX.LT.0.77) THEN
          FM=FRHO(DMAX)
          ELSE
          FM=1.
          ENDIF
          IF(FM.EQ.0.)FM=1.E-06
          NTRY1=0
10        DM = RANART(NSEED) * (DMAX-DMIN) + DMIN
          NTRY1=NTRY1+1
          IF((RANART(NSEED) .GT. FRHO(DM)/FM).AND.
     1    (NTRY1.LE.10)) GOTO 10
clin-2/26/03 limit the rho mass below a certain value
c     (here taken as its central value + 2* B-W fullwidth):
          if(dm.gt.1.07) goto 10

       RHOMAS=DM
       RETURN
       END
******************************************
* for pp-->pp+2pi
c      real*4 function X2pi(srt)
      real function X2pi(srt)
*  This function contains the experimental 
c     total pp-pp+pi(+)pi(-) Xsections    *
*  srt    = DSQRT(s) in GeV                                                  *
*  xsec   = production cross section in mb                                   *
*  earray = EXPerimental table with proton momentum in GeV/c                 *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye)*
*                                                                            *
******************************************
c      real*4   xarray(15), earray(15)
      real   xarray(15), earray(15)
      SAVE   
      data earray /2.23,2.81,3.67,4.0,4.95,5.52,5.97,6.04,
     &6.6,6.9,7.87,8.11,10.01,16.0,19./
      data xarray /1.22,2.51,2.67,2.95,2.96,2.84,2.8,3.2,
     &2.7,3.0,2.54,2.46,2.4,1.66,1.5/

           pmass=0.9383 
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
       x2pi=0.000001
       if(srt.le.2.2)return
      plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
      if (plab .lt. earray(1)) then
        x2pi = xarray(1)
        return
      end if
*
* 2.Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,15
        if (earray(ie) .eq. plab) then
          x2pi= xarray(ie)
          return
        else if (earray(ie) .gt. plab) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          X2pi = exp(ymin + (alog(plab)-xmin)*(ymax-ymin)
     &    /(xmax-xmin) )
          return
        end if
 1001 continue
      return
        END
******************************************
* for pp-->pn+pi(+)pi(+)pi(-)
c      real*4 function X3pi(srt)
      real function X3pi(srt)
*  This function contains the experimental pp->pp+3pi cross sections          *
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*                                                                             *
******************************************
c      real*4   xarray(12), earray(12)
      real   xarray(12), earray(12)
      SAVE   
      data xarray /0.02,0.4,1.15,1.60,2.19,2.85,2.30,
     &3.10,2.47,2.60,2.40,1.70/
      data earray /2.23,2.81,3.67,4.00,4.95,5.52,5.97,
     &6.04,6.60,6.90,10.01,19./

           pmass=0.9383 
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
       x3pi=1.E-06
       if(srt.le.2.3)return
      plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
      if (plab .lt. earray(1)) then
        x3pi = xarray(1)
        return
      end if
*
* 2.Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,12
        if (earray(ie) .eq. plab) then
          x3pi= xarray(ie)
          return
        else if (earray(ie) .gt. plab) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          X3pi= exp(ymin + (alog(plab)-xmin)*(ymax-ymin)
     &                                            /(xmax-xmin) )
          return
        end if
 1001 continue
      return
        END
******************************************
******************************************
* for pp-->pp+pi(+)pi(-)pi(0)
c      real*4 function X33pi(srt)
      real function X33pi(srt)
*  This function contains the experimental pp->pp+3pi cross sections          *
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*                                                                             *
******************************************
c      real*4   xarray(12), earray(12)
      real   xarray(12), earray(12)
      SAVE   
      data xarray /0.02,0.22,0.74,1.10,1.76,1.84,2.20,
     &2.40,2.15,2.60,2.30,1.70/
      data earray /2.23,2.81,3.67,4.00,4.95,5.52,5.97,
     &6.04,6.60,6.90,10.01,19./

           pmass=0.9383 
       x33pi=1.E-06
       if(srt.le.2.3)return
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
      plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
      if (plab .lt. earray(1)) then
        x33pi = xarray(1)
        return
      end if
*
* 2.Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,12
        if (earray(ie) .eq. plab) then
          x33pi= xarray(ie)
          return
        else if (earray(ie) .gt. plab) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          x33pi= exp(ymin + (alog(plab)-xmin)*(ymax-ymin)
     &    /(xmax-xmin))
          return
        end if
 1001   continue
        return
        END
******************************************
c       REAL*4 FUNCTION X4pi(SRT)
      REAL FUNCTION X4pi(SRT)
      SAVE   
*       CROSS SECTION FOR NN-->DD+rho PROCESS
* *****************************
       akp=0.498
       ak0=0.498
       ana=0.94
       ada=1.232
       al=1.1157
       as=1.1197
       pmass=0.9383
       ES=SRT
       IF(ES.LE.4)THEN
       X4pi=0.
       ELSE
* cross section for two resonance pp-->DD+DN*+N*N*
       xpp2pi=4.*x2pi(es)
* cross section for pp-->pp+spi
       xpp3pi=3.*(x3pi(es)+x33pi(es))
* cross section for pp-->pD+ and nD++
       pps1=sigma(es,1,1,0)+0.5*sigma(es,1,1,1)
       pps2=1.5*sigma(es,1,1,1)
       ppsngl=pps1+pps2+s1535(es)
* CROSS SECTION FOR KAON PRODUCTION from the four channels
* for NLK channel
       xk1=0
       xk2=0
       xk3=0
       xk4=0
       t1nlk=ana+al+akp
       t2nlk=ana+al-akp
       if(es.le.t1nlk)go to 333
       pmnlk2=(es**2-t1nlk**2)*(es**2-t2nlk**2)/(4.*es**2)
       pmnlk=sqrt(pmnlk2)
       xk1=pplpk(es)
* for DLK channel
       t1dlk=ada+al+akp
       t2dlk=ada+al-akp
       if(es.le.t1dlk)go to 333
       pmdlk2=(es**2-t1dlk**2)*(es**2-t2dlk**2)/(4.*es**2)
       pmdlk=sqrt(pmdlk2)
       xk3=pplpk(es)
* for NSK channel
       t1nsk=ana+as+akp
       t2nsk=ana+as-akp
       if(es.le.t1nsk)go to 333
       pmnsk2=(es**2-t1nsk**2)*(es**2-t2nsk**2)/(4.*es**2)
       pmnsk=sqrt(pmnsk2)
       xk2=ppk1(es)+ppk0(es)
* for DSK channel
       t1DSk=aDa+aS+akp
       t2DSk=aDa+aS-akp
       if(es.le.t1dsk)go to 333
       pmDSk2=(es**2-t1DSk**2)*(es**2-t2DSk**2)/(4.*es**2)
       pmDSk=sqrt(pmDSk2)
       xk4=ppk1(es)+ppk0(es)
* THE TOTAL KAON+ AND KAON0 PRODUCTION CROSS SECTION IS THEN
333       XKAON=3.*(xk1+xk2+xk3+xk4)
* cross section for pp-->DD+rho
       x4pi=pp1(es)-ppsngl-xpp2pi-xpp3pi-XKAON
       if(x4pi.le.0)x4pi=1.E-06
       ENDIF
       RETURN
       END
******************************************
* for pp-->inelastic
c      real*4 function pp1(srt)
      real function pp1(srt)
      SAVE   
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*                                                                             *
******************************************
           pmass=0.9383 
       PP1=0.
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
      plab2=((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2
       IF(PLAB2.LE.0)RETURN
      plab=sqrt(PLAB2)
       pmin=0.968
       pmax=2080
      if ((plab .lt. pmin).or.(plab.gt.pmax)) then
        pp1 = 0.
        return
      end if
c* fit parameters
       a=30.9
       b=-28.9
       c=0.192
       d=-0.835
       an=-2.46
        pp1 = a+b*(plab**an)+c*(alog(plab))**2
       if(pp1.le.0)pp1=0.0
        return
        END
******************************************
* for pp-->elastic
c      real*4 function pp2(srt)
      real function pp2(srt)
      SAVE   
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*                                                                             *
******************************************
           pmass=0.9383 
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)

clin-9/2012: check argument in sqrt():
       scheck=((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2
       if(scheck.lt.0) then
          write(99,*) 'scheck33: ', scheck
          scheck=0.
       endif
       plab=sqrt(scheck)
c      plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)

       pmin=2.
       pmax=2050
       if(plab.gt.pmax)then
       pp2=8.
       return
       endif
        if(plab .lt. pmin)then
        pp2 = 25.
        return
        end if
c* fit parameters
       a=11.2
       b=25.5
       c=0.151
       d=-1.62
       an=-1.12
        pp2 = a+b*(plab**an)+c*(alog(plab))**2+d*alog(plab)
       if(pp2.le.0)pp2=0
        return
        END

******************************************
* for pp-->total
c      real*4 function ppt(srt)
      real function ppt(srt)
      SAVE   
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*                                                                             *
******************************************
           pmass=0.9383 
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)

clin-9/2012: check argument in sqrt():
       scheck=((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2
       if(scheck.lt.0) then
          write(99,*) 'scheck34: ', scheck
          scheck=0.
       endif
       plab=sqrt(scheck)
c      plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)

       pmin=3. 
       pmax=2100
      if ((plab .lt. pmin).or.(plab.gt.pmax)) then
        ppt = 55.
        return
      end if
c* fit parameters
       a=45.6
       b=219.0
       c=0.410
       d=-3.41
       an=-4.23
        ppt = a+b*(plab**an)+c*(alog(plab))**2+d*alog(plab)
       if(ppt.le.0)ppt=0.0
        return
        END

*************************
* cross section for N*(1535) production in PP collisions
* VARIABLES:
* LB1,LB2 ARE THE LABLES OF THE TWO COLLIDING PARTICLES
* SRT IS THE CMS ENERGY
* X1535 IS THE N*(1535) PRODUCTION CROSS SECTION
* NOTE THAT THE N*(1535) PRODUCTION CROSS SECTION IS 2 TIMES THE ETA 
* PRODUCTION CROSS SECTION
* DATE: Aug. 1 , 1994
* ********************************
       real function s1535(SRT)
      SAVE   
       S0=2.424
       s1535=0.
       IF(SRT.LE.S0)RETURN
       S1535=2.*0.102*(SRT-S0)/(0.058+(SRT-S0)**2)
       return
       end
****************************************
* generate a table for pt distribution for
       subroutine tablem
* THE PROCESS N+N--->N+N+PION
*       DATE : July 11, 1994
*****************************************
        COMMON/TABLE/ xarray(0:1000),earray(0:1000)
cc      SAVE /TABLE/
      SAVE   
       ptmax=2.01
       anorm=ptdis(ptmax)
       do 10 L=0,200
       x=0.01*float(L+1)
       rr=ptdis(x)/anorm
       earray(l)=rr
       xarray(l)=x
10       continue
       RETURN
       end
*********************************
       real function ptdis(x)
      SAVE   
* NUCLEON TRANSVERSE MOMENTUM DISTRIBUTION AT HIGH ENERGIES
* DATE: Aug. 11, 1994
*********************************
       b=3.78
       c=0.47
       d=3.60
c       b=b*3
c       d=d*3
       ptdis=1./(2.*b)*(1.-exp(-b*x**2))-c/d*x*exp(-d*x)
     1     -c/D**2*(exp(-d*x)-1.)
       return
       end
*****************************
       subroutine ppxS(lb1,lb2,srt,ppsig,spprho,ipp)
* purpose: this subroutine gives the cross section for pion+pion 
*          elastic collision
* variables: 
*       input: lb1,lb2 and srt are the labels and srt for I1 and I2
*       output: ppsig: pp xsection
*               ipp: label for the pion+pion channel
*               Ipp=0 NOTHING HAPPEND 
*                  1 for Pi(+)+PI(+) DIRECT
*                   2     PI(+)+PI(0) FORMING RHO(+)
*                  3     PI(+)+PI(-) FORMING RHO(0)
*                   4     PI(0)+PI(O) DIRECT
*                  5     PI(0)+PI(-) FORMING RHO(-)
*                  6     PI(-)+PI(-) DIRECT
* reference: G.F. Bertsch, Phys. Rev. D37 (1988) 1202.
* date : Aug 29, 1994
*****************************
       parameter (amp=0.14,pi=3.1415926)
      SAVE   
       PPSIG=0.0

cbzdbg10/15/99
        spprho=0.0
cbzdbg10/15/99 end

       IPP=0
       IF(SRT.LE.0.3)RETURN
       q=sqrt((srt/2)**2-amp**2)
       esigma=5.8*amp
       tsigma=2.06*q
       erho=0.77
       trho=0.095*q*(q/amp/(1.+(q/erho)**2))**2
       esi=esigma-srt
       if(esi.eq.0)then
       d00=pi/2.
       go to 10
       endif
       d00=atan(tsigma/2./esi)
10       erh=erho-srt
       if(erh.eq.0.)then
       d11=pi/2.
       go to 20
       endif
       d11=atan(trho/2./erh)
20       d20=-0.12*q/amp
       s0=8.*pi*sin(d00)**2/q**2
       s1=8*pi*3*sin(d11)**2/q**2
       s2=8*pi*5*sin(d20)**2/q**2
c    !! GeV^-2 to mb
        s0=s0*0.197**2*10.
        s1=s1*0.197**2*10.
        s2=s2*0.197**2*10.
C       ppXS=s0/9.+s1/3.+s2*0.56
C       if(ppxs.le.0)ppxs=0.00001
       spprho=s1/2.
* (1) PI(+)+PI(+)
       IF(LB1.EQ.5.AND.LB2.EQ.5)THEN
       IPP=1
       PPSIG=S2
       RETURN
       ENDIF
* (2) PI(+)+PI(0)
       IF((LB1.EQ.5.AND.LB2.EQ.4).OR.(LB1.EQ.4.AND.LB2.EQ.5))THEN
       IPP=2
       PPSIG=S2/2.+S1/2.
       RETURN
       ENDIF
* (3) PI(+)+PI(-)
       IF((LB1.EQ.5.AND.LB2.EQ.3).OR.(LB1.EQ.3.AND.LB2.EQ.5))THEN
       IPP=3
       PPSIG=S2/6.+S1/2.+S0/3.
       RETURN
       ENDIF
* (4) PI(0)+PI(0)
       IF(LB1.EQ.4.AND.LB2.EQ.4)THEN
       IPP=4
       PPSIG=2*S2/3.+S0/3.
       RETURN
       ENDIF
* (5) PI(0)+PI(-)
       IF((LB1.EQ.4.AND.LB2.EQ.3).OR.(LB1.EQ.3.AND.LB2.EQ.4))THEN
       IPP=5
       PPSIG=S2/2.+S1/2.
       RETURN
       ENDIF
* (6) PI(-)+PI(-)
       IF(LB1.EQ.3.AND.LB2.EQ.3)THEN
       IPP=6
       PPSIG=S2
       ENDIF
       return
       end
**********************************
* elementary kaon production cross sections
*  from the CERN data book
*  date: Sept.2, 1994
*  for pp-->pLK+
c      real*4 function pplpk(srt)
      real function pplpk(srt)
      SAVE   
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*                                                                             *
******************************************
           pmass=0.9383 
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
*   find the center of mass energy corresponding to the given pm as
*   if Lambda+N+K are produced
       pplpk=0.

clin-9/2012: check argument in sqrt():
       scheck=((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2
       if(scheck.lt.0) then
          write(99,*) 'scheck35: ', scheck
          scheck=0.
       endif
       plab=sqrt(scheck)
c        plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)

       pmin=2.82
       pmax=25.0
       if(plab.gt.pmax)then
       pplpk=0.036
       return
       endif
        if(plab .lt. pmin)then
        pplpk = 0.
        return
        end if
c* fit parameters
       a=0.0654
       b=-3.16
       c=-0.0029
       an=-4.14
        pplpk = a+b*(plab**an)+c*(alog(plab))**2
       if(pplpk.le.0)pplpk=0
        return
        END

******************************************
* for pp-->pSigma+K0
c      real*4 function ppk0(srt)
      real function ppk0(srt)
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*                                                                             *
******************************************
c      real*4   xarray(7), earray(7)
      real   xarray(7), earray(7)
      SAVE   
      data xarray /0.030,0.025,0.025,0.026,0.02,0.014,0.06/
      data earray /3.67,4.95,5.52,6.05,6.92,7.87,10./

           pmass=0.9383 
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
       ppk0=0
       if(srt.le.2.63)return
       if(srt.gt.4.54)then
       ppk0=0.037
       return
       endif
        plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
        if (plab .lt. earray(1)) then
        ppk0 = xarray(1)
        return
      end if
*
* 2.Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,7
        if (earray(ie) .eq. plab) then
          ppk0 = xarray(ie)
          go to 10
        else if (earray(ie) .gt. plab) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          ppk0 = exp(ymin + (alog(plab)-xmin)*(ymax-ymin)
     &/(xmax-xmin) )
          go to 10
        end if
 1001 continue
10       continue
      return
        END
******************************************
* for pp-->pSigma0K+
c      real*4 function ppk1(srt)
      real function ppk1(srt)
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*                                                                             *
******************************************
c      real*4   xarray(7), earray(7)
      real   xarray(7), earray(7)
      SAVE   
      data xarray /0.013,0.025,0.016,0.012,0.017,0.029,0.025/
      data earray /3.67,4.95,5.52,5.97,6.05,6.92,7.87/

           pmass=0.9383 
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
       ppk1=0.
       if(srt.le.2.63)return
       if(srt.gt.4.08)then
       ppk1=0.025
       return
       endif
        plab=sqrt(((srt**2-2.*pmass**2)/(2.*pmass))**2-pmass**2)
        if (plab .lt. earray(1)) then
        ppk1 =xarray(1)
        return
      end if
*
* 2.Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,7
        if (earray(ie) .eq. plab) then
          ppk1 = xarray(ie)
          go to 10
        else if (earray(ie) .gt. plab) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          ppk1 = exp(ymin + (alog(plab)-xmin)*(ymax-ymin)
     &/(xmax-xmin) )
          go to 10
        end if
 1001 continue
10       continue
      return
        END
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE CRPN(PX,PY,PZ,SRT,I1,I2,
     & IBLOCK,xkaon0,xkaon,Xphi,xphin)
*     PURPOSE:                                                         *
*           DEALING WITH PION+N-->L/S+KAON PROCESS AND PION PRODUCTION *
*     NOTE   :                                                         *
*          
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                     7  PION+N-->L/S+KAON
*           iblock   - 77 pion+N-->Delta+pion
*           iblock   - 78 pion+N-->Delta+RHO
*           iblock   - 79 pion+N-->Delta+OMEGA
*           iblock   - 222 pion+N-->Phi 
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,APHI=1.020,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

      PX0=PX
      PY0=PY
      PZ0=PZ
      iblock=1
      x1=RANART(NSEED)
      ianti=0
      if(lb(i1).lt.0 .or. lb(i2).lt.0) ianti=1
      if(xkaon0/(xkaon+Xphi).ge.x1)then
* kaon production
*-----------------------------------------------------------------------
        IBLOCK=7
        if(ianti .eq. 1)iblock=-7
        NTAG=0
* RELABLE PARTICLES FOR THE PROCESS PION+n-->LAMBDA K OR SIGMA k
* DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
* MOMENTA FOR PARTICLES IN THE FINAL STATE.
       KAONC=0
       IF(PNLKA(SRT)/(PNLKA(SRT)
     &       +PNSKA(SRT)).GT.RANART(NSEED))KAONC=1
       IF(E(I1).LE.0.2)THEN
           LB(I1)=23
           E(I1)=AKA
           IF(KAONC.EQ.1)THEN
              LB(I2)=14
              E(I2)=ALA
           ELSE
              LB(I2) = 15 + int(3 * RANART(NSEED))
              E(I2)=ASA       
           ENDIF
           if(ianti .eq. 1)then
              lb(i1) = 21
              lb(i2) = -lb(i2)
           endif
       ELSE
           LB(I2)=23
           E(I2)=AKA
           IF(KAONC.EQ.1)THEN
              LB(I1)=14
              E(I1)=ALA
           ELSE
              LB(I1) = 15 + int(3 * RANART(NSEED))
              E(I1)=ASA       
           ENDIF
           if(ianti .eq. 1)then
              lb(i2) = 21
              lb(i1) = -lb(i1)
           endif
       ENDIF
        EM1=E(I1)
        EM2=E(I2)
        go to 50
* to gererate the momentum for the kaon and L/S
      elseif(Xphi/(xkaon+Xphi).ge.x1)then
          iblock=222
         if(xphin/Xphi .ge. RANART(NSEED))then
          LB(I1)= 1+int(2*RANART(NSEED))
           E(I1)=AMN
         else
          LB(I1)= 6+int(4*RANART(NSEED))
           E(I1)=AM0
         endif
c  !! at present only baryon
         if(ianti .eq. 1)lb(i1)=-lb(i1)
          LB(I2)= 29
           E(I2)=APHI
        EM1=E(I1)
        EM2=E(I2)
       go to 50
         else
* CHECK WHAT KIND OF PION PRODUCTION PROCESS HAS HAPPENED
       IF(RANART(NSEED).LE.TWOPI(SRT)/
     &  (TWOPI(SRT)+THREPI(SRT)+FOURPI(SRT)))THEN
       iblock=77
       ELSE 
        IF(THREPI(SRT)/(THREPI(SRT)+FOURPI(SRT)).
     &  GT.RANART(NSEED))THEN
       IBLOCK=78
       ELSE
       IBLOCK=79
       ENDIF
       endif
       ntag=0
* pion production (Delta+pion/rho/omega in the final state)
* generate the mass of the delta resonance
       X2=RANART(NSEED)
* relable the particles
       if(iblock.eq.77)then
* GENERATE THE DELTA MASS
       dmax=srt-ap1-0.02
       dm=rmass(dmax,iseed)
* pion+baryon-->pion+delta
* Relable particles, I1 is assigned to the Delta and I2 is assigned to the
* meson
*(1) for pi(+)+p-->D(+)+P(+) OR D(++)+p(0)
       if( ((lb(i1).eq.1.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.1))
     &       .OR. ((lb(i1).eq.-1.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.-1)) )then
              if(iabs(lb(i1)).eq.1)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=8
       e(i1)=dm
       lb(i2)=5
       e(i2)=ap1
       go to 40
       ELSE
       lb(i1)=9
       e(i1)=dm
       lb(i2)=4
        ipi = 4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=8
       e(i2)=dm
       lb(i1)=5
       e(i1)=ap1
       go to 40
       ELSE
       lb(i2)=9
       e(i2)=dm
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(2) for pi(-)+p-->D(0)+P(0) OR D(+)+p(-),or D(-)+p(+)
       if( ((lb(i1).eq.1.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.1))
     &        .OR. ((lb(i1).eq.-1.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-1)) )then
              if(iabs(lb(i1)).eq.1)then
        ii = i1
       IF(X2.LE.0.33)THEN
       lb(i1)=6
       e(i1)=dm
       lb(i2)=5
       e(i2)=ap1
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i1)=7
       e(i1)=dm
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i1)=8
       e(i1)=dm
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.33)THEN
       lb(i2)=6
       e(i2)=dm
       lb(i1)=5
       e(i1)=ap1
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i2)=7
       e(i2)=dm
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i2)=8
       e(i2)=dm
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(3) for pi(+)+n-->D(+)+Pi(0) OR D(++)+p(-) or D(0)+pi(+)
       if( ((lb(i1).eq.2.and.lb(i2).eq.5).
     &   or.(lb(i1).eq.5.and.lb(i2).eq.2))
     & .OR. ((lb(i1).eq.-2.and.lb(i2).eq.3).
     &   or.(lb(i1).eq.3.and.lb(i2).eq.-2)) )then
              if(iabs(lb(i1)).eq.2)then
        ii = i1
       IF(X2.LE.0.33)THEN
       lb(i1)=8
       e(i1)=dm
       lb(i2)=4
       e(i2)=ap1
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i1)=7
       e(i1)=dm
       lb(i2)=5
       e(i2)=ap1
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i1)=9
       e(i1)=dm
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.33)THEN
       lb(i2)=8
       e(i2)=dm
       lb(i1)=4
       e(i1)=ap1
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i2)=7
       e(i2)=dm
       lb(i1)=5
       e(i1)=ap1
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i2)=9
       e(i2)=dm
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(4) for pi(0)+p-->D(+)+Pi(0) OR D(++)+p(-) or D(0)+pi(+)
       if((iabs(lb(i1)).eq.1.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.1))then
              if(iabs(lb(i1)).eq.1)then
        ii = i1
       IF(X2.LE.0.33)THEN
       lb(i1)=8
       e(i1)=dm
       lb(i2)=4
       e(i2)=ap1
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i1)=7
       e(i1)=dm
       lb(i2)=5
       e(i2)=ap1
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i1)=9
       e(i1)=dm
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.33)THEN
       lb(i2)=8
       e(i2)=dm
       lb(i1)=4
       e(i1)=ap1
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i2)=7
       e(i2)=dm
       lb(i1)=5
       e(i1)=ap1
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i2)=9
       e(i2)=dm
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       endif 
*(5) for pi(-)+n-->D(-)+P(0) OR D(0)+p(-)
       if( ((lb(i1).eq.2.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.2))
     &         .OR. ((lb(i1).eq.-2.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-2)) )then
              if(iabs(lb(i1)).eq.2)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=6
       e(i1)=dm
       lb(i2)=4
       e(i2)=ap1
       go to 40
       ELSE
       lb(i1)=7
       e(i1)=dm
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=6
       e(i2)=dm
       lb(i1)=4
       e(i1)=ap1
       go to 40
       ELSE
       lb(i2)=7
       e(i2)=dm
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(6) for pi(0)+n-->D(0)+P(0), D(-)+p(+) or D(+)+p(-)
       if((iabs(lb(i1)).eq.2.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.2))then
              if(iabs(lb(i1)).eq.2)then
        ii = i1
       IF(X2.LE.0.33)THEN
       lb(i1)=7
       e(i1)=dm
       lb(i2)=4
       e(i2)=ap1
       go to 40
       Endif
       IF(X2.LE.0.67.AND.X2.GT.0.33)THEN       
       lb(i1)=6
       e(i1)=dm
       lb(i2)=5
       e(i2)=ap1
       go to 40
       endif
       IF(X2.GT.0.67)THEN
       LB(I1)=8
       E(I1)=DM
       LB(I2)=3
       E(I2)=AP1
       GO TO 40
       ENDIF
              else
        ii = i2
       IF(X2.LE.0.33)THEN
       lb(i2)=7
       e(i2)=dm
       lb(i1)=4
       e(i1)=ap1
       go to 40
       ENDIF
       IF(X2.LE.0.67.AND.X2.GT.0.33)THEN       
       lb(i2)=6
       e(i2)=dm
       lb(i1)=5
       e(i1)=ap1
       go to 40
       endif
       IF(X2.GT.0.67)THEN
       LB(I2)=8
       E(I2)=DM
       LB(I1)=3
       E(I1)=AP1
       GO TO 40
       ENDIF
              endif
       endif
                     ENDIF
       if(iblock.eq.78)then
       call Rmasdd(srt,1.232,0.77,1.08,
     &  0.28,ISEED,4,dm,ameson)
       arho=AMESON
* pion+baryon-->Rho+delta
*(1) for pi(+)+p-->D(+)+rho(+) OR D(++)+rho(0)
       if( ((lb(i1).eq.1.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.1))
     &        .OR. ((lb(i1).eq.-1.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.-1)) )then
              if(iabs(lb(i1)).eq.1)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=8
       e(i1)=dm
       lb(i2)=27
       e(i2)=arho
       go to 40
       ELSE
       lb(i1)=9
       e(i1)=dm
       lb(i2)=26
       e(i2)=arho
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=8
       e(i2)=dm
       lb(i1)=27
       e(i1)=arho
       go to 40
       ELSE
       lb(i2)=9
       e(i2)=dm
       lb(i1)=26
       e(i1)=arho
       go to 40
       endif
              endif
       endif
*(2) for pi(-)+p-->D(+)+rho(-) OR D(0)+rho(0) or D(-)+rho(+)
       if( ((lb(i1).eq.1.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.1))
     &        .OR. ((lb(i1).eq.-1.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-1)) )then
              if(iabs(lb(i1)).eq.1)then
        ii = i1
       IF(X2.LE.0.33)THEN
       lb(i1)=6
       e(i1)=dm
       lb(i2)=27
       e(i2)=arho
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i1)=7
       e(i1)=dm
       lb(i2)=26
       e(i2)=arho
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i1)=8
       e(i1)=dm
       lb(i2)=25
       e(i2)=arho
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.33)THEN
       lb(i2)=6
       e(i2)=dm
       lb(i1)=27
       e(i1)=arho
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i2)=7
       e(i2)=dm
       lb(i1)=26
       e(i1)=arho
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i2)=8
       e(i2)=dm
       lb(i1)=25
       e(i1)=arho
       go to 40
       endif
              endif
       endif
*(3) for pi(+)+n-->D(+)+rho(0) OR D(++)+rho(-) or D(0)+rho(+)
       if( ((lb(i1).eq.2.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.2))
     &       .OR.((lb(i1).eq.-2.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.-2)) )then
              if(iabs(lb(i1)).eq.2)then
        ii = i1
       IF(X2.LE.0.33)THEN
       lb(i1)=8
       e(i1)=dm
       lb(i2)=26
       e(i2)=arho
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i1)=7
       e(i1)=dm
       lb(i2)=27
       e(i2)=arho
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i1)=9
       e(i1)=dm
       lb(i2)=25
       e(i2)=arho
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.33)THEN
       lb(i2)=8
       e(i2)=dm
       lb(i1)=26
       e(i1)=arho
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i2)=7
       e(i2)=dm
       lb(i1)=27
       e(i1)=arho
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i2)=9
       e(i2)=dm
       lb(i1)=25
       e(i1)=arho
       go to 40
       endif
              endif
       endif
*(4) for pi(0)+p-->D(+)+rho(0) OR D(++)+rho(-) or D(0)+rho(+)
       if((iabs(lb(i1)).eq.1.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.1))then
              if(iabs(lb(i1)).eq.1)then
        ii = i1
       IF(X2.LE.0.33)THEN
       lb(i1)=7
       e(i1)=dm
       lb(i2)=27
       e(i2)=arho
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i1)=8
       e(i1)=dm
       lb(i2)=26
       e(i2)=arho
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i1)=9
       e(i1)=dm
       lb(i2)=25
       e(i2)=arho
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.33)THEN
       lb(i2)=7
       e(i2)=dm
       lb(i1)=27
       e(i1)=arho
       go to 40
       ENDIF
       if(X2.gt.0.33.and.X2.le.0.67)then
       lb(i2)=8
       e(i2)=dm
       lb(i1)=26
       e(i1)=arho
       go to 40
       endif
       if(X2.gt.0.67)then
       lb(i2)=9
       e(i2)=dm
       lb(i1)=25
       e(i1)=arho
       go to 40
       endif
              endif
       endif 
*(5) for pi(-)+n-->D(-)+rho(0) OR D(0)+rho(-)
       if( ((lb(i1).eq.2.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.2))
     &        .OR. ((lb(i1).eq.-2.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-2)) )then
              if(iabs(lb(i1)).eq.2)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=6
       e(i1)=dm
       lb(i2)=26
       e(i2)=arho
       go to 40
       ELSE
       lb(i1)=7
       e(i1)=dm
       lb(i2)=25
       e(i2)=arho
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=6
       e(i2)=dm
       lb(i1)=26
       e(i1)=arho
       go to 40
       ELSE
       lb(i2)=7
       e(i2)=dm
       lb(i1)=25
       e(i1)=arho
       go to 40
       endif
              endif
       ENDIF
*(6) for pi(0)+n-->D(0)+rho(0), D(-)+rho(+) and D(+)+rho(-)
       if((iabs(lb(i1)).eq.2.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.2))then
              if(iabs(lb(i1)).eq.2)then
        ii = i1
       IF(X2.LE.0.33)THEN
       lb(i1)=7
       e(i1)=dm
       lb(i2)=26
       e(i2)=arho
       go to 40
       endif
       if(x2.gt.0.33.and.x2.le.0.67)then       
       lb(i1)=6
       e(i1)=dm
       lb(i2)=27
       e(i2)=arho
       go to 40
       endif
       if(x2.gt.0.67)then
       lb(i1)=8
       e(i1)=dm
       lb(i2)=25
       e(i2)=arho
       endif
              else
        ii = i2
       IF(X2.LE.0.33)THEN
       lb(i2)=7
       e(i2)=dm
       lb(i1)=26
       e(i1)=arho
       go to 40
       endif
       if(x2.le.0.67.and.x2.gt.0.33)then       
       lb(i2)=6
       e(i2)=dm
       lb(i1)=27
       e(i1)=arho
       go to 40
       endif
       if(x2.gt.0.67)then
       lb(i2)=8
       e(i2)=dm
       lb(i1)=25
       e(i1)=arho
       endif
              endif
       endif
                     Endif
       if(iblock.eq.79)then
       aomega=0.782
* GENERATE THE DELTA MASS
       dmax=srt-0.782-0.02
       dm=rmass(dmax,iseed)
* pion+baryon-->omega+delta
*(1) for pi(+)+p-->D(++)+omega(0)
       if( ((lb(i1).eq.1.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.1))
     &  .OR.((lb(i1).eq.-1.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.-1)) )then
              if(iabs(lb(i1)).eq.1)then
        ii = i1
       lb(i1)=9
       e(i1)=dm
       lb(i2)=28
       e(i2)=aomega
       go to 40
              else
        ii = i2
       lb(i2)=9
       e(i2)=dm
       lb(i1)=28
       e(i1)=aomega
       go to 40
              endif
       endif
*(2) for pi(-)+p-->D(0)+omega(0) 
       if( ((lb(i1).eq.1.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.1))
     &        .OR. ((lb(i1).eq.-1.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-1)) )then
              if(iabs(lb(i1)).eq.1)then
        ii = i1
       lb(i1)=7
       e(i1)=dm
       lb(i2)=28
       e(i2)=aomega
       go to 40
              else
        ii = i2
       lb(i2)=7
       e(i2)=dm
       lb(i1)=28
       e(i1)=aomega
       go to 40
              endif
       endif
*(3) for pi(+)+n-->D(+)+omega(0) 
       if( ((lb(i1).eq.2.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.2))
     &       .OR. ((lb(i1).eq.-2.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.-2)) )then
              if(iabs(lb(i1)).eq.2)then
        ii = i1
       lb(i1)=8
       e(i1)=dm
       lb(i2)=28
       e(i2)=aomega
       go to 40
              else
        ii = i2
       lb(i2)=8
       e(i2)=dm
       lb(i1)=28
       e(i1)=aomega
       go to 40
              endif
       endif
*(4) for pi(0)+p-->D(+)+omega(0) 
       if((iabs(lb(i1)).eq.1.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.1))then
              if(iabs(lb(i1)).eq.1)then
        ii = i1
       lb(i1)=8
       e(i1)=dm
       lb(i2)=28
       e(i2)=aomega
       go to 40
              else
        ii = i2
       lb(i2)=8
       e(i2)=dm
       lb(i1)=28
       e(i1)=aomega
       go to 40
              endif
       endif 
*(5) for pi(-)+n-->D(-)+omega(0) 
       if( ((lb(i1).eq.2.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.2))
     &        .OR. ((lb(i1).eq.-2.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-2)) )then
              if(iabs(lb(i1)).eq.2)then
        ii = i1
       lb(i1)=6
       e(i1)=dm
       lb(i2)=28
       e(i2)=aomega
       go to 40
              ELSE
        ii = i2
       lb(i2)=6
       e(i2)=dm
       lb(i1)=28
       e(i1)=aomega
              endif
       ENDIF
*(6) for pi(0)+n-->D(0)+omega(0) 
       if((iabs(lb(i1)).eq.2.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.2))then
              if(iabs(lb(i1)).eq.2)then
        ii = i1
       lb(i1)=7
       e(i1)=dm
       lb(i2)=28
       e(i2)=aomega
       go to 40
              else
        ii = i2
       lb(i2)=7
       e(i2)=dm
       lb(i1)=26
       e(i1)=arho
       go to 40
              endif
       endif
                     Endif
40       em1=e(i1)
       em2=e(i2)
       if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
         lb(ii) = -lb(ii)
           jj = i2
          if(ii .eq. i2)jj = i1
         if(iblock .eq. 77)then
          if(lb(jj).eq.3)then
           lb(jj) = 5
          elseif(lb(jj).eq.5)then
           lb(jj) = 3
          endif
         elseif(iblock .eq. 78)then
          if(lb(jj).eq.25)then
           lb(jj) = 27
          elseif(lb(jj).eq.27)then
           lb(jj) = 25
          endif
         endif
       endif
           endif
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
50          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=0.00000001
          PR=SQRT(PR2)/(2.*SRT)
* here we use the same transverse momentum distribution as for
* pp collisions, it might be necessary to use a different distribution

clin-10/25/02 get rid of argument usage mismatch in PTR():
          xptr=0.33*pr
c         cc1=ptr(0.33*pr,iseed)
         cc1=ptr(xptr,iseed)
clin-10/25/02-end

clin-9/2012: check argument in sqrt():
         scheck=pr**2-cc1**2
         if(scheck.lt.0) then
            write(99,*) 'scheck36: ', scheck
            scheck=0.
         endif
         c1=sqrt(scheck)/pr
c         c1=sqrt(pr**2-cc1**2)/pr

*          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
* ROTATE IT 
       CALL ROTATE(PX0,PY0,PZ0,PX,PY,PZ) 
      RETURN
      END
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE CREN(PX,PY,PZ,SRT,I1,I2,IBLOCK)
*     PURPOSE:                                                         *
*             DEALING WITH ETA+N-->L/S+KAON PROCESS                   *
*     NOTE   :                                                         *
*          
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                     7  ETA+N-->L/S+KAON
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       PX0=PX
       PY0=PY
       PZ0=PZ
        NTAG=0
        IBLOCK=7
        ianti=0
        if(lb(i1).lt.0 .or. lb(i2).lt.0)then
          ianti=1
          iblock=-7
        endif
* RELABLE PARTICLES FOR THE PROCESS eta+n-->LAMBDA K OR SIGMA k
* DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
* MOMENTA FOR PARTICLES IN THE FINAL STATE.
       KAONC=0
       IF(PNLKA(SRT)/(PNLKA(SRT)
     & +PNSKA(SRT)).GT.RANART(NSEED))KAONC=1
       IF(E(I1).LE.0.6)THEN
       LB(I1)=23
       E(I1)=AKA
        IF(KAONC.EQ.1)THEN
       LB(I2)=14
       E(I2)=ALA
        ELSE
        LB(I2) = 15 + int(3 * RANART(NSEED))
       E(I2)=ASA       
        ENDIF
          if(ianti .eq. 1)then
            lb(i1)=21
            lb(i2)=-lb(i2)
          endif
       ELSE
       LB(I2)=23
       E(I2)=AKA
        IF(KAONC.EQ.1)THEN
       LB(I1)=14
       E(I1)=ALA
        ELSE
         LB(I1) = 15 + int(3 * RANART(NSEED))
       E(I1)=ASA       
        ENDIF
          if(ianti .eq. 1)then
            lb(i2)=21
            lb(i1)=-lb(i1)
          endif
       ENDIF
        EM1=E(I1)
        EM2=E(I2)
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
        PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
* FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
      RETURN
      END
**********************************
*                                                                      *
*                                                                      *
c      SUBROUTINE Crdir(PX,PY,PZ,SRT,I1,I2)
      SUBROUTINE Crdir(PX,PY,PZ,SRT,I1,I2,IBLOCK)
*     PURPOSE:                                                         *
*             DEALING WITH pion+N-->pion+N PROCESS                   *
*     NOTE   :                                                         *
*          
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                    
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       PX0=PX
       PY0=PY
       PZ0=PZ
        IBLOCK=999
        NTAG=0
        EM1=E(I1)
        EM2=E(I2)
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
        PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)

clin-10/25/02 get rid of argument usage mismatch in PTR():
          xptr=0.33*pr
c         cc1=ptr(0.33*pr,iseed)
         cc1=ptr(xptr,iseed)
clin-10/25/02-end

clin-9/2012: check argument in sqrt():
         scheck=pr**2-cc1**2
         if(scheck.lt.0) then
            write(99,*) 'scheck37: ', scheck
            scheck=0.
         endif
         c1=sqrt(scheck)/pr
c         c1=sqrt(pr**2-cc1**2)/pr

           T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
* ROTATE the momentum
      call rotate(px0,py0,pz0,px,py,pz)
      RETURN
      END
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE CRPD(PX,PY,PZ,SRT,I1,I2,
     & IBLOCK,xkaon0,xkaon,Xphi,xphin)
*     PURPOSE:                                                         *
*     DEALING WITH PION+D(N*)-->PION +N OR 
*                                             L/S+KAON PROCESS         *
*     NOTE   :                                                         *
*          
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                     7  PION+D(N*)-->L/S+KAON
*           iblock   - 80 pion+D(N*)-->pion+N
*           iblock   - 81 RHO+D(N*)-->PION+N
*           iblock   - 82 OMEGA+D(N*)-->PION+N
*                     222  PION+D --> PHI
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,APHI=1.020,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       PX0=PX
       PY0=PY
       PZ0=PZ
        IBLOCK=1
       x1=RANART(NSEED)
        ianti=0
        if(lb(i1).lt.0 .or. lb(i2).lt.0)ianti=1
       if(xkaon0/(xkaon+Xphi).ge.x1)then
* kaon production
*-----------------------------------------------------------------------
        IBLOCK=7
        if(ianti .eq. 1)iblock=-7
        NTAG=0
* RELABLE PARTICLES FOR THE PROCESS PION+n-->LAMBDA K OR SIGMA k
* DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
* MOMENTA FOR PARTICLES IN THE FINAL STATE.
       KAONC=0
       IF(PNLKA(SRT)/(PNLKA(SRT)
     &       +PNSKA(SRT)).GT.RANART(NSEED))KAONC=1
clin-8/17/00     & +PNSKA(SRT)).GT.RANART(NSEED))KAONC=1
       IF(E(I1).LE.0.2)THEN
           LB(I1)=23
           E(I1)=AKA
           IF(KAONC.EQ.1)THEN
              LB(I2)=14
              E(I2)=ALA
           ELSE
              LB(I2) = 15 + int(3 * RANART(NSEED))
              E(I2)=ASA       
           ENDIF
           if(ianti .eq. 1)then
              lb(i1)=21
              lb(i2)=-lb(i2)
           endif
       ELSE
           LB(I2)=23
           E(I2)=AKA
           IF(KAONC.EQ.1)THEN
              LB(I1)=14
              E(I1)=ALA
           ELSE
              LB(I1) = 15 + int(3 * RANART(NSEED))
              E(I1)=ASA       
           ENDIF
           if(ianti .eq. 1)then
              lb(i2)=21
              lb(i1)=-lb(i1)
           endif
       ENDIF
        EM1=E(I1)
        EM2=E(I2)
       go to 50
* to gererate the momentum for the kaon and L/S
c
c* Phi production
       elseif(Xphi/(xkaon+Xphi).ge.x1)then
          iblock=222
         if(xphin/Xphi .ge. RANART(NSEED))then
          LB(I1)= 1+int(2*RANART(NSEED))
           E(I1)=AMN
         else
          LB(I1)= 6+int(4*RANART(NSEED))
           E(I1)=AM0
         endif
c   !! at present only baryon
          if(ianti .eq. 1)lb(i1)=-lb(i1)
          LB(I2)= 29
           E(I2)=APHI
        EM1=E(I1)
        EM2=E(I2)
       go to 50
         else
* PION REABSORPTION HAS HAPPENED
       X2=RANART(NSEED)
       IBLOCK=80
       ntag=0
* Relable particles, I1 is assigned to the nucleon
* and I2 is assigned to the pion
* for the reverse of the following process
*(1) for D(+)+P(+)-->p+pion(+)
        if( ((lb(i1).eq.8.and.lb(i2).eq.5).
     &       or.(lb(i1).eq.5.and.lb(i2).eq.8))
     &       .OR.((lb(i1).eq.-8.and.lb(i2).eq.3).
     &       or.(lb(i1).eq.3.and.lb(i2).eq.-8)) )then
           if(iabs(lb(i1)).eq.8)then
              ii = i1
              lb(i1)=1
              e(i1)=amn
              lb(i2)=5
              e(i2)=ap1
              go to 40
           else
              ii = i2
              lb(i2)=1
              e(i2)=amn
              lb(i1)=5
              e(i1)=ap1
              go to 40
           endif
       endif
c
*(2) for D(0)+P(0)-->n+pi(0) or p+pi(-) 
       if((iabs(lb(i1)).eq.7.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.7))then
              if(iabs(lb(i1)).eq.7)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(3) for D(+)+Pi(0)-->pi(+)+n or pi(0)+p 
       if((iabs(lb(i1)).eq.8.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.8))then
              if(iabs(lb(i1)).eq.8)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(4) for D(-)+Pi(0)-->n+pi(-) 
       if((iabs(lb(i1)).eq.6.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.6))then
              if(iabs(lb(i1)).eq.6)then
        ii = i1
       lb(i1)=2
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=2
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       ENDIF
       endif
*(5) for D(+)+Pi(-)-->pi(0)+n or pi(-)+p
       if( ((lb(i1).eq.8.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.8))
     &        .OR.((lb(i1).eq.-8.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-8)) )then
              if(iabs(lb(i1)).eq.8)then
        ii = i1
        IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       ELSE
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
        IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       ELSE
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(6) D(0)+P(+)-->n+pi(+) or p+pi(0)
       if( ((lb(i1).eq.7.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.7))
     &        .OR.((lb(i1).eq.-7.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.-7)) )then
              if(iabs(lb(i1)).eq.7)then
        ii = i1
         IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
         IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(7) for D(0)+Pi(-)-->n+pi(-) 
       if( ((lb(i1).eq.7.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.7))
     &        .OR.((lb(i1).eq.-7.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-7)) )then
              if(iabs(lb(i1)).eq.7)then
        ii = i1
       lb(i1)=2
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=2
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       ENDIF
       endif
*(8) D(-)+P(+)-->n+pi(0) or p+pi(-)
       if( ((lb(i1).eq.6.and.lb(i2).eq.5)
     &      .or.(lb(i1).eq.5.and.lb(i2).eq.6))
     &   .OR.((lb(i1).eq.-6.and.lb(i2).eq.3).
     &      or.(lb(i1).eq.3.and.lb(i2).eq.-6)) )then
              if(iabs(lb(i1)).eq.6)then
         ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
         ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
c
*(9) D(++)+P(-)-->n+pi(+) or p+pi(0)
       if( ((lb(i1).eq.9.and.lb(i2).eq.3)
     &   .or.(lb(i1).eq.3.and.lb(i2).eq.9))
     &       .OR. ((lb(i1).eq.-9.and.lb(i2).eq.5)
     &   .or.(lb(i1).eq.5.and.lb(i2).eq.-9)) )then
              if(iabs(lb(i1)).eq.9)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(10) for D(++)+Pi(0)-->p+pi(+) 
       if((iabs(lb(i1)).eq.9.and.lb(i2).eq.4)
     &    .or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.9))then
           if(iabs(lb(i1)).eq.9)then
        ii = i1
       lb(i1)=1
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=1
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       ENDIF
       endif
*(11) for N*(1440)(+)or N*(1535)(+)+P(+)-->p+pion(+)
       if( ((lb(i1).eq.11.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.11).
     &  or.(lb(i1).eq.13.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.13))
     &        .OR.((lb(i1).eq.-11.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.-11).
     &  or.(lb(i1).eq.-13.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.-13)) )then
              if(iabs(lb(i1)).eq.11.or.iabs(lb(i1)).eq.13)then
        ii = i1
       lb(i1)=1
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=1
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
              endif
       endif
*(12) for N*(1440) or N*(1535)(0)+P(0)-->n+pi(0) or p+pi(-) 
       if((iabs(lb(i1)).eq.10.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.10).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.12).
     &  or.(lb(i2).eq.4.and.iabs(lb(i1)).eq.12))then
              if(iabs(lb(i1)).eq.10.or.iabs(lb(i1)).eq.12)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(13) for N*(1440) or N*(1535)(+)+Pi(0)-->pi(+)+n or pi(0)+p 
       if((iabs(lb(i1)).eq.11.and.lb(i2).eq.4).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.11).
     &  or.(lb(i1).eq.4.and.iabs(lb(i2)).eq.13).
     &  or.(lb(i2).eq.4.and.iabs(lb(i1)).eq.13))then
              if(iabs(lb(i1)).eq.11.or.iabs(lb(i1)).eq.13)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(14) for N*(1440) or N*(1535)(+)+Pi(-)-->pi(0)+n or pi(-)+p
       if( ((lb(i1).eq.11.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.11).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.13).
     &  or.(lb(i2).eq.3.and.lb(i1).eq.13))
     &        .OR.((lb(i1).eq.-11.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-11).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-13).
     &  or.(lb(i2).eq.5.and.lb(i1).eq.-13)) )then
       if(iabs(lb(i1)).eq.11.or.iabs(lb(i1)).eq.13)then
        ii = i1
         IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       ELSE
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
         IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       ELSE
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(15) N*(1440) or N*(1535)(0)+P(+)-->n+pi(+) or p+pi(0)
       if( ((lb(i1).eq.10.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.10).
     &  or.(lb(i1).eq.12.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.12))
     &        .OR.((lb(i1).eq.-10.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.-10).
     &  or.(lb(i1).eq.-12.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.-12)) )then
       if(iabs(lb(i1)).eq.10.or.iabs(lb(i1)).eq.12)then
        ii = i1
        IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
        IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(16) for N*(1440) or N*(1535) (0)+Pi(-)-->n+pi(-) 
       if( ((lb(i1).eq.10.and.lb(i2).eq.3).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.10).
     &  or.(lb(i1).eq.3.and.lb(i2).eq.12).
     &  or.(lb(i1).eq.12.and.lb(i2).eq.3))
     &        .OR.((lb(i1).eq.-10.and.lb(i2).eq.5).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-10).
     &  or.(lb(i1).eq.5.and.lb(i2).eq.-12).
     &  or.(lb(i1).eq.-12.and.lb(i2).eq.5)) )then
           if(iabs(lb(i1)).eq.10.or.iabs(lb(i1)).eq.12)then
        ii = i1
       lb(i1)=2
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=2
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       ENDIF
       endif
40       em1=e(i1)
       em2=e(i2)
       if(ianti.eq.1 .and.  lb(i1).ge.1 .and. lb(i2).ge.1)then
         lb(ii) = -lb(ii)
           jj = i2
          if(ii .eq. i2)jj = i1
          if(lb(jj).eq.3)then
           lb(jj) = 5
          elseif(lb(jj).eq.5)then
           lb(jj) = 3
          endif
         endif
          endif
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
50          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.E-09
          PR=SQRT(PR2)/(2.*SRT)

clin-10/25/02 get rid of argument usage mismatch in PTR():
          xptr=0.33*pr
c         cc1=ptr(0.33*pr,iseed)
         cc1=ptr(xptr,iseed)
clin-10/25/02-end

clin-9/2012: check argument in sqrt():
         scheck=pr**2-cc1**2
         if(scheck.lt.0) then
            write(99,*) 'scheck38: ', scheck
            scheck=0.
         endif
         c1=sqrt(scheck)/pr
c         c1=sqrt(pr**2-cc1**2)/pr

c         C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1 
* rotate the momentum
       call rotate(px0,py0,pz0,px,py,pz)
      RETURN
      END
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE CRRD(PX,PY,PZ,SRT,I1,I2,
     & IBLOCK,xkaon0,xkaon,Xphi,xphin)
*     PURPOSE:                                                         *
*     DEALING WITH rho(omega)+N or D(N*)-->PION +N OR 
*                                             L/S+KAON PROCESS         *
*     NOTE   :                                                         *
*          
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                     7  rho(omega)+N or D(N*)-->L/S+KAON
*           iblock   - 80 pion+D(N*)-->pion+N
*           iblock   - 81 RHO+D(N*)-->PION+N
*           iblock   - 82 OMEGA+D(N*)-->PION+N
*           iblock   - 222 pion+N-->Phi 
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER     (AKA=0.498,ALA=1.1157,ASA=1.1974,APHI=1.02)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       PX0=PX
       PY0=PY
       PZ0=PZ
       IBLOCK=1
       ianti=0
       if(lb(i1).lt.0 .or. lb(i2).lt.0) ianti=1
       x1=RANART(NSEED)
       if(xkaon0/(xkaon+Xphi).ge.x1)then
* kaon production
*-----------------------------------------------------------------------
        IBLOCK=7
        if(ianti .eq. 1)iblock=-7
        NTAG=0
* RELABLE PARTICLES FOR THE PROCESS PION+n-->LAMBDA K OR SIGMA k
* DECIDE LAMBDA OR SIGMA PRODUCTION, AND TO CALCULATE THE NEW
* MOMENTA FOR PARTICLES IN THE FINAL STATE.
       KAONC=0
       IF(PNLKA(SRT)/(PNLKA(SRT)
     & +PNSKA(SRT)).GT.RANART(NSEED))KAONC=1
clin-8/17/00     & +PNSKA(SRT)).GT.RANART(NSEED))KAONC=1
       IF(E(I1).LE.0.92)THEN
       LB(I1)=23
       E(I1)=AKA
              IF(KAONC.EQ.1)THEN
       LB(I2)=14
       E(I2)=ALA
              ELSE
        LB(I2) = 15 + int(3 * RANART(NSEED))
       E(I2)=ASA       
              ENDIF
         if(ianti .eq. 1)then
          lb(i1) = 21
          lb(i2) = -lb(i2)
         endif
       ELSE
       LB(I2)=23
       E(I2)=AKA
              IF(KAONC.EQ.1)THEN
       LB(I1)=14
       E(I1)=ALA
              ELSE
         LB(I1) = 15 + int(3 * RANART(NSEED))
       E(I1)=ASA       
              ENDIF
         if(ianti .eq. 1)then
          lb(i2) = 21
          lb(i1) = -lb(i1)
         endif
       ENDIF
        EM1=E(I1)
        EM2=E(I2)
       go to 50
* to gererate the momentum for the kaon and L/S
c
c* Phi production
       elseif(Xphi/(xkaon+Xphi).ge.x1)then
          iblock=222
         if(xphin/Xphi .ge. RANART(NSEED))then
          LB(I1)= 1+int(2*RANART(NSEED))
           E(I1)=AMN
         else
          LB(I1)= 6+int(4*RANART(NSEED))
           E(I1)=AM0
         endif
c   !! at present only baryon
         if(ianti .eq. 1)lb(i1)=-lb(i1)
          LB(I2)= 29
           E(I2)=APHI
        EM1=E(I1)
        EM2=E(I2)
       go to 50
         else
* rho(omega) REABSORPTION HAS HAPPENED
       X2=RANART(NSEED)
       IBLOCK=81
       ntag=0
       if(lb(i1).eq.28.or.lb(i2).eq.28)go to 60
* we treat Rho reabsorption in the following 
* Relable particles, I1 is assigned to the Delta 
* and I2 is assigned to the meson
* for the reverse of the following process
*(1) for D(+)+rho(+)-->p+pion(+)
       if( ((lb(i1).eq.8.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.8))
     &        .OR. ((lb(i1).eq.-8.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.-8)) )then
              if(iabs(lb(i1)).eq.8)then
        ii = i1
       lb(i1)=1
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=1
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
              endif
       endif
*(2) for D(0)+rho(0)-->n+pi(0) or p+pi(-) 
       if((iabs(lb(i1)).eq.7.and.lb(i2).eq.26).
     &  or.(lb(i1).eq.26.and.iabs(lb(i2)).eq.7))then
              if(iabs(lb(i1)).eq.7)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(3) for D(+)+rho(0)-->pi(+)+n or pi(0)+p 
       if((iabs(lb(i1)).eq.8.and.lb(i2).eq.26).
     &  or.(lb(i1).eq.26.and.iabs(lb(i2)).eq.8))then
              if(iabs(lb(i1)).eq.8)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(4) for D(-)+rho(0)-->n+pi(-) 
       if((iabs(lb(i1)).eq.6.and.lb(i2).eq.26).
     &  or.(lb(i1).eq.26.and.iabs(lb(i2)).eq.6))then
              if(iabs(lb(i1)).eq.6)then
        ii = i1
       lb(i1)=2
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=2
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       ENDIF
       endif
*(5) for D(+)+rho(-)-->pi(0)+n or pi(-)+p
       if( ((lb(i1).eq.8.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.8))
     &        .OR. ((lb(i1).eq.-8.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.-8)) )then
              if(iabs(lb(i1)).eq.8)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       ELSE
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       ELSE
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(6) D(0)+rho(+)-->n+pi(+) or p+pi(0)
       if( ((lb(i1).eq.7.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.7))
     &       .OR.((lb(i1).eq.-7.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.-7)) )then
              if(iabs(lb(i1)).eq.7)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(7) for D(0)+rho(-)-->n+pi(-) 
       if( ((lb(i1).eq.7.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.7))
     &       .OR.((lb(i1).eq.-7.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.-7)) )then
              if(iabs(lb(i1)).eq.7)then
        ii = i1
       lb(i1)=2
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=2
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       ENDIF
       endif
*(8) D(-)+rho(+)-->n+pi(0) or p+pi(-)
       if( ((lb(i1).eq.6.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.6))
     &        .OR. ((lb(i1).eq.-6.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.-6)) )then
              if(iabs(lb(i1)).eq.6)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(9) D(++)+rho(-)-->n+pi(+) or p+pi(0)
       if( ((lb(i1).eq.9.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.9))
     &        .OR.((lb(i1).eq.-9.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.-9)) )then
              if(iabs(lb(i1)).eq.9)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(10) for D(++)+rho(0)-->p+pi(+) 
       if((iabs(lb(i1)).eq.9.and.lb(i2).eq.26).
     &  or.(lb(i1).eq.26.and.iabs(lb(i2)).eq.9))then
              if(iabs(lb(i1)).eq.9)then
        ii = i1
       lb(i1)=1
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=1
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       ENDIF
       endif
*(11) for N*(1440)(+)or N*(1535)(+)+rho(+)-->p+pion(+)
       if( ((lb(i1).eq.11.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.11).
     &  or.(lb(i1).eq.13.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.13))
     &        .OR. ((lb(i1).eq.-11.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.-11).
     &  or.(lb(i1).eq.-13.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.-13)) )then
              if(iabs(lb(i1)).eq.11.or.iabs(lb(i1)).eq.13)then
        ii = i1
       lb(i1)=1
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=1
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
              endif
       endif
*(12) for N*(1440) or N*(1535)(0)+rho(0)-->n+pi(0) or p+pi(-) 
       if((iabs(lb(i1)).eq.10.and.lb(i2).eq.26).
     &  or.(lb(i1).eq.26.and.iabs(lb(i2)).eq.10).
     &  or.(lb(i1).eq.26.and.iabs(lb(i2)).eq.12).
     &  or.(lb(i2).eq.26.and.iabs(lb(i1)).eq.12))then
              if(iabs(lb(i1)).eq.10.or.iabs(lb(i1)).eq.12)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(13) for N*(1440) or N*(1535)(+)+rho(0)-->pi(+)+n or pi(0)+p 
       if((iabs(lb(i1)).eq.11.and.lb(i2).eq.26).
     &  or.(lb(i1).eq.26.and.iabs(lb(i2)).eq.11).
     &  or.(lb(i1).eq.26.and.iabs(lb(i2)).eq.13).
     &  or.(lb(i2).eq.26.and.iabs(lb(i1)).eq.13))then
              if(iabs(lb(i1)).eq.11.or.iabs(lb(i1)).eq.13)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(14) for N*(1440) or N*(1535)(+)+rho(-)-->pi(0)+n or pi(-)+p
       if( ((lb(i1).eq.11.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.11).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.13).
     &  or.(lb(i2).eq.25.and.lb(i1).eq.13))
     &        .OR.((lb(i1).eq.-11.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.-11).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.-13).
     &  or.(lb(i2).eq.27.and.lb(i1).eq.-13)) )then
       if(iabs(lb(i1)).eq.11.or.iabs(lb(i1)).eq.13)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       ELSE
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       ELSE
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(15) N*(1440) or N*(1535)(0)+rho(+)-->n+pi(+) or p+pi(0)
       if( ((lb(i1).eq.10.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.10).
     &  or.(lb(i1).eq.12.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.12))
     &         .OR.((lb(i1).eq.-10.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.-10).
     &  or.(lb(i1).eq.-12.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.-12)) )then
       if(iabs(lb(i1)).eq.10.or.iabs(lb(i1)).eq.12)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       ENDIF
*(16) for N*(1440) or N*(1535) (0)+rho(-)-->n+pi(-) 
       if( ((lb(i1).eq.10.and.lb(i2).eq.25).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.10).
     &  or.(lb(i1).eq.25.and.lb(i2).eq.12).
     &  or.(lb(i1).eq.12.and.lb(i2).eq.25))
     &       .OR. ((lb(i1).eq.-10.and.lb(i2).eq.27).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.-10).
     &  or.(lb(i1).eq.27.and.lb(i2).eq.-12).
     &  or.(lb(i1).eq.-12.and.lb(i2).eq.27)) )then
       if(iabs(lb(i1)).eq.10.or.iabs(lb(i1)).eq.12)then
        ii = i1
       lb(i1)=2
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=2
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       ENDIF
       endif
60       IBLOCK=82
* FOR OMEGA REABSORPTION
* Relable particles, I1 is assigned to the Delta 
* and I2 is assigned to the meson
* for the reverse of the following process
*(1) for D(0)+OMEGA(0)-->n+pi(0) or p+pi(-) 
       if((iabs(lb(i1)).eq.7.and.lb(i2).eq.28).
     &  or.(lb(i1).eq.28.and.iabs(lb(i2)).eq.7))then
              if(iabs(lb(i1)).eq.7)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(2) for D(+)+OMEGA(0)-->pi(+)+n or pi(0)+p 
       if((iabs(lb(i1)).eq.8.and.lb(i2).eq.28).
     &  or.(lb(i1).eq.28.and.iabs(lb(i2)).eq.8))then
              if(iabs(lb(i1)).eq.8)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(3) for D(-)+OMEGA(0)-->n+pi(-) 
       if((iabs(lb(i1)).eq.6.and.lb(i2).eq.28).
     &  or.(lb(i1).eq.28.and.iabs(lb(i2)).eq.6))then
              if(iabs(lb(i1)).eq.6)then
        ii = i1
       lb(i1)=2
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=2
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       ENDIF
       endif
*(4) for D(++)+OMEGA(0)-->p+pi(+) 
       if((iabs(lb(i1)).eq.9.and.lb(i2).eq.28).
     &  or.(lb(i1).eq.28.and.iabs(lb(i2)).eq.9))then
              if(iabs(lb(i1)).eq.9)then
        ii = i1
       lb(i1)=1
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       else
        ii = i2
       lb(i2)=1
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       ENDIF
       endif
*(5) for N*(1440) or N*(1535)(0)+omega(0)-->n+pi(0) or p+pi(-) 
       if((iabs(lb(i1)).eq.10.and.lb(i2).eq.28).
     &  or.(lb(i1).eq.28.and.iabs(lb(i2)).eq.10).
     &  or.(lb(i1).eq.28.and.iabs(lb(i2)).eq.12).
     &  or.(lb(i2).eq.28.and.iabs(lb(i1)).eq.12))then
              if(iabs(lb(i1)).eq.10.or.iabs(lb(i1)).eq.12)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=3
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=3
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
*(6) for N*(1440) or N*(1535)(+)+omega(0)-->pi(+)+n or pi(0)+p 
       if((iabs(lb(i1)).eq.11.and.lb(i2).eq.28).
     &  or.(lb(i1).eq.28.and.iabs(lb(i2)).eq.11).
     &  or.(lb(i1).eq.28.and.iabs(lb(i2)).eq.13).
     &  or.(lb(i2).eq.28.and.iabs(lb(i1)).eq.13))then
              if(iabs(lb(i1)).eq.11.or.iabs(lb(i1)).eq.13)then
        ii = i1
       IF(X2.LE.0.5)THEN
       lb(i1)=2
       e(i1)=amn
       lb(i2)=5
       e(i2)=ap1
       go to 40
       Else
       lb(i1)=1
       e(i1)=amn
       lb(i2)=4
       e(i2)=ap1
       go to 40
       endif
              else
        ii = i2
       IF(X2.LE.0.5)THEN
       lb(i2)=2
       e(i2)=amn
       lb(i1)=5
       e(i1)=ap1
       go to 40
       Else
       lb(i2)=1
       e(i2)=amn
       lb(i1)=4
       e(i1)=ap1
       go to 40
       endif
              endif
       endif
40       em1=e(i1)
       em2=e(i2)
       if(ianti.eq.1 .and. lb(i1).ge.1 .and. lb(i2).ge.1)then
         lb(ii) = -lb(ii)
           jj = i2
          if(ii .eq. i2)jj = i1
          if(lb(jj).eq.3)then
           lb(jj) = 5
          elseif(lb(jj).eq.5)then
           lb(jj) = 3
          endif
         endif
       endif
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
50          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.E-09
          PR=SQRT(PR2)/(2.*SRT)
*          C1   = 1.0 - 2.0 * RANART(NSEED)

clin-10/25/02 get rid of argument usage mismatch in PTR():
          xptr=0.33*pr
c         cc1=ptr(0.33*pr,iseed)
         cc1=ptr(xptr,iseed)
clin-10/25/02-end

clin-9/2012: check argument in sqrt():
         scheck=pr**2-cc1**2
         if(scheck.lt.0) then
            write(99,*) 'scheck39: ', scheck
            scheck=0.
         endif
         c1=sqrt(scheck)/pr
c         c1=sqrt(pr**2-cc1**2)/pr

          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1 
* ROTATE THE MOMENTUM
       CALL ROTATE(PX0,PY0,PZ0,PX,PY,PZ)
      RETURN
      END
**********************************
* sp 03/19/01                                                          *
*                                                                      *
        SUBROUTINE Crlaba(PX,PY,PZ,SRT,brel,brsgm,
     &                        I1,I2,nt,IBLOCK,nchrg,icase)
*     PURPOSE:                                                         *
*            DEALING WITH   K+ + N(D,N*)-bar <-->  La(Si)-bar + pi     *
*     NOTE   :                                                         *
*                                                                      *
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                     8-> elastic scatt                               *
*                     100-> K+ + N-bar -> Sigma-bar + PI
*                     102-> PI + Sigma(Lambda)-bar -> K+ + N-bar
**********************************
        PARAMETER (MAXSTR=150001, MAXR=1, AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER  (AKA=0.498,ALA=1.1157,ASA=1.1974)
        PARAMETER  (ETAM=0.5475, AOMEGA=0.782, ARHO=0.77)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
c
      PX0=PX
      PY0=PY
      PZ0=PZ
c
      if(icase .eq. 3)then
         rrr=RANART(NSEED)
         if(rrr.lt.brel) then
c            !! elastic scat.  (avoid in reverse process)
            IBLOCK=8
        else 
            IBLOCK=100
            if(rrr.lt.(brel+brsgm)) then
c*    K+ + N-bar -> Sigma-bar + PI
               LB(i1) = -15 - int(3 * RANART(NSEED))

               e(i1)=asa
            else
c*    K+ + N-bar -> Lambda-bar + PI
               LB(i1)= -14  
               e(i1)=ala
            endif
            LB(i2) = 3 + int(3 * RANART(NSEED))
            e(i2)=0.138
        endif
      endif
c
c
      if(icase .eq. 4)then
         rrr=RANART(NSEED)
         if(rrr.lt.brel) then
c            !! elastic scat.
            IBLOCK=8
         else    
            IBLOCK=102
c    PI + Sigma(Lambda)-bar -> K+ + N-bar
c         ! K+
            LB(i1) = 23
            LB(i2) = -1 - int(2 * RANART(NSEED))
            if(nchrg.eq.-2) LB(i2) = -6
            if(nchrg.eq. 1) LB(i2) = -9
            e(i1) = aka
            e(i2) = 0.938
            if(nchrg.eq.-2.or.nchrg.eq.1) e(i2)=1.232
         endif
      endif
c
      EM1=E(I1)
      EM2=E(I2)
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
      PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1     - 4.0 * (EM1*EM2)**2
      IF(PR2.LE.0.)PR2=1.e-09
      PR=SQRT(PR2)/(2.*SRT)
      C1   = 1.0 - 2.0 * RANART(NSEED)
      T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
* ROTATE IT 
      CALL ROTATE(PX0,PY0,PZ0,PX,PY,PZ) 
      RETURN
      END
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE Crkn(PX,PY,PZ,SRT,I1,I2,IBLOCK)
*     PURPOSE:                                                         *
*             DEALING WITH kaON+N/pi-->KAON +N/pi elastic PROCESS      *
*     NOTE   :                                                         *
*          
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                     8-> PION+N-->L/S+KAON
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       PX0=PX
       PY0=PY
       PZ0=PZ
*-----------------------------------------------------------------------
        IBLOCK=8
        NTAG=0
        EM1=E(I1)
        EM2=E(I2)
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
      RETURN
      END
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE Crppba(PX,PY,PZ,SRT,I1,I2,IBLOCK)
*     PURPOSE:                                                         *

clin-8/29/00*             DEALING WITH anti-nucleon annihilation with 
*             DEALING WITH anti-baryon annihilation with 

*             nucleons or baryon resonances
*             Determine:                                               *
*             (1) no. of pions in the final state
*             (2) relable particles in the final state
*             (3) new momenta of final state particles                 *
*                  
*     QUANTITIES:                                                      *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - INFORMATION about the reaction channel          *
*                
*           iblock   - 1902 annihilation-->pion(+)+pion(-)   (2 pion)
*           iblock   - 1903 annihilation-->pion(+)+rho(-)    (3 pion)
*           iblock   - 1904 annihilation-->rho(+)+rho(-)     (4 pion)
*           iblock   - 1905 annihilation-->rho(0)+omega      (5 pion)
*           iblock   - 1906 annihilation-->omega+omega       (6 pion)
*       charge conservation is enforced in relabling particles 
*       in the final state (note: at the momentum we don't check the
*       initial charges while dealing with annihilation, since some
*       annihilation channels between antinucleons and nucleons (baryon
*       resonances) might be forbiden by charge conservation, this effect
*       should be small, but keep it in mind.
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AMRHO=0.769,AMOMGA=0.782,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       PX0=PX
       PY0=PY
       PZ0=PZ
* determine the no. of pions in the final state using a 
* statistical model
       call pbarfs(srt,npion,iseed)
* find the masses of the final state particles before calculate 
* their momenta, and relable them. The masses of rho and omega 
* will be generated according to the Breit Wigner formula       (NOTE!!!
* NOT DONE YET, AT THE MOMENT LET US USE FIXED RHO AND OMEGA MAEES)
cbali2/22/99
* Here we generate two stes of integer random numbers (3,4,5)
* one or both of them are used directly as the lables of pions
* similarly, 22+nchrg1 and 22+nchrg2 are used directly 
* to label rhos  
       nchrg1=3+int(3*RANART(NSEED))
       nchrg2=3+int(3*RANART(NSEED))
* the corresponding masses of pions
      pmass1=ap1
       pmass2=ap1
       if(nchrg1.eq.3.or.nchrg1.eq.5)pmass1=ap2
       if(nchrg2.eq.3.or.nchrg2.eq.5)pmass2=ap2
* (1) for 2 pion production
       IF(NPION.EQ.2)THEN 
       IBLOCK=1902
* randomly generate the charges of final state particles,
       LB(I1)=nchrg1
       E(I1)=pmass1
       LB(I2)=nchrg2
       E(I2)=pmass2
* TO CALCULATE THE FINAL MOMENTA
       GO TO 50
       ENDIF
* (2) FOR 3 PION PRODUCTION
       IF(NPION.EQ.3)THEN 
       IBLOCK=1903
       LB(I1)=nchrg1
       E(I1)=pmass1
       LB(I2)=22+nchrg2
            E(I2)=AMRHO
       GO TO 50
       ENDIF
* (3) FOR 4 PION PRODUCTION
* we allow both rho+rho and pi+omega with 50-50% probability
        IF(NPION.EQ.4)THEN 
       IBLOCK=1904
* determine rho+rho or pi+omega
       if(RANART(NSEED).ge.0.5)then
* rho+rho  
       LB(I1)=22+nchrg1
       E(I1)=AMRHO
       LB(I2)=22+nchrg2
            E(I2)=AMRHO
       else
* pion+omega
       LB(I1)=nchrg1
       E(I1)=pmass1
       LB(I2)=28
            E(I2)=AMOMGA
       endif
       GO TO 50
       ENDIF
* (4) FOR 5 PION PRODUCTION
        IF(NPION.EQ.5)THEN 
       IBLOCK=1905
* RHO AND OMEGA
        LB(I1)=22+nchrg1
       E(I1)=AMRHO
       LB(I2)=28
       E(I2)=AMOMGA
       GO TO 50
       ENDIF
* (5) FOR 6 PION PRODUCTION
         IF(NPION.EQ.6)THEN 
       IBLOCK=1906
* OMEGA AND OMEGA
        LB(I1)=28
       E(I1)=AMOMGA
       LB(I2)=28
          E(I2)=AMOMGA
       ENDIF
cbali2/22/99
50    EM1=E(I1)
      EM2=E(I2)
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.E-08
          PR=SQRT(PR2)/(2.*SRT)
* WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS 
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
* ROTATE IT 
       CALL ROTATE(PX0,PY0,PZ0,PX,PY,PZ) 
      RETURN
      END
cbali2/7/99end
cbali3/5/99
**********************************
*     PURPOSE:                                                         *
*     assign final states for K+K- --> light mesons
*
      SUBROUTINE crkkpi(I1,I2,XSK1, XSK2, XSK3, XSK4,
     &             XSK5, XSK6, XSK7, XSK8, XSK9, XSK10, XSK11, SIGK,
     &             IBLOCK,lbp1,lbp2,emm1,emm2)
*
*     QUANTITIES:                                                     *
*           IBLOCK   - INFORMATION about the reaction channel          *
*                
*             iblock   - 1907
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AMRHO=0.769,AMOMGA=0.782,
     &  AMETA = 0.5473,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       IBLOCK=1907
        X1 = RANART(NSEED) * SIGK
        XSK2 = XSK1 + XSK2
        XSK3 = XSK2 + XSK3
        XSK4 = XSK3 + XSK4
        XSK5 = XSK4 + XSK5
        XSK6 = XSK5 + XSK6
        XSK7 = XSK6 + XSK7
        XSK8 = XSK7 + XSK8
        XSK9 = XSK8 + XSK9
        XSK10 = XSK9 + XSK10
        IF (X1 .LE. XSK1) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 3 + int(3 * RANART(NSEED))
           E(I1) = AP2
           E(I2) = AP2
           GOTO 100
        ELSE IF (X1 .LE. XSK2) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 25 + int(3 * RANART(NSEED))
           E(I1) = AP2
           E(I2) = AMRHO
           GOTO 100
        ELSE IF (X1 .LE. XSK3) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 28
           E(I1) = AP2
           E(I2) = AMOMGA
           GOTO 100
        ELSE IF (X1 .LE. XSK4) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 0
           E(I1) = AP2
           E(I2) = AMETA
           GOTO 100
        ELSE IF (X1 .LE. XSK5) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = 25 + int(3 * RANART(NSEED))
           E(I1) = AMRHO
           E(I2) = AMRHO
           GOTO 100
        ELSE IF (X1 .LE. XSK6) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = 28
           E(I1) = AMRHO
           E(I2) = AMOMGA
           GOTO 100
        ELSE IF (X1 .LE. XSK7) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = 0
           E(I1) = AMRHO
           E(I2) = AMETA
           GOTO 100
        ELSE IF (X1 .LE. XSK8) THEN
           LB(I1) = 28
           LB(I2) = 28
           E(I1) = AMOMGA
           E(I2) = AMOMGA
           GOTO 100
        ELSE IF (X1 .LE. XSK9) THEN
           LB(I1) = 28
           LB(I2) = 0
           E(I1) = AMOMGA
           E(I2) = AMETA
           GOTO 100
        ELSE IF (X1 .LE. XSK10) THEN
           LB(I1) = 0
           LB(I2) = 0
           E(I1) = AMETA
           E(I2) = AMETA
        ELSE
          iblock = 222
          call rhores(i1,i2)
c     !! phi
          lb(i1) = 29
c          return
          e(i2)=0.
        END IF

 100    CONTINUE
        lbp1=lb(i1)
        lbp2=lb(i2)
        emm1=e(i1)
        emm2=e(i2)

      RETURN
      END
**********************************
*     PURPOSE:                                                         *
*             DEALING WITH K+Y -> piN scattering
*
      SUBROUTINE Crkhyp(PX,PY,PZ,SRT,I1,I2,
     &     XKY1, XKY2, XKY3, XKY4, XKY5,
     &     XKY6, XKY7, XKY8, XKY9, XKY10, XKY11, XKY12, XKY13,
     &     XKY14, XKY15, XKY16, XKY17, SIGK, IKMP,
     &     IBLOCK)
*
*             Determine:                                               *
*             (1) relable particles in the final state                 *
*             (2) new momenta of final state particles                 *
*                                                                        *
*     QUANTITIES:                                                    *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - INFORMATION about the reaction channel          *
*                                                                     *
*             iblock   - 1908                                          *
*             iblock   - 222   !! phi                                  *
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AMRHO=0.769,AMOMGA=0.782,APHI=1.02,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
          parameter (pimass=0.140, AMETA = 0.5473, aka=0.498,
     &     aml=1.116,ams=1.193, AM1440 = 1.44, AM1535 = 1.535)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       PX0=PX
       PY0=PY
       PZ0=PZ
       IBLOCK=1908
c
        X1 = RANART(NSEED) * SIGK
        XKY2 = XKY1 + XKY2
        XKY3 = XKY2 + XKY3
        XKY4 = XKY3 + XKY4
        XKY5 = XKY4 + XKY5
        XKY6 = XKY5 + XKY6
        XKY7 = XKY6 + XKY7
        XKY8 = XKY7 + XKY8
        XKY9 = XKY8 + XKY9
        XKY10 = XKY9 + XKY10
        XKY11 = XKY10 + XKY11
        XKY12 = XKY11 + XKY12
        XKY13 = XKY12 + XKY13
        XKY14 = XKY13 + XKY14
        XKY15 = XKY14 + XKY15
        XKY16 = XKY15 + XKY16
        IF (X1 .LE. XKY1) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 1 + int(2 * RANART(NSEED))
           E(I1) = PIMASS
           E(I2) = AMP
           GOTO 100
        ELSE IF (X1 .LE. XKY2) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 6 + int(4 * RANART(NSEED))
           E(I1) = PIMASS
           E(I2) = AM0
           GOTO 100
        ELSE IF (X1 .LE. XKY3) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 10 + int(2 * RANART(NSEED))
           E(I1) = PIMASS
           E(I2) = AM1440
           GOTO 100
        ELSE IF (X1 .LE. XKY4) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 12 + int(2 * RANART(NSEED))
           E(I1) = PIMASS
           E(I2) = AM1535
           GOTO 100
        ELSE IF (X1 .LE. XKY5) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = 1 + int(2 * RANART(NSEED))
           E(I1) = AMRHO
           E(I2) = AMP
           GOTO 100
        ELSE IF (X1 .LE. XKY6) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = 6 + int(4 * RANART(NSEED))
           E(I1) = AMRHO
           E(I2) = AM0
           GOTO 100
        ELSE IF (X1 .LE. XKY7) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = 10 + int(2 * RANART(NSEED))
           E(I1) = AMRHO
           E(I2) = AM1440
           GOTO 100
        ELSE IF (X1 .LE. XKY8) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = 12 + int(2 * RANART(NSEED))
           E(I1) = AMRHO
           E(I2) = AM1535
           GOTO 100
        ELSE IF (X1 .LE. XKY9) THEN
           LB(I1) = 28
           LB(I2) = 1 + int(2 * RANART(NSEED))
           E(I1) = AMOMGA
           E(I2) = AMP
           GOTO 100
        ELSE IF (X1 .LE. XKY10) THEN
           LB(I1) = 28
           LB(I2) = 6 + int(4 * RANART(NSEED))
           E(I1) = AMOMGA
           E(I2) = AM0
           GOTO 100
        ELSE IF (X1 .LE. XKY11) THEN
           LB(I1) = 28
           LB(I2) = 10 + int(2 * RANART(NSEED))
           E(I1) = AMOMGA
           E(I2) = AM1440
           GOTO 100
        ELSE IF (X1 .LE. XKY12) THEN
           LB(I1) = 28
           LB(I2) = 12 + int(2 * RANART(NSEED))
           E(I1) = AMOMGA
           E(I2) = AM1535
           GOTO 100
        ELSE IF (X1 .LE. XKY13) THEN
           LB(I1) = 0
           LB(I2) = 1 + int(2 * RANART(NSEED))
           E(I1) = AMETA
           E(I2) = AMP
           GOTO 100
        ELSE IF (X1 .LE. XKY14) THEN
           LB(I1) = 0
           LB(I2) = 6 + int(4 * RANART(NSEED))
           E(I1) = AMETA
           E(I2) = AM0
           GOTO 100
        ELSE IF (X1 .LE. XKY15) THEN
           LB(I1) = 0
           LB(I2) = 10 + int(2 * RANART(NSEED))
           E(I1) = AMETA
           E(I2) = AM1440
           GOTO 100
        ELSE IF (X1 .LE. XKY16) THEN
           LB(I1) = 0
           LB(I2) = 12 + int(2 * RANART(NSEED))
           E(I1) = AMETA
           E(I2) = AM1535
           GOTO 100
        ELSE
           LB(I1) = 29
           LB(I2) = 1 + int(2 * RANART(NSEED))
           E(I1) = APHI
           E(I2) = AMN
          IBLOCK=222
           GOTO 100
        END IF

 100    CONTINUE
         if(IKMP .eq. -1) LB(I2) = -LB(I2)

      EM1=E(I1)
      EM2=E(I2)
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.E-08
          PR=SQRT(PR2)/(2.*SRT)
* WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS 
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
* ROTATE IT 
       CALL ROTATE(PX0,PY0,PZ0,PX,PY,PZ) 
      RETURN
      END
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE CRLAN(PX,PY,PZ,SRT,I1,I2,IBLOCK)
*     PURPOSE:                                                         *
*      DEALING WITH La/Si-bar + N --> K+ + pi PROCESS                  *
*                   La/Si + N-bar --> K- + pi                          *
*     NOTE   :                                                         *
*
*     QUANTITIES:                                                      *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                      71
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

        PX0=PX
        PY0=PY                                                          
        PZ0=PZ
        IBLOCK=71
        NTAG=0
       if( (lb(i1).ge.14.and.lb(i1).le.17) .OR.
     &     (lb(i2).ge.14.and.lb(i2).le.17) )then
        LB(I1)=21
       else
        LB(I1)=23
       endif
        LB(I2)= 3 + int(3 * RANART(NSEED))
        E(I1)=AKA
        E(I2)=0.138
        EM1=E(I1)
        EM2=E(I2)
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
        PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1
      PY   = PR * S1*ST1
* FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
      RETURN
      END
csp11/03/01 end
********************************** 
**********************************
*                                                                      *
*                                                                      *
        SUBROUTINE Crkpla(PX,PY,PZ,EC,SRT,spika,
     &                  emm1,emm2,lbp1,lbp2,I1,I2,icase,srhoks)
 
*     PURPOSE:                                                         *
*     DEALING WITH  K+ + Pi ---> La/Si-bar + B, phi+K, phi+K* OR  K* *
*                   K- + Pi ---> La/Si + B-bar  OR   K*-bar          *
 
*     NOTE   :                                                         *
*
*     QUANTITIES:                                                      *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                      71
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AP2=0.13957,AMRHO=0.769,AMOMGA=0.782,
     2  AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER (AKA=0.498,AKS=0.895,ALA=1.1157,ASA=1.1974
     1 ,APHI=1.02)
        PARAMETER (AM1440 = 1.44, AM1535 = 1.535)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

          emm1=0.
          emm2=0.
          lbp1=0
          lbp2=0
           XKP0 = spika
           XKP1 = 0.
           XKP2 = 0.
           XKP3 = 0.
           XKP4 = 0.
           XKP5 = 0.
           XKP6 = 0.
           XKP7 = 0.
           XKP8 = 0.
           XKP9 = 0.
           XKP10 = 0.
           sigm = 15.
c         if(lb(i1).eq.21.or.lb(i2).eq.21)sigm=10.
        pdd = (srt**2-(aka+ap1)**2)*(srt**2-(aka-ap1)**2)
c
         if(srt .lt. (ala+amn))go to 70
        XKP1 = sigm*(4./3.)*(srt**2-(ala+amn)**2)*
     &           (srt**2-(ala-amn)**2)/pdd
         if(srt .gt. (ala+am0))then
        XKP2 = sigm*(16./3.)*(srt**2-(ala+am0)**2)*
     &           (srt**2-(ala-am0)**2)/pdd
         endif
         if(srt .gt. (ala+am1440))then
        XKP3 = sigm*(4./3.)*(srt**2-(ala+am1440)**2)*
     &           (srt**2-(ala-am1440)**2)/pdd
         endif
         if(srt .gt. (ala+am1535))then
        XKP4 = sigm*(4./3.)*(srt**2-(ala+am1535)**2)*
     &           (srt**2-(ala-am1535)**2)/pdd
         endif
c
         if(srt .gt. (asa+amn))then
        XKP5 = sigm*4.*(srt**2-(asa+amn)**2)*
     &           (srt**2-(asa-amn)**2)/pdd
         endif
         if(srt .gt. (asa+am0))then
        XKP6 = sigm*16.*(srt**2-(asa+am0)**2)*
     &           (srt**2-(asa-am0)**2)/pdd
         endif
         if(srt .gt. (asa+am1440))then
        XKP7 = sigm*4.*(srt**2-(asa+am1440)**2)*
     &           (srt**2-(asa-am1440)**2)/pdd
         endif
         if(srt .gt. (asa+am1535))then
        XKP8 = sigm*4.*(srt**2-(asa+am1535)**2)*
     &           (srt**2-(asa-am1535)**2)/pdd
         endif
70     continue
          sig1 = 195.639
          sig2 = 372.378
       if(srt .gt. aphi+aka)then
        pff = sqrt((srt**2-(aphi+aka)**2)*(srt**2-(aphi-aka)**2))

clin-9/2012: check argument in sqrt():
        scheck=pdd
        if(scheck.le.0) then
           write(99,*) 'scheck40: ', scheck
           stop
        endif
        
         XKP9 = sig1*pff/sqrt(pdd)*1./32./pi/srt**2
        if(srt .gt. aphi+aks)then
        pff = sqrt((srt**2-(aphi+aks)**2)*(srt**2-(aphi-aks)**2))

clin-9/2012: check argument in sqrt():
        scheck=pdd
        if(scheck.le.0) then
           write(99,*) 'scheck41: ', scheck
           stop
        endif

         XKP10 = sig2*pff/sqrt(pdd)*3./32./pi/srt**2
       endif
        endif

clin-8/15/02 K pi -> K* (rho omega), from detailed balance, 
c neglect rho and omega mass difference for now:
        sigpik=0.
        if(srt.gt.(amrho+aks)) then
           sigpik=srhoks*9.
     1          *(srt**2-(0.77-aks)**2)*(srt**2-(0.77+aks)**2)/4
     2          /srt**2/(px**2+py**2+pz**2)
           if(srt.gt.(amomga+aks)) sigpik=sigpik*12./9.
        endif

c
         sigkp = XKP0 + XKP1 + XKP2 + XKP3 + XKP4
     &         + XKP5 + XKP6 + XKP7 + XKP8 + XKP9 + XKP10 +sigpik
           icase = 0 
         DSkn=SQRT(sigkp/PI/10.)
        dsknr=dskn+0.1
        CALL DISTCE(I1,I2,dsknr,DSkn,DT,EC,SRT,IC,
     1  PX,PY,PZ)
        IF(IC.EQ.-1)return
c
        randu = RANART(NSEED)*sigkp
        XKP1 = XKP0 + XKP1
        XKP2 = XKP1 + XKP2
        XKP3 = XKP2 + XKP3
        XKP4 = XKP3 + XKP4
        XKP5 = XKP4 + XKP5
        XKP6 = XKP5 + XKP6
        XKP7 = XKP6 + XKP7
        XKP8 = XKP7 + XKP8
        XKP9 = XKP8 + XKP9

        XKP10 = XKP9 + XKP10
c
c   !! K* formation
         if(randu .le. XKP0)then
           icase = 1
            return
         else
* La/Si-bar + B formation
           icase = 2
         if( randu .le. XKP1 )then
             lbp1 = -14
             lbp2 = 1 + int(2*RANART(NSEED))
             emm1 = ala
             emm2 = amn
             go to 60
         elseif( randu .le. XKP2 )then
             lbp1 = -14
             lbp2 = 6 + int(4*RANART(NSEED))
             emm1 = ala
             emm2 = am0
             go to 60
         elseif( randu .le. XKP3 )then
             lbp1 = -14
             lbp2 = 10 + int(2*RANART(NSEED))
             emm1 = ala
             emm2 = am1440
             go to 60
         elseif( randu .le. XKP4 )then
             lbp1 = -14
             lbp2 = 12 + int(2*RANART(NSEED))
             emm1 = ala
             emm2 = am1535
             go to 60
         elseif( randu .le. XKP5 )then
             lbp1 = -15 - int(3*RANART(NSEED))
             lbp2 = 1 + int(2*RANART(NSEED))
             emm1 = asa
             emm2 = amn
             go to 60
         elseif( randu .le. XKP6 )then
             lbp1 = -15 - int(3*RANART(NSEED))
             lbp2 = 6 + int(4*RANART(NSEED))
             emm1 = asa
             emm2 = am0
             go to 60
          elseif( randu .lt. XKP7 )then
             lbp1 = -15 - int(3*RANART(NSEED))
             lbp2 = 10 + int(2*RANART(NSEED))
             emm1 = asa
             emm2 = am1440
             go to 60
          elseif( randu .lt. XKP8 )then
             lbp1 = -15 - int(3*RANART(NSEED))
             lbp2 = 12 + int(2*RANART(NSEED))
             emm1 = asa
             emm2 = am1535
             go to 60
          elseif( randu .lt. XKP9 )then
c       !! phi +K  formation (iblock=224)
            icase = 3
             lbp1 = 29
             lbp2 = 23
             emm1 = aphi
             emm2 = aka
           if(lb(i1).eq.21.or.lb(i2).eq.21)then
c         !! phi +K-bar  formation (iblock=124)
             lbp2 = 21
             icase = -3
           endif
             go to 60
          elseif( randu .lt. XKP10 )then
c       !! phi +K* formation (iblock=226)
            icase = 4
             lbp1 = 29
             lbp2 = 30
             emm1 = aphi
             emm2 = aks
           if(lb(i1).eq.21.or.lb(i2).eq.21)then
             lbp2 = -30
             icase = -4
           endif
           go to 60

          else
c       !! (rho,omega) +K* formation (iblock=88)
            icase=5
            lbp1=25+int(3*RANART(NSEED))
            lbp2=30
            emm1=amrho
            emm2=aks
            if(srt.gt.(amomga+aks).and.RANART(NSEED).lt.0.25) then
               lbp1=28
               emm1=amomga
            endif
            if(lb(i1).eq.21.or.lb(i2).eq.21)then
               lbp2=-30
               icase=-5
            endif

          endif
          endif
c
60       if( icase.eq.2 .and. (lb(i1).eq.21.or.lb(i2).eq.21) )then
            lbp1 = -lbp1
            lbp2 = -lbp2
         endif
        PX0=PX
        PY0=PY
        PZ0=PZ
*-----------------------------------------------------------------------       
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
           PR2   = (SRT**2 - EMM1**2 - EMM2**2)**2
     1                - 4.0 * (EMM1*EMM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1
      PY   = PR * S1*ST1
* FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
      RETURN
      END
**********************************       
*                                                                      *
*                                                                      *
        SUBROUTINE Crkphi(PX,PY,PZ,EC,SRT,IBLOCK,
     &                  emm1,emm2,lbp1,lbp2,I1,I2,ikk,icase,rrkk,prkk)
 
*     PURPOSE:                                                         *
*     DEALING WITH   KKbar, KK*bar, KbarK*, K*K*bar --> Phi + pi(rho,omega)
*     and KKbar --> (pi eta) (pi eta), (rho omega) (rho omega)
*     and KK*bar or Kbar K* --> (pi eta) (rho omega)
*
*     NOTE   :                                                         *
*
*     QUANTITIES:                                                      *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                      222
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AP2=0.13957,APHI=1.02,
     2  AM0=1.232,AMNS=1.52,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974,ACAS=1.3213)
        PARAMETER      (AKS=0.895,AOMEGA=0.7819, ARHO=0.77)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

        lb1 = lb(i1) 
        lb2 = lb(i2) 
        icase = 0

c        if(srt .lt. aphi+ap1)return
cc        if(srt .lt. aphi+ap1) then
        if(srt .lt. (aphi+ap1)) then
           sig1 = 0.
           sig2 = 0.
           sig3 = 0.
        else
c
         if((lb1.eq.23.and.lb2.eq.21).or.(lb2.eq.23.and.lb1.eq.21))then
            dnr =  4.
            ikk = 2
          elseif((lb1.eq.21.and.lb2.eq.30).or.(lb2.eq.21.and.lb1.eq.30)
     & .or.(lb1.eq.23.and.lb2.eq.-30).or.(lb2.eq.23.and.lb1.eq.-30))then
             dnr = 12.
             ikk = 1
          else
             dnr = 36.
             ikk = 0
          endif
              
          sig1 = 0.
          sig2 = 0.
          sig3 = 0.
          srri = E(i1)+E(i2)
          srr1 = aphi+ap1
          srr2 = aphi+aomega
          srr3 = aphi+arho
c
          pii = (srt**2-(e(i1)+e(i2))**2)*(srt**2-(e(i1)-e(i2))**2)
          srrt = srt - amax1(srri,srr1)
cc   to avoid divergent/negative values at small srrt:
c          if(srrt .lt. 0.3)then
          if(srrt .lt. 0.3 .and. srrt .gt. 0.01)then
          sig = 1.69/(srrt**0.141 - 0.407)
         else
          sig = 3.74 + 0.008*srrt**1.9
         endif                 
          sig1=sig*(9./dnr)*(srt**2-(aphi+ap1)**2)*
     &           (srt**2-(aphi-ap1)**2)/pii
          if(srt .gt. aphi+aomega)then
          srrt = srt - amax1(srri,srr2)
cc         if(srrt .lt. 0.3)then
          if(srrt .lt. 0.3 .and. srrt .gt. 0.01)then
          sig = 1.69/(srrt**0.141 - 0.407)
         else
          sig = 3.74 + 0.008*srrt**1.9
         endif                 
          sig2=sig*(9./dnr)*(srt**2-(aphi+aomega)**2)*
     &           (srt**2-(aphi-aomega)**2)/pii
           endif
         if(srt .gt. aphi+arho)then
          srrt = srt - amax1(srri,srr3)
cc         if(srrt .lt. 0.3)then
          if(srrt .lt. 0.3 .and. srrt .gt. 0.01)then
          sig = 1.69/(srrt**0.141 - 0.407)
         else
          sig = 3.74 + 0.008*srrt**1.9
         endif                 
          sig3=sig*(27./dnr)*(srt**2-(aphi+arho)**2)*
     &           (srt**2-(aphi-arho)**2)/pii
         endif                 
c         sig1 = amin1(20.,sig1)
c         sig2 = amin1(20.,sig2)
c         sig3 = amin1(20.,sig3)
        endif

        rrkk0=rrkk
        prkk0=prkk
        SIGM=0.
        if((lb1.eq.23.and.lb2.eq.21).or.(lb2.eq.23.and.lb1.eq.21))then
           CALL XKKANN(SRT, XSK1, XSK2, XSK3, XSK4, XSK5,
     &          XSK6, XSK7, XSK8, XSK9, XSK10, XSK11, SIGM, rrkk0)
        elseif((lb1.eq.21.and.lb2.eq.30).or.(lb2.eq.21.and.lb1.eq.30)
     & .or.(lb1.eq.23.and.lb2.eq.-30).or.(lb2.eq.23.and.lb1.eq.-30))then
           CALL XKKSAN(i1,i2,SRT,SIGKS1,SIGKS2,SIGKS3,SIGKS4,SIGM,prkk0)
        else
        endif
c
c         sigks = sig1 + sig2 + sig3
        sigm0=sigm
        sigks = sig1 + sig2 + sig3 + SIGM
        DSkn=SQRT(sigks/PI/10.)
        dsknr=dskn+0.1
        CALL DISTCE(I1,I2,dsknr,DSkn,DT,EC,SRT,IC,
     1  PX,PY,PZ)
        IF(IC.EQ.-1)return
        icase = 1
        ranx = RANART(NSEED) 

        lbp1 = 29
        emm1 = aphi
        if(ranx .le. sig1/sigks)then 
           lbp2 = 3 + int(3*RANART(NSEED))
           emm2 = ap1
        elseif(ranx .le. (sig1+sig2)/sigks)then
           lbp2 = 28
           emm2 = aomega
        elseif(ranx .le. (sig1+sig2+sig3)/sigks)then
           lbp2 = 25 + int(3*RANART(NSEED))
           emm2 = arho
        else
           if((lb1.eq.23.and.lb2.eq.21)
     &          .or.(lb2.eq.23.and.lb1.eq.21))then
              CALL crkkpi(I1,I2,XSK1, XSK2, XSK3, XSK4,
     &             XSK5, XSK6, XSK7, XSK8, XSK9, XSK10, XSK11, SIGM0,
     &             IBLOCK,lbp1,lbp2,emm1,emm2)
           elseif((lb1.eq.21.and.lb2.eq.30)
     &             .or.(lb2.eq.21.and.lb1.eq.30)
     &             .or.(lb1.eq.23.and.lb2.eq.-30)
     &             .or.(lb2.eq.23.and.lb1.eq.-30))then
              CALL crkspi(I1,I2,SIGKS1, SIGKS2, SIGKS3, SIGKS4,
     &             SIGM0,IBLOCK,lbp1,lbp2,emm1,emm2)
           else
           endif
        endif
*
        PX0=PX
        PY0=PY
        PZ0=PZ
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
           PR2   = (SRT**2 - EMM1**2 - EMM2**2)**2
     1                - 4.0 * (EMM1*EMM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1
      PY   = PR * S1*ST1
* FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
      RETURN
      END
csp11/21/01 end
**********************************
*                                                                      *
*                                                                      *
        SUBROUTINE Crksph(PX,PY,PZ,EC,SRT,
     &     emm1,emm2,lbp1,lbp2,I1,I2,ikkg,ikkl,iblock,
     &     icase,srhoks)
 
*     PURPOSE:                                                         *
*     DEALING WITH   K + rho(omega) or K* + pi(rho,omega) 
*                    --> Phi + K(K*), pi + K* or pi + K, and elastic 
*     NOTE   :                                                         *
*
*     QUANTITIES:                                                      *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                      222
*                      223 --> phi + pi(rho,omega)
*                      224 --> phi + K <-> K + pi(rho,omega)
*                      225 --> phi + K <-> K* + pi(rho,omega)
*                      226 --> phi + K* <-> K + pi(rho,omega)
*                      227 --> phi + K* <-> K* + pi(rho,omega)
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AP2=0.13957,APHI=1.02,
     2  AM0=1.232,AMNS=1.52,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974,ACAS=1.3213)
        PARAMETER      (AKS=0.895,AOMEGA=0.7819, ARHO=0.77)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

        lb1 = lb(i1) 
        lb2 = lb(i2) 
        icase = 0
        sigela=10.
        sigkm=0.
c     K(K*) + rho(omega) -> pi K*(K)
        if((lb1.ge.25.and.lb1.le.28).or.(lb2.ge.25.and.lb2.le.28)) then
           if(iabs(lb1).eq.30.or.iabs(lb2).eq.30) then
              sigkm=srhoks
clin-2/26/03 check whether (rho K) is above the (pi K*) thresh:
           elseif((lb1.eq.23.or.lb1.eq.21.or.lb2.eq.23.or.lb2.eq.21)
     1             .and.srt.gt.(ap2+aks)) then
              sigkm=srhoks
           endif
        endif

c        if(srt .lt. aphi+aka)return
        if(srt .lt. (aphi+aka)) then
           sig11=0.
           sig22=0.
        else

c K*-bar +pi --> phi + (K,K*)-bar
         if( (iabs(lb1).eq.30.and.(lb2.ge.3.and.lb2.le.5)) .or.
     &       (iabs(lb2).eq.30.and.(lb1.ge.3.and.lb1.le.5)) )then
              dnr =  18.
              ikkl = 0
              IBLOCK = 225
c               sig1 = 15.0  
c               sig2 = 30.0  
clin-2/06/03 these large values reduces to ~10 mb for sig11 or sig22
c     due to the factors of ~1/(32*pi*s)~1/200:
               sig1 = 2047.042  
               sig2 = 1496.692
c K(-bar)+rho --> phi + (K,K*)-bar
       elseif((lb1.eq.23.or.lb1.eq.21.and.(lb2.ge.25.and.lb2.le.27)).or.
     &      (lb2.eq.23.or.lb2.eq.21.and.(lb1.ge.25.and.lb1.le.27)) )then
              dnr =  18.
              ikkl = 1
              IBLOCK = 224
c               sig1 = 3.5  
c               sig2 = 9.0  
               sig1 = 526.702
               sig2 = 1313.960
c K*(-bar) +rho
         elseif( (iabs(lb1).eq.30.and.(lb2.ge.25.and.lb2.le.27)) .or.
     &           (iabs(lb2).eq.30.and.(lb1.ge.25.and.lb1.le.27)) )then
              dnr =  54.
              ikkl = 0
              IBLOCK = 225
c               sig1 = 3.5  
c               sig2 = 9.0  
               sig1 = 1371.257
               sig2 = 6999.840
c K(-bar) + omega
         elseif( ((lb1.eq.23.or.lb1.eq.21) .and. lb2.eq.28).or.
     &           ((lb2.eq.23.or.lb2.eq.21) .and. lb1.eq.28) )then
              dnr = 6.
              ikkl = 1
              IBLOCK = 224
c               sig1 = 3.5  
c               sig2 = 6.5  
               sig1 = 355.429
               sig2 = 440.558
c K*(-bar) +omega
          else
              dnr = 18.
              ikkl = 0
              IBLOCK = 225
c               sig1 = 3.5  
c               sig2 = 15.0  
               sig1 = 482.292
               sig2 = 1698.903
          endif

            sig11 = 0.
            sig22 = 0.
c         sig11=sig1*(6./dnr)*(srt**2-(aphi+aka)**2)*
c    &           (srt**2-(aphi-aka)**2)/(srt**2-(e(i1)+e(i2))**2)/
c    &           (srt**2-(e(i1)-e(i2))**2)

clin-9/2012: check argument in sqrt():
            scheck=(srt**2-(e(i1)+e(i2))**2)*(srt**2-(e(i1)-e(i2))**2)
            if(scheck.le.0) then
               write(99,*) 'scheck42: ', scheck
               stop
            endif
            pii=sqrt(scheck)
c        pii = sqrt((srt**2-(e(i1)+e(i2))**2)*(srt**2-(e(i1)-e(i2))**2))

clin-9/2012: check argument in sqrt():
            scheck=(srt**2-(aphi+aka)**2)*(srt**2-(aphi-aka)**2)
            if(scheck.lt.0) then
               write(99,*) 'scheck43: ', scheck
               scheck=0.
            endif
        pff = sqrt(scheck)
c        pff = sqrt((srt**2-(aphi+aka)**2)*(srt**2-(aphi-aka)**2))

          sig11 = sig1*pff/pii*6./dnr/32./pi/srt**2
c
          if(srt .gt. aphi+aks)then
c         sig22=sig2*(18./dnr)*(srt**2-(aphi+aks)**2)*
c    &           (srt**2-(aphi-aks)**2)/(srt**2-(e(i1)+e(i2))**2)/
c    &           (srt**2-(e(i1)-e(i2))**2)
        pff = sqrt((srt**2-(aphi+aks)**2)*(srt**2-(aphi-aks)**2))
          sig22 = sig2*pff/pii*18./dnr/32./pi/srt**2
           endif
c         sig11 = amin1(20.,sig11)
c         sig22 = amin1(20.,sig22)
c
        endif

c         sigks = sig11 + sig22
         sigks=sig11+sig22+sigela+sigkm
c
        DSkn=SQRT(sigks/PI/10.)
        dsknr=dskn+0.1
        CALL DISTCE(I1,I2,dsknr,DSkn,DT,EC,SRT,IC,
     1  PX,PY,PZ)
        IF(IC.EQ.-1)return
        icase = 1
        ranx = RANART(NSEED) 

         if(ranx .le. (sigela/sigks))then 
            lbp1=lb1
            emm1=e(i1)
            lbp2=lb2
            emm2=e(i2)
            iblock=111
         elseif(ranx .le. ((sigela+sigkm)/sigks))then 
            lbp1=3+int(3*RANART(NSEED))
            emm1=0.14
            if(lb1.eq.23.or.lb2.eq.23) then
               lbp2=30
               emm2=aks
            elseif(lb1.eq.21.or.lb2.eq.21) then
               lbp2=-30
               emm2=aks
            elseif(lb1.eq.30.or.lb2.eq.30) then
               lbp2=23
               emm2=aka
            else
               lbp2=21
               emm2=aka
            endif
            iblock=112
         elseif(ranx .le. ((sigela+sigkm+sig11)/sigks))then 
            lbp2 = 23
            emm2 = aka
            ikkg = 1
            if(lb1.eq.21.or.lb2.eq.21.or.lb1.eq.-30.or.lb2.eq.-30)then
               lbp2=21
               iblock=iblock-100
            endif
            lbp1 = 29
            emm1 = aphi
         else
            lbp2 = 30
            emm2 = aks
            ikkg = 0
            IBLOCK=IBLOCK+2
            if(lb1.eq.21.or.lb2.eq.21.or.lb1.eq.-30.or.lb2.eq.-30)then
               lbp2=-30
               iblock=iblock-100
            endif
            lbp1 = 29
            emm1 = aphi
         endif
*
        PX0=PX
        PY0=PY
        PZ0=PZ
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
           PR2   = (SRT**2 - EMM1**2 - EMM2**2)**2
     1                - 4.0 * (EMM1*EMM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1
      PY   = PR * S1*ST1
* FOR THE ISOTROPIC DISTRIBUTION THERE IS NO NEED TO ROTATE
      RETURN
      END
csp11/21/01 end
**********************************
********************************** 
        SUBROUTINE bbkaon(ic,SRT,PX,PY,PZ,ana,PlX,
     &  PlY,PlZ,ala,pkX,PkY,PkZ,icou1)
* purpose: generate the momenta for kaon,lambda/sigma and nucleon/delta
*          in the BB-->nlk process
* date: Sept. 9, 1994
c
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       PI=3.1415962
       icou1=0
       aka=0.498
        ala=1.116
       if(ic.eq.2.or.ic.eq.4)ala=1.197
       ana=0.939
* generate the mass of the delta
       if(ic.gt.2)then
       dmax=srt-aka-ala-0.02
        DM1=RMASS(DMAX,ISEED)
       ana=dm1
       endif
       t1=aka+ana+ala
       t2=ana+ala-aka
       if(srt.le.t1)then
       icou1=-1
       return
       endif
       pmax=sqrt((srt**2-t1**2)*(srt**2-t2**2))/(2.*srt)
       if(pmax.eq.0.)pmax=1.e-09
* (1) Generate the momentum of the kaon according to the distribution Fkaon
*     and assume that the angular distribution is isotropic       
*     in the cms of the colliding pair
       ntry=0
1       pk=pmax*RANART(NSEED)
       ntry=ntry+1
       prob=fkaon(pk,pmax)
       if((prob.lt.RANART(NSEED)).and.(ntry.le.40))go to 1
       cs=1.-2.*RANART(NSEED)
       ss=sqrt(1.-cs**2)
       fai=2.*3.14*RANART(NSEED)
       pkx=pk*ss*cos(fai)
       pky=pk*ss*sin(fai)
       pkz=pk*cs
* the energy of the kaon
       ek=sqrt(aka**2+pk**2)
* (2) Generate the momentum of the nucleon/delta in the cms of N/delta 
*     and lamda/sigma 
*  the energy of the cms of NL
        eln=srt-ek
       if(eln.le.0)then
       icou1=-1
       return
       endif
* beta and gamma of the cms of L/S+N
       bx=-pkx/eln
       by=-pky/eln
       bz=-pkz/eln

clin-9/2012: check argument in sqrt():
       scheck=1.-bx**2-by**2-bz**2
       if(scheck.le.0) then
          write(99,*) 'scheck44: ', scheck
          stop
       endif
       ga=1./sqrt(scheck)
c       ga=1./sqrt(1.-bx**2-by**2-bz**2)

        elnc=eln/ga
       pn2=((elnc**2+ana**2-ala**2)/(2.*elnc))**2-ana**2
       if(pn2.le.0.)pn2=1.e-09
       pn=sqrt(pn2)
       csn=1.-2.*RANART(NSEED)
       ssn=sqrt(1.-csn**2)
       fain=2.*3.14*RANART(NSEED)
       px=pn*ssn*cos(fain)
       py=pn*ssn*sin(fain)
       pz=pn*csn
       en=sqrt(ana**2+pn2)
* the momentum of the lambda/sigma in the n-l cms frame is
       plx=-px
       ply=-py
       plz=-pz
* (3) LORENTZ-TRANSFORMATION INTO nn cms FRAME for the neutron/delta
        PBETA  = PX*BX + PY*By+ PZ*Bz
              TRANS0  = GA * ( GA * PBETA / (GA + 1.) + En )
              Px = BX * TRANS0 + PX
              Py = BY * TRANS0 + PY
              Pz = BZ * TRANS0 + PZ
* (4) Lorentz-transformation for the lambda/sigma
       el=sqrt(ala**2+plx**2+ply**2+plz**2)
        PBETA  = PlX*BX + PlY*By+ PlZ*Bz
              TRANS0  = GA * ( GA * PBETA / (GA + 1.) + El )
              Plx = BX * TRANS0 + PlX
              Ply = BY * TRANS0 + PlY
              Plz = BZ * TRANS0 + PlZ
             return
             end
******************************************
* for pion+pion-->K+K-
c      real*4 function pipik(srt)
      real function pipik(srt)
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  NOTE: DEVIDE THE CROSS SECTION TO OBTAIN K+ PRODUCTION                     *
******************************************
c      real*4   xarray(5), earray(5)
      real   xarray(5), earray(5)
      SAVE   
      data xarray /0.001, 0.7,1.5,1.7,2.0/
      data earray /1.,1.2,1.6,2.0,2.4/

           pmass=0.9383 
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
       pipik=0.
       if(srt.le.1.)return
       if(srt.gt.2.4)then
           pipik=2.0/2.
           return
       endif
        if (srt .lt. earray(1)) then
           pipik =xarray(1)/2.
           return
        end if
*
* 2.Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,5
        if (earray(ie) .eq. srt) then
          pipik = xarray(ie)
          go to 10
        else if (earray(ie) .gt. srt) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          pipik = exp(ymin + (alog(srt)-xmin)*(ymax-ymin)
     &/(xmax-xmin) )
          go to 10
        end if
 1001 continue
10       PIPIK=PIPIK/2.
       continue
      return
        END
**********************************
* TOTAL PION-P INELASTIC CROSS SECTION 
*  from the CERN data book
*  date: Sept.2, 1994
*  for pion++p-->Delta+pion
c      real*4 function pionpp(srt)
      real function pionpp(srt)
      SAVE   
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in fm**2                                 *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*                                                                             *
******************************************
           pmass=0.14 
       pmass1=0.938
       PIONPP=0.00001
       IF(SRT.LE.1.22)RETURN
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
        plab=sqrt(((srt**2-pmass**2-pmass1**2)/(2.*pmass1))**2-pmass**2)
       pmin=0.3
       pmax=25.0
       if(plab.gt.pmax)then
       pionpp=20./10.
       return
       endif
        if(plab .lt. pmin)then
        pionpp = 0.
        return
        end if
c* fit parameters
       a=24.3
       b=-12.3
       c=0.324
       an=-1.91
       d=-2.44
        pionpp = a+b*(plab**an)+c*(alog(plab))**2+d*alog(plab)
       if(pionpp.le.0)pionpp=0
       pionpp=pionpp/10.
        return
        END
**********************************
* elementary cross sections
*  from the CERN data book
*  date: Sept.2, 1994
*  for pion-+p-->INELASTIC
c      real*4 function pipp1(srt)
      real function pipp1(srt)
      SAVE   
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in fm**2                                 *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*  UNITS: FM**2
******************************************
           pmass=0.14 
       pmass1=0.938
       PIPP1=0.0001
       IF(SRT.LE.1.22)RETURN
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
c      ekin = 2.*pmass*((srt/(2.*pmass))**2 - 1.)
        plab=sqrt(((srt**2-pmass**2-pmass1**2)/(2.*pmass1))**2-pmass**2)
       pmin=0.3
       pmax=25.0
       if(plab.gt.pmax)then
       pipp1=20./10.
       return
       endif
        if(plab .lt. pmin)then
        pipp1 = 0.
        return
        end if
c* fit parameters
       a=26.6
       b=-7.18
       c=0.327
       an=-1.86
       d=-2.81
        pipp1 = a+b*(plab**an)+c*(alog(plab))**2+d*alog(plab)
       if(pipp1.le.0)pipp1=0
       PIPP1=PIPP1/10.
        return
        END
* *****************************
c       real*4 function xrho(srt)
      real function xrho(srt)
      SAVE   
*       xsection for pp-->pp+rho
* *****************************
       pmass=0.9383
       rmass=0.77
       trho=0.151
       xrho=0.000000001
       if(srt.le.2.67)return
       ESMIN=2.*0.9383+rmass-trho/2.
       ES=srt
* the cross section for tho0 production is
       xrho0=0.24*(es-esmin)/(1.4+(es-esmin)**2)
       xrho=3.*Xrho0
       return
       end
* *****************************
c       real*4 function omega(srt)
      real function omega(srt)
      SAVE   
*       xsection for pp-->pp+omega
* *****************************
       pmass=0.9383
       omass=0.782
       tomega=0.0084
       omega=0.00000001
       if(srt.le.2.68)return
       ESMIN=2.*0.9383+omass-tomega/2.
       es=srt
       omega=0.36*(es-esmin)/(1.25+(es-esmin)**2)
       return
       end
******************************************
* for ppi(+)-->DELTA+pi
c      real*4 function TWOPI(srt)
      real function TWOPI(srt)
*  This function contains the experimental pi+p-->DELTA+PION cross sections   *
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*                                                                             *
******************************************
c      real*4   xarray(19), earray(19)
      real   xarray(19), earray(19)
      SAVE   
      data xarray /0.300E-05,0.187E+01,0.110E+02,0.149E+02,0.935E+01,
     &0.765E+01,0.462E+01,0.345E+01,0.241E+01,0.185E+01,0.165E+01,
     &0.150E+01,0.132E+01,0.117E+01,0.116E+01,0.100E+01,0.856E+00,
     &0.745E+00,0.300E-05/
      data earray /0.122E+01, 0.147E+01, 0.172E+01, 0.197E+01,
     &0.222E+01, 0.247E+01, 0.272E+01, 0.297E+01, 0.322E+01,
     &0.347E+01, 0.372E+01, 0.397E+01, 0.422E+01, 0.447E+01,
     &0.472E+01, 0.497E+01, 0.522E+01, 0.547E+01, 0.572E+01/

           pmass=0.14 
       pmass1=0.938
       TWOPI=0.000001
       if(srt.le.1.22)return
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
        plab=SRT
      if (plab .lt. earray(1)) then
        TWOPI= 0.00001
        return
      end if
*
* 2.Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,19
        if (earray(ie) .eq. plab) then
          TWOPI= xarray(ie)
          return
        else if (earray(ie) .gt. plab) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          TWOPI= exp(ymin + (alog(plab)-xmin)*(ymax-ymin)
     &    /(xmax-xmin) )
          return
        end if
 1001   continue
      return
        END
******************************************
******************************************
* for ppi(+)-->DELTA+RHO
c      real*4 function THREPI(srt)
      real function THREPI(srt)
*  This function contains the experimental pi+p-->DELTA + rho cross sections  *
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*                                                                             *
******************************************
c      real*4   xarray(15), earray(15)
      real   xarray(15), earray(15)
      SAVE   
      data xarray /8.0000000E-06,6.1999999E-05,1.881940,5.025690,    
     &11.80154,13.92114,15.07308,11.79571,11.53772,10.01197,9.792673,    
     &9.465264,8.970490,7.944254,6.886320/    
      data earray /0.122E+01, 0.147E+01, 0.172E+01, 0.197E+01,
     &0.222E+01, 0.247E+01, 0.272E+01, 0.297E+01, 0.322E+01,
     &0.347E+01, 0.372E+01, 0.397E+01, 0.422E+01, 0.447E+01,
     &0.472E+01/

           pmass=0.14 
       pmass1=0.938
       THREPI=0.000001
       if(srt.le.1.36)return
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
        plab=SRT
      if (plab .lt. earray(1)) then
        THREPI = 0.00001
        return
      end if
*
* 2.Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,15
        if (earray(ie) .eq. plab) then
          THREPI= xarray(ie)
          return
        else if (earray(ie) .gt. plab) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          THREPI = exp(ymin + (alog(plab)-xmin)*(ymax-ymin)
     &    /(xmax-xmin) )
          return
        end if
 1001   continue
      return
        END
******************************************
******************************************
* for ppi(+)-->DELTA+omega
c      real*4 function FOURPI(srt)
      real function FOURPI(srt)
*  This function contains the experimental pi+p-->DELTA+PION cross sections   *
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*                                                                             *
******************************************
c      real*4   xarray(10), earray(10)
      real   xarray(10), earray(10)
      SAVE   
      data xarray /0.0001,1.986597,6.411932,7.636956,    
     &9.598362,9.889740,10.24317,10.80138,11.86988,12.83925/    
      data earray /2.468,2.718,2.968,0.322E+01,
     &0.347E+01, 0.372E+01, 0.397E+01, 0.422E+01, 0.447E+01,
     &0.472E+01/

           pmass=0.14 
       pmass1=0.938
       FOURPI=0.000001
       if(srt.le.1.52)return
* 1.Calculate p(lab)  from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
        plab=SRT
      if (plab .lt. earray(1)) then
        FOURPI= 0.00001
        return
      end if
*
* 2.Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,10
        if (earray(ie) .eq. plab) then
          FOURPI= xarray(ie)
          return
        else if (earray(ie) .gt. plab) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          FOURPI= exp(ymin + (alog(plab)-xmin)*(ymax-ymin)
     &    /(xmax-xmin) )
          return
        end if
 1001   continue
      return
        END
******************************************
******************************************
* for pion (rho or omega)+baryon resonance collisions
c      real*4 function reab(i1,i2,srt,ictrl)
      real function reab(i1,i2,srt,ictrl)
*  This function calculates the cross section for 
*  pi+Delta(N*)-->N+PION process                                              *
*  srt    = DSQRT(s) in GeV                                                   *
*  reab   = cross section in fm**2                                            *
*  ictrl=1,2,3 for pion, rho and omega+D(N*)    
****************************************
      PARAMETER (MAXSTR=150001,MAXR=1,PI=3.1415926)
      parameter      (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
      PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
      parameter      (amn=0.938,ap1=0.14,arho=0.77,aomega=0.782)
       parameter       (maxx=20,maxz=24)
      COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
      COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      COMMON  /EE/      ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      SAVE   
       LB1=LB(I1)
       LB2=LB(I2)
       reab=0
       if(ictrl.eq.1.and.srt.le.(amn+2.*ap1+0.02))return
       if(ictrl.eq.3.and.srt.le.(amn+ap1+aomega+0.02))return
       pin2=((srt**2+ap1**2-amn**2)/(2.*srt))**2-ap1**2
       if(pin2.le.0)return
* for pion+D(N*)-->pion+N
       if(ictrl.eq.1)then
       if(e(i1).gt.1)then 
       ed=e(i1)       
       else
       ed=e(i2)
       endif       
       pout2=((srt**2+ap1**2-ed**2)/(2.*srt))**2-ap1**2
       if(pout2.le.0)return
       xpro=twopi(srt)/10.
       factor=1/3.
       if( ((lb1.eq.8.and.lb2.eq.5).or.
     &    (lb1.eq.5.and.lb2.eq.8))
     &        .OR.((lb1.eq.-8.and.lb2.eq.3).or.
     &    (lb1.eq.3.and.lb2.eq.-8)) )factor=1/4.
       if((iabs(lb1).ge.10.and.iabs(lb1).le.13).
     &  or.(iabs(lb2).ge.10.and.iabs(lb2).le.13))factor=1.
       reab=factor*pin2/pout2*xpro
       return
       endif
* for rho reabsorption
       if(ictrl.eq.2)then
       if(lb(i2).ge.25)then 
       ed=e(i1)
       arho1=e(i2)       
       else
       ed=e(i2)
       arho1=e(i1)
       endif       
       if(srt.le.(amn+ap1+arho1+0.02))return
       pout2=((srt**2+arho1**2-ed**2)/(2.*srt))**2-arho1**2
       if(pout2.le.0)return
       xpro=threpi(srt)/10.
       factor=1/3.
       if( ((lb1.eq.8.and.lb2.eq.27).or.
     &       (lb1.eq.27.and.lb2.eq.8))
     & .OR. ((lb1.eq.-8.and.lb2.eq.25).or.
     &       (lb1.eq.25.and.lb2.eq.-8)) )factor=1/4.
       if((iabs(lb1).ge.10.and.iabs(lb1).le.13).
     &  or.(iabs(lb2).ge.10.and.iabs(lb2).le.13))factor=1.
       reab=factor*pin2/pout2*xpro
       return
       endif
* for omega reabsorption
       if(ictrl.eq.3)then
       if(e(i1).gt.1)ed=e(i1)       
       if(e(i2).gt.1)ed=e(i2)       
       pout2=((srt**2+aomega**2-ed**2)/(2.*srt))**2-aomega**2
       if(pout2.le.0)return
       xpro=fourpi(srt)/10.
       factor=1/6.
       if((iabs(lb1).ge.10.and.iabs(lb1).le.13).
     &  or.(iabs(lb2).ge.10.and.iabs(lb2).le.13))factor=1./3.
       reab=factor*pin2/pout2*xpro
       endif
      return
        END
******************************************
* for the reabsorption of two resonances
* This function calculates the cross section for 
* DD-->NN, N*N*-->NN and DN*-->NN
c      real*4 function reab2d(i1,i2,srt)
      real function reab2d(i1,i2,srt)
*  srt    = DSQRT(s) in GeV                                                   *
*  reab   = cross section in mb
****************************************
      PARAMETER      (MAXSTR=150001,MAXR=1,PI=3.1415926)
      parameter      (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
      PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
      parameter      (amn=0.938,ap1=0.14,arho=0.77,aomega=0.782)
       parameter       (maxx=20,maxz=24)
      COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
      COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      COMMON  /EE/      ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      SAVE   
       reab2d=0
       LB1=iabs(LB(I1))
       LB2=iabs(LB(I2))
       ed1=e(i1)       
       ed2=e(i2)       
       pin2=(srt/2.)**2-amn**2
       pout2=((srt**2+ed1**2-ed2**2)/(2.*srt))**2-ed1**2
       if(pout2.le.0)return
       xpro=x2pi(srt)
       factor=1/4.
       if((lb1.ge.10.and.lb1.le.13).and.
     &    (lb2.ge.10.and.lb2.le.13))factor=1.
       if((lb1.ge.6.and.lb1.le.9).and.
     &    (lb2.gt.10.and.lb2.le.13))factor=1/2.
       if((lb2.ge.6.and.lb2.le.9).and.
     &    (lb1.gt.10.and.lb1.le.13))factor=1/2.
       reab2d=factor*pin2/pout2*xpro
       return
       end
***************************************
      SUBROUTINE rotate(PX0,PY0,PZ0,px,py,pz)
      SAVE   
* purpose: rotate the momentum of a particle in the CMS of p1+p2 such that 
* the x' y' and z' in the cms of p1+p2 is the same as the fixed x y and z
* quantities:
*            px0,py0 and pz0 are the cms momentum of the incoming colliding
*            particles
*            px, py and pz are the cms momentum of any one of the particles 
*            after the collision to be rotated
***************************************
* the momentum, polar and azimuthal angles of the incoming momentm
      PR0  = SQRT( PX0**2 + PY0**2 + PZ0**2 )
      IF(PR0.EQ.0)PR0=0.00000001
      C2  = PZ0 / PR0
      IF(PX0 .EQ. 0.0 .AND. PY0 .EQ. 0.0) THEN
        T2 = 0.0
      ELSE
        T2=ATAN2(PY0,PX0)
      END IF

clin-9/2012: check argument in sqrt():
      scheck=1.0 - C2**2
      if(scheck.lt.0) then
         write(99,*) 'scheck45: ', scheck
         scheck=0.
      endif
      S2=sqrt(scheck)
c      S2  =  SQRT( 1.0 - C2**2 )

      CT2  = COS(T2)
      ST2  = SIN(T2)
* the momentum, polar and azimuthal angles of the momentum to be rotated
      PR=SQRT(PX**2+PY**2+PZ**2)
      IF(PR.EQ.0)PR=0.0000001
      C1=PZ/PR
      IF(PX.EQ.0.AND.PY.EQ.0)THEN
      T1=0.
      ELSE
      T1=ATAN2(PY,PX)
      ENDIF

clin-9/2012: check argument in sqrt():
      scheck=1.0 - C1**2
      if(scheck.lt.0) then
         write(99,*) 'scheck46: ', scheck
         scheck=0.
      endif
      S1=sqrt(scheck)
c      S1   = SQRT( 1.0 - C1**2 )

      CT1  = COS(T1)
      ST1  = SIN(T1)
      SS   = C2 * S1 * CT1  +  S2 * C1
* THE MOMENTUM AFTER ROTATION
      PX   = PR * ( SS*CT2 - S1*ST1*ST2 )
      PY   = PR * ( SS*ST2 + S1*ST1*CT2 )
      PZ   = PR * ( C1*C2 - S1*S2*CT1 )
      RETURN
      END
******************************************
c      real*4 function Xpp(srt)
      real function Xpp(srt)
*  This function contains the experimental total n-p cross sections           *
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*  WITH A CUTOFF AT 55MB                                                      *
******************************************
c      real*4   xarray(14), earray(14)
      real   xarray(14), earray(14)
      SAVE   
      data earray /20.,30.,40.,60.,80.,100.,
     &170.,250.,310.,
     &350.,460.,560.,660.,800./
      data xarray /150.,90.,80.6,48.0,36.6,
     &31.6,25.9,24.0,23.1,
     &24.0,28.3,33.6,41.5,47/

       pmass=0.9383 
* 1.Calculate E_kin(lab) [MeV] from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
      ekin = 2000.*pmass*((srt/(2.*pmass))**2 - 1.)
      if (ekin .lt. earray(1)) then
        xpp = xarray(1)
       IF(XPP.GT.55)XPP=55
        return
      end if
       IF(EKIN.GT.EARRAY(14))THEN
       XPP=XARRAY(14)
       RETURN
       ENDIF
*
*
* 2.Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,14
        if (earray(ie) .eq. ekin) then
          xPP= xarray(ie)
       if(xpp.gt.55)xpp=55.
          return
       endif
        if (earray(ie) .gt. ekin) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          XPP = exp(ymin + (alog(ekin)-xmin)
     &          *(ymax-ymin)/(xmax-xmin) )
       IF(XPP.GT.55)XPP=55.
       go to 50
        end if
 1001 continue
50       continue
        return
        END
******************************************
      real function Xnp(srt)
*  This function contains the experimental total n-p cross sections           *
*  srt    = DSQRT(s) in GeV                                                   *
*  xsec   = production cross section in mb                                    *
*  earray = EXPerimental table with proton energies in MeV                    *
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
*  WITH  A CUTOFF AT 55MB                                                *
******************************************
c      real*4   xarray(11), earray(11)
      real   xarray(11), earray(11)
      SAVE   
      data   earray /20.,30.,40.,60.,90.,135.0,200.,
     &300.,400.,600.,800./
      data  xarray / 410.,270.,214.5,130.,78.,53.5,
     &41.6,35.9,34.2,34.3,34.9/

       pmass=0.9383
* 1.Calculate E_kin(lab) [MeV] from srt [GeV]
*   Formula used:   DSQRT(s) = 2 m DSQRT(E_kin/(2m) + 1)
      ekin = 2000.*pmass*((srt/(2.*pmass))**2 - 1.)
      if (ekin .lt. earray(1)) then
        xnp = xarray(1)
       IF(XNP.GT.55)XNP=55
        return
      end if
       IF(EKIN.GT.EARRAY(11))THEN
       XNP=XARRAY(11)
       RETURN
       ENDIF
*
*Interpolate double logarithmically to find sigma(srt)
*
      do 1001 ie = 1,11
        if (earray(ie) .eq. ekin) then
          xNP = xarray(ie)
         if(xnp.gt.55)xnp=55.
          return
       endif
        if (earray(ie) .gt. ekin) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          xNP = exp(ymin + (alog(ekin)-xmin)
     &          *(ymax-ymin)/(xmax-xmin) )
       IF(XNP.GT.55)XNP=55
       go to 50
        end if
 1001 continue
50       continue
        return
        END
*******************************
       function ptr(ptmax,iseed)
* (2) Generate the transverse momentum
*     OF nucleons
*******************************
        COMMON/TABLE/ xarray(0:1000),earray(0:1000)
cc      SAVE /TABLE/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
       ptr=0.
       if(ptmax.le.1.e-02)then
       ptr=ptmax
       return
       endif
       if(ptmax.gt.2.01)ptmax=2.01
       tryial=ptdis(ptmax)/ptdis(2.01)
       XT=RANART(NSEED)*tryial
* look up the table and
*Interpolate double logarithmically to find pt
        do 50 ie = 1,200
        if (earray(ie) .eq. xT) then
          ptr = xarray(ie)
       return
       end if
          if(xarray(ie-1).le.0.00001)go to 50
          if(xarray(ie).le.0.00001)go to 50
          if(earray(ie-1).le.0.00001)go to 50
          if(earray(ie).le.0.00001)go to 50
        if (earray(ie) .gt. xT) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          ptr= exp(ymin + (alog(xT)-xmin)*(ymax-ymin)
     &    /(xmax-xmin) )
       if(ptr.gt.ptmax)ptr=ptmax
       return
       endif
50      continue
       return
       end

**********************************
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE XND(px,py,pz,srt,I1,I2,xinel,
     &               sigk,xsk1,xsk2,xsk3,xsk4,xsk5)
*     PURPOSE:                                                         *
*             calculate NUCLEON-BARYON RESONANCE inelatic Xsection     *
*     NOTE   :                                                         *
*     QUANTITIES:                                                 *
*                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
*                      N12,                                            *
*                      M12=1 FOR p+n-->delta(+)+ n                     *
*                          2     p+n-->delta(0)+ p                     *
*                          3     p+p-->delta(++)+n                     *
*                          4     p+p-->delta(+)+p                      *
*                          5     n+n-->delta(0)+n                      *
*                          6     n+n-->delta(-)+p                      *
*                          7     n+p-->N*(0)(1440)+p                   *
*                          8     n+p-->N*(+)(1440)+n                   *
*                        9     p+p-->N*(+)(1535)+p                     *
*                        10    n+n-->N*(0)(1535)+n                     *
*                         11    n+p-->N*(+)(1535)+n                     *
*                        12    n+p-->N*(0)(1535)+p
*                        13    D(++)+D(-)-->N*(+)(1440)+n
*                         14    D(++)+D(-)-->N*(0)(1440)+p
*                        15    D(+)+D(0)--->N*(+)(1440)+n
*                        16    D(+)+D(0)--->N*(0)(1440)+p
*                        17    D(++)+D(0)-->N*(+)(1535)+p
*                        18    D(++)+D(-)-->N*(0)(1535)+p
*                        19    D(++)+D(-)-->N*(+)(1535)+n
*                        20    D(+)+D(+)-->N*(+)(1535)+p
*                        21    D(+)+D(0)-->N*(+)(1535)+n
*                        22    D(+)+D(0)-->N*(0)(1535)+p
*                        23    D(+)+D(-)-->N*(0)(1535)+n
*                        24    D(0)+D(0)-->N*(0)(1535)+n
*                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
*                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
*                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
*                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
*                        29    N*(+)(14)+D+-->N*(+)(15)+p
*                        30    N*(+)(14)+D0-->N*(+)(15)+n
*                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
*                        32    N*(0)(14)+D++--->N*(+)(15)+p
*                        33    N*(0)(14)+D+--->N*(+)(15)+n
*                        34    N*(0)(14)+D+--->N*(0)(15)+p
*                        35    N*(0)(14)+D0-->N*(0)(15)+n
*                        36    N*(+)(14)+D0--->N*(0)(15)+p
*                            and more
***********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AKA=0.498,APHI=1.020,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common /ff/f(-mx:mx,-my:my,-mz:mz,-mpx:mpx,-mpy:mpy,-mpz:mpzp)
cc      SAVE /ff/
        common /gg/ dx,dy,dz,dpx,dpy,dpz
cc      SAVE /gg/
        COMMON /INPUT/ NSTAR,NDIRCT,DIR
cc      SAVE /INPUT/
        COMMON /NN/NNN
cc      SAVE /NN/
        COMMON /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      SAVE   

*-----------------------------------------------------------------------
       xinel=0.
       sigk=0
       xsk1=0
       xsk2=0
       xsk3=0
       xsk4=0
       xsk5=0
        EM1=E(I1)
        EM2=E(I2)
      PR  = SQRT( PX**2 + PY**2 + PZ**2 )
*     CAN HAPPEN ANY MORE ==> RETURN (2.04 = 2*AVMASS + PI-MASS+0.02)
        IF (SRT .LT. 2.04) RETURN
* Resonance absorption or Delta + N-->N*(1440), N*(1535)
* COM: TEST FOR DELTA OR N* ABSORPTION
*      IN THE PROCESS DELTA+N-->NN, N*+N-->NN
        PRF=SQRT(0.25*SRT**2-AVMASS**2)
        IF(EM1.GT.1.)THEN
        DELTAM=EM1
        ELSE
        DELTAM=EM2
        ENDIF
        RENOM=DELTAM*PRF**2/DENOM(SRT,1.)/PR
        RENOMN=DELTAM*PRF**2/DENOM(SRT,2.)/PR
        RENOM1=DELTAM*PRF**2/DENOM(SRT,-1.)/PR
* avoid the inelastic collisions between n+delta- -->N+N 
*       and p+delta++ -->N+N due to charge conservation,
*       but they can scatter to produce kaons 
       if((iabs(lb(i1)).eq.2).and.(iabs(lb(i2)).eq.6)) renom=0.
       if((iabs(lb(i2)).eq.2).and.(iabs(lb(i1)).eq.6)) renom=0.
       if((iabs(lb(i1)).eq.1).and.(iabs(lb(i2)).eq.9)) renom=0.
       if((iabs(lb(i2)).eq.1).and.(iabs(lb(i1)).eq.9)) renom=0.
       Call M1535(iabs(lb(i1)),iabs(lb(i2)),srt,x1535)
        X1440=(3./4.)*SIGMA(SRT,2,0,1)
* CROSS SECTION FOR KAON PRODUCTION from the four channels
* for NLK channel
       akp=0.498
       ak0=0.498
       ana=0.94
       ada=1.232
       al=1.1157
       as=1.1197
       xsk1=0
       xsk2=0
       xsk3=0
       xsk4=0
c      !! phi production
       xsk5=0
       t1nlk=ana+al+akp
       if(srt.le.t1nlk)go to 222
       XSK1=1.5*PPLPK(SRT)
* for DLK channel
       t1dlk=ada+al+akp
       t2dlk=ada+al-akp
       if(srt.le.t1dlk)go to 222
       es=srt
       pmdlk2=(es**2-t1dlk**2)*(es**2-t2dlk**2)/(4.*es**2)
       pmdlk=sqrt(pmdlk2)
       XSK3=1.5*PPLPK(srt)
* for NSK channel
       t1nsk=ana+as+akp
       t2nsk=ana+as-akp
       if(srt.le.t1nsk)go to 222
       pmnsk2=(es**2-t1nsk**2)*(es**2-t2nsk**2)/(4.*es**2)
       pmnsk=sqrt(pmnsk2)
       XSK2=1.5*(PPK1(srt)+PPK0(srt))
* for DSK channel
       t1DSk=aDa+aS+akp
       t2DSk=aDa+aS-akp
       if(srt.le.t1dsk)go to 222
       pmDSk2=(es**2-t1DSk**2)*(es**2-t2DSk**2)/(4.*es**2)
       pmDSk=sqrt(pmDSk2)
       XSK4=1.5*(PPK1(srt)+PPK0(srt))
csp11/21/01
c phi production
       if(srt.le.(2.*amn+aphi))go to 222
c  !! mb put the correct form
         xsk5 = 0.0001
csp11/21/01 end

* THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
222       SIGK=XSK1+XSK2+XSK3+XSK4

cbz3/7/99 neutralk
        XSK1 = 2.0 * XSK1
        XSK2 = 2.0 * XSK2
        XSK3 = 2.0 * XSK3
        XSK4 = 2.0 * XSK4
        SIGK = 2.0 * SIGK + xsk5
cbz3/7/99 neutralk end

* avoid the inelastic collisions between n+delta- -->N+N 
*       and p+delta++ -->N+N due to charge conservation,
*       but they can scatter to produce kaons 
       if(((iabs(lb(i1)).eq.2).and.(iabs(lb(i2)).eq.6)).OR. 
     &         ((iabs(lb(i2)).eq.2).and.(iabs(lb(i1)).eq.6)).OR.
     &         ((iabs(lb(i1)).eq.1).and.(iabs(lb(i2)).eq.9)).OR.
     &         ((iabs(lb(i2)).eq.1).and.(iabs(lb(i1)).eq.9)))THEN
       xinel=sigk
       return
       ENDIF
* WE DETERMINE THE REACTION CHANNELS IN THE FOLLOWING
* FOR n+delta(++)-->p+p or n+delta(++)-->n+N*(+)(1440),n+N*(+)(1535)
* REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN, 
        IF(LB(I1)*LB(I2).EQ.18.AND.
     &    (iabs(LB(I1)).EQ.2.OR.iabs(LB(I2)).EQ.2))then
        SIGND=SIGMA(SRT,1,1,0)+0.5*SIGMA(SRT,1,1,1)
        SIGDN=0.25*SIGND*RENOM
        xinel=SIGDN+X1440+X1535+SIGK
       RETURN
       endif
* FOR p+delta(-)-->n+n or p+delta(-)-->n+N*(0)(1440),n+N*(0)(1535)
* REABSORPTION OR N*(1535) PRODUCTION LIKE IN P+P OR N*(1440) LIKE PN, 
        IF(LB(I1)*LB(I2).EQ.6.AND.
     &    (iabs(LB(I1)).EQ.1.OR.iabs(LB(I2)).EQ.1))THEN
        SIGND=SIGMA(SRT,1,1,0)+0.5*SIGMA(SRT,1,1,1)
        SIGDN=0.25*SIGND*RENOM
        xinel=SIGDN+X1440+X1535+SIGK
       RETURN
       endif
* FOR p+delta(+)-->p+p, N*(+)(144)+p, N*(+)(1535)+p
cbz11/25/98
        IF(LB(I1)*LB(I2).EQ.8.AND.
     &    (iabs(LB(I1)).EQ.1.OR.iabs(LB(I2)).EQ.1))THEN
        SIGND=1.5*SIGMA(SRT,1,1,1)
        SIGDN=0.25*SIGND*RENOM
        xinel=SIGDN+x1440+x1535+SIGK
       RETURN
       endif
* FOR n+delta(0)-->n+n, N*(0)(144)+n, N*(0)(1535)+n
        IF(LB(I1)*LB(I2).EQ.14.AND.
     &   (iabs(LB(I1)).EQ.2.AND.iabs(LB(I2)).EQ.2))THEN
        SIGND=1.5*SIGMA(SRT,1,1,1)
        SIGDN=0.25*SIGND*RENOM
        xinel=SIGDN+x1440+x1535+SIGK
       RETURN
       endif
* FOR n+delta(+)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
*                       N*(+)(1535)+n,N*(0)(1535)+p
        IF(LB(I1)*LB(I2).EQ.16.AND.
     &     (iabs(LB(I1)).EQ.2.OR.iabs(LB(I2)).EQ.2))THEN
        SIGND=0.5*SIGMA(SRT,1,1,1)+0.25*SIGMA(SRT,1,1,0)
        SIGDN=0.5*SIGND*RENOM
        xinel=SIGDN+2.*x1440+2.*x1535+SIGK
       RETURN
       endif
* FOR p+delta(0)-->n+p, N*(+)(1440)+n,N*(0)(1440)+p,
*                       N*(+)(1535)+n,N*(0)(1535)+p
        IF(LB(I1)*LB(I2).EQ.7)THEN
        SIGND=0.5*SIGMA(SRT,1,1,1)+0.25*SIGMA(SRT,1,1,0)
        SIGDN=0.5*SIGND*RENOM
        xinel=SIGDN+2.*x1440+2.*x1535+SIGK
       RETURN
       endif
* FOR p+N*(0)(14)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
* OR  P+N*(0)(14)-->D(+)+N, D(0)+P, 
        IF(LB(I1)*LB(I2).EQ.10.AND.
     &   (iabs(LB(I1)).EQ.1.OR.iabs(LB(I2)).EQ.1))then
        SIGND=(3./4.)*SIGMA(SRT,2,0,1)
        SIGDN=SIGND*RENOMN
        xinel=SIGDN+X1535+SIGK
       RETURN
       endif
* FOR n+N*(+)-->p+n, N*(+)(1535)+n,N*(0)(1535)+p
        IF(LB(I1)*LB(I2).EQ.22.AND.
     &   (iabs(LB(I1)).EQ.2.OR.iabs(LB(I2)).EQ.2))then
        SIGND=(3./4.)*SIGMA(SRT,2,0,1)
        SIGDN=SIGND*RENOMN
        xinel=SIGDN+X1535+SIGK
       RETURN
       endif
* FOR N*(1535)+N-->N+N COLLISIONS
        IF((iabs(LB(I1)).EQ.12).OR.(iabs(LB(I1)).EQ.13).OR.
     1  (iabs(LB(I2)).EQ.12).OR.(iabs(LB(I2)).EQ.13))THEN
        SIGND=X1535
        SIGDN=SIGND*RENOM1
        xinel=SIGDN+SIGK
       RETURN
       endif
        RETURN
       end
**********************************
*                                                                      *
*                                                                      *
      SUBROUTINE XDDIN(PX,PY,PZ,SRT,I1,I2,
     &XINEL,SIGK,XSK1,XSK2,XSK3,XSK4,XSK5)
*     PURPOSE:                                                         *
*             DEALING WITH BARYON RESONANCE-BARYON RESONANCE COLLISIONS*
*     NOTE   :                                                         *
*           VALID ONLY FOR BARYON-BARYON-DISTANCES LESS THAN 1.32 FM   *
*           (1.32 = 2 * HARD-CORE-RADIUS [HRC] )                       *
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           NSTAR =1 INCLUDING N* RESORANCE,ELSE NOT                   *
*           NDIRCT=1 INCLUDING DIRECT PION PRODUCTION PROCESS         *
*           IBLOCK   - THE INFORMATION BACK                            *
*                      0-> COLLISION CANNOT HAPPEN                     *
*                      1-> N-N ELASTIC COLLISION                       *
*                      2-> N+N->N+DELTA,OR N+N->N+N* REACTION          *
*                      3-> N+DELTA->N+N OR N+N*->N+N REACTION          *
*                      4-> N+N->N+N+PION,DIRTCT PROCESS                *
*                     5-> DELTA(N*)+DELTA(N*)   TOTAL   COLLISIONS    *
*           N12       - IS USED TO SPECIFY BARYON-BARYON REACTION      *
*                      CHANNELS. M12 IS THE REVERSAL CHANNEL OF N12    *
*                      N12,                                            *
*                      M12=1 FOR p+n-->delta(+)+ n                     *
*                          2     p+n-->delta(0)+ p                     *
*                          3     p+p-->delta(++)+n                     *
*                          4     p+p-->delta(+)+p                      *
*                          5     n+n-->delta(0)+n                      *
*                          6     n+n-->delta(-)+p                      *
*                          7     n+p-->N*(0)(1440)+p                   *
*                          8     n+p-->N*(+)(1440)+n                   *
*                        9     p+p-->N*(+)(1535)+p                     *
*                        10    n+n-->N*(0)(1535)+n                     *
*                         11    n+p-->N*(+)(1535)+n                     *
*                        12    n+p-->N*(0)(1535)+p
*                        13    D(++)+D(-)-->N*(+)(1440)+n
*                         14    D(++)+D(-)-->N*(0)(1440)+p
*                        15    D(+)+D(0)--->N*(+)(1440)+n
*                        16    D(+)+D(0)--->N*(0)(1440)+p
*                        17    D(++)+D(0)-->N*(+)(1535)+p
*                        18    D(++)+D(-)-->N*(0)(1535)+p
*                        19    D(++)+D(-)-->N*(+)(1535)+n
*                        20    D(+)+D(+)-->N*(+)(1535)+p
*                        21    D(+)+D(0)-->N*(+)(1535)+n
*                        22    D(+)+D(0)-->N*(0)(1535)+p
*                        23    D(+)+D(-)-->N*(0)(1535)+n
*                        24    D(0)+D(0)-->N*(0)(1535)+n
*                          25    N*(+)(14)+N*(+)(14)-->N*(+)(15)+p
*                          26    N*(0)(14)+N*(0)(14)-->N*(0)(15)+n
*                          27    N*(+)(14)+N*(0)(14)-->N*(+)(15)+n
*                        28    N*(+)(14)+N*(0)(14)-->N*(0)(15)+p
*                        29    N*(+)(14)+D+-->N*(+)(15)+p
*                        30    N*(+)(14)+D0-->N*(+)(15)+n
*                        31    N*(+)(14)+D(-)-->N*(0)(1535)+n
*                        32    N*(0)(14)+D++--->N*(+)(15)+p
*                        33    N*(0)(14)+D+--->N*(+)(15)+n
*                        34    N*(0)(14)+D+--->N*(0)(15)+p
*                        35    N*(0)(14)+D0-->N*(0)(15)+n
*                        36    N*(+)(14)+D0--->N*(0)(15)+p
*                        +++
*               AND MORE CHANNELS AS LISTED IN THE NOTE BOOK      
*
* NOTE ABOUT N*(1440) RESORANCE:                                       *
*     As it has been discussed in VerWest's paper,I= 1 (initial isospin)
*     channel can all be attributed to delta resorance while I= 0      *
*     channel can all be  attribured to N* resorance.Only in n+p       *
*     one can have I=0 channel so is the N*(1440) resorance            *
* REFERENCES:    J. CUGNON ET AL., NUCL. PHYS. A352, 505 (1981)        *
*                    Y. KITAZOE ET AL., PHYS. LETT. 166B, 35 (1986)    *
*                    B. VerWest el al., PHYS. PRV. C25 (1982)1979      *
*                    Gy. Wolf  et al, Nucl Phys A517 (1990) 615        *
*                    CUTOFF = 2 * AVMASS + 20 MEV                      *
*                                                                      *
*       for N*(1535) we use the parameterization by Gy. Wolf et al     *
*       Nucl phys A552 (1993) 349, added May 18, 1994                  *
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AKA=0.498,APHI=1.020,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common /ff/f(-mx:mx,-my:my,-mz:mz,-mpx:mpx,-mpy:mpy,-mpz:mpzp)
cc      SAVE /ff/
        common /gg/ dx,dy,dz,dpx,dpy,dpz
cc      SAVE /gg/
        COMMON /INPUT/ NSTAR,NDIRCT,DIR
cc      SAVE /INPUT/
        COMMON /NN/NNN
cc      SAVE /NN/
        COMMON /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      SAVE   
*-----------------------------------------------------------------------
       XINEL=0
       SIGK=0
       XSK1=0
       XSK2=0
       XSK3=0
       XSK4=0
       XSK5=0
        EM1=E(I1)
        EM2=E(I2)
      PR  = SQRT( PX**2 + PY**2 + PZ**2 )
*     IF THERE WERE 2 N*(1535) AND THEY DIDN'T SCATT. ELAST., 
*     ALLOW THEM TO PRODUCE KAONS. NO OTHER INELASTIC CHANNELS
*     ARE KNOWN
C       if((lb(i1).ge.12).and.(lb(i2).ge.12))return
*     ALL the inelastic collisions between N*(1535) and Delta as well
*     as N*(1440) TO PRODUCE KAONS, NO OTHER CHANNELS ARE KNOWN
C       if((lb(i1).ge.12).and.(lb(i2).ge.3))return
C       if((lb(i2).ge.12).and.(lb(i1).ge.3))return
*     calculate the N*(1535) production cross section in I1+I2 collisions
       call N1535(iabs(lb(i1)),iabs(lb(i2)),srt,X1535)
c
* for Delta+Delta-->N*(1440 OR 1535)+N AND N*(1440)+N*(1440)-->N*(1535)+X 
*     AND DELTA+N*(1440)-->N*(1535)+X
* WE ASSUME THEY HAVE THE SAME CROSS SECTIONS as CORRESPONDING N+N COLLISION):
* FOR D++D0, D+D+,D+D-,D0D0,N*+N*+,N*0N*0,N*(+)D+,N*(+)D(-),N*(0)D(0)
* N*(1535) production, kaon production and reabsorption through 
* D(N*)+D(N*)-->NN are ALLOWED.
* CROSS SECTION FOR KAON PRODUCTION from the four channels are
* for NLK channel
       akp=0.498
       ak0=0.498
       ana=0.94
       ada=1.232
       al=1.1157
       as=1.1197
       xsk1=0
       xsk2=0
       xsk3=0
       xsk4=0
       t1nlk=ana+al+akp
       if(srt.le.t1nlk)go to 222
       XSK1=1.5*PPLPK(SRT)
* for DLK channel
       t1dlk=ada+al+akp
       t2dlk=ada+al-akp
       if(srt.le.t1dlk)go to 222
       es=srt
       pmdlk2=(es**2-t1dlk**2)*(es**2-t2dlk**2)/(4.*es**2)
       pmdlk=sqrt(pmdlk2)
       XSK3=1.5*PPLPK(srt)
* for NSK channel
       t1nsk=ana+as+akp
       t2nsk=ana+as-akp
       if(srt.le.t1nsk)go to 222
       pmnsk2=(es**2-t1nsk**2)*(es**2-t2nsk**2)/(4.*es**2)
       pmnsk=sqrt(pmnsk2)
       XSK2=1.5*(PPK1(srt)+PPK0(srt))
* for DSK channel
       t1DSk=aDa+aS+akp
       t2DSk=aDa+aS-akp
       if(srt.le.t1dsk)go to 222
       pmDSk2=(es**2-t1DSk**2)*(es**2-t2DSk**2)/(4.*es**2)
       pmDSk=sqrt(pmDSk2)
       XSK4=1.5*(PPK1(srt)+PPK0(srt))
csp11/21/01
c phi production
       if(srt.le.(2.*amn+aphi))go to 222
c  !! mb put the correct form
         xsk5 = 0.0001
csp11/21/01 end
* THE TOTAL KAON+ PRODUCTION CROSS SECTION IS THEN
222       SIGK=XSK1+XSK2+XSK3+XSK4

cbz3/7/99 neutralk
        XSK1 = 2.0 * XSK1
        XSK2 = 2.0 * XSK2
        XSK3 = 2.0 * XSK3
        XSK4 = 2.0 * XSK4
        SIGK = 2.0 * SIGK + xsk5
cbz3/7/99 neutralk end

        IDD=iabs(LB(I1)*LB(I2))
* The reabsorption cross section for the process
* D(N*)D(N*)-->NN is
       s2d=reab2d(i1,i2,srt)

cbz3/16/99 pion
        S2D = 0.
cbz3/16/99 pion end

*(1) N*(1535)+D(N*(1440)) reactions
*    we allow kaon production and reabsorption only
       if(((iabs(lb(i1)).ge.12).and.(iabs(lb(i2)).ge.12)).OR.
     &       ((iabs(lb(i1)).ge.12).and.(iabs(lb(i2)).ge.6)).OR.
     &       ((iabs(lb(i2)).ge.12).and.(iabs(lb(i1)).ge.6)))THEN
       XINEL=sigk+s2d
       RETURN
       ENDIF
* channels have the same charge as pp 
        IF((IDD.EQ.63).OR.(IDD.EQ.64).OR.(IDD.EQ.48).
     1  OR.(IDD.EQ.49).OR.(IDD.EQ.11*11).OR.(IDD.EQ.10*10).
     2  OR.(IDD.EQ.88).OR.(IDD.EQ.66).
     3  OR.(IDD.EQ.90).OR.(IDD.EQ.70))THEN
        XINEL=X1535+SIGK+s2d
       RETURN
        ENDIF
* IN DELTA+N*(1440) and N*(1440)+N*(1440) COLLISIONS, 
* N*(1535), kaon production and reabsorption are ALLOWED
* IN N*(1440)+N*(1440) COLLISIONS, ONLY N*(1535) IS ALLOWED
       IF((IDD.EQ.110).OR.(IDD.EQ.77).OR.(IDD.EQ.80))THEN
       XINEL=X1535+SIGK+s2d
       RETURN
       ENDIF       
       IF((IDD.EQ.54).OR.(IDD.EQ.56))THEN
* LIKE FOR N+P COLLISION, 
* IN DELTA+DELTA COLLISIONS BOTH N*(1440) AND N*(1535) CAN BE PRODUCED
        SIG2=(3./4.)*SIGMA(SRT,2,0,1)
        XINEL=2.*(SIG2+X1535)+SIGK+s2d
       RETURN
       ENDIF
       RETURN
       END
******************************************
      real function dirct1(srt)
*  This function contains the experimental, direct pion(+) + p cross sections *
*  srt    = DSQRT(s) in GeV                                                   *
*  dirct1  = cross section in fm**2                                     *
*  earray = EXPerimental table with the srt            
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
******************************************
c      real*4   xarray(122), earray(122)
      real   xarray(122), earray(122)
      SAVE   
      data   earray /
     &1.568300,1.578300,1.588300,1.598300,1.608300,1.618300,1.628300,    
     &1.638300,1.648300,1.658300,1.668300,1.678300,1.688300,1.698300,    
     &1.708300,1.718300,1.728300,1.738300,1.748300,1.758300,1.768300,    
     &1.778300,1.788300,1.798300,1.808300,1.818300,1.828300,1.838300,    
     &1.848300,1.858300,1.868300,1.878300,1.888300,1.898300,1.908300,    
     &1.918300,1.928300,1.938300,1.948300,1.958300,1.968300,1.978300,    
     &1.988300,1.998300,2.008300,2.018300,2.028300,2.038300,2.048300,    
     &2.058300,2.068300,2.078300,2.088300,2.098300,2.108300,2.118300,    
     &2.128300,2.138300,2.148300,2.158300,2.168300,2.178300,2.188300,    
     &2.198300,2.208300,2.218300,2.228300,2.238300,2.248300,2.258300,    
     &2.268300,2.278300,2.288300,2.298300,2.308300,2.318300,2.328300,    
     &2.338300,2.348300,2.358300,2.368300,2.378300,2.388300,2.398300,    
     &2.408300,2.418300,2.428300,2.438300,2.448300,2.458300,2.468300,    
     &2.478300,2.488300,2.498300,2.508300,2.518300,2.528300,2.538300,    
     &2.548300,2.558300,2.568300,2.578300,2.588300,2.598300,2.608300,    
     &2.618300,2.628300,2.638300,2.648300,2.658300,2.668300,2.678300,
     &2.688300,2.698300,2.708300,2.718300,2.728300,2.738300,2.748300,    
     &2.758300,2.768300,2.778300/
      data xarray/
     &1.7764091E-02,0.5643668,0.8150568,1.045565,2.133695,3.327922,
     &4.206488,3.471242,4.486876,5.542213,6.800052,7.192446,6.829848,    
     &6.580306,6.868410,8.527946,10.15720,9.716511,9.298335,8.901310,    
     &10.31213,10.52185,11.17630,11.61639,12.05577,12.71596,13.46036,    
     &14.22060,14.65449,14.94775,14.93310,15.32907,16.56481,16.29422,    
     &15.18548,14.12658,13.72544,13.24488,13.31003,14.42680,12.84423,    
     &12.49025,12.14858,11.81870,11.18993,11.35816,11.09447,10.83873,    
     &10.61592,10.53754,9.425521,8.195912,9.661075,9.696192,9.200142,    
     &8.953734,8.715461,8.484999,8.320765,8.255512,8.190969,8.127125,    
     &8.079508,8.073004,8.010611,7.948909,7.887895,7.761005,7.626290,    
     &7.494696,7.366132,7.530178,8.392097,9.046881,8.962544,8.879403,    
     &8.797427,8.716601,8.636904,8.558312,8.404368,8.328978,8.254617,    
     &8.181265,8.108907,8.037527,7.967100,7.897617,7.829057,7.761405,    
     &7.694647,7.628764,7.563742,7.499570,7.387562,7.273281,7.161334,    
     &6.973375,6.529592,6.280323,6.293136,6.305725,6.318097,6.330258,    
     &6.342214,6.353968,6.365528,6.376895,6.388079,6.399081,6.409906,    
     &6.420560,6.431045,6.441367,6.451529,6.461533,6.471386,6.481091,    
     &6.490650,6.476413,6.297259,6.097826/

      if (srt .lt. earray(1)) then
        dirct1 = 0.00001
        return
      end if
      if (srt .gt. earray(122)) then
        dirct1 = xarray(122)
       dirct1=dirct1/10.
        return
      end if
*
*Interpolate double logarithmically to find xdirct2(srt)
*
      do 1001 ie = 1,122
        if (earray(ie) .eq. srt) then
          dirct1= xarray(ie)
         dirct1=dirct1/10.
          return
       endif
        if (earray(ie) .gt. srt) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          dirct1= exp(ymin + (alog(srt)-xmin)
     &          *(ymax-ymin)/(xmax-xmin) )
       dirct1=dirct1/10.
       go to 50
        end if
 1001 continue
50       continue
        return
        END
*******************************
******************************************
      real function dirct2(srt)
*  This function contains the experimental, direct pion(-) + p cross sections *
*  srt    = DSQRT(s) in GeV                                                   *
*  dirct2 = cross section in fm**2
*  earray = EXPerimental table with the srt            
*  xarray = EXPerimental table with cross sections in mb (curve to guide eye) *
******************************************
c      real*4   xarray(122), earray(122)
      real   xarray(122), earray(122)
      SAVE   
      data   earray /
     &1.568300,1.578300,1.588300,1.598300,1.608300,1.618300,1.628300,    
     &1.638300,1.648300,1.658300,1.668300,1.678300,1.688300,1.698300,    
     &1.708300,1.718300,1.728300,1.738300,1.748300,1.758300,1.768300,    
     &1.778300,1.788300,1.798300,1.808300,1.818300,1.828300,1.838300,    
     &1.848300,1.858300,1.868300,1.878300,1.888300,1.898300,1.908300,    
     &1.918300,1.928300,1.938300,1.948300,1.958300,1.968300,1.978300,    
     &1.988300,1.998300,2.008300,2.018300,2.028300,2.038300,2.048300,    
     &2.058300,2.068300,2.078300,2.088300,2.098300,2.108300,2.118300,    
     &2.128300,2.138300,2.148300,2.158300,2.168300,2.178300,2.188300,    
     &2.198300,2.208300,2.218300,2.228300,2.238300,2.248300,2.258300,    
     &2.268300,2.278300,2.288300,2.298300,2.308300,2.318300,2.328300,    
     &2.338300,2.348300,2.358300,2.368300,2.378300,2.388300,2.398300,    
     &2.408300,2.418300,2.428300,2.438300,2.448300,2.458300,2.468300,    
     &2.478300,2.488300,2.498300,2.508300,2.518300,2.528300,2.538300,    
     &2.548300,2.558300,2.568300,2.578300,2.588300,2.598300,2.608300,    
     &2.618300,2.628300,2.638300,2.648300,2.658300,2.668300,2.678300,
     &2.688300,2.698300,2.708300,2.718300,2.728300,2.738300,2.748300,    
     &2.758300,2.768300,2.778300/
      data xarray/0.5773182,1.404156,2.578629,3.832013,4.906011,
     &9.076963,13.10492,10.65975,15.31156,19.77611,19.92874,18.68979,    
     &19.80114,18.39536,14.34269,13.35353,13.58822,14.57031,10.24686,    
     &11.23386,9.764803,10.35652,10.53539,10.07524,9.582198,9.596469,    
     &9.818489,9.012848,9.378012,9.529244,9.529698,8.835624,6.671396,    
     &8.797758,8.133437,7.866227,7.823946,7.808504,7.791755,7.502062,    
     &7.417275,7.592349,7.752028,7.910585,8.068122,8.224736,8.075289,    
     &7.895902,7.721359,7.551512,7.386224,7.225343,7.068739,6.916284,    
     &6.767842,6.623294,6.482520,6.345404,6.211833,7.339510,7.531462,    
     &7.724824,7.919620,7.848021,7.639856,7.571083,7.508881,7.447474,    
     &7.386855,7.327011,7.164454,7.001266,6.842526,6.688094,6.537823,    
     &6.391583,6.249249,6.110689,5.975790,5.894200,5.959503,6.024602,    
     &6.089505,6.154224,6.218760,6.283128,6.347331,6.297411,6.120248,    
     &5.948606,6.494864,6.357106,6.222824,6.091910,5.964267,5.839795,    
     &5.718402,5.599994,5.499146,5.451325,5.404156,5.357625,5.311721,    
     &5.266435,5.301964,5.343963,5.385833,5.427577,5.469200,5.510702,    
     &5.552088,5.593359,5.634520,5.675570,5.716515,5.757356,5.798093,    
     &5.838732,5.879272,5.919717,5.960068,5.980941/

      if (srt .lt. earray(1)) then
        dirct2 = 0.00001
        return
      end if
      if (srt .gt. earray(122)) then
        dirct2 = xarray(122)
       dirct2=dirct2/10.
        return
      end if
*
*Interpolate double logarithmically to find xdirct2(srt)
*
      do 1001 ie = 1,122
        if (earray(ie) .eq. srt) then
          dirct2= xarray(ie)
         dirct2=dirct2/10.
          return
       endif
        if (earray(ie) .gt. srt) then
          ymin = alog(xarray(ie-1))
          ymax = alog(xarray(ie))
          xmin = alog(earray(ie-1))
          xmax = alog(earray(ie))
          dirct2= exp(ymin + (alog(srt)-xmin)
     &          *(ymax-ymin)/(xmax-xmin) )
       dirct2=dirct2/10.
       go to 50
        end if
 1001 continue
50       continue
        return
        END
*******************************
******************************
* this program calculates the elastic cross section for rho+nucleon
* through higher resonances
c       real*4 function ErhoN(em1,em2,lb1,lb2,srt)
       real function ErhoN(em1,em2,lb1,lb2,srt)
* date : Dec. 19, 1994
* ****************************
c       implicit real*4 (a-h,o-z)
      dimension   arrayj(19),arrayl(19),arraym(19),
     &arrayw(19),arrayb(19)
      SAVE   
      data arrayj /0.5,1.5,0.5,0.5,2.5,2.5,1.5,0.5,1.5,3.5,
     &1.5,0.5,1.5,0.5,2.5,0.5,1.5,2.5,3.5/
      data arrayl/1,2,0,0,2,3,2,1,1,3,
     &1,0,2,0,3,1,1,2,3/
      data arraym /1.44,1.52,1.535,1.65,1.675,1.68,1.70,1.71,
     &1.72,1.99,1.60,1.62,1.70,1.90,1.905,1.910,
     &1.86,1.93,1.95/
      data arrayw/0.2,0.125,0.15,0.15,0.155,0.125,0.1,0.11,
     &0.2,0.29,0.25,0.16,0.28,0.15,0.3,0.22,0.25,
     &0.25,0.24/
      data arrayb/0.15,0.20,0.05,0.175,0.025,0.125,0.1,0.20,
     &0.53,0.34,0.05,0.07,0.15,0.45,0.45,0.058,
     &0.08,0.12,0.08/

* the minimum energy for pion+delta collision
       pi=3.1415926
       xs=0
* include contribution from each resonance
       do 1001 ir=1,19
cbz11/25/98
       IF(IR.LE.8)THEN
c       if(lb1*lb2.eq.27.OR.LB1*LB2.EQ.25*2)branch=0.
c       if(lb1*lb2.eq.26.OR.LB1*LB2.EQ.26*2)branch=1./3.
c       if(lb1*lb2.eq.27*2.OR.LB1*LB2.EQ.25)branch=2./3.
c       ELSE
c       if(lb1*lb2.eq.27.OR.LB1*LB2.EQ.25*2)branch=1.
c       if(lb1*lb2.eq.26.OR.LB1*LB2.EQ.26*2)branch=2./3.
c       if(lb1*lb2.eq.27*2.OR.LB1*LB2.EQ.25)branch=1./3.
c       ENDIF
       if( ((lb1*lb2.eq.27.AND.(LB1.EQ.1.OR.LB2.EQ.1)).OR.
     &     (LB1*LB2.EQ.25*2.AND.(LB1.EQ.2.OR.LB2.EQ.2)))
     &       .OR.((lb1*lb2.eq.-25.AND.(LB1.EQ.-1.OR.LB2.EQ.-1)).OR.
     &     (LB1*LB2.EQ.-27*2.AND.(LB1.EQ.-2.OR.LB2.EQ.-2))) )
     &     branch=0.
        if((iabs(lb1*lb2).eq.26.AND.(iabs(LB1).EQ.1.OR.iabs(LB2).EQ.1))
     &   .OR.(iabs(LB1*LB2).EQ.26*2
     &   .AND.(iabs(LB1).EQ.2.OR.iabs(LB2).EQ.2)))
     &     branch=1./3.
       if( ((lb1*lb2.eq.27*2.AND.(LB1.EQ.2.OR.LB2.EQ.2)).OR.
     &     (LB1*LB2.EQ.25.AND.(LB1.EQ.1.OR.LB2.EQ.1)))
     &  .OR.((lb1*lb2.eq.-25*2.AND.(LB1.EQ.-2.OR.LB2.EQ.-2)).OR.
     &     (LB1*LB2.EQ.-27.AND.(LB1.EQ.-1.OR.LB2.EQ.-1))) )
     &     branch=2./3.
       ELSE
       if( ((lb1*lb2.eq.27.AND.(LB1.EQ.1.OR.LB2.EQ.1)).OR.
     &     (LB1*LB2.EQ.25*2.AND.(LB1.EQ.2.OR.LB2.EQ.2)))
     &       .OR.((lb1*lb2.eq.-25.AND.(LB1.EQ.-1.OR.LB2.EQ.-1)).OR.
     &     (LB1*LB2.EQ.-27*2.AND.(LB1.EQ.-2.OR.LB2.EQ.-2))) )
     &     branch=1.
        if((iabs(lb1*lb2).eq.26.AND.(iabs(LB1).EQ.1.OR.iabs(LB2).EQ.1))
     &   .OR.(iabs(LB1*LB2).EQ.26*2
     &   .AND.(iabs(LB1).EQ.2.OR.iabs(LB2).EQ.2)))
     &     branch=2./3.
       if( ((lb1*lb2.eq.27*2.AND.(LB1.EQ.2.OR.LB2.EQ.2)).OR.
     &     (LB1*LB2.EQ.25.AND.(LB1.EQ.1.OR.LB2.EQ.1)))
     &  .OR.((lb1*lb2.eq.-25*2.AND.(LB1.EQ.-2.OR.LB2.EQ.-2)).OR.
     &     (LB1*LB2.EQ.-27.AND.(LB1.EQ.-1.OR.LB2.EQ.-1))) )
     &     branch=1./3.
       ENDIF
cbz11/25/98end
       xs0=fdR(arraym(ir),arrayj(ir),arrayl(ir),
     &arrayw(ir),arrayb(ir),srt,EM1,EM2)
       xs=xs+1.3*pi*branch*xs0*(0.1973)**2
 1001 continue
       Erhon=xs
       return
       end
***************************8
*FUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
*KITAZOE'S FORMULA
c        REAL*4 FUNCTION FDR(DMASS,aj,al,width,widb0,srt,em1,em2)
      REAL FUNCTION FDR(DMASS,aj,al,width,widb0,srt,em1,em2)
      SAVE   
        AMd=em1
        AmP=em2
           Ak02= 0.25*(DMASS**2-amd**2-amp**2)**2
     &           -(Amp*amd)**2
            IF (ak02 .GT. 0.) THEN
              Q0 = SQRT(ak02/DMASS)
            ELSE
              Q0= 0.0
             fdR=0
           return
            END IF
           Ak2= 0.25*(srt**2-amd**2-amp**2)**2
     &           -(Amp*amd)**2
            IF (ak2 .GT. 0.) THEN
              Q = SQRT(ak2/DMASS)
            ELSE
              Q= 0.00
             fdR=0
             return
            END IF
       b=widb0*1.2*dmass/srt*(q/q0)**(2.*al+1)
     &  /(1.+0.2*(q/q0)**(2*al))
        FDR=(2.*aj+1)*WIDTH**2*b/((srt-dmass)**2
     1  +0.25*WIDTH**2)/(6.*q**2)
        RETURN
        END
******************************
* this program calculates the elastic cross section for pion+delta
* through higher resonances
c       REAL*4 FUNCTION DIRCT3(SRT)
      REAL FUNCTION DIRCT3(SRT)
* date : Dec. 19, 1994
* ****************************
c     implicit real*4 (a-h,o-z)
      dimension   arrayj(17),arrayl(17),arraym(17),
     &arrayw(17),arrayb(17)
      SAVE   
      data arrayj /1.5,0.5,2.5,2.5,1.5,0.5,1.5,3.5,
     &1.5,0.5,1.5,0.5,2.5,0.5,1.5,2.5,3.5/
      data arrayl/2,0,2,3,2,1,1,3,
     &1,0,2,0,3,1,1,2,3/
      data arraym /1.52,1.65,1.675,1.68,1.70,1.71,
     &1.72,1.99,1.60,1.62,1.70,1.90,1.905,1.910,
     &1.86,1.93,1.95/
      data arrayw/0.125,0.15,0.155,0.125,0.1,0.11,
     &0.2,0.29,0.25,0.16,0.28,0.15,0.3,0.22,0.25,
     &0.25,0.24/
      data arrayb/0.55,0.6,0.375,0.6,0.1,0.15,
     &0.15,0.05,0.35,0.3,0.15,0.1,0.1,0.22,
     &0.2,0.09,0.4/

* the minimum energy for pion+delta collision
       pi=3.1415926
       amn=0.938
       amp=0.138
       xs=0
* include contribution from each resonance
       branch=1./3.
       do 1001 ir=1,17
       if(ir.gt.8)branch=2./3.
       xs0=fd1(arraym(ir),arrayj(ir),arrayl(ir),
     &arrayw(ir),arrayb(ir),srt)
       xs=xs+1.3*pi*branch*xs0*(0.1973)**2
 1001   continue
       DIRCT3=XS
       RETURN
       end
***************************8
*FUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
*KITAZOE'S FORMULA
c        REAL*4 FUNCTION FD1(DMASS,aj,al,width,widb0,srt)
      REAL FUNCTION FD1(DMASS,aj,al,width,widb0,srt)
      SAVE   
        AMN=0.938
        AmP=0.138
       amd=amn
           Ak02= 0.25*(DMASS**2-amd**2-amp**2)**2
     &           -(Amp*amd)**2
            IF (ak02 .GT. 0.) THEN
              Q0 = SQRT(ak02/DMASS)
            ELSE
              Q0= 0.0
             fd1=0
           return
            END IF
           Ak2= 0.25*(srt**2-amd**2-amp**2)**2
     &           -(Amp*amd)**2
            IF (ak2 .GT. 0.) THEN
              Q = SQRT(ak2/DMASS)
            ELSE
              Q= 0.00
             fd1=0
             return
            END IF
       b=widb0*1.2*dmass/srt*(q/q0)**(2.*al+1)
     &  /(1.+0.2*(q/q0)**(2*al))
        FD1=(2.*aj+1)*WIDTH**2*b/((srt-dmass)**2
     1  +0.25*WIDTH**2)/(2.*q**2)
        RETURN
        END
******************************
* this program calculates the elastic cross section for pion+delta
* through higher resonances
c       REAL*4 FUNCTION DPION(EM1,EM2,LB1,LB2,SRT)
      REAL FUNCTION DPION(EM1,EM2,LB1,LB2,SRT)
* date : Dec. 19, 1994
* ****************************
c     implicit real*4 (a-h,o-z)
      dimension   arrayj(19),arrayl(19),arraym(19),
     &arrayw(19),arrayb(19)
      SAVE   
      data arrayj /0.5,1.5,0.5,0.5,2.5,2.5,1.5,0.5,1.5,3.5,
     &1.5,0.5,1.5,0.5,2.5,0.5,1.5,2.5,3.5/
      data arrayl/1,2,0,0,2,3,2,1,1,3,
     &1,0,2,0,3,1,1,2,3/
      data arraym /1.44,1.52,1.535,1.65,1.675,1.68,1.70,1.71,
     &1.72,1.99,1.60,1.62,1.70,1.90,1.905,1.910,
     &1.86,1.93,1.95/
      data arrayw/0.2,0.125,0.15,0.15,0.155,0.125,0.1,0.11,
     &0.2,0.29,0.25,0.16,0.28,0.15,0.3,0.22,0.25,
     &0.25,0.24/
      data arrayb/0.15,0.25,0.,0.05,0.575,0.125,0.379,0.10,
     &0.10,0.062,0.45,0.60,0.6984,0.05,0.25,0.089,
     &0.19,0.2,0.13/

* the minimum energy for pion+delta collision
       pi=3.1415926
       amn=0.94
       amp=0.14
       xs=0
* include contribution from each resonance
       do 1001 ir=1,19
       BRANCH=0.
cbz11/25/98
       if(ir.LE.8)THEN
c       IF(LB1*LB2.EQ.5*7.OR.LB1*LB2.EQ.3*8)branch=1./6.
c       IF(LB1*LB2.EQ.4*7.OR.LB1*LB2.EQ.4*8)branch=1./3.
c       IF(LB1*LB2.EQ.5*6.OR.LB1*LB2.EQ.3*9)branch=1./2.
c       ELSE
c       IF(LB1*LB2.EQ.5*8.OR.LB1*LB2.EQ.5*6)branch=2./5.
c       IF(LB1*LB2.EQ.3*9.OR.LB1*LB2.EQ.3*7)branch=2./5.
c       IF(LB1*LB2.EQ.5*7.OR.LB1*LB2.EQ.3*8)branch=8./15.
c       IF(LB1*LB2.EQ.4*7.OR.LB1*LB2.EQ.4*8)branch=1./15.
c       IF(LB1*LB2.EQ.4*9.OR.LB1*LB2.EQ.4*6)branch=3./5.
c       ENDIF
       IF( ((LB1*LB2.EQ.5*7.AND.(LB1.EQ.5.OR.LB2.EQ.5)).OR.
     &     (LB1*LB2.EQ.3*8.AND.(LB1.EQ.3.OR.LB2.EQ.3)))
     &       .OR.((LB1*LB2.EQ.-3*7.AND.(LB1.EQ.3.OR.LB2.EQ.3)).OR.
     &     (LB1*LB2.EQ.-5*8.AND.(LB1.EQ.5.OR.LB2.EQ.5))) )
     &     branch=1./6.
       IF((iabs(LB1*LB2).EQ.4*7.AND.(LB1.EQ.4.OR.LB2.EQ.4)).OR.
     &     (iabs(LB1*LB2).EQ.4*8.AND.(LB1.EQ.4.OR.LB2.EQ.4)))
     &     branch=1./3.
       IF( ((LB1*LB2.EQ.5*6.AND.(LB1.EQ.5.OR.LB2.EQ.5)).OR.
     &     (LB1*LB2.EQ.3*9.AND.(LB1.EQ.3.OR.LB2.EQ.3)))
     &       .OR.((LB1*LB2.EQ.-3*6.AND.(LB1.EQ.3.OR.LB2.EQ.3)).OR.
     &     (LB1*LB2.EQ.-5*9.AND.(LB1.EQ.5.OR.LB2.EQ.5))) )
     &     branch=1./2.
       ELSE
       IF( ((LB1*LB2.EQ.5*8.AND.(LB1.EQ.5.OR.LB2.EQ.5)).OR.
     &     (LB1*LB2.EQ.5*6.AND.(LB1.EQ.5.OR.LB2.EQ.5)))
     &        .OR.((LB1*LB2.EQ.-3*8.AND.(LB1.EQ.3.OR.LB2.EQ.3)).OR.
     &     (LB1*LB2.EQ.-3*6.AND.(LB1.EQ.3.OR.LB2.EQ.3))) )
     &     branch=2./5.
       IF( ((LB1*LB2.EQ.3*9.AND.(LB1.EQ.3.OR.LB2.EQ.3)).OR.
     &     (LB1*LB2.EQ.3*7.AND.(LB1.EQ.3.OR.LB2.EQ.3)))
     &        .OR. ((LB1*LB2.EQ.-5*9.AND.(LB1.EQ.5.OR.LB2.EQ.5)).OR.
     &     (LB1*LB2.EQ.-5*7.AND.(LB1.EQ.5.OR.LB2.EQ.5))) )
     &     branch=2./5.
       IF( ((LB1*LB2.EQ.5*7.AND.(LB1.EQ.5.OR.LB2.EQ.5)).OR.
     &     (LB1*LB2.EQ.3*8.AND.(LB1.EQ.3.OR.LB2.EQ.3)))
     &        .OR.((LB1*LB2.EQ.-3*7.AND.(LB1.EQ.3.OR.LB2.EQ.3)).OR.
     &     (LB1*LB2.EQ.-5*8.AND.(LB1.EQ.5.OR.LB2.EQ.5))) )
     &     branch=8./15.
       IF((iabs(LB1*LB2).EQ.4*7.AND.(LB1.EQ.4.OR.LB2.EQ.4)).OR.
     &     (iabs(LB1*LB2).EQ.4*8.AND.(LB1.EQ.4.OR.LB2.EQ.4)))
     &     branch=1./15.
       IF((iabs(LB1*LB2).EQ.4*9.AND.(LB1.EQ.4.OR.LB2.EQ.4)).OR.
     &     (iabs(LB1*LB2).EQ.4*6.AND.(LB1.EQ.4.OR.LB2.EQ.4)))
     &     branch=3./5.
       ENDIF
cbz11/25/98end
       xs0=fd2(arraym(ir),arrayj(ir),arrayl(ir),
     &arrayw(ir),arrayb(ir),EM1,EM2,srt)
       xs=xs+1.3*pi*branch*xs0*(0.1973)**2
 1001   continue
       DPION=XS
       RETURN
       end
***************************8
*FUNCTION FDE(DMASS) GIVES DELTA MASS DISTRIBUTION BY USING OF
*KITAZOE'S FORMULA
c        REAL*4 FUNCTION FD2(DMASS,aj,al,width,widb0,EM1,EM2,srt)
      REAL FUNCTION FD2(DMASS,aj,al,width,widb0,EM1,EM2,srt)
      SAVE   
        AmP=EM1
       amd=EM2
           Ak02= 0.25*(DMASS**2-amd**2-amp**2)**2
     &           -(Amp*amd)**2
            IF (ak02 .GT. 0.) THEN
              Q0 = SQRT(ak02/DMASS)
            ELSE
              Q0= 0.0
             fd2=0
           return
            END IF
           Ak2= 0.25*(srt**2-amd**2-amp**2)**2
     &           -(Amp*amd)**2
            IF (ak2 .GT. 0.) THEN
              Q = SQRT(ak2/DMASS)
            ELSE
              Q= 0.00
             fd2=0
             return
            END IF
       b=widb0*1.2*dmass/srt*(q/q0)**(2.*al+1)
     &  /(1.+0.2*(q/q0)**(2*al))
        FD2=(2.*aj+1)*WIDTH**2*b/((srt-dmass)**2
     1  +0.25*WIDTH**2)/(4.*q**2)
        RETURN
        END
***************************8
*   MASS GENERATOR for two resonances simultaneously
       subroutine Rmasdd(srt,am10,am20,
     &dmin1,dmin2,ISEED,ic,dm1,dm2)
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
       amn=0.94
       amp=0.14
* the maximum mass for resonance 1
         dmax1=srt-dmin2
* generate the mass for the first resonance
 5        NTRY1=0
         ntry2=0
         ntry=0
         ictrl=0
10        DM1 = RANART(NSEED) * (DMAX1-DMIN1) + DMIN1
          NTRY1=NTRY1+1
* the maximum mass for resonance 2 
         if(ictrl.eq.0)dmax2=srt-dm1
* generate the mass for the second resonance
20         dm2=RANART(NSEED)*(dmax2-dmin2)+dmin2
          NTRY2=NTRY2+1
* check the energy-momentum conservation with two masses
* q2 in the following is q**2*4*srt**2
         q2=((srt**2-dm1**2-dm2**2)**2-4.*dm1**2*dm2**2)
         if(q2.le.0)then
         dmax2=dm2-0.01
c         dmax1=dm1-0.01
         ictrl=1
         go to 20
         endif
* determine the weight of the mass pair         
          IF(DMAX1.LT.am10) THEN
          if(ic.eq.1)FM1=Fmassd(DMAX1)
          if(ic.eq.2)FM1=Fmassn(DMAX1)
          if(ic.eq.3)FM1=Fmassd(DMAX1)
          if(ic.eq.4)FM1=Fmassd(DMAX1)
          ELSE
          if(ic.eq.1)FM1=Fmassd(am10)
          if(ic.eq.2)FM1=Fmassn(am10)
          if(ic.eq.3)FM1=Fmassd(am10)
          if(ic.eq.4)FM1=Fmassd(am10)
          ENDIF
          IF(DMAX2.LT.am20) THEN
          if(ic.eq.1)FM2=Fmassd(DMAX2)
          if(ic.eq.2)FM2=Fmassn(DMAX2)
          if(ic.eq.3)FM2=Fmassn(DMAX2)
          if(ic.eq.4)FM2=Fmassr(DMAX2)
          ELSE
          if(ic.eq.1)FM2=Fmassd(am20)
          if(ic.eq.2)FM2=Fmassn(am20)
          if(ic.eq.3)FM2=Fmassn(am20)
          if(ic.eq.4)FM2=Fmassr(am20)
          ENDIF
          IF(FM1.EQ.0.)FM1=1.e-04
          IF(FM2.EQ.0.)FM2=1.e-04
         prob0=fm1*fm2
          if(ic.eq.1)prob=Fmassd(dm1)*fmassd(dm2)
          if(ic.eq.2)prob=Fmassn(dm1)*fmassn(dm2)
          if(ic.eq.3)prob=Fmassd(dm1)*fmassn(dm2)
          if(ic.eq.4)prob=Fmassd(dm1)*fmassr(dm2)
         if(prob.le.1.e-06)prob=1.e-06
         fff=prob/prob0
         ntry=ntry+1 
          IF(RANART(NSEED).GT.fff.AND.
     1    NTRY.LE.20) GO TO 10

clin-2/26/03 limit the mass of (rho,Delta,N*1440) below a certain value
c     (here taken as its central value + 2* B-W fullwidth):
          if((abs(am10-0.77).le.0.01.and.dm1.gt.1.07)
     1         .or.(abs(am10-1.232).le.0.01.and.dm1.gt.1.47)
     2         .or.(abs(am10-1.44).le.0.01.and.dm1.gt.2.14)) goto 5
          if((abs(am20-0.77).le.0.01.and.dm2.gt.1.07)
     1         .or.(abs(am20-1.232).le.0.01.and.dm2.gt.1.47)
     2         .or.(abs(am20-1.44).le.0.01.and.dm2.gt.2.14)) goto 5

       RETURN
       END
*FUNCTION Fmassd(DMASS) GIVES the delta MASS DISTRIBUTION 
        REAL FUNCTION Fmassd(DMASS)
      SAVE   
        AM0=1.232
        Fmassd=am0*WIDTH(DMASS)/((DMASS**2-am0**2)**2
     1  +am0**2*WIDTH(DMASS)**2)
        RETURN
        END
*FUNCTION Fmassn(DMASS) GIVES the N* MASS DISTRIBUTION 
        REAL FUNCTION Fmassn(DMASS)
      SAVE   
        AM0=1.44
        Fmassn=am0*W1440(DMASS)/((DMASS**2-am0**2)**2
     1  +am0**2*W1440(DMASS)**2)
        RETURN
        END
*FUNCTION Fmassr(DMASS) GIVES the rho MASS DISTRIBUTION 
        REAL FUNCTION Fmassr(DMASS)
      SAVE   
        AM0=0.77
       wid=0.153
        Fmassr=am0*Wid/((DMASS**2-am0**2)**2
     1  +am0**2*Wid**2)
        RETURN
        END
**********************************
* PURPOSE : flow analysis  
* DATE : Feb. 1, 1995
***********************************
       subroutine flow(nt)
c       IMPLICIT REAL*4 (A-H,O-Z)
       PARAMETER ( PI=3.1415926,APion=0.13957,aka=0.498)
        PARAMETER   (MAXSTR=150001,MAXR=1,AMU= 0.9383,etaM=0.5475)
       DIMENSION ypion(-80:80),ypr(-80:80),ykaon(-80:80)
       dimension pxpion(-80:80),pxpro(-80:80),pxkaon(-80:80)
*----------------------------------------------------------------------*
      COMMON  /AA/      R(3,MAXSTR)
cc      SAVE /AA/
      COMMON  /BB/      P(3,MAXSTR)
cc      SAVE /BB/
      COMMON  /CC/      E(MAXSTR)
cc      SAVE /CC/
      COMMON  /EE/      ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      COMMON  /RR/      MASSR(0:MAXR)
cc      SAVE /RR/
      COMMON  /RUN/     NUM
cc      SAVE /RUN/
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      SAVE   
*----------------------------------------------------------------------*
       ycut1=-2.6
       ycut2=2.6
       DY=0.2
       LY=NINT((YCUT2-YCUT1)/DY)
***********************************
C initialize the transverse momentum counters 
       do 11 kk=-80,80
       pxpion(kk)=0
       pxpro(kk)=0
       pxkaon(kk)=0
11       continue
       DO 701 J=-LY,LY
       ypion(j)=0
       ykaon(j)=0
       ypr(j)=0
  701   CONTINUE
       nkaon=0
       npr=0
       npion=0
          IS=0
          DO 20 NRUN=1,NUM
          IS=IS+MASSR(NRUN-1)
          DO 20 J=1,MASSR(NRUN)
          I=J+IS
* for protons go to 200 to calculate its rapidity and transvese momentum
* distributions
       e00=sqrt(P(1,I)**2+P(2,i)**2+P(3,i)**2+e(I)**2)
       y00=0.5*alog((e00+p(3,i))/(e00-p(3,i)))
       if(abs(y00).ge.ycut2)go to 20
       iy=nint(y00/DY)
       if(abs(iy).ge.80)go to 20
       if(e(i).eq.0)go to 20
       if(lb(i).ge.25)go to 20
       if((lb(i).le.5).and.(lb(i).ge.3))go to 50
       if(lb(i).eq.1.or.lb(i).eq.2)go to 200
cbz3/10/99
c       if(lb(i).ge.6.and.lb(i).le.15)go to 200
       if(lb(i).ge.6.and.lb(i).le.17)go to 200
cbz3/10/99 end
       if(lb(i).eq.23)go to 400
       go to 20
* calculate rapidity and transverse momentum distribution for pions
50       npion=npion+1
* (2) rapidity distribution in the cms frame
        ypion(iy)=ypion(iy)+1
       pxpion(iy)=pxpion(iy)+p(1,i)/e(I)
       go TO 20
* calculate rapidity and transverse energy distribution for baryons
200      npr=npr+1  
                pxpro(iy)=pxpro(iy)+p(1,I)/E(I)
                 ypr(iy)=ypr(iy)+1.
        go to 20
400     nkaon=nkaon+1  
                 ykaon(iy)=ykaon(iy)+1.
                pxkaon(iy)=pxkaon(iy)+p(1,i)/E(i)
20      CONTINUE
C PRINT OUT NUCLEON'S TRANSVERSE MOMENTUM distribution
c       write(1041,*)Nt
c       write(1042,*)Nt
c       write(1043,*)Nt
c       write(1090,*)Nt
c       write(1091,*)Nt
c       write(1092,*)Nt
       do 3 npt=-10,10
       IF(ypr(npt).eq.0) go to 101
       pxpro(NPT)=-Pxpro(NPT)/ypr(NPT)
       DNUC=Pxpro(NPT)/SQRT(ypr(NPT))
c       WRITE(1041,*)NPT*DY,Pxpro(NPT),DNUC
c print pion's transverse momentum distribution
101       IF(ypion(npt).eq.0) go to 102
       pxpion(NPT)=-pxpion(NPT)/ypion(NPT)
       DNUCp=pxpion(NPT)/SQRT(ypion(NPT))
c       WRITE(1042,*)NPT*DY,Pxpion(NPT),DNUCp
c kaons
102       IF(ykaon(npt).eq.0) go to 3
       pxkaon(NPT)=-pxkaon(NPT)/ykaon(NPT)
       DNUCk=pxkaon(NPT)/SQRT(ykaon(NPT))
c       WRITE(1043,*)NPT*DY,Pxkaon(NPT),DNUCk
3       CONTINUE
********************************
* OUTPUT PION AND PROTON RAPIDITY DISTRIBUTIONS
       DO 1001 M=-LY,LY
* PROTONS
       DYPR=0
       IF(YPR(M).NE.0)DYPR=SQRT(YPR(M))/FLOAT(NRUN)/DY
       YPR(M)=YPR(M)/FLOAT(NRUN)/DY
c       WRITE(1090,'(E11.3,2X,E11.3,2X,E11.3)')m*DY,YPR(M),DYPR
* PIONS
       DYPION=0
       IF(YPION(M).NE.0)DYPION=SQRT(YPION(M))/FLOAT(NRUN)/DY
       YPION(M)=YPION(M)/FLOAT(NRUN)/DY
c       WRITE(1091,'(E11.3,2X,E11.3,2X,E11.3)')m*DY,YPION(M),DYPION
* KAONS
       DYKAON=0
       IF(YKAON(M).NE.0)DYKAON=SQRT(YKAON(M))/FLOAT(NRUN)/DY
       YKAON(M)=YKAON(M)/FLOAT(NRUN)/DY
c       WRITE(1092,'(E11.3,2X,E11.3,2X,E11.3)')m*DY,YKAON(M),DYKAON
 1001 CONTINUE
       return
       end
cbali1/16/99
********************************************
* Purpose: pp_bar annihilation cross section as a functon of their cms energy
c      real*4 function xppbar(srt)
      real function xppbar(srt)
*  srt    = DSQRT(s) in GeV                                                   *
*  xppbar = pp_bar annihilation cross section in mb                           *
*                                                    
*  Reference: G.J. Wang, R. Bellwied, C. Pruneau and G. Welke
*             Proc. of the 14th Winter Workshop on Nuclear Dynamics, 
*             Snowbird, Utah 31, Eds. W. Bauer and H.G. Ritter 
*             (Plenum Publishing, 1998)                             *
*
******************************************
       Parameter (pmass=0.9383,xmax=400.)
      SAVE   
* Note:
* (1) we introduce a new parameter xmax=400 mb:
*     the maximum annihilation xsection 
* there are shadowing effects in pp_bar annihilation, with this parameter
* we can probably look at these effects  
* (2) Calculate p(lab) from srt [GeV], since the formular in the 
* reference applies only to the case of a p_bar on a proton at rest
* Formula used: srt**2=2.*pmass*(pmass+sqrt(pmass**2+plab**2))
       xppbar=1.e-06
       plab2=(srt**2/(2.*pmass)-pmass)**2-pmass**2
       if(plab2.gt.0)then
           plab=sqrt(plab2)
       xppbar=67./(plab**0.7)
       if(xppbar.gt.xmax)xppbar=xmax
       endif
         return
      END
cbali1/16/99 end
**********************************
cbali2/6/99
********************************************
* Purpose: To generate randomly the no. of pions in the final 
*          state of pp_bar annihilation according to a statistical 
*          model by using of the rejection method.  
cbz2/25/99
c      real*4 function pbarfs(srt,npion,iseed)
      subroutine pbarfs(srt,npion,iseed)
cbz2/25/99end
* Quantities: 
*  srt: DSQRT(s) in GeV                                                    *
*  npion: No. of pions produced in the annihilation of ppbar at srt        *
*  nmax=6, cutoff of the maximum no. of n the code can handle     
*                                             
*  Reference: C.M. Ko and R. Yuan, Phys. Lett. B192 (1987) 31      *
*
******************************************
       parameter (pimass=0.140,pi=3.1415926) 
       Dimension factor(6),pnpi(6) 
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
C the factorial coefficients in the pion no. distribution 
* from n=2 to 6 calculated use the formula in the reference
       factor(2)=1.
       factor(3)=1.17e-01
       factor(4)=3.27e-03
       factor(5)=3.58e-05
       factor(6)=1.93e-07
       ene=(srt/pimass)**3/(6.*pi**2)
c the relative probability from n=2 to 6
       do 1001 n=2,6 
           pnpi(n)=ene**n*factor(n)
 1001   continue
c find the maximum of the probabilities, I checked a 
c Fortan manual: max() returns the maximum value of 
c the same type as in the argument list
       pmax=max(pnpi(2),pnpi(3),pnpi(4),pnpi(5),pnpi(6))
c randomly generate n between 2 and 6
       ntry=0
 10    npion=2+int(5*RANART(NSEED))
clin-4/2008 check bounds:
       if(npion.gt.6) goto 10
       thisp=pnpi(npion)/pmax  
       ntry=ntry+1 
c decide whether to take this npion according to the distribution
c using rejection method.
       if((thisp.lt.RANART(NSEED)).and.(ntry.le.20)) go to 10
c now take the last generated npion and return
       return
       END
**********************************
cbali2/6/99 end
cbz3/9/99 kkbar
cbali3/5/99
******************************************
* purpose: Xsection for K+ K- to pi+ pi-
c      real*4 function xkkpi(srt)
*  srt    = DSQRT(s) in GeV                                  *
*  xkkpi   = xsection in mb obtained from
*           the detailed balance                             *
* ******************************************
c          parameter (pimass=0.140,aka=0.498)
c       xkkpi=1.e-08 
c       ppi2=(srt/2)**2-pimass**2
c       pk2=(srt/2)**2-aka**2
c       if(ppi2.le.0.or.pk2.le.0)return
cbz3/9/99 kkbar
c       xkkpi=ppi2/pk2*pipik(srt)
c       xkkpi=9.0 / 4.0 * ppi2/pk2*pipik(srt)
c        xkkpi = 2.0 * xkkpi
cbz3/9/99 kkbar end

cbz3/9/99 kkbar
c       end
c       return
c        END
cbz3/9/99 kkbar end

cbali3/5/99 end
cbz3/9/99 kkbar end

cbz3/9/99 kkbar
*****************************
* purpose: Xsection for K+ K- to pi+ pi-
      SUBROUTINE XKKANN(SRT, XSK1, XSK2, XSK3, XSK4, XSK5,
     &     XSK6, XSK7, XSK8, XSK9, XSK10, XSK11, SIGK, rrkk)
*  srt    = DSQRT(s) in GeV                                       *
*  xsk1   = annihilation into pi pi                               *
*  xsk2   = annihilation into pi rho (shifted to XKKSAN)         *
*  xsk3   = annihilation into pi omega (shifted to XKKSAN)       *
*  xsk4   = annihilation into pi eta                              *
*  xsk5   = annihilation into rho rho                             *
*  xsk6   = annihilation into rho omega                           *
*  xsk7   = annihilation into rho eta (shifted to XKKSAN)        *
*  xsk8   = annihilation into omega omega                         *
*  xsk9   = annihilation into omega eta (shifted to XKKSAN)      *
*  xsk10  = annihilation into eta eta                             *
*  sigk   = xsection in mb obtained from                          *
*           the detailed balance                                  *
* ***************************
      PARAMETER  (MAXSTR=150001, MAXX=20,  MAXZ=24)
          PARAMETER (AKA=0.498, PIMASS=0.140, RHOM = 0.770, 
     &     OMEGAM = 0.7819, ETAM = 0.5473, APHI=1.02)
      COMMON  /AA/ R(3,MAXSTR)
cc      SAVE /AA/
      COMMON /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
      SAVE   

        S = SRT ** 2
       SIGK = 1.E-08
        XSK1 = 0.0
        XSK2 = 0.0
        XSK3 = 0.0
        XSK4 = 0.0
        XSK5 = 0.0
        XSK6 = 0.0
        XSK7 = 0.0
        XSK8 = 0.0
        XSK9 = 0.0
        XSK10 = 0.0
        XSK11 = 0.0

        XPION0 = PIPIK(SRT)
c.....take into account both K+ and K0
        XPION0 = 2.0 * XPION0
        PI2 = S * (S - 4.0 * AKA ** 2)
         if(PI2 .le. 0.0)return

        XM1 = PIMASS
        XM2 = PIMASS
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XSK1 = 9.0 / 4.0 * PF2 / PI2 * XPION0
        END IF

clin-8/28/00 (pi eta) eta -> K+K- is assumed the same as pi pi -> K+K-:
        XM1 = PIMASS
        XM2 = ETAM
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XSK4 = 3.0 / 4.0 * PF2 / PI2 * XPION0
        END IF

        XM1 = ETAM
        XM2 = ETAM
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XSK10 = 1.0 / 4.0 * PF2 / PI2 * XPION0
        END IF

        XPION0 = rrkk

clin-11/07/00: (pi eta) (rho omega) -> K* Kbar (or K*bar K) instead to K Kbar:
c        XM1 = PIMASS
c        XM2 = RHOM
c        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
c        IF (PF2 .GT. 0.0) THEN
c           XSK2 = 27.0 / 4.0 * PF2 / PI2 * XPION0
c        END IF

c        XM1 = PIMASS
c        XM2 = OMEGAM
c        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
c        IF (PF2 .GT. 0.0) THEN
c           XSK3 = 9.0 / 4.0 * PF2 / PI2 * XPION0
c        END IF

        XM1 = RHOM
        XM2 = RHOM
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XSK5 = 81.0 / 4.0 * PF2 / PI2 * XPION0
        END IF

        XM1 = RHOM
        XM2 = OMEGAM
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XSK6 = 27.0 / 4.0 * PF2 / PI2 * XPION0
        END IF

c        XM1 = RHOM
c        XM2 = ETAM
c        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
c        IF (PF2 .GT. 0.0) THEN
c           XSK7 = 9.0 / 4.0 * PF2 / PI2 * XPION0
c        END IF

        XM1 = OMEGAM
        XM2 = OMEGAM
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XSK8 = 9.0 / 4.0 * PF2 / PI2 * XPION0
        END IF

c        XM1 = OMEGAM
c        XM2 = ETAM
c        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
c        IF (PF2 .GT. 0.0) THEN
c           XSK9 = 3.0 / 4.0 * PF2 / PI2 * XPION0
c        END IF

c* K+ + K- --> phi
          fwdp = 1.68*(aphi**2-4.*aka**2)**1.5/6./aphi/aphi     

clin-9/2012: check argument in sqrt():
          scheck=srt**2-4.0*aka**2
          if(scheck.le.0) then
             write(99,*) 'scheck47: ', scheck
             stop
          endif
          pkaon=0.5*sqrt(scheck)
c          pkaon=0.5*sqrt(srt**2-4.0*aka**2)

          XSK11 = 30.*3.14159*0.1973**2*(aphi*fwdp)**2/
     &             ((srt**2-aphi**2)**2+(aphi*fwdp)**2)/pkaon**2
c
        SIGK = XSK1 + XSK2 + XSK3 + XSK4 + XSK5 + 
     &     XSK6 + XSK7 + XSK8 + XSK9 + XSK10 + XSK11

       RETURN
        END
cbz3/9/99 kkbar end

*****************************
* purpose: Xsection for Phi + B 
       SUBROUTINE XphiB(LB1, LB2, EM1, EM2, SRT,
     &                  XSK1, XSK2, XSK3, XSK4, XSK5, SIGP)
c
* ***************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AP2=0.13957,AM0=1.232,PI=3.1415926)
          PARAMETER (AKA=0.498, ALA = 1.1157, PIMASS=0.140, APHI=1.02)
        parameter (arho=0.77)
      SAVE   

       SIGP = 1.E-08
        XSK1 = 0.0
        XSK2 = 0.0
        XSK3 = 0.0
        XSK4 = 0.0
        XSK5 = 0.0
        XSK6 = 0.0
          srrt = srt - (em1+em2)

c* phi + N(D) -> elastic scattering
c            XSK1 = 0.56  !! mb
c  !! mb  (photo-production xsecn used)
            XSK1 = 8.00
c
c* phi + N(D) -> pi + N
        IF (srt  .GT. (ap1+amn)) THEN
             XSK2 = 0.0235*srrt**(-0.519) 
        END IF
c
c* phi + N(D) -> pi + D
        IF (srt  .GT. (ap1+am0)) THEN
            if(srrt .lt. 0.7)then
             XSK3 = 0.0119*srrt**(-0.534)
            else
             XSK3 = 0.0130*srrt**(-0.304)
            endif      
        END IF
c
c* phi + N(D) -> rho + N
        IF (srt  .GT. (arho+amn)) THEN
           if(srrt .lt. 0.7)then
             XSK4 = 0.0166*srrt**(-0.786)
            else
             XSK4 = 0.0189*srrt**(-0.277)
            endif
        END IF
c
c* phi + N(D) -> rho + D   (same as pi + D)
        IF (srt  .GT. (arho+am0)) THEN
            if(srrt .lt. 0.7)then
             XSK5 = 0.0119*srrt**(-0.534)
            else
             XSK5 = 0.0130*srrt**(-0.304)
            endif      
        END IF
c
c* phi + N -> K+ + La
       IF( (lb1.ge.1.and.lb1.le.2) .or. (lb2.ge.1.and.lb2.le.2) )THEN
        IF (srt  .GT. (aka+ala)) THEN
           XSK6 = 1.715/((srrt+3.508)**2-12.138)  
        END IF
       END IF
        SIGP = XSK1 + XSK2 + XSK3 + XSK4 + XSK5 + XSK6
       RETURN
        END
c
**********************************
*
        SUBROUTINE CRPHIB(PX,PY,PZ,SRT,I1,I2,
     &     XSK1, XSK2, XSK3, XSK4, XSK5, SIGP, IBLOCK)
*
*     PURPOSE:                                                         *
*             DEALING WITH PHI + N(D) --> pi+N(D), rho+N(D),  K+ + La
*     QUANTITIES:                                                      *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - INFORMATION about the reaction channel          *
*                
*             iblock   - 20  elastic
*             iblock   - 221  K+ formation
*             iblock   - 223  others
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AMRHO=0.769,AMOMGA=0.782,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974,ARHO=0.77)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
c
       PX0=PX
       PY0=PY
       PZ0=PZ
       IBLOCK=223
c
        X1 = RANART(NSEED) * SIGP
        XSK2 = XSK1 + XSK2
        XSK3 = XSK2 + XSK3
        XSK4 = XSK3 + XSK4
        XSK5 = XSK4 + XSK5
c
c  !! elastic scatt.
        IF (X1 .LE. XSK1) THEN
           iblock=20
           GOTO 100
        ELSE IF (X1 .LE. XSK2) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 1 + int(2 * RANART(NSEED))
           E(I1) = AP1
           E(I2) = AMN
           GOTO 100
        ELSE IF (X1 .LE. XSK3) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 6 + int(4 * RANART(NSEED))
           E(I1) = AP1
           E(I2) = AM0
           GOTO 100
        ELSE IF (X1 .LE. XSK4) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = 1 + int(2 * RANART(NSEED))
           E(I1) = ARHO
           E(I2) = AMN
           GOTO 100
        ELSE IF (X1 .LE. XSK5) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = 6 + int(4 * RANART(NSEED))
           E(I1) = ARHO
           E(I2) = AM0
           GOTO 100
        ELSE 
           LB(I1) = 23
           LB(I2) = 14
           E(I1) = AKA
           E(I2) = ALA
          IBLOCK=221
         ENDIF
 100    CONTINUE
      EM1=E(I1)
      EM2=E(I2)
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.E-08
          PR=SQRT(PR2)/(2.*SRT)
* WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS 
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
* ROTATE IT 
       CALL ROTATE(PX0,PY0,PZ0,PX,PY,PZ) 
      RETURN
      END
c
*****************************
* purpose: Xsection for Phi + B 
c!! in fm^2
      SUBROUTINE pibphi(srt,lb1,lb2,em1,em2,Xphi,xphin) 
c
*      phi + N(D) <- pi + N
*      phi + N(D) <- pi + D
*      phi + N(D) <- rho + N
*      phi + N(D) <- rho + D   (same as pi + D)
c
* ***************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AP2=0.13957,AM0=1.232,PI=3.1415926)
          PARAMETER (AKA=0.498, ALA = 1.1157, PIMASS=0.140, APHI=1.02)
        parameter (arho=0.77)
      SAVE   

       Xphi = 0.0
       xphin = 0.0
       xphid = 0.0
c
       if( (lb1.ge.3.and.lb1.le.5) .or.
     &     (lb2.ge.3.and.lb2.le.5) )then
c
       if( (iabs(lb1).ge.1.and.iabs(lb1).le.2) .or.
     &     (iabs(lb2).ge.1.and.iabs(lb2).le.2) )then
c* phi + N <- pi + N
        IF (srt  .GT. (aphi+amn)) THEN
             srrt = srt - (aphi+amn)
             sig = 0.0235*srrt**(-0.519) 
          xphin=sig*1.*(srt**2-(aphi+amn)**2)*
     &           (srt**2-(aphi-amn)**2)/(srt**2-(em1+em2)**2)/
     &           (srt**2-(em1-em2)**2)
        END IF
c* phi + D <- pi + N
        IF (srt  .GT. (aphi+am0)) THEN
             srrt = srt - (aphi+am0)
             sig = 0.0235*srrt**(-0.519) 
          xphid=sig*4.*(srt**2-(aphi+am0)**2)*
     &           (srt**2-(aphi-am0)**2)/(srt**2-(em1+em2)**2)/
     &           (srt**2-(em1-em2)**2)
        END IF
       else
c* phi + N <- pi + D
        IF (srt  .GT. (aphi+amn)) THEN
             srrt = srt - (aphi+amn)
            if(srrt .lt. 0.7)then
             sig = 0.0119*srrt**(-0.534)
            else
             sig = 0.0130*srrt**(-0.304)
            endif      
          xphin=sig*(1./4.)*(srt**2-(aphi+amn)**2)*
     &           (srt**2-(aphi-amn)**2)/(srt**2-(em1+em2)**2)/
     &           (srt**2-(em1-em2)**2)
        END IF
c* phi + D <- pi + D
        IF (srt  .GT. (aphi+am0)) THEN
             srrt = srt - (aphi+am0)
             if(srrt .lt. 0.7)then
             sig = 0.0119*srrt**(-0.534)
            else
             sig = 0.0130*srrt**(-0.304)
            endif      
          xphid=sig*1.*(srt**2-(aphi+am0)**2)*
     &           (srt**2-(aphi-am0)**2)/(srt**2-(em1+em2)**2)/
     &           (srt**2-(em1-em2)**2)
        END IF
       endif
c
c
C** for rho + N(D) colln
c
       else
c
       if( (iabs(lb1).ge.1.and.iabs(lb1).le.2) .or.
     &     (iabs(lb2).ge.1.and.iabs(lb2).le.2) )then
c
c* phi + N <- rho + N
        IF (srt  .GT. (aphi+amn)) THEN
             srrt = srt - (aphi+amn)
           if(srrt .lt. 0.7)then
             sig = 0.0166*srrt**(-0.786)
            else
             sig = 0.0189*srrt**(-0.277)
            endif
          xphin=sig*(1./3.)*(srt**2-(aphi+amn)**2)*
     &           (srt**2-(aphi-amn)**2)/(srt**2-(em1+em2)**2)/
     &           (srt**2-(em1-em2)**2)
        END IF
c* phi + D <- rho + N
        IF (srt  .GT. (aphi+am0)) THEN
             srrt = srt - (aphi+am0)
           if(srrt .lt. 0.7)then
             sig = 0.0166*srrt**(-0.786)
            else
             sig = 0.0189*srrt**(-0.277)
            endif
          xphid=sig*(4./3.)*(srt**2-(aphi+am0)**2)*
     &           (srt**2-(aphi-am0)**2)/(srt**2-(em1+em2)**2)/
     &           (srt**2-(em1-em2)**2)
        END IF
       else
c* phi + N <- rho + D  (same as pi+D->phi+N)
        IF (srt  .GT. (aphi+amn)) THEN
             srrt = srt - (aphi+amn)
            if(srrt .lt. 0.7)then
             sig = 0.0119*srrt**(-0.534)
            else
             sig = 0.0130*srrt**(-0.304)
            endif      
          xphin=sig*(1./12.)*(srt**2-(aphi+amn)**2)*
     &           (srt**2-(aphi-amn)**2)/(srt**2-(em1+em2)**2)/
     &           (srt**2-(em1-em2)**2)
        END IF
c* phi + D <- rho + D  (same as pi+D->phi+D)
        IF (srt  .GT. (aphi+am0)) THEN
             srrt = srt - (aphi+am0)
             if(srrt .lt. 0.7)then
             sig = 0.0119*srrt**(-0.534)
            else
             sig = 0.0130*srrt**(-0.304)
            endif      
          xphid=sig*(1./3.)*(srt**2-(aphi+am0)**2)*
     &           (srt**2-(aphi-am0)**2)/(srt**2-(em1+em2)**2)/
     &           (srt**2-(em1-em2)**2)
        END IF
       endif
        END IF
c   !! in fm^2
         xphin = xphin/10.
c   !! in fm^2
         xphid = xphid/10.
         Xphi = xphin + xphid

       RETURN
        END
c
*****************************
* purpose: Xsection for phi +M to K+K etc
      SUBROUTINE PHIMES(I1, I2, SRT, XSK1, XSK2, XSK3, XSK4, XSK5,
     1     XSK6, XSK7, SIGPHI)

*     QUANTITIES:                                                      *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                      223 --> phi destruction
*                      20 -->  elastic
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER  (AKA=0.498, AKS=0.895, AOMEGA=0.7819,
     3               ARHO=0.77, APHI=1.02)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        PARAMETER  (MAXX=20,  MAXZ=24)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
      COMMON  /DD/      RHO(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHOP(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ),
     &                     RHON(-MAXX:MAXX,-MAXX:MAXX,-MAXZ:MAXZ)
cc      SAVE /DD/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      SAVE   

        S = SRT ** 2
       SIGPHI = 1.E-08
        XSK1 = 0.0
        XSK2 = 0.0
        XSK3 = 0.0
        XSK4 = 0.0
        XSK5 = 0.0
        XSK6 = 0.0
        XSK7 = 0.0
         em1 = E(i1)
         em2 = E(i2)
         LB1 = LB(i1)
         LB2 = LB(i2)
         akap = aka
c******
c
c   !! mb, elastic
         XSK1 = 5.0
         
clin-9/2012: check argument in sqrt():
         scheck=(S-(em1+em2)**2)*(S-(em1-em2)**2)
         if(scheck.le.0) then
            write(99,*) 'scheck48: ', scheck
            stop
         endif
         pii=sqrt(scheck)
c           pii = sqrt((S-(em1+em2)**2)*(S-(em1-em2)**2))

* phi + K(-bar) channel
       if( lb1.eq.23.or.lb2.eq.23 .or. lb1.eq.21.or.lb2.eq.21 )then
          if(srt .gt. (ap1+akap))then
c             XSK2 = 2.5  
           pff = sqrt((S-(ap1+akap)**2)*(S-(ap1-akap)**2))
           XSK2 = 195.639*pff/pii/32./pi/S 
          endif
          if(srt .gt. (arho+akap))then
c              XSK3 = 3.5  
           pff = sqrt((S-(arho+akap)**2)*(S-(arho-akap)**2))
           XSK3 = 526.702*pff/pii/32./pi/S 
          endif
          if(srt .gt. (aomega+akap))then
c               XSK4 = 3.5 
           pff = sqrt((S-(aomega+akap)**2)*(S-(aomega-akap)**2))
           XSK4 = 355.429*pff/pii/32./pi/S 
          endif
          if(srt .gt. (ap1+aks))then
c           XSK5 = 15.0  
           pff = sqrt((S-(ap1+aks)**2)*(S-(ap1-aks)**2))
           XSK5 = 2047.042*pff/pii/32./pi/S 
          endif
          if(srt .gt. (arho+aks))then
c            XSK6 = 3.5 
           pff = sqrt((S-(arho+aks)**2)*(S-(arho-aks)**2))
           XSK6 = 1371.257*pff/pii/32./pi/S 
          endif
          if(srt .gt. (aomega+aks))then
c            XSK7 = 3.5 
           pff = sqrt((S-(aomega+aks)**2)*(S-(aomega-aks)**2))
           XSK7 = 482.292*pff/pii/32./pi/S 
          endif
c
       elseif( iabs(lb1).eq.30.or.iabs(lb2).eq.30 )then
* phi + K*(-bar) channel
c
          if(srt .gt. (ap1+akap))then
c             XSK2 = 3.5  
           pff = sqrt((S-(ap1+akap)**2)*(S-(ap1-akap)**2))
           XSK2 = 372.378*pff/pii/32./pi/S 
          endif
          if(srt .gt. (arho+akap))then
c              XSK3 = 9.0  
           pff = sqrt((S-(arho+akap)**2)*(S-(arho-akap)**2))
           XSK3 = 1313.960*pff/pii/32./pi/S 
          endif
          if(srt .gt. (aomega+akap))then
c               XSK4 = 6.5 
           pff = sqrt((S-(aomega+akap)**2)*(S-(aomega-akap)**2))
           XSK4 = 440.558*pff/pii/32./pi/S 
          endif
          if(srt .gt. (ap1+aks))then
c           XSK5 = 30.0 !wrong  
           pff = sqrt((S-(ap1+aks)**2)*(S-(ap1-aks)**2))
           XSK5 = 1496.692*pff/pii/32./pi/S 
          endif
          if(srt .gt. (arho+aks))then
c            XSK6 = 9.0 
           pff = sqrt((S-(arho+aks)**2)*(S-(arho-aks)**2))
           XSK6 = 6999.840*pff/pii/32./pi/S 
          endif
          if(srt .gt. (aomega+aks))then
c            XSK7 = 15.0 
           pff = sqrt((S-(aomega+aks)**2)*(S-(aomega-aks)**2))
           XSK7 = 1698.903*pff/pii/32./pi/S 
          endif
       else
c
* phi + rho(pi,omega) channel
c
           srr1 = em1+em2
         if(srt .gt. (akap+akap))then
          srrt = srt - srr1
cc          if(srrt .lt. 0.3)then
          if(srrt .lt. 0.3 .and. srrt .gt. 0.01)then
          XSK2 = 1.69/(srrt**0.141 - 0.407)
          else
          XSK2 = 3.74 + 0.008*srrt**1.9
          endif                 
         endif
         if(srt .gt. (akap+aks))then
          srr2 = akap+aks
          srr = amax1(srr1,srr2)
          srrt = srt - srr
cc          if(srrt .lt. 0.3)then
          if(srrt .lt. 0.3 .and. srrt .gt. 0.01)then
          XSK3 = 1.69/(srrt**0.141 - 0.407)
          else
          XSK3 = 3.74 + 0.008*srrt**1.9
          endif
         endif
         if(srt .gt. (aks+aks))then
          srr2 = aks+aks
          srr = amax1(srr1,srr2)
          srrt = srt - srr
cc          if(srrt .lt. 0.3)then
          if(srrt .lt. 0.3 .and. srrt .gt. 0.01)then
          XSK4 = 1.69/(srrt**0.141 - 0.407)
          else
          XSK4 = 3.74 + 0.008*srrt**1.9
          endif
         endif
c          xsk2 = amin1(20.,xsk2)
c          xsk3 = amin1(20.,xsk3)
c          xsk4 = amin1(20.,xsk4)
      endif

        SIGPHI = XSK1 + XSK2 + XSK3 + XSK4 + XSK5 + XSK6 + XSK7

       RETURN
       END

**********************************
*     PURPOSE:                                                         *
*             DEALING WITH phi+M  scatt.
*
       SUBROUTINE CRPHIM(PX,PY,PZ,SRT,I1,I2,
     &  XSK1, XSK2, XSK3, XSK4, XSK5, XSK6, SIGPHI, IKKG, IKKL, IBLOCK)
*
*     QUANTITIES:                                                      *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                      20 -->  elastic
*                      223 --> phi + pi(rho,omega)
*                      224 --> phi + K -> K + pi(rho,omega)
*                      225 --> phi + K -> K* + pi(rho,omega)
*                      226 --> phi + K* -> K + pi(rho,omega)
*                      227 --> phi + K* -> K* + pi(rho,omega)
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,ARHO=0.77,AOMEGA=0.7819,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER    (AKA=0.498,AKS=0.895)
        parameter   (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   
c
       PX0=PX
       PY0=PY
       PZ0=PZ
         LB1 = LB(i1)
         LB2 = LB(i2)

        X1 = RANART(NSEED) * SIGPHI
        XSK2 = XSK1 + XSK2
        XSK3 = XSK2 + XSK3
        XSK4 = XSK3 + XSK4
        XSK5 = XSK4 + XSK5
        XSK6 = XSK5 + XSK6
        IF (X1 .LE. XSK1) THEN
c        !! elastic scatt
           IBLOCK=20
           GOTO 100
        ELSE
c
*phi + (K,K*)-bar
       if( lb1.eq.23.or.lb1.eq.21.or.iabs(lb1).eq.30 .OR.
     &     lb2.eq.23.or.lb2.eq.21.or.iabs(lb2).eq.30 )then
c
             if(lb1.eq.23.or.lb2.eq.23)then
               IKKL=1
               IBLOCK=224
               iad1 = 23
               iad2 = 30
              elseif(lb1.eq.30.or.lb2.eq.30)then
               IKKL=0
               IBLOCK=226
               iad1 = 23
               iad2 = 30
             elseif(lb1.eq.21.or.lb2.eq.21)then
               IKKL=1
               IBLOCK=124
               iad1 = 21
               iad2 = -30
c         !! -30
             else
               IKKL=0
               IBLOCK=126
               iad1 = 21
               iad2 = -30
              endif
         IF (X1 .LE. XSK2) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = iad1
           E(I1) = AP1
           E(I2) = AKA
           IKKG = 1
           GOTO 100
        ELSE IF (X1 .LE. XSK3) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = iad1
           E(I1) = ARHO
           E(I2) = AKA
           IKKG = 1
           GOTO 100
        ELSE IF (X1 .LE. XSK4) THEN
           LB(I1) = 28
           LB(I2) = iad1
           E(I1) = AOMEGA
           E(I2) = AKA
           IKKG = 1
           GOTO 100
        ELSE IF (X1 .LE. XSK5) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = iad2
           E(I1) = AP1
           E(I2) = AKS
           IKKG = 0
           IBLOCK=IBLOCK+1
           GOTO 100
        ELSE IF (X1 .LE. XSK6) THEN
           LB(I1) = 25 + int(3 * RANART(NSEED))
           LB(I2) = iad2
           E(I1) = ARHO
           E(I2) = AKS
           IKKG = 0
           IBLOCK=IBLOCK+1
           GOTO 100
        ELSE 
           LB(I1) = 28
           LB(I2) = iad2
           E(I1) = AOMEGA
           E(I2) = AKS
           IKKG = 0
           IBLOCK=IBLOCK+1
           GOTO 100
         ENDIF
       else
c      !! phi destruction via (pi,rho,omega)
          IBLOCK=223
*phi + pi(rho,omega)
         IF (X1 .LE. XSK2) THEN
           LB(I1) = 23
           LB(I2) = 21
           E(I1) = AKA
           E(I2) = AKA
           IKKG = 2
           IKKL = 0
           GOTO 100
        ELSE IF (X1 .LE. XSK3) THEN
           LB(I1) = 23
c           LB(I2) = 30
           LB(I2) = -30
clin-2/10/03 currently take XSK3 to be the sum of KK*bar & KbarK*:
           if(RANART(NSEED).le.0.5) then
              LB(I1) = 21
              LB(I2) = 30
           endif
              
           E(I1) = AKA
           E(I2) = AKS
           IKKG = 1
           IKKL = 0
           GOTO 100
        ELSE IF (X1 .LE. XSK4) THEN
           LB(I1) = 30
c           LB(I2) = 30
           LB(I2) = -30
           E(I1) = AKS
           E(I2) = AKS
           IKKG = 0
           IKKL = 0
           GOTO 100
         ENDIF
       endif
         ENDIF
*
100    CONTINUE
       EM1=E(I1)
       EM2=E(I2)

*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.E-08
          PR=SQRT(PR2)/(2.*SRT)
* WE ASSUME AN ISOTROPIC ANGULAR DISTRIBUTION IN THE CMS 
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
* ROTATE IT 
       CALL ROTATE(PX0,PY0,PZ0,PX,PY,PZ) 
      RETURN
      END
**********************************
**********************************
cbz3/9/99 khyperon
*************************************
* purpose: Xsection for K+Y ->  piN                                       *
*          Xsection for K+Y-bar ->  piN-bar   !! sp03/29/01               *
*
        SUBROUTINE XKHYPE(I1, I2, SRT, XKY1, XKY2, XKY3, XKY4, XKY5,
     &     XKY6, XKY7, XKY8, XKY9, XKY10, XKY11, XKY12, XKY13,
     &     XKY14, XKY15, XKY16, XKY17, SIGK)
c      subroutine xkhype(i1, i2, srt, sigk)
*  srt    = DSQRT(s) in GeV                                               *
*  xkkpi   = xsection in mb obtained from                                 *
*           the detailed balance                                          *
* ***********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,AMRHO=0.769,AMOMGA=0.782,APHI=1.02,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
          parameter (pimass=0.140, AMETA = 0.5473, aka=0.498,
     &     aml=1.116,ams=1.193, AM1440 = 1.44, AM1535 = 1.535)
        COMMON  /EE/ID(MAXSTR), LB(MAXSTR)
cc      SAVE /EE/
      SAVE   

        S = SRT ** 2
       SIGK=1.E-08 
        XKY1 = 0.0
        XKY2 = 0.0
        XKY3 = 0.0
        XKY4 = 0.0
        XKY5 = 0.0
        XKY6 = 0.0
        XKY7 = 0.0
        XKY8 = 0.0
        XKY9 = 0.0
        XKY10 = 0.0
        XKY11 = 0.0
        XKY12 = 0.0
        XKY13 = 0.0
        XKY14 = 0.0
        XKY15 = 0.0
        XKY16 = 0.0
        XKY17 = 0.0

        LB1 = LB(I1)
        LB2 = LB(I2)
        IF (iabs(LB1) .EQ. 14 .OR. iabs(LB2) .EQ. 14) THEN
           XKAON0 = PNLKA(SRT)
           XKAON0 = 2.0 * XKAON0
           PI2 = (S - (AML + AKA) ** 2) * (S - (AML - AKA) ** 2)
        ELSE
           XKAON0 = PNSKA(SRT)
           XKAON0 = 2.0 * XKAON0
           PI2 = (S - (AMS + AKA) ** 2) * (S - (AMS - AKA) ** 2)
        END IF
          if(PI2 .le. 0.0)return

        XM1 = PIMASS
        XM2 = AMP
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY1 = 3.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = PIMASS
        XM2 = AM0
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY2 = 12.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = PIMASS
        XM2 = AM1440
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY3 = 3.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = PIMASS
        XM2 = AM1535
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY4 = 3.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMRHO
        XM2 = AMP
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY5 = 9.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMRHO
        XM2 = AM0
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY6 = 36.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMRHO
        XM2 = AM1440
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY7 = 9.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMRHO
        XM2 = AM1535
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY8 = 9.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMOMGA
        XM2 = AMP
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY9 = 3.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMOMGA
        XM2 = AM0
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY10 = 12.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMOMGA
        XM2 = AM1440
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY11 = 3.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMOMGA
        XM2 = AM1535
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY12 = 3.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMETA
        XM2 = AMP
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY13 = 1.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMETA
        XM2 = AM0
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY14 = 4.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMETA
        XM2 = AM1440
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY15 = 1.0 * PF2 / PI2 * XKAON0
        END IF
        
        XM1 = AMETA
        XM2 = AM1535
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           XKY16 = 1.0 * PF2 / PI2 * XKAON0
        END IF

csp11/21/01  K+ + La --> phi + N 
        if(lb1.eq.14 .or. lb2.eq.14)then
         if(srt .gt. (aphi+amn))then
           srrt = srt - (aphi+amn)
           sig = 1.715/((srrt+3.508)**2-12.138)
         XM1 = AMN
         XM2 = APHI
         PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
c     ! fm^-1
         XKY17 = 3.0 * PF2 / PI2 * SIG/10.
        endif
       endif
csp11/21/01  end 
c

       IF ((iabs(LB1) .GE. 15 .AND. iabs(LB1) .LE. 17) .OR. 
     &     (iabs(LB2) .GE. 15 .AND. iabs(LB2) .LE. 17)) THEN
           DDF = 3.0
           XKY1 = XKY1 / DDF
           XKY2 = XKY2 / DDF
           XKY3 = XKY3 / DDF
           XKY4 = XKY4 / DDF
           XKY5 = XKY5 / DDF
           XKY6 = XKY6 / DDF
           XKY7 = XKY7 / DDF
           XKY8 = XKY8 / DDF
           XKY9 = XKY9 / DDF
           XKY10 = XKY10/ DDF
           XKY11 = XKY11 / DDF
           XKY12 = XKY12 / DDF
           XKY13 = XKY13 / DDF
           XKY14 = XKY14 / DDF
           XKY15 = XKY15 / DDF
           XKY16 = XKY16 / DDF
        END IF
        
        SIGK = XKY1 + XKY2 + XKY3 + XKY4 +
     &       XKY5 + XKY6 + XKY7 + XKY8 +
     &       XKY9 + XKY10 + XKY11 + XKY12 +
     &       XKY13 + XKY14 + XKY15 + XKY16 + XKY17

       RETURN
       END

C*******************************  
      BLOCK DATA PPBDAT 
    
      parameter (AMP=0.93828,AMN=0.939457,
     1     AM0=1.232,AM1440 = 1.44, AM1535 = 1.535)

c     to give default values to parameters for BbarB production from mesons
      COMMON/ppbmas/niso(15),nstate,ppbm(15,2),thresh(15),weight(15)
cc      SAVE /ppbmas/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   
c     thresh(i) gives the mass thresh for final channel i:
      DATA thresh/1.87656,1.877737,1.878914,2.17028,
     1     2.171457,2.37828,2.379457,2.464,2.47328,2.474457,
     2     2.672,2.767,2.88,2.975,3.07/
c     ppbm(i,j=1,2) gives masses for the two final baryons of channel i,
c     with j=1 for the lighter baryon:
      DATA (ppbm(i,1),i=1,15)/amp,amp,amn,amp,amn,amp,amn,
     1     am0,amp,amn,am0,am0,am1440,am1440,am1535/
      DATA (ppbm(i,2),i=1,15)/amp,amn,amn,am0,am0,am1440,am1440,
     1     am0,am1535,am1535,am1440,am1535,am1440,am1535,am1535/
c     factr2(i) gives weights for producing i pions from ppbar annihilation:
      DATA factr2/0,1,1.17e-01,3.27e-03,3.58e-05,1.93e-07/
c     niso(i) gives the degeneracy factor for final channel i:
      DATA niso/1,2,1,16,16,4,4,64,4,4,32,32,4,8,4/

      END   


*****************************************
* get the number of BbarB states available for mm collisions of energy srt 
      subroutine getnst(srt)
*  srt    = DSQRT(s) in GeV                                                   *
*****************************************
      parameter (pimass=0.140,pi=3.1415926)
      COMMON/ppbmas/niso(15),nstate,ppbm(15,2),thresh(15),weight(15)
cc      SAVE /ppbmas/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      s=srt**2
      nstate=0
      wtot=0.
      if(srt.le.thresh(1)) return
      do 1001 i=1,15
         weight(i)=0.
         if(srt.gt.thresh(i)) nstate=i
 1001 continue
      do 1002 i=1,nstate
         pf2=(s-(ppbm(i,1)+ppbm(i,2))**2)
     1        *(s-(ppbm(i,1)-ppbm(i,2))**2)/4/s
         weight(i)=pf2*niso(i)
         wtot=wtot+weight(i)
 1002 continue
      ene=(srt/pimass)**3/(6.*pi**2)
      fsum=factr2(2)+factr2(3)*ene+factr2(4)*ene**2
     1     +factr2(5)*ene**3+factr2(6)*ene**4

      return
      END

*****************************************
* for pion+pion-->Bbar B                                                      *
c      real*4 function ppbbar(srt)
      real function ppbbar(srt)
*****************************************
      parameter (pimass=0.140,arho=0.77,aomega=0.782)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      sppb2p=xppbar(srt)*factr2(2)/fsum
      pi2=(s-4*pimass**2)/4
      ppbbar=4./9.*sppb2p/pi2*wtot

      return
      END

*****************************************
* for pion+rho-->Bbar B                                                      *
c      real*4 function prbbar(srt)
      real function prbbar(srt)
*****************************************
      parameter (pimass=0.140,arho=0.77,aomega=0.782)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      sppb3p=xppbar(srt)*factr2(3)*ene/fsum
      pi2=(s-(pimass+arho)**2)*(s-(pimass-arho)**2)/4/s
      prbbar=4./27.*sppb3p/pi2*wtot

      return
      END

*****************************************
* for rho+rho-->Bbar B                                                      *
c      real*4 function rrbbar(srt)
      real function rrbbar(srt)
*****************************************
      parameter (pimass=0.140,arho=0.77,aomega=0.782)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      sppb4p=xppbar(srt)*factr2(4)*ene**2/fsum
      pi2=(s-4*arho**2)/4
      rrbbar=4./81.*(sppb4p/2)/pi2*wtot

      return
      END

*****************************************
* for pi+omega-->Bbar B                                                      *
c      real*4 function pobbar(srt)
      real function pobbar(srt)
*****************************************
      parameter (pimass=0.140,arho=0.77,aomega=0.782)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      sppb4p=xppbar(srt)*factr2(4)*ene**2/fsum
      pi2=(s-(pimass+aomega)**2)*(s-(pimass-aomega)**2)/4/s
      pobbar=4./9.*(sppb4p/2)/pi2*wtot

      return
      END

*****************************************
* for rho+omega-->Bbar B                                                      *
c      real*4 function robbar(srt)
      real function robbar(srt)
*****************************************
      parameter (pimass=0.140,arho=0.77,aomega=0.782)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      sppb5p=xppbar(srt)*factr2(5)*ene**3/fsum
      pi2=(s-(arho+aomega)**2)*(s-(arho-aomega)**2)/4/s
      robbar=4./27.*sppb5p/pi2*wtot

      return
      END

*****************************************
* for omega+omega-->Bbar B                                                    *
c      real*4 function oobbar(srt)
      real function oobbar(srt)
*****************************************
      parameter (pimass=0.140,arho=0.77,aomega=0.782)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      sppb6p=xppbar(srt)*factr2(6)*ene**4/fsum
      pi2=(s-4*aomega**2)/4
      oobbar=4./9.*sppb6p/pi2*wtot

      return
      END

*****************************************
* Generate final states for mm-->Bbar B                                       *
      SUBROUTINE bbarfs(lbb1,lbb2,ei1,ei2,iblock,iseed)
*****************************************
      COMMON/ppbmas/niso(15),nstate,ppbm(15,2),thresh(15),weight(15)
cc      SAVE /ppbmas/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

c     determine which final BbarB channel occurs:
      rd=RANART(NSEED)
      wsum=0.
      do 1001 i=1,nstate
         wsum=wsum+weight(i)
         if(rd.le.(wsum/wtot)) then
            ifs=i
            ei1=ppbm(i,1)
            ei2=ppbm(i,2)
            goto 10
         endif
 1001 continue
 10   continue

c1    pbar p
      if(ifs.eq.1) then
         iblock=1801
         lbb1=-1
         lbb2=1
      elseif(ifs.eq.2) then
c2    pbar n
         if(RANART(NSEED).le.0.5) then
            iblock=18021
            lbb1=-1
            lbb2=2
c2    nbar p
         else
            iblock=18022
            lbb1=1
            lbb2=-2
         endif
c3    nbar n
      elseif(ifs.eq.3) then
         iblock=1803
         lbb1=-2
         lbb2=2
c4&5  (pbar nbar) Delta, (p n) anti-Delta
      elseif(ifs.eq.4.or.ifs.eq.5) then
         rd=RANART(NSEED)
         if(rd.le.0.5) then
c     (pbar nbar) Delta
            if(ifs.eq.4) then
               iblock=18041
               lbb1=-1
            else
               iblock=18051
               lbb1=-2
            endif
            rd2=RANART(NSEED)
            if(rd2.le.0.25) then
               lbb2=6
            elseif(rd2.le.0.5) then
               lbb2=7
            elseif(rd2.le.0.75) then
               lbb2=8
            else
               lbb2=9
            endif
         else
c     (p n) anti-Delta
            if(ifs.eq.4) then
               iblock=18042
               lbb1=1
            else
               iblock=18052
               lbb1=2
            endif
            rd2=RANART(NSEED)
            if(rd2.le.0.25) then
               lbb2=-6
            elseif(rd2.le.0.5) then
               lbb2=-7
            elseif(rd2.le.0.75) then
               lbb2=-8
            else
               lbb2=-9
            endif
         endif
c6&7  (pbar nbar) N*(1440), (p n) anti-N*(1440)
      elseif(ifs.eq.6.or.ifs.eq.7) then
         rd=RANART(NSEED)
         if(rd.le.0.5) then
c     (pbar nbar) N*(1440)
            if(ifs.eq.6) then
               iblock=18061
               lbb1=-1
            else
               iblock=18071
               lbb1=-2
            endif
            rd2=RANART(NSEED)
            if(rd2.le.0.5) then
               lbb2=10
            else
               lbb2=11
            endif
         else
c     (p n) anti-N*(1440)
            if(ifs.eq.6) then
               iblock=18062
               lbb1=1
            else
               iblock=18072
               lbb1=2
            endif
            rd2=RANART(NSEED)
            if(rd2.le.0.5) then
               lbb2=-10
            else
               lbb2=-11
            endif
         endif
c8    Delta anti-Delta
      elseif(ifs.eq.8) then
         iblock=1808
         rd1=RANART(NSEED)
         if(rd1.le.0.25) then
            lbb1=6
         elseif(rd1.le.0.5) then
            lbb1=7
         elseif(rd1.le.0.75) then
            lbb1=8
         else
            lbb1=9
         endif
         rd2=RANART(NSEED)
         if(rd2.le.0.25) then
            lbb2=-6
         elseif(rd2.le.0.5) then
            lbb2=-7
         elseif(rd2.le.0.75) then
            lbb2=-8
         else
            lbb2=-9
         endif
c9&10 (pbar nbar) N*(1535), (p n) anti-N*(1535)
      elseif(ifs.eq.9.or.ifs.eq.10) then
         rd=RANART(NSEED)
         if(rd.le.0.5) then
c     (pbar nbar) N*(1440)
            if(ifs.eq.9) then
               iblock=18091
               lbb1=-1
            else
               iblock=18101
               lbb1=-2
            endif
            rd2=RANART(NSEED)
            if(rd2.le.0.5) then
               lbb2=12
            else
               lbb2=13
            endif
         else
c     (p n) anti-N*(1535)
            if(ifs.eq.9) then
               iblock=18092
               lbb1=1
            else
               iblock=18102
               lbb1=2
            endif
            rd2=RANART(NSEED)
            if(rd2.le.0.5) then
               lbb2=-12
            else
               lbb2=-13
            endif
         endif
c11&12 anti-Delta N*, Delta anti-N*
      elseif(ifs.eq.11.or.ifs.eq.12) then
         rd=RANART(NSEED)
         if(rd.le.0.5) then
c     anti-Delta N*
            rd1=RANART(NSEED)
            if(rd1.le.0.25) then
               lbb1=-6
            elseif(rd1.le.0.5) then
               lbb1=-7
            elseif(rd1.le.0.75) then
               lbb1=-8
            else
               lbb1=-9
            endif
            if(ifs.eq.11) then
               iblock=18111
               rd2=RANART(NSEED)
               if(rd2.le.0.5) then
                  lbb2=10
               else
                  lbb2=11
               endif
            else
               iblock=18121
               rd2=RANART(NSEED)
               if(rd2.le.0.5) then
                  lbb2=12
               else
                  lbb2=13
               endif
            endif
         else
c     Delta anti-N*
            rd1=RANART(NSEED)
            if(rd1.le.0.25) then
               lbb1=6
            elseif(rd1.le.0.5) then
               lbb1=7
            elseif(rd1.le.0.75) then
               lbb1=8
            else
               lbb1=9
            endif
            if(ifs.eq.11) then
               iblock=18112
               rd2=RANART(NSEED)
               if(rd2.le.0.5) then
                  lbb2=-10
               else
                  lbb2=-11
               endif
            else
               iblock=18122
               rd2=RANART(NSEED)
               if(rd2.le.0.5) then
                  lbb2=-12
               else
                  lbb2=-13
               endif
            endif
         endif
c13   N*(1440) anti-N*(1440)
      elseif(ifs.eq.13) then
         iblock=1813
         rd1=RANART(NSEED)
         if(rd1.le.0.5) then
            lbb1=10
         else
            lbb1=11
         endif
         rd2=RANART(NSEED)
         if(rd2.le.0.5) then
            lbb2=-10
         else
            lbb2=-11
         endif
c14   anti-N*(1440) N*(1535), N*(1440) anti-N*(1535)
      elseif(ifs.eq.14) then
         rd=RANART(NSEED)
         if(rd.le.0.5) then
c     anti-N*(1440) N*(1535)
            iblock=18141
            rd1=RANART(NSEED)
            if(rd1.le.0.5) then
               lbb1=-10
            else
               lbb1=-11
            endif
            rd2=RANART(NSEED)
            if(rd2.le.0.5) then
               lbb2=12
            else
               lbb2=13
            endif
         else
c     N*(1440) anti-N*(1535)
            iblock=18142
            rd1=RANART(NSEED)
            if(rd1.le.0.5) then
               lbb1=10
            else
               lbb1=11
            endif
            rd2=RANART(NSEED)
            if(rd2.le.0.5) then
               lbb2=-12
            else
               lbb2=-13
            endif
         endif
c15   N*(1535) anti-N*(1535)
      elseif(ifs.eq.15) then
         iblock=1815
         rd1=RANART(NSEED)
         if(rd1.le.0.5) then
            lbb1=12
         else
            lbb1=13
         endif
         rd2=RANART(NSEED)
         if(rd2.le.0.5) then
            lbb2=-12
         else
            lbb2=-13
         endif
      else
      endif

      RETURN
      END

*****************************************
* for pi pi <-> rho rho cross sections
        SUBROUTINE spprr(lb1,lb2,srt)
        parameter (arho=0.77)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

        pprr=0.
        if((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.3.and.lb2.le.5)) then
c     for now, rho mass taken to be the central value in these two processes
           if(srt.gt.(2*arho)) pprr=ptor(srt)
        elseif((lb1.ge.25.and.lb1.le.27).and.(lb2.ge.25.and.lb2.le.27)) 
     1          then
           pprr=rtop(srt)
        endif
c
        return
        END

*****************************************
* for pi pi -> rho rho, determined from detailed balance
      real function ptor(srt)
*****************************************
      parameter (pimass=0.140,arho=0.77)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      s2=srt**2
      ptor=9*(s2-4*arho**2)/(s2-4*pimass**2)*rtop(srt)

      return
      END

*****************************************
* for rho rho -> pi pi, assumed a constant cross section (in mb)
      real function rtop(srt)
*****************************************
      rtop=5.
      return
      END

*****************************************
* for pi pi <-> rho rho final states
      SUBROUTINE pi2ro2(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
      PARAMETER (MAXSTR=150001)
      PARAMETER (AP1=0.13496,AP2=0.13957)
      COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

      if((lb(i1).ge.3.and.lb(i1).le.5)
     1     .and.(lb(i2).ge.3.and.lb(i2).le.5)) then
         iblock=1850
         ei1=0.77
         ei2=0.77
c     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 -> 2rho)
c     thus the cross sections used are considered as the isospin-averaged ones.
         lbb1=25+int(3*RANART(NSEED))
         lbb2=25+int(3*RANART(NSEED))
      elseif((lb(i1).ge.25.and.lb(i1).le.27)
     1     .and.(lb(i2).ge.25.and.lb(i2).le.27)) then
         iblock=1851
         lbb1=3+int(3*RANART(NSEED))
         lbb2=3+int(3*RANART(NSEED))
         ei1=ap2
         ei2=ap2
         if(lbb1.eq.4) ei1=ap1
         if(lbb2.eq.4) ei2=ap1
      endif

      return
      END

*****************************************
* for pi pi <-> eta eta cross sections
        SUBROUTINE sppee(lb1,lb2,srt)
        parameter (ETAM=0.5475)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

        ppee=0.
        if((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.3.and.lb2.le.5)) then
           if(srt.gt.(2*ETAM)) ppee=ptoe(srt)
        elseif(lb1.eq.0.and.lb2.eq.0) then
           ppee=etop(srt)
        endif

        return
        END

*****************************************
* for pi pi -> eta eta, determined from detailed balance, spin-isospin averaged
      real function ptoe(srt)
*****************************************
      parameter (pimass=0.140,ETAM=0.5475)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      s2=srt**2
      ptoe=1./9.*(s2-4*etam**2)/(s2-4*pimass**2)*etop(srt)

      return
      END
*****************************************
* for eta eta -> pi pi, assumed a constant cross section (in mb)
      real function etop(srt)
*****************************************

c     eta equilibration:
c     most important channel is found to be pi pi <-> pi eta, then
c     rho pi <-> rho eta.
      etop=5.
      return
      END

*****************************************
* for pi pi <-> eta eta final states
      SUBROUTINE pi2et2(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
      PARAMETER (MAXSTR=150001)
      PARAMETER (AP1=0.13496,AP2=0.13957,ETAM=0.5475)
      COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

      if((lb(i1).ge.3.and.lb(i1).le.5)
     1     .and.(lb(i2).ge.3.and.lb(i2).le.5)) then
         iblock=1860
         ei1=etam
         ei2=etam
c     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 -> 2rho)
c     thus the cross sections used are considered as the isospin-averaged ones.
         lbb1=0
         lbb2=0
      elseif(lb(i1).eq.0.and.lb(i2).eq.0) then
         iblock=1861
         lbb1=3+int(3*RANART(NSEED))
         lbb2=3+int(3*RANART(NSEED))
         ei1=ap2
         ei2=ap2
         if(lbb1.eq.4) ei1=ap1
         if(lbb2.eq.4) ei2=ap1
      endif

      return
      END

*****************************************
* for pi pi <-> pi eta cross sections
        SUBROUTINE spppe(lb1,lb2,srt)
        parameter (pimass=0.140,ETAM=0.5475)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

        pppe=0.
        if((lb1.ge.3.and.lb1.le.5).and.(lb2.ge.3.and.lb2.le.5)) then
           if(srt.gt.(ETAM+pimass)) pppe=pptope(srt)
        elseif((lb1.ge.3.and.lb1.le.5).and.lb2.eq.0) then
           pppe=petopp(srt)
        elseif((lb2.ge.3.and.lb2.le.5).and.lb1.eq.0) then
           pppe=petopp(srt)
        endif

        return
        END

*****************************************
* for pi pi -> pi eta, determined from detailed balance, spin-isospin averaged
      real function pptope(srt)
*****************************************
      parameter (pimass=0.140,ETAM=0.5475)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      s2=srt**2
      pf2=(s2-(pimass+ETAM)**2)*(s2-(pimass-ETAM)**2)/2/sqrt(s2)
      pi2=(s2-4*pimass**2)*s2/2/sqrt(s2)
      pptope=1./3.*pf2/pi2*petopp(srt)

      return
      END
*****************************************
* for pi eta -> pi pi, assumed a constant cross section (in mb)
      real function petopp(srt)
*****************************************

c     eta equilibration:
      petopp=5.
      return
      END

*****************************************
* for pi pi <-> pi eta final states
      SUBROUTINE pi3eta(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
      PARAMETER (MAXSTR=150001)
      PARAMETER (AP1=0.13496,AP2=0.13957,ETAM=0.5475)
      COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

      if((lb(i1).ge.3.and.lb(i1).le.5)
     1     .and.(lb(i2).ge.3.and.lb(i2).le.5)) then
         iblock=1870
         ei1=ap2
         ei2=etam
c     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 -> 2rho)
c     thus the cross sections used are considered as the isospin-averaged ones.
         lbb1=3+int(3*RANART(NSEED))
         if(lbb1.eq.4) ei1=ap1
         lbb2=0
      elseif((lb(i1).ge.3.and.lb(i1).le.5.and.lb(i2).eq.0).or.
     1        (lb(i2).ge.3.and.lb(i2).le.5.and.lb(i1).eq.0)) then
         iblock=1871
         lbb1=3+int(3*RANART(NSEED))
         lbb2=3+int(3*RANART(NSEED))
         ei1=ap2
         ei2=ap2
         if(lbb1.eq.4) ei1=ap1
         if(lbb2.eq.4) ei2=ap1
      endif

      return
      END

*****************************************
* for rho pi <-> rho eta cross sections
        SUBROUTINE srpre(lb1,lb2,srt)
        parameter (pimass=0.140,ETAM=0.5475,arho=0.77)
        common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
        common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

        rpre=0.
        if(lb1.ge.25.and.lb1.le.27.and.lb2.ge.3.and.lb2.le.5) then
           if(srt.gt.(ETAM+arho)) rpre=rptore(srt)
        elseif(lb2.ge.25.and.lb2.le.27.and.lb1.ge.3.and.lb1.le.5) then
           if(srt.gt.(ETAM+arho)) rpre=rptore(srt)
        elseif(lb1.ge.25.and.lb1.le.27.and.lb2.eq.0) then
           if(srt.gt.(pimass+arho)) rpre=retorp(srt)
        elseif(lb2.ge.25.and.lb2.le.27.and.lb1.eq.0) then
           if(srt.gt.(pimass+arho)) rpre=retorp(srt)
        endif

        return
        END

*****************************************
* for rho pi->rho eta, determined from detailed balance, spin-isospin averaged
      real function rptore(srt)
*****************************************
      parameter (pimass=0.140,ETAM=0.5475,arho=0.77)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      s2=srt**2
      pf2=(s2-(arho+ETAM)**2)*(s2-(arho-ETAM)**2)/2/sqrt(s2)
      pi2=(s2-(arho+pimass)**2)*(s2-(arho-pimass)**2)/2/sqrt(s2)
      rptore=1./3.*pf2/pi2*retorp(srt)

      return
      END
*****************************************
* for rho eta -> rho pi, assumed a constant cross section (in mb)
      real function retorp(srt)
*****************************************

c     eta equilibration:
      retorp=5.
      return
      END

*****************************************
* for rho pi <-> rho eta final states
      SUBROUTINE rpiret(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
      PARAMETER (MAXSTR=150001)
      PARAMETER (AP1=0.13496,AP2=0.13957,ETAM=0.5475,arho=0.77)
      COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

      if((lb(i1).ge.25.and.lb(i1).le.27
     1     .and.lb(i2).ge.3.and.lb(i2).le.5).or.
     2     (lb(i1).ge.3.and.lb(i1).le.5
     3     .and.lb(i2).ge.25.and.lb(i2).le.27)) then
         iblock=1880
         ei1=arho
         ei2=etam
c     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 -> 2rho)
c     thus the cross sections used are considered as the isospin-averaged ones.
         lbb1=25+int(3*RANART(NSEED))
         lbb2=0
      elseif((lb(i1).ge.25.and.lb(i1).le.27.and.lb(i2).eq.0).or.
     1        (lb(i2).ge.25.and.lb(i2).le.27.and.lb(i1).eq.0)) then
         iblock=1881
         lbb1=25+int(3*RANART(NSEED))
         lbb2=3+int(3*RANART(NSEED))
         ei1=arho
         ei2=ap2
         if(lbb2.eq.4) ei2=ap1
      endif

      return
      END

*****************************************
* for omega pi <-> omega eta cross sections
        SUBROUTINE sopoe(lb1,lb2,srt)
        parameter (ETAM=0.5475,aomega=0.782)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

        xopoe=0.
        if((lb1.eq.28.and.lb2.ge.3.and.lb2.le.5).or.
     1       (lb2.eq.28.and.lb1.ge.3.and.lb1.le.5)) then
           if(srt.gt.(aomega+ETAM)) xopoe=xop2oe(srt)
        elseif((lb1.eq.28.and.lb2.eq.0).or.
     1          (lb1.eq.0.and.lb2.eq.28)) then
           if(srt.gt.(aomega+ETAM)) xopoe=xoe2op(srt)
        endif

        return
        END

*****************************************
* for omega pi -> omega eta, 
c     determined from detailed balance, spin-isospin averaged
      real function xop2oe(srt)
*****************************************
      parameter (pimass=0.140,ETAM=0.5475,aomega=0.782)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      s2=srt**2
      pf2=(s2-(aomega+ETAM)**2)*(s2-(aomega-ETAM)**2)/2/sqrt(s2)
      pi2=(s2-(aomega+pimass)**2)*(s2-(aomega-pimass)**2)/2/sqrt(s2)
      xop2oe=1./3.*pf2/pi2*xoe2op(srt)

      return
      END
*****************************************
* for omega eta -> omega pi, assumed a constant cross section (in mb)
      real function xoe2op(srt)
*****************************************

c     eta equilibration:
      xoe2op=5.
      return
      END

*****************************************
* for omega pi <-> omega eta final states
      SUBROUTINE opioet(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
      PARAMETER (MAXSTR=150001)
      PARAMETER (AP1=0.13496,AP2=0.13957,ETAM=0.5475,aomega=0.782)
      COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

      if((lb(i1).ge.3.and.lb(i1).le.5.and.lb(i2).eq.28).or.
     1     (lb(i2).ge.3.and.lb(i2).le.5.and.lb(i1).eq.28)) then
         iblock=1890
         ei1=aomega
         ei2=etam
c     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 -> 2rho)
c     thus the cross sections used are considered as the isospin-averaged ones.
         lbb1=28
         lbb2=0
      elseif((lb(i1).eq.28.and.lb(i2).eq.0).or.
     1        (lb(i1).eq.0.and.lb(i2).eq.28)) then
         iblock=1891
         lbb1=28
         lbb2=3+int(3*RANART(NSEED))
         ei1=aomega
         ei2=ap2
         if(lbb2.eq.4) ei2=ap1
      endif

      return
      END

*****************************************
* for rho rho <-> eta eta cross sections
        SUBROUTINE srree(lb1,lb2,srt)
        parameter (ETAM=0.5475,arho=0.77)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

        rree=0.
        if(lb1.ge.25.and.lb1.le.27.and.
     1       lb2.ge.25.and.lb2.le.27) then
           if(srt.gt.(2*ETAM)) rree=rrtoee(srt)
        elseif(lb1.eq.0.and.lb2.eq.0) then
           if(srt.gt.(2*arho)) rree=eetorr(srt)
        endif

        return
        END

*****************************************
* for eta eta -> rho rho
c     determined from detailed balance, spin-isospin averaged
      real function eetorr(srt)
*****************************************
      parameter (ETAM=0.5475,arho=0.77)
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      SAVE   

      s2=srt**2
      eetorr=81.*(s2-4*arho**2)/(s2-4*etam**2)*rrtoee(srt)

      return
      END
*****************************************
* for rho rho -> eta eta, assumed a constant cross section (in mb)
      real function rrtoee(srt)
*****************************************

c     eta equilibration:
      rrtoee=5.
      return
      END

*****************************************
* for rho rho <-> eta eta final states
      SUBROUTINE ro2et2(i1,i2,lbb1,lbb2,ei1,ei2,iblock,iseed)
      PARAMETER (MAXSTR=150001)
      parameter (ETAM=0.5475,arho=0.77)
      COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      common/ppb1/ene,factr2(6),fsum,ppinnb,s,wtot
cc      SAVE /ppb1/
      common/ppmm/pprr,ppee,pppe,rpre,xopoe,rree
cc      SAVE /ppmm/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

      if(lb(i1).ge.25.and.lb(i1).le.27.and.
     1     lb(i2).ge.25.and.lb(i2).le.27) then
         iblock=1895
         ei1=etam
         ei2=etam
c     for now, we don't check isospin states(allowing pi+pi+ & pi0pi0 -> 2rho)
c     thus the cross sections used are considered as the isospin-averaged ones.
         lbb1=0
         lbb2=0
      elseif(lb(i1).eq.0.and.lb(i2).eq.0) then
         iblock=1896
         lbb1=25+int(3*RANART(NSEED))
         lbb2=25+int(3*RANART(NSEED))
         ei1=arho
         ei2=arho
      endif

      return
      END

*****************************
* purpose: Xsection for K* Kbar or K*bar K to pi(eta) rho(omega)
      SUBROUTINE XKKSAN(i1,i2,SRT,SIGKS1,SIGKS2,SIGKS3,SIGKS4,SIGK,prkk)
*  srt    = DSQRT(s) in GeV                                       *
*  sigk   = xsection in mb obtained from                          *
*           the detailed balance                                  *
* ***************************
          PARAMETER (AKA=0.498, PIMASS=0.140, RHOM = 0.770,aks=0.895,
     & OMEGAM = 0.7819, ETAM = 0.5473)
      PARAMETER (MAXSTR=150001)
      COMMON  /CC/      E(MAXSTR)
cc      SAVE /CC/
      SAVE   

        S = SRT ** 2
       SIGKS1 = 1.E-08
       SIGKS2 = 1.E-08
       SIGKS3 = 1.E-08
       SIGKS4 = 1.E-08

        XPION0 = prkk
clin note that prkk is for pi (rho omega) -> K* Kbar (AND!) K*bar K:
        XPION0 = XPION0/2

cc
c        PI2 = (S - (aks + AKA) ** 2) * (S - (aks - AKA) ** 2)
        PI2 = (S - (e(i1) + e(i2)) ** 2) * (S - (e(i1) - e(i2)) ** 2)
        SIGK = 1.E-08
        if(PI2 .le. 0.0) return

        XM1 = PIMASS
        XM2 = RHOM
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PI2 .GT. 0.0 .AND. PF2 .GT. 0.0) THEN
           SIGKS1 = 27.0 / 4.0 * PF2 / PI2 * XPION0
        END IF

        XM1 = PIMASS
        XM2 = OMEGAM
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PI2 .GT. 0.0 .AND. PF2 .GT. 0.0) THEN
           SIGKS2 = 9.0 / 4.0 * PF2 / PI2 * XPION0
        END IF

        XM1 = RHOM
        XM2 = ETAM
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           SIGKS3 = 9.0 / 4.0 * PF2 / PI2 * XPION0
        END IF

        XM1 = OMEGAM
        XM2 = ETAM
        PF2 = (S - (XM1 + XM2) ** 2) * (S - (XM1 - XM2) ** 2)
        IF (PF2 .GT. 0.0) THEN
           SIGKS4 = 3.0 / 4.0 * PF2 / PI2 * XPION0
        END IF

        SIGK=SIGKS1+SIGKS2+SIGKS3+SIGKS4

       RETURN
        END

**********************************
*     PURPOSE:                                                         *
*     assign final states for KK*bar or K*Kbar --> light mesons
*
c      SUBROUTINE Crkspi(PX,PY,PZ,SRT,I1,I2,IBLOCK)
      SUBROUTINE crkspi(I1,I2,XSK1, XSK2, XSK3, XSK4, SIGK,
     & IBLOCK,lbp1,lbp2,emm1,emm2)
*             iblock   - 466
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1)
          PARAMETER (AP1=0.13496,AP2=0.13957,RHOM = 0.770,PI=3.1415926)
        PARAMETER (AETA=0.548,AMOMGA=0.782)
        parameter (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       IBLOCK=466
* charges of final state mesons:

        X1 = RANART(NSEED) * SIGK
        XSK2 = XSK1 + XSK2
        XSK3 = XSK2 + XSK3
        XSK4 = XSK3 + XSK4
        IF (X1 .LE. XSK1) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 25 + int(3 * RANART(NSEED))
           E(I1) = AP2
           E(I2) = rhom
        ELSE IF (X1 .LE. XSK2) THEN
           LB(I1) = 3 + int(3 * RANART(NSEED))
           LB(I2) = 28
           E(I1) = AP2
           E(I2) = AMOMGA
        ELSE IF (X1 .LE. XSK3) THEN
           LB(I1) = 0
           LB(I2) = 25 + int(3 * RANART(NSEED))
           E(I1) = AETA
           E(I2) = rhom
        ELSE
           LB(I1) = 0
           LB(I2) = 28
           E(I1) = AETA
           E(I2) = AMOMGA
        ENDIF

        if(lb(i1).eq.4) E(I1) = AP1
        lbp1=lb(i1)
        lbp2=lb(i2)
        emm1=e(i1)
        emm2=e(i2)

      RETURN
      END

*---------------------------------------------------------------------------
* PURPOSE : CALCULATE THE MASS AND MOMENTUM OF K* RESONANCE 
*           AFTER PION + KAON COLLISION
*clin only here the K* mass may be different from aks=0.895
        SUBROUTINE KSRESO(I1,I2)
        PARAMETER (MAXSTR=150001,MAXR=1,
     1  AMN=0.939457,AMP=0.93828,
     2  AP1=0.13496,AP2=0.13957,AM0=1.232,PI=3.1415926)
clin-9/2012: improve precision for argument in sqrt():
        double precision e10,e20,scheck,p1,p2,p3
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON   /RUN/NUM
cc      SAVE /RUN/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      SAVE   
* 1. DETERMINE THE MOMENTUM COMPONENT OF THE K* IN THE CMS OF PI-K FRAME
*    WE LET I1 TO BE THE K* AND ABSORB I2

clin-9/2012: improve precision for argument in sqrt():
c        E10=SQRT(E(I1)**2+P(1,I1)**2+P(2,I1)**2+P(3,I1)**2)
c        E20=SQRT(E(I2)**2+P(1,I2)**2+P(2,I2)**2+P(3,I2)**2)
        E10=dSQRT(dble(E(I1))**2+dble(P(1,I1))**2
     1     +dble(P(2,I1))**2+dble(P(3,I1))**2)
        E20=dSQRT(dble(E(I2))**2+dble(P(1,I2))**2
     1       +dble(P(2,I2))**2+dble(P(3,I2))**2)
        p1=dble(P(1,I1))+dble(P(1,I2))
        p2=dble(P(2,I1))+dble(P(2,I2))
        p3=dble(P(3,I1))+dble(P(3,I2))

        IF(LB(I2) .EQ. 21 .OR. LB(I2) .EQ. 23) THEN
        E(I1)=0.
        I=I2
        ELSE
        E(I2)=0.
        I=I1
        ENDIF
        if(LB(I).eq.23) then
           LB(I)=30
        else if(LB(I).eq.21) then
           LB(I)=-30
        endif
        P(1,I)=P(1,I1)+P(1,I2)
        P(2,I)=P(2,I1)+P(2,I2)
        P(3,I)=P(3,I1)+P(3,I2)
* 2. DETERMINE THE MASS OF K* BY USING THE REACTION KINEMATICS

clin-9/2012: check argument in sqrt():
        scheck=(E10+E20)**2-p1**2-p2**2-p3**2
        if(scheck.lt.0) then
           write(99,*) 'scheck49: ',scheck
           write(99,*) 'scheck49',scheck,E10,E20,P(1,I),P(2,I),P(3,I)
           write(99,*) 'scheck49-1',E(I1),P(1,I1),P(2,I1),P(3,I1)
           write(99,*) 'scheck49-2',E(I2),P(1,I2),P(2,I2),P(3,I2)
        endif
        DM=sqrt(sngl(scheck))
c        DM=SQRT((E10+E20)**2-P(1,I)**2-P(2,I)**2-P(3,I)**2)

        E(I)=DM
        RETURN
        END

c--------------------------------------------------------
*************************************
*                                                                         *
      SUBROUTINE pertur(PX,PY,PZ,SRT,IRUN,I1,I2,nt,kp,icont)
*                                                                         *
*       PURPOSE:   TO PRODUCE CASCADE AND OMEGA PERTURBATIVELY            *
c sp 01/03/01
*                   40 cascade-
*                  -40 cascade-(bar)
*                   41 cascade0
*                  -41 cascade0(bar)
*                   45 Omega baryon
*                  -45 Omega baryon(bar)
*                   44 Di-Omega
**********************************
      PARAMETER      (MAXSTR=150001,MAXR=1,PI=3.1415926)
      parameter      (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
      PARAMETER (AMN=0.939457,AMP=0.93828,AP1=0.13496,AP2=0.13957)
      PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974,aks=0.895)
      PARAMETER      (ACAS=1.3213,AOME=1.6724,AMRHO=0.769,AMOMGA=0.782)
      PARAMETER      (AETA=0.548,ADIOMG=3.2288)
      parameter            (maxx=20,maxz=24)
      COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
      COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
      COMMON   /EE/  ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      COMMON   /HH/  PROPER(MAXSTR)
cc      SAVE /HH/
      common /ff/f(-mx:mx,-my:my,-mz:mz,-mpx:mpx,-mpy:mpy,-mpz:mpzp)
cc      SAVE /ff/
      common   /gg/  dx,dy,dz,dpx,dpy,dpz
cc      SAVE /gg/
      COMMON   /INPUT/ NSTAR,NDIRCT,DIR
cc      SAVE /INPUT/
      COMMON   /NN/NNN
cc      SAVE /NN/
      COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
      COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
      COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
      COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
      COMMON   /PE/PROPI(MAXSTR,MAXR)
cc      SAVE /PE/
      COMMON   /RR/  MASSR(0:MAXR)
cc      SAVE /RR/
      COMMON   /BG/BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
c     perturbative method is disabled:
c      common /imulst/ iperts
c
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      SAVE   

      px0 = px
      py0 = py
      pz0 = pz
      LB1 = LB(I1)
      EM1 = E(I1)
      X1  = R(1,I1)
      Y1  = R(2,I1)
      Z1  = R(3,I1)
      prob1 = PROPER(I1)
c     
      LB2 = LB(I2)
      EM2 = E(I2)
      X2  = R(1,I2)
      Y2  = R(2,I2)
      Z2  = R(3,I2)
      prob2 = PROPER(I2)
c
c                 !! flag for real 2-body process (1/0=no/yes)
      icont = 1
c                !! flag for elastic scatt only (-1=no)
      icsbel = -1

* K-/K*0bar + La/Si --> cascade + pi
* K+/K*0 + La/Si (bar) --> cascade-bar + pi
       if( (lb1.eq.21.or.lb1.eq.23.or.iabs(lb1).eq.30) .and.
     &     (iabs(lb2).ge.14.and.iabs(lb2).le.17) )go to 60
       if( (lb2.eq.21.or.lb2.eq.23.or.iabs(lb2).eq.30) .and.
     &     (iabs(lb1).ge.14.and.iabs(lb1).le.17) )go to 60
* K-/K*0bar + cascade --> omega + pi
* K+/K*0 + cascade-bar --> omega-bar + pi
        if( (lb1.eq.21.or.lb1.eq.23.or.iabs(lb1).eq.30) .and.
     &      (iabs(lb2).eq.40.or.iabs(lb2).eq.41) )go to 70
        if( (lb2.eq.21.or.lb2.eq.23.or.iabs(lb2).eq.30) .and.
     &      (iabs(lb1).eq.40.or.iabs(lb1).eq.41) )go to 70
c
c annhilation of cascade,cascade-bar, omega,omega-bar
c
* K- + La/Si <-- cascade + pi(eta,rho,omega)
* K+ + La/Si(bar) <-- cascade-bar + pi(eta,rho,omega)
       if( (((lb1.ge.3.and.lb1.le.5).or.lb1.eq.0) 
     &        .and.(iabs(lb2).eq.40.or.iabs(lb2).eq.41))
     & .OR. (((lb2.ge.3.and.lb2.le.5).or.lb2.eq.0) 
     &        .and.(iabs(lb1).eq.40.or.iabs(lb1).eq.41)) )go to 90
* K- + cascade <-- omega + pi
* K+ + cascade-bar <-- omega-bar + pi
c         if( (lb1.eq.0.and.iabs(lb2).eq.45)
c    &    .OR. (lb2.eq.0.and.iabs(lb1).eq.45) ) go to 110
       if( ((lb1.ge.3.and.lb1.le.5).and.iabs(lb2).eq.45)
     & .OR.((lb2.ge.3.and.lb2.le.5).and.iabs(lb1).eq.45) )go to 110
c

c----------------------------------------------------
*  for process:  K-bar + L(S) --> Ca + pi 
*
60         if(iabs(lb1).ge.14 .and. iabs(lb1).le.17)then 
             asap = e(i1)
             akap = e(i2)
             idp = i1
           else
             asap = e(i2)
             akap = e(i1)
             idp = i2
           endif
          app = 0.138
         if(srt .lt. (acas+app))return
          srrt = srt - (acas+app) + (amn+akap)
          pkaon = sqrt(((srrt**2-(amn**2+akap**2))/2./amn)**2 - akap**2)
          sigca = 1.5*( akNPsg(pkaon)+akNPsg(pkaon) )
clin pii & pff should be each divided by (4*srt**2), 
c     but these two factors cancel out in the ratio pii/pff:
          pii = sqrt((srt**2-(amn+akap)**2)*(srt**2-(amn-akap)**2))
          pff = sqrt((srt**2-(asap+app)**2)*(srt**2-(asap-app)**2))
         cmat = sigca*pii/pff
         sigpi = cmat*
     &            sqrt((srt**2-(acas+app)**2)*(srt**2-(acas-app)**2))/
     &            sqrt((srt**2-(asap+akap)**2)*(srt**2-(asap-akap)**2))
c 
         sigeta = 0.
        if(srt .gt. (acas+aeta))then
           srrt = srt - (acas+aeta) + (amn+akap)
         pkaon = sqrt(((srrt**2-(amn**2+akap**2))/2./amn)**2 - akap**2)
            sigca = 1.5*( akNPsg(pkaon)+akNPsg(pkaon) )
         cmat = sigca*pii/pff
         sigeta = cmat*
     &            sqrt((srt**2-(acas+aeta)**2)*(srt**2-(acas-aeta)**2))/
     &            sqrt((srt**2-(asap+akap)**2)*(srt**2-(asap-akap)**2))
        endif
c
         sigca = sigpi + sigeta
         sigpe = 0.
clin-2/25/03 disable the perturb option:
c        if(iperts .eq. 1) sigpe = 40.   !! perturbative xsecn
           sig = amax1(sigpe,sigca)     
         ds = sqrt(sig/31.4)
         dsr = ds + 0.1
         ec = (em1+em2+0.02)**2
         call distce(i1,i2,dsr,ds,dt,ec,srt,ic,px,py,pz)
           if(ic .eq. -1)return
          brpp = sigca/sig
c
c else particle production
          if( (lb1.ge.14.and.lb1.le.17) .or.
     &          (lb2.ge.14.and.lb2.le.17) )then
c   !! cascade- or cascde0
            lbpp1 = 40 + int(2*RANART(NSEED))
          else
* elseif(lb1 .eq. -14 .or. lb2 .eq. -14)
c     !! cascade-bar- or cascde0 -bar
            lbpp1 = -40 - int(2*RANART(NSEED))
          endif
              empp1 = acas
           if(RANART(NSEED) .lt. sigpi/sigca)then
c    !! pion
            lbpp2 = 3 + int(3*RANART(NSEED))
            empp2 = 0.138
           else
c    !! eta
            lbpp2 = 0
            empp2 = aeta
           endif        
c* check real process of cascade(bar) and pion formation
          if(RANART(NSEED) .lt. brpp)then
c       !! real process flag
            icont = 0
            lb(i1) = lbpp1
            e(i1) = empp1
c  !! cascade formed with prob Gam
            proper(i1) = brpp
            lb(i2) = lbpp2
            e(i2) = empp2
c         !! pion/eta formed with prob 1.
            proper(i2) = 1.
           endif
c else only cascade(bar) formed perturbatively
             go to 700
            
c----------------------------------------------------
*  for process:  Cas(bar) + K_bar(K) --> Om(bar) + pi  !! eta
*
70         if(iabs(lb1).eq.40 .or. iabs(lb1).eq.41)then 
             acap = e(i1)
             akap = e(i2)
             idp = i1
           else
             acap = e(i2)
             akap = e(i1)
             idp = i2
           endif
           app = 0.138
*         ames = aeta
c  !! only pion
           ames = 0.138
         if(srt .lt. (aome+ames))return 
          srrt = srt - (aome+ames) + (amn+akap)
         pkaon = sqrt(((srrt**2-(amn**2+akap**2))/2./amn)**2 - akap**2)
c use K(bar) + Ca --> Om + eta  xsecn same as  K(bar) + N --> Si + Pi
*  as Omega have no resonances
c** using same matrix elements as K-bar + N -> Si + pi
         sigomm = 1.5*( akNPsg(pkaon)+akNPsg(pkaon) )
         cmat = sigomm*
     &          sqrt((srt**2-(amn+akap)**2)*(srt**2-(amn-akap)**2))/
     &          sqrt((srt**2-(asa+app)**2)*(srt**2-(asa-app)**2))
        sigom = cmat*
     &           sqrt((srt**2-(aome+ames)**2)*(srt**2-(aome-ames)**2))/
     &           sqrt((srt**2-(acap+akap)**2)*(srt**2-(acap-akap)**2))
          sigpe = 0.
clin-2/25/03 disable the perturb option:
c         if(iperts .eq. 1) sigpe = 40.   !! perturbative xsecn
          sig = amax1(sigpe,sigom)     
         ds = sqrt(sig/31.4)
         dsr = ds + 0.1
         ec = (em1+em2+0.02)**2
         call distce(i1,i2,dsr,ds,dt,ec,srt,ic,px,py,pz)
           if(ic .eq. -1)return
           brpp = sigom/sig
c
c else particle production
           if( (lb1.ge.40.and.lb1.le.41) .or.
     &           (lb2.ge.40.and.lb2.le.41) )then
c    !! omega
            lbpp1 = 45
           else
* elseif(lb1 .eq. -40 .or. lb2 .eq. -40)
c    !! omega-bar
            lbpp1 = -45
           endif
           empp1 = aome
*           lbpp2 = 0    !! eta
c    !! pion
           lbpp2 = 3 + int(3*RANART(NSEED))
           empp2 = ames
c
c* check real process of omega(bar) and pion formation
           xrand=RANART(NSEED)
         if(xrand .lt. (proper(idp)*brpp))then
c       !! real process flag
            icont = 0
            lb(i1) = lbpp1
            e(i1) = empp1
c  !! P_Om = P_Cas*Gam
            proper(i1) = proper(idp)*brpp
            lb(i2) = lbpp2
            e(i2) = empp2
c   !! pion formed with prob 1.
            proper(i2) = 1.
          elseif(xrand.lt.brpp) then
c else omega(bar) formed perturbatively and cascade destroyed
             e(idp) = 0.
          endif
             go to 700
            
c-----------------------------------------------------------
*  for process:  Ca + pi/eta --> K-bar + L(S)
*
90         if(iabs(lb1).eq.40 .or. iabs(lb1).eq.41)then 
             acap = e(i1)
             app = e(i2)
             idp = i1
             idn = i2
           else
             acap = e(i2)
             app = e(i1)
             idp = i2
             idn = i1
           endif
c            akal = (aka+aks)/2.  !! average of K and K* taken
c  !! using K only
            akal = aka
c
         alas = ala
       if(srt .le. (alas+aka))return
           srrt = srt - (acap+app) + (amn+aka)
         pkaon = sqrt(((srrt**2-(amn**2+aka**2))/2./amn)**2 - aka**2)
c** using same matrix elements as K-bar + N -> La/Si + pi
         sigca = 1.5*( akNPsg(pkaon)+akNPsg(pkaon) )
         cmat = sigca*
     &          sqrt((srt**2-(amn+aka)**2)*(srt**2-(amn-aka)**2))/
     &          sqrt((srt**2-(alas+0.138)**2)*(srt**2-(alas-0.138)**2))
         sigca = cmat*
     &            sqrt((srt**2-(acap+app)**2)*(srt**2-(acap-app)**2))/
     &            sqrt((srt**2-(alas+aka)**2)*(srt**2-(alas-aka)**2))
c    !! pi
            dfr = 1./3.
c       !! eta
           if(lb(idn).eq.0)dfr = 1.
        sigcal = sigca*dfr*(srt**2-(alas+aka)**2)*
     &           (srt**2-(alas-aka)**2)/(srt**2-(acap+app)**2)/
     &           (srt**2-(acap-app)**2)
c
          alas = ASA
       if(srt .le. (alas+aka))then
         sigcas = 0.
       else
           srrt = srt - (acap+app) + (amn+aka)
        pkaon = sqrt(((srrt**2-(amn**2+aka**2))/2./amn)**2 - aka**2)
c use K(bar) + La/Si --> Ca + Pi  xsecn same as  K(bar) + N --> Si + Pi
c** using same matrix elements as K-bar + N -> La/Si + pi
          sigca = 1.5*( akNPsg(pkaon)+akNPsg(pkaon) )
         cmat = sigca*
     &          sqrt((srt**2-(amn+aka)**2)*(srt**2-(amn-aka)**2))/
     &          sqrt((srt**2-(alas+0.138)**2)*(srt**2-(alas-0.138)**2))
         sigca = cmat*
     &            sqrt((srt**2-(acap+app)**2)*(srt**2-(acap-app)**2))/
     &            sqrt((srt**2-(alas+aka)**2)*(srt**2-(alas-aka)**2))
c    !! pi
            dfr = 1.
c    !! eta
           if(lb(idn).eq.0)dfr = 3.
        sigcas = sigca*dfr*(srt**2-(alas+aka)**2)*
     &           (srt**2-(alas-aka)**2)/(srt**2-(acap+app)**2)/
     &           (srt**2-(acap-app)**2)
       endif
c
         sig = sigcal + sigcas
         brpp = 1.                                                   
         ds = sqrt(sig/31.4)
         dsr = ds + 0.1
         ec = (em1+em2+0.02)**2
         call distce(i1,i2,dsr,ds,dt,ec,srt,ic,px,py,pz)
c
clin-2/25/03: checking elastic scatt after failure of inelastic scatt gives 
c     conditional probability (in general incorrect), tell Pal to correct:
       if(ic .eq. -1)then
c check for elastic scatt, no particle annhilation
c  !! elastic cross section of 20 mb
         ds = sqrt(20.0/31.4)
         dsr = ds + 0.1
         call distce(i1,i2,dsr,ds,dt,ec,srt,icsbel,px,py,pz)
           if(icsbel .eq. -1)return
            empp1 = EM1
            empp2 = EM2
             go to 700
       endif
c
c else pert. produced cascade(bar) is annhilated OR real process
c
* DECIDE LAMBDA OR SIGMA PRODUCTION
c
       IF(sigcal/sig .GT. RANART(NSEED))THEN  
          if(lb1.eq.40.or.lb1.eq.41.or.lb2.eq.40.or.lb2.eq.41)then
          lbpp1 = 21
           lbpp2 = 14
          else
           lbpp1 = 23
           lbpp2 = -14
          endif
         alas = ala
       ELSE
          if(lb1.eq.40.or.lb1.eq.41.or.lb2.eq.40.or.lb2.eq.41)then
           lbpp1 = 21
            lbpp2 = 15 + int(3 * RANART(NSEED))
          else
            lbpp1 = 23
            lbpp2 = -15 - int(3 * RANART(NSEED))
          endif
         alas = ASA       
        ENDIF
             empp1 = aka  
             empp2 = alas 
c
c check for real process for L/S(bar) and K(bar) formation
          if(RANART(NSEED) .lt. proper(idp))then
* real process
c       !! real process flag
            icont = 0
            lb(i1) = lbpp1
            e(i1) = empp1
c   !! K(bar) formed with prob 1.
            proper(i1) = 1.
            lb(i2) = lbpp2
            e(i2) = empp2
c   !! L/S(bar) formed with prob 1.
            proper(i2) = 1.
             go to 700
           else
c else only cascade(bar) annhilation & go out
            e(idp) = 0.
           endif
          return
c
c----------------------------------------------------
*  for process:  Om(bar) + pi --> Cas(bar) + K_bar(K)
*
110         if(lb1 .eq. 45 .or. lb1 .eq. -45)then 
             aomp = e(i1)
             app = e(i2)
             idp = i1
             idn = i2
           else
             aomp = e(i2)
             app = e(i1)
             idp = i2
             idn = i1
           endif
c            akal = (aka+aks)/2.  !! average of K and K* taken 
c  !! using K only
            akal = aka
       if(srt .le. (acas+aka))return
           srrt = srt - (aome+app) + (amn+aka)
         pkaon = sqrt(((srrt**2-(amn**2+aka**2))/2./amn)**2 - aka**2)
c use K(bar) + Ca --> Om + eta  xsecn same as  K(bar) + N --> Si + Pi
c** using same matrix elements as K-bar + N -> La/Si + pi
           sigca = 1.5*( akNPsg(pkaon)+akNPsg(pkaon) )
         cmat = sigca*
     &          sqrt((srt**2-(amn+aka)**2)*(srt**2-(amn-aka)**2))/
     &          sqrt((srt**2-(asa+0.138)**2)*(srt**2-(asa-0.138)**2))
         sigom = cmat*
     &            sqrt((srt**2-(aomp+app)**2)*(srt**2-(aomp-app)**2))/
     &            sqrt((srt**2-(acas+aka)**2)*(srt**2-(acas-aka)**2))
c            dfr = 2.    !! eta
c    !! pion
           dfr = 2./3.
        sigom = sigom*dfr*(srt**2-(acas+aka)**2)*
     &           (srt**2-(acas-aka)**2)/(srt**2-(aomp+app)**2)/
     &           (srt**2-(aomp-app)**2)
c                                                                         
         brpp = 1.
         ds = sqrt(sigom/31.4)
         dsr = ds + 0.1
         ec = (em1+em2+0.02)**2
         call distce(i1,i2,dsr,ds,dt,ec,srt,ic,px,py,pz)
c
clin-2/25/03: checking elastic scatt after failure of inelastic scatt gives 
c     conditional probability (in general incorrect), tell Pal to correct:
       if(ic .eq. -1)then
c check for elastic scatt, no particle annhilation
c  !! elastic cross section of 20 mb
         ds = sqrt(20.0/31.4)
         dsr = ds + 0.1
         call distce(i1,i2,dsr,ds,dt,ec,srt,icsbel,px,py,pz)
           if(icsbel .eq. -1)return
            empp1 = EM1
            empp2 = EM2
             go to 700
       endif
c
c else pert. produced omega(bar) annhilated  OR real process
c annhilate only pert. omega, rest from hijing go out WITHOUT annhil.
           if(lb1.eq.45 .or. lb2.eq.45)then
c  !! Ca
             lbpp1 = 40 + int(2*RANART(NSEED))
c   !! K-
             lbpp2 = 21
            else
* elseif(lb1 .eq. -45 .or. lb2 .eq. -45)
c    !! Ca-bar
            lbpp1 = -40 - int(2*RANART(NSEED))
c      !! K+
            lbpp2 = 23
           endif
             empp1 = acas
             empp2 = aka  
c
c check for real process for Cas(bar) and K(bar) formation
          if(RANART(NSEED) .lt. proper(idp))then
c       !! real process flag
            icont = 0
            lb(i1) = lbpp1
            e(i1) = empp1
c   !! P_Cas(bar) = P_Om(bar)
            proper(i1) = proper(idp)
            lb(i2) = lbpp2
            e(i2) = empp2
c   !! K(bar) formed with prob 1.
            proper(i2) = 1.
c
           else
c else Cascade(bar)  produced and Omega(bar) annhilated
            e(idp) = 0.
           endif
c   !! for produced particles
             go to 700
c
c-----------------------------------------------------------
700    continue
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
          PR2   = (SRT**2 - EMpp1**2 - EMpp2**2)**2
     &                - 4.0 * (EMpp1*EMpp2)**2
          IF(PR2.LE.0.)PR2=0.00000001
          PR=SQRT(PR2)/(2.*SRT)
* using isotropic
      C1   = 1.0 - 2.0 * RANART(NSEED)
      T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
* ROTATE IT 
       CALL ROTATE(PX0,PY0,PZ0,PX,PY,PZ) 
       if(icont .eq. 0)return
c
* LORENTZ-TRANSFORMATION INTO CMS FRAME
              E1CM    = SQRT (EMpp1**2 + PX**2 + PY**2 + PZ**2)
              P1BETA  = PX*BETAX + PY*BETAY + PZ*BETAZ
              TRANSF  = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) + E1CM )
              Ppt11 = BETAX * TRANSF + PX
              Ppt12 = BETAY * TRANSF + PY
              Ppt13 = BETAZ * TRANSF + PZ
c
cc** for elastic scattering update the momentum of pertb particles
         if(icsbel .ne. -1)then
c            if(EMpp1 .gt. 0.9)then
              p(1,i1) = Ppt11
              p(2,i1) = Ppt12
              p(3,i1) = Ppt13
c            else
              E2CM    = SQRT (EMpp2**2 + PX**2 + PY**2 + PZ**2)
              TRANSF  = GAMMA * ( -GAMMA * P1BETA / (GAMMA + 1) + E2CM )
              Ppt21 = BETAX * TRANSF - PX
              Ppt22 = BETAY * TRANSF - PY
              Ppt23 = BETAZ * TRANSF - PZ
              p(1,i2) = Ppt21
              p(2,i2) = Ppt22
              p(3,i2) = Ppt23
c            endif
             return
          endif
clin-5/2008:
c2008        X01 = 1.0 - 2.0 * RANART(NSEED)
c            Y01 = 1.0 - 2.0 * RANART(NSEED)
c            Z01 = 1.0 - 2.0 * RANART(NSEED)
c        IF ((X01*X01+Y01*Y01+Z01*Z01) .GT. 1.0) GOTO 2008
c                Xpt=X1+0.5*x01
c                Ypt=Y1+0.5*y01
c                Zpt=Z1+0.5*z01
                Xpt=X1
                Ypt=Y1
                Zpt=Z1
c
c
c          if(lbpp1 .eq. 45)then
c           write(*,*)'II lb1,lb2,lbpp1,empp1,proper(idp),brpp'
c           write(*,*)lb1,lb2,lbpp1,empp1,proper(idp),brpp
c          endif
c
               NNN=NNN+1
               PROPI(NNN,IRUN)= proper(idp)*brpp
               LPION(NNN,IRUN)= lbpp1
               EPION(NNN,IRUN)= empp1
                RPION(1,NNN,IRUN)=Xpt
                RPION(2,NNN,IRUN)=Ypt
                RPION(3,NNN,IRUN)=Zpt
               PPION(1,NNN,IRUN)=Ppt11
               PPION(2,NNN,IRUN)=Ppt12
               PPION(3,NNN,IRUN)=Ppt13
clin-5/2008:
               dppion(nnn,irun)=dpertp(i1)*dpertp(i2)
            RETURN
            END
**********************************
*  sp 12/08/00                                                         *
      SUBROUTINE Crhb(PX,PY,PZ,SRT,I1,I2,IBLOCK)
*     PURPOSE:                                                         *
*        DEALING WITH hyperon+N(D,N*)->hyp+N(D,N*) elastic PROCESS     *
*     NOTE   :                                                         *
*          
*     QUANTITIES:                                                 *
*           PX,PY,PZ - MOMENTUM COORDINATES OF ONE PARTICLE IN CM FRAME*
*           SRT      - SQRT OF S                                       *
*           IBLOCK   - THE INFORMATION BACK                            *
*                     144-> hyp+N(D,N*)->hyp+N(D,N*)
**********************************
        PARAMETER (MAXSTR=150001,MAXR=1,AMN=0.939457,
     1  AMP=0.93828,AP1=0.13496,
     2  AP2=0.13957,AM0=1.232,PI=3.1415926,CUTOFF=1.8966,AVMASS=0.9383)
        PARAMETER      (AKA=0.498,ALA=1.1157,ASA=1.1974)
        parameter     (MX=4,MY=4,MZ=8,MPX=4,MPY=4,mpz=10,mpzp=10)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      SAVE   

       PX0=PX
       PY0=PY
       PZ0=PZ
*-----------------------------------------------------------------------
        IBLOCK=144
        NTAG=0
        EM1=E(I1)
        EM2=E(I2)
*-----------------------------------------------------------------------
* CALCULATE THE MAGNITUDE OF THE FINAL MOMENTUM THROUGH
* ENERGY CONSERVATION
          PR2   = (SRT**2 - EM1**2 - EM2**2)**2
     1                - 4.0 * (EM1*EM2)**2
          IF(PR2.LE.0.)PR2=1.e-09
          PR=SQRT(PR2)/(2.*SRT)
          C1   = 1.0 - 2.0 * RANART(NSEED)
          T1   = 2.0 * PI * RANART(NSEED)
      S1   = SQRT( 1.0 - C1**2 )
      CT1  = COS(T1)
      ST1  = SIN(T1)
      PZ   = PR * C1
      PX   = PR * S1*CT1 
      PY   = PR * S1*ST1
      RETURN
      END
****************************************
c sp 04/05/01
* Purpose: lambda-baryon elastic xsection as a functon of their cms energy
         subroutine lambar(i1,i2,srt,siglab)
*  srt    = DSQRT(s) in GeV                                               *
*  siglab = lambda-nuclar elastic cross section in mb 
*         = 12 + 0.43/p_lab**3.3 (mb)  
*                                                    
* (2) Calculate p(lab) from srt [GeV], since the formular in the 
* reference applies only to the case of a p_bar on a proton at rest
* Formula used: srt**2=2.*pmass*(pmass+sqrt(pmass**2+plab**2))
*****************************
        PARAMETER (MAXSTR=150001)
        COMMON /AA/ R(3,MAXSTR)
cc      SAVE /AA/
        COMMON /BB/ P(3,MAXSTR)
cc      SAVE /BB/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      SAVE   

          siglab=1.e-06
        if( iabs(lb(i1)).ge.14.and.iabs(lb(i1)).le.17 )then
          eml = e(i1)
          emb = e(i2)
         else
          eml = e(i2)
          emb = e(i1)
        endif
       pthr = srt**2-eml**2-emb**2
        if(pthr .gt. 0.)then
       plab2=(pthr/2./emb)**2-eml**2
       if(plab2.gt.0)then
         plab=sqrt(plab2)
         siglab=12. + 0.43/(plab**3.3)
       if(siglab.gt.200.)siglab=200.
       endif
       endif
         return
      END
C------------------------------------------------------------------
clin-7/26/03 improve speed
***************************************
            SUBROUTINE distc0(drmax,deltr0,DT,
     1     Ifirst,PX1CM,PY1CM,PZ1CM,
     2     x1,y1,z1,px1,py1,pz1,em1,x2,y2,z2,px2,py2,pz2,em2)
* PURPOSE : CHECK IF THE COLLISION BETWEEN TWO PARTICLES CAN HAPPEN
*           BY CHECKING
*                      (2) IF PARTICLE WILL PASS EACH OTHER WITHIN
*           TWO HARD CORE RADIUS.
*                      (3) IF PARTICLES WILL GET CLOSER.
* VARIABLES :
*           Ifirst=1 COLLISION may HAPPENED
*           Ifirst=-1 COLLISION CAN NOT HAPPEN
*****************************************
            COMMON   /BG/  BETAX,BETAY,BETAZ,GAMMA
cc      SAVE /BG/
      SAVE   
            Ifirst=-1
            E1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
*NOW PARTICLES ARE CLOSE ENOUGH TO EACH OTHER !
            E2     = SQRT ( EM2**2 + PX2**2 + PY2**2 + PZ2**2 )
*NOW THERE IS ENOUGH ENERGY AVAILABLE !
*LORENTZ-TRANSFORMATION IN I1-I2-C.M. SYSTEM
* BETAX, BETAY, BETAZ AND GAMMA HAVE BEEN GIVEN IN THE SUBROUTINE CMS
*TRANSFORMATION OF MOMENTA (PX1CM = - PX2CM)
              P1BETA = PX1*BETAX + PY1*BETAY + PZ1 * BETAZ
              TRANSF = GAMMA * ( GAMMA * P1BETA / (GAMMA + 1) - E1 )
              PRCM   = SQRT (PX1CM**2 + PY1CM**2 + PZ1CM**2)
              IF (PRCM .LE. 0.00001) return
*TRANSFORMATION OF SPATIAL DISTANCE
              DRBETA = BETAX*(X1-X2) + BETAY*(Y1-Y2) + BETAZ*(Z1-Z2)
              TRANSF = GAMMA * GAMMA * DRBETA / (GAMMA + 1)
              DXCM   = BETAX * TRANSF + X1 - X2
              DYCM   = BETAY * TRANSF + Y1 - Y2
              DZCM   = BETAZ * TRANSF + Z1 - Z2
*DETERMINING IF THIS IS THE POINT OF CLOSEST APPROACH
              DRCM   = SQRT (DXCM**2  + DYCM**2  + DZCM**2 )
              DZZ    = (PX1CM*DXCM + PY1CM*DYCM + PZ1CM*DZCM) / PRCM
              if ((drcm**2 - dzz**2) .le. 0.) then
                BBB = 0.
              else
                BBB    = SQRT (DRCM**2 - DZZ**2)
              end if
*WILL PARTICLE PASS EACH OTHER WITHIN 2 * HARD CORE RADIUS ?
              IF (BBB .GT. drmax) return
              RELVEL = PRCM * (1.0/E1 + 1.0/E2)
              DDD    = RELVEL * DT * 0.5
*WILL PARTICLES GET CLOSER ?
              IF (ABS(DDD) .LT. ABS(DZZ)) return
              Ifirst=1
              RETURN
              END
*---------------------------------------------------------------------------
c
clin-8/2008 B+B->Deuteron+Meson cross section in mb:
      subroutine sbbdm(srt,sdprod,ianti,lbm,xmm,pfinal)
      PARAMETER (xmd=1.8756,AP1=0.13496,AP2=0.13957,
     1     xmrho=0.770,xmomega=0.782,xmeta=0.548,srt0=2.012)
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1     px1n,py1n,pz1n,dp1n
      common /dpi/em2,lb2
      common /para8/ idpert,npertd,idxsec
      COMMON/RNDF77/NSEED
      SAVE   
c
      sdprod=0.
      sbbdpi=0.
      sbbdrho=0.
      sbbdomega=0.
      sbbdeta=0.
      if(srt.le.(em1+em2)) return
c
      ilb1=iabs(lb1)
      ilb2=iabs(lb2)
ctest off check Xsec using fixed mass for resonances:
c      if(ilb1.ge.6.and.ilb1.le.9) then
c         em1=1.232
c      elseif(ilb1.ge.10.and.ilb1.le.11) then
c         em1=1.44
c      elseif(ilb1.ge.12.and.ilb1.le.13) then
c         em1=1.535
c      endif
c      if(ilb2.ge.6.and.ilb2.le.9) then
c         em2=1.232
c      elseif(ilb2.ge.10.and.ilb2.le.11) then
c         em2=1.44
c      elseif(ilb2.ge.12.and.ilb2.le.13) then
c         em2=1.535
c      endif
c
      s=srt**2

clin-9/2012: check argument in sqrt():
      scheck=(s-(em1+em2)**2)*(s-(em1-em2)**2)
      if(scheck.le.0) then
         write(99,*) 'scheck50: ', scheck
         stop
      endif
      pinitial=sqrt(scheck)/2./srt
c      pinitial=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt

      fs=fnndpi(s)
c     Determine isospin and spin factors for the ratio between 
c     BB->Deuteron+Meson and Deuteron+Meson->BB cross sections:
      if(idxsec.eq.1.or.idxsec.eq.2) then
c     Assume B+B -> d+Meson has the same cross sections as N+N -> d+pi:
      else
c     Assume d+Meson -> B+B has the same cross sections as d+pi -> N+N, 
c     then determine B+B -> d+Meson cross sections:
         if(ilb1.ge.1.and.ilb1.le.2.and.
     1        ilb2.ge.1.and.ilb2.le.2) then
            pifactor=9./8.
         elseif((ilb1.ge.1.and.ilb1.le.2.and.
     1           ilb2.ge.6.and.ilb2.le.9).or.
     2           (ilb2.ge.1.and.ilb2.le.2.and.
     1           ilb1.ge.6.and.ilb1.le.9)) then
            pifactor=9./64.
         elseif((ilb1.ge.1.and.ilb1.le.2.and.
     1           ilb2.ge.10.and.ilb2.le.13).or.
     2           (ilb2.ge.1.and.ilb2.le.2.and.
     1           ilb1.ge.10.and.ilb1.le.13)) then
            pifactor=9./16.
         elseif(ilb1.ge.6.and.ilb1.le.9.and.
     1           ilb2.ge.6.and.ilb2.le.9) then
            pifactor=9./128.
         elseif((ilb1.ge.6.and.ilb1.le.9.and.
     1           ilb2.ge.10.and.ilb2.le.13).or.
     2           (ilb2.ge.6.and.ilb2.le.9.and.
     1           ilb1.ge.10.and.ilb1.le.13)) then
            pifactor=9./64.
         elseif((ilb1.ge.10.and.ilb1.le.11.and.
     1           ilb2.ge.10.and.ilb2.le.11).or.
     2           (ilb2.ge.12.and.ilb2.le.13.and.
     1           ilb1.ge.12.and.ilb1.le.13)) then
            pifactor=9./8.
         elseif((ilb1.ge.10.and.ilb1.le.11.and.
     1           ilb2.ge.12.and.ilb2.le.13).or.
     2           (ilb2.ge.10.and.ilb2.le.11.and.
     1           ilb1.ge.12.and.ilb1.le.13)) then
            pifactor=9./16.
         endif
      endif
c     d pi: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
*     (1) FOR P+P->Deuteron+pi+:
      IF((ilb1*ilb2).EQ.1)THEN
         lbm=5
         if(ianti.eq.1) lbm=3
         xmm=ap2
*     (2)FOR N+N->Deuteron+pi-:
      ELSEIF(ilb1.EQ.2.AND.ilb2.EQ.2)THEN
         lbm=3
         if(ianti.eq.1) lbm=5
         xmm=ap2
*     (3)FOR N+P->Deuteron+pi0:
      ELSEIF((ilb1*ilb2).EQ.2)THEN
         lbm=4
         xmm=ap1
      ELSE
c     For baryon resonances, use isospin-averaged cross sections:
         lbm=3+int(3 * RANART(NSEED))
         if(lbm.eq.4) then
            xmm=ap1
         else
            xmm=ap2
         endif
      ENDIF
c
      if(srt.ge.(xmd+xmm)) then
         pfinal=sqrt((s-(xmd+xmm)**2)*(s-(xmd-xmm)**2))/2./srt
         if((ilb1.eq.1.and.ilb2.eq.1).or.
     1        (ilb1.eq.2.and.ilb2.eq.2)) then
c     for pp or nn initial states:
            sbbdpi=fs*pfinal/pinitial/4.
         elseif((ilb1.eq.1.and.ilb2.eq.2).or.
     1           (ilb1.eq.2.and.ilb2.eq.1)) then
c     factor of 1/2 for pn or np initial states:
            sbbdpi=fs*pfinal/pinitial/4./2.
         else
c     for other BB initial states (spin- and isospin averaged):
            if(idxsec.eq.1) then
c     1: assume the same |matrix element|**2/s (after averaging over initial 
c     spins and isospins) for B+B -> deuteron+meson at the same sqrt(s);
               sbbdpi=fs*pfinal/pinitial*3./16.
            elseif(idxsec.eq.2.or.idxsec.eq.4) then
               threshold=amax1(xmd+xmm,em1+em2)
               snew=(srt-threshold+srt0)**2
               if(idxsec.eq.2) then
c     2: assume the same |matrix element|**2/s for B+B -> deuteron+meson 
c     at the same sqrt(s)-threshold:
                  sbbdpi=fnndpi(snew)*pfinal/pinitial*3./16.
               elseif(idxsec.eq.4) then
c     4: assume the same |matrix element|**2/s for B+B <- deuteron+meson 
c     at the same sqrt(s)-threshold:
                  sbbdpi=fnndpi(snew)*pfinal/pinitial/6.*pifactor
               endif
            elseif(idxsec.eq.3) then
c     3: assume the same |matrix element|**2/s for B+B <- deuteron+meson 
c     at the same sqrt(s):
               sbbdpi=fs*pfinal/pinitial/6.*pifactor
            endif
c
         endif
      endif
c     
*     d rho: DETERMINE THE CROSS SECTION TO THIS FINAL STATE:
      if(srt.gt.(xmd+xmrho)) then
         pfinal=sqrt((s-(xmd+xmrho)**2)*(s-(xmd-xmrho)**2))/2./srt
         if(idxsec.eq.1) then
            sbbdrho=fs*pfinal/pinitial*3./16.
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmd+xmrho,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sbbdrho=fnndpi(snew)*pfinal/pinitial*3./16.
            elseif(idxsec.eq.4) then
c     The spin- and isospin-averaged factor is 3-times larger for rho:
               sbbdrho=fnndpi(snew)*pfinal/pinitial/6.*(pifactor*3.)
            endif
         elseif(idxsec.eq.3) then
            sbbdrho=fs*pfinal/pinitial/6.*(pifactor*3.)
         endif
      endif
c
*     d omega: DETERMINE THE CROSS SECTION TO THIS FINAL STATE:
      if(srt.gt.(xmd+xmomega)) then
         pfinal=sqrt((s-(xmd+xmomega)**2)*(s-(xmd-xmomega)**2))/2./srt
         if(idxsec.eq.1) then
            sbbdomega=fs*pfinal/pinitial*3./16.
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmd+xmomega,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sbbdomega=fnndpi(snew)*pfinal/pinitial*3./16.
            elseif(idxsec.eq.4) then
               sbbdomega=fnndpi(snew)*pfinal/pinitial/6.*pifactor
            endif
         elseif(idxsec.eq.3) then
            sbbdomega=fs*pfinal/pinitial/6.*pifactor
         endif
      endif
c
*     d eta: DETERMINE THE CROSS SECTION TO THIS FINAL STATE:
      if(srt.gt.(xmd+xmeta)) then
         pfinal=sqrt((s-(xmd+xmeta)**2)*(s-(xmd-xmeta)**2))/2./srt
         if(idxsec.eq.1) then
            sbbdeta=fs*pfinal/pinitial*3./16.
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmd+xmeta,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sbbdeta=fnndpi(snew)*pfinal/pinitial*3./16.
            elseif(idxsec.eq.4) then
               sbbdeta=fnndpi(snew)*pfinal/pinitial/6.*(pifactor/3.)
            endif
         elseif(idxsec.eq.3) then
            sbbdeta=fs*pfinal/pinitial/6.*(pifactor/3.)
         endif
      endif
c
      sdprod=sbbdpi+sbbdrho+sbbdomega+sbbdeta
ctest off
c      write(99,111) srt,sbbdpi,sbbdrho,sbbdomega,sbbdeta,sdprod
c 111  format(6(f8.2,1x))
c
      if(sdprod.le.0) return
c
c     choose final state and assign masses here:
      x1=RANART(NSEED)
      if(x1.le.sbbdpi/sdprod) then
c     use the above-determined lbm and xmm.
      elseif(x1.le.(sbbdpi+sbbdrho)/sdprod) then
         lbm=25+int(3*RANART(NSEED))
         xmm=xmrho
      elseif(x1.le.(sbbdpi+sbbdrho+sbbdomega)/sdprod) then
         lbm=28
         xmm=xmomega
      else
         lbm=0
         xmm=xmeta
      endif
c
      return
      end
c
c     Generate angular distribution of Deuteron in the CMS frame:
      subroutine bbdangle(pxd,pyd,pzd,nt,ipert1,ianti,idloop,pfinal,
     1 dprob1,lbm)
      PARAMETER (PI=3.1415926)
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1     px1n,py1n,pz1n,dp1n
      common /dpi/em2,lb2
      COMMON/RNDF77/NSEED
      common /para8/ idpert,npertd,idxsec
      COMMON /AREVT/ IAEVT, IARUN, MISS
      SAVE   
c     take isotropic distribution for now:
      C1=1.0-2.0*RANART(NSEED)
      T1=2.0*PI*RANART(NSEED)
      S1=SQRT(1.0-C1**2)
      CT1=COS(T1)
      ST1=SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      PZd=pfinal*C1
      PXd=pfinal*S1*CT1 
      PYd=pfinal*S1*ST1
clin-5/2008 track the number of produced deuterons:
      if(idpert.eq.1.and.npertd.ge.1) then
         dprob=dprob1
      elseif(idpert.eq.2.and.npertd.ge.1) then
         dprob=1./float(npertd)
      endif
      if(ianti.eq.0) then
         if(idpert.eq.0.or.(idpert.eq.1.and.ipert1.eq.0).or.
     1        (idpert.eq.2.and.idloop.eq.(npertd+1))) then
            write (91,*) lb1,' *',lb2,' ->d+',lbm,' (regular d prodn) 
     1 @evt#',iaevt,' @nt=',nt
         elseif((idpert.eq.1.or.idpert.eq.2).and.idloop.eq.npertd) then
            write (91,*) lb1,' *',lb2,' ->d+',lbm,' (pert d prodn) 
     1 @evt#',iaevt,' @nt=',nt,' @prob=',dprob
         endif
      else
         if(idpert.eq.0.or.(idpert.eq.1.and.ipert1.eq.0).or.
     1        (idpert.eq.2.and.idloop.eq.(npertd+1))) then
            write (91,*) lb1,' *',lb2,' ->d+',lbm,' (regular dbar prodn) 
     1 @evt#',iaevt,' @nt=',nt
         elseif((idpert.eq.1.or.idpert.eq.2).and.idloop.eq.npertd) then
            write (91,*) lb1,' *',lb2,' ->d+',lbm,' (pert dbar prodn) 
     1 @evt#',iaevt,' @nt=',nt,' @prob=',dprob
         endif
      endif
c
      return
      end
c
c     Deuteron+Meson->B+B cross section (in mb)
      subroutine sdmbb(SRT,sdm,ianti)
      PARAMETER (AMN=0.939457,AMP=0.93828,
     1     AM0=1.232,AM1440=1.44,AM1535=1.535,srt0=2.012)
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1     px1n,py1n,pz1n,dp1n
      common /dpi/em2,lb2
      common /dpifsl/lbnn1,lbnn2,lbnd1,lbnd2,lbns1,lbns2,lbnp1,lbnp2,
     1     lbdd1,lbdd2,lbds1,lbds2,lbdp1,lbdp2,lbss1,lbss2,
     2     lbsp1,lbsp2,lbpp1,lbpp2
      common /dpifsm/xmnn1,xmnn2,xmnd1,xmnd2,xmns1,xmns2,xmnp1,xmnp2,
     1     xmdd1,xmdd2,xmds1,xmds2,xmdp1,xmdp2,xmss1,xmss2,
     2     xmsp1,xmsp2,xmpp1,xmpp2
      common /dpisig/sdmel,sdmnn,sdmnd,sdmns,sdmnp,sdmdd,sdmds,sdmdp,
     1     sdmss,sdmsp,sdmpp
      common /para8/ idpert,npertd,idxsec
      COMMON/RNDF77/NSEED
      SAVE   
c
      sdm=0.
      sdmel=0.
      sdmnn=0.
      sdmnd=0.
      sdmns=0.
      sdmnp=0.
      sdmdd=0.
      sdmds=0.
      sdmdp=0.
      sdmss=0.
      sdmsp=0.
      sdmpp=0.
ctest off check Xsec using fixed mass for resonances:
c      if(lb1.ge.25.and.lb1.le.27) then
c         em1=0.776
c      elseif(lb1.eq.28) then
c         em1=0.783
c      elseif(lb1.eq.0) then
c         em1=0.548
c      endif
c      if(lb2.ge.25.and.lb2.le.27) then
c         em2=0.776
c      elseif(lb2.eq.28) then
c         em2=0.783
c      elseif(lb2.eq.0) then
c         em2=0.548
c      endif
c
      if(srt.le.(em1+em2)) return
      s=srt**2
      pinitial=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt
      fs=fnndpi(s)
c     Determine isospin and spin factors for the ratio between 
c     Deuteron+Meson->BB and BB->Deuteron+Meson cross sections:
      if(idxsec.eq.1.or.idxsec.eq.2) then
c     Assume B+B -> d+Meson has the same cross sections as N+N -> d+pi, 
c     then determine d+Meson -> B+B cross sections:
         if((lb1.ge.3.and.lb1.le.5).or.
     1        (lb2.ge.3.and.lb2.le.5)) then
            xnnfactor=8./9.
         elseif((lb1.ge.25.and.lb1.le.27).or.
     1           (lb2.ge.25.and.lb2.le.27)) then
            xnnfactor=8./27.
         elseif(lb1.eq.28.or.lb2.eq.28) then
            xnnfactor=8./9.
         elseif(lb1.eq.0.or.lb2.eq.0) then
            xnnfactor=8./3.
         endif
      else
c     Assume d+Meson -> B+B has the same cross sections as d+pi -> N+N:
      endif
clin-9/2008 For elastic collisions:
      if(idxsec.eq.1.or.idxsec.eq.3) then
c     1/3: assume the same |matrix element|**2/s (after averaging over initial 
c     spins and isospins) for d+Meson elastic at the same sqrt(s);
         sdmel=fdpiel(s)
      elseif(idxsec.eq.2.or.idxsec.eq.4) then
c     2/4: assume the same |matrix element|**2/s (after averaging over initial 
c     spins and isospins) for d+Meson elastic at the same sqrt(s)-threshold:
         threshold=em1+em2
         snew=(srt-threshold+srt0)**2
         sdmel=fdpiel(snew)
      endif
c
*     NN: DETERMINE THE CHARGE STATES OF PARTICLESIN THE FINAL STATE
      IF(((lb1.eq.5.or.lb2.eq.5.or.lb1.eq.27.or.lb2.eq.27)
     1     .and.ianti.eq.0).or.
     2     ((lb1.eq.3.or.lb2.eq.3.or.lb1.eq.25.or.lb2.eq.25)
     3     .and.ianti.eq.1))THEN
*     (1) FOR Deuteron+(pi+,rho+) -> P+P or DeuteronBar+(pi-,rho-)-> PBar+PBar:
         lbnn1=1
         lbnn2=1
         xmnn1=amp
         xmnn2=amp
      ELSEIF(lb1.eq.3.or.lb2.eq.3.or.lb1.eq.26.or.lb2.eq.26
     1        .or.lb1.eq.28.or.lb2.eq.28.or.lb1.eq.0.or.lb2.eq.0)THEN
*     (2) FOR Deuteron+(pi0,rho0,omega,eta) -> N+P 
*     or DeuteronBar+(pi0,rho0,omega,eta) ->NBar+PBar:
         lbnn1=2
         lbnn2=1
         xmnn1=amn
         xmnn2=amp
      ELSE
*     (3) FOR Deuteron+(pi-,rho-) -> N+N or DeuteronBar+(pi+,rho+)-> NBar+NBar:
         lbnn1=2
         lbnn2=2
         xmnn1=amn
         xmnn2=amn
      ENDIF
      if(srt.gt.(xmnn1+xmnn2)) then
         pfinal=sqrt((s-(xmnn1+xmnn2)**2)*(s-(xmnn1-xmnn2)**2))/2./srt
         if(idxsec.eq.1) then
c     1: assume the same |matrix element|**2/s (after averaging over initial 
c     spins and isospins) for B+B -> deuteron+meson at the same sqrt(s);
            sdmnn=fs*pfinal/pinitial*3./16.*xnnfactor
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmnn1+xmnn2,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
c     2: assume the same |matrix element|**2/s for B+B -> deuteron+meson 
c     at the same sqrt(s)-threshold:
               sdmnn=fnndpi(snew)*pfinal/pinitial*3./16.*xnnfactor
            elseif(idxsec.eq.4) then
c     4: assume the same |matrix element|**2/s for B+B <- deuteron+meson 
c     at the same sqrt(s)-threshold:
               sdmnn=fnndpi(snew)*pfinal/pinitial/6.
            endif
         elseif(idxsec.eq.3) then
c     3: assume the same |matrix element|**2/s for B+B <- deuteron+meson 
c     at the same sqrt(s):
            sdmnn=fs*pfinal/pinitial/6.
         endif
      endif
c     
*     ND: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
      lbnd1=1+int(2*RANART(NSEED))
      lbnd2=6+int(4*RANART(NSEED))
      if(lbnd1.eq.1) then
         xmnd1=amp
      elseif(lbnd1.eq.2) then
         xmnd1=amn
      endif
      xmnd2=am0
      if(srt.gt.(xmnd1+xmnd2)) then
         pfinal=sqrt((s-(xmnd1+xmnd2)**2)*(s-(xmnd1-xmnd2)**2))/2./srt
         if(idxsec.eq.1) then
c     The spin- and isospin-averaged factor is 8-times larger for ND:
            sdmnd=fs*pfinal/pinitial*3./16.*(xnnfactor*8.)
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmnd1+xmnd2,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sdmnd=fnndpi(snew)*pfinal/pinitial*3./16.*(xnnfactor*8.)
            elseif(idxsec.eq.4) then
               sdmnd=fnndpi(snew)*pfinal/pinitial/6.
            endif
         elseif(idxsec.eq.3) then
            sdmnd=fs*pfinal/pinitial/6.
         endif
      endif
c
*     NS: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
      lbns1=1+int(2*RANART(NSEED))
      lbns2=10+int(2*RANART(NSEED))
      if(lbns1.eq.1) then
         xmns1=amp
      elseif(lbns1.eq.2) then
         xmns1=amn
      endif
      xmns2=am1440
      if(srt.gt.(xmns1+xmns2)) then
         pfinal=sqrt((s-(xmns1+xmns2)**2)*(s-(xmns1-xmns2)**2))/2./srt
         if(idxsec.eq.1) then
            sdmns=fs*pfinal/pinitial*3./16.*(xnnfactor*2.)
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmns1+xmns2,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sdmns=fnndpi(snew)*pfinal/pinitial*3./16.*(xnnfactor*2.)
            elseif(idxsec.eq.4) then
               sdmns=fnndpi(snew)*pfinal/pinitial/6.
            endif
         elseif(idxsec.eq.3) then
            sdmns=fs*pfinal/pinitial/6.
         endif
      endif
c
*     NP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
      lbnp1=1+int(2*RANART(NSEED))
      lbnp2=12+int(2*RANART(NSEED))
      if(lbnp1.eq.1) then
         xmnp1=amp
      elseif(lbnp1.eq.2) then
         xmnp1=amn
      endif
      xmnp2=am1535
      if(srt.gt.(xmnp1+xmnp2)) then
         pfinal=sqrt((s-(xmnp1+xmnp2)**2)*(s-(xmnp1-xmnp2)**2))/2./srt
         if(idxsec.eq.1) then
            sdmnp=fs*pfinal/pinitial*3./16.*(xnnfactor*2.)
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmnp1+xmnp2,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sdmnp=fnndpi(snew)*pfinal/pinitial*3./16.*(xnnfactor*2.)
            elseif(idxsec.eq.4) then
               sdmnp=fnndpi(snew)*pfinal/pinitial/6.
            endif
         elseif(idxsec.eq.3) then
            sdmnp=fs*pfinal/pinitial/6.
         endif
      endif
c
*     DD: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
      lbdd1=6+int(4*RANART(NSEED))
      lbdd2=6+int(4*RANART(NSEED))
      xmdd1=am0
      xmdd2=am0
      if(srt.gt.(xmdd1+xmdd2)) then
         pfinal=sqrt((s-(xmdd1+xmdd2)**2)*(s-(xmdd1-xmdd2)**2))/2./srt
         if(idxsec.eq.1) then
            sdmdd=fs*pfinal/pinitial*3./16.*(xnnfactor*16.)
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmdd1+xmdd2,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sdmdd=fnndpi(snew)*pfinal/pinitial*3./16.*(xnnfactor*16.)
            elseif(idxsec.eq.4) then
               sdmdd=fnndpi(snew)*pfinal/pinitial/6.
            endif
         elseif(idxsec.eq.3) then
            sdmdd=fs*pfinal/pinitial/6.
         endif
      endif
c
*     DS: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
      lbds1=6+int(4*RANART(NSEED))
      lbds2=10+int(2*RANART(NSEED))
      xmds1=am0
      xmds2=am1440
      if(srt.gt.(xmds1+xmds2)) then
         pfinal=sqrt((s-(xmds1+xmds2)**2)*(s-(xmds1-xmds2)**2))/2./srt
         if(idxsec.eq.1) then
            sdmds=fs*pfinal/pinitial*3./16.*(xnnfactor*8.)
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmds1+xmds2,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sdmds=fnndpi(snew)*pfinal/pinitial*3./16.*(xnnfactor*8.)
            elseif(idxsec.eq.4) then
               sdmds=fnndpi(snew)*pfinal/pinitial/6.
            endif
         elseif(idxsec.eq.3) then
            sdmds=fs*pfinal/pinitial/6.
         endif
      endif
c
*     DP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
      lbdp1=6+int(4*RANART(NSEED))
      lbdp2=12+int(2*RANART(NSEED))
      xmdp1=am0
      xmdp2=am1535
      if(srt.gt.(xmdp1+xmdp2)) then
         pfinal=sqrt((s-(xmdp1+xmdp2)**2)*(s-(xmdp1-xmdp2)**2))/2./srt
         if(idxsec.eq.1) then
            sdmdp=fs*pfinal/pinitial*3./16.*(xnnfactor*8.)
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmdp1+xmdp2,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sdmdp=fnndpi(snew)*pfinal/pinitial*3./16.*(xnnfactor*8.)
            elseif(idxsec.eq.4) then
               sdmdp=fnndpi(snew)*pfinal/pinitial/6.
            endif
         elseif(idxsec.eq.3) then
            sdmdp=fs*pfinal/pinitial/6.
         endif
      endif
c
*     SS: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
      lbss1=10+int(2*RANART(NSEED))
      lbss2=10+int(2*RANART(NSEED))
      xmss1=am1440
      xmss2=am1440
      if(srt.gt.(xmss1+xmss2)) then
         pfinal=sqrt((s-(xmss1+xmss2)**2)*(s-(xmss1-xmss2)**2))/2./srt
         if(idxsec.eq.1) then
            sdmss=fs*pfinal/pinitial*3./16.*xnnfactor
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmss1+xmss2,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sdmss=fnndpi(snew)*pfinal/pinitial*3./16.*xnnfactor
            elseif(idxsec.eq.4) then
               sdmss=fnndpi(snew)*pfinal/pinitial/6.
            endif
         elseif(idxsec.eq.3) then
            sdmns=fs*pfinal/pinitial/6.
         endif
      endif
c
*     SP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
      lbsp1=10+int(2*RANART(NSEED))
      lbsp2=12+int(2*RANART(NSEED))
      xmsp1=am1440
      xmsp2=am1535
      if(srt.gt.(xmsp1+xmsp2)) then
         pfinal=sqrt((s-(xmsp1+xmsp2)**2)*(s-(xmsp1-xmsp2)**2))/2./srt
         if(idxsec.eq.1) then
            sdmsp=fs*pfinal/pinitial*3./16.*(xnnfactor*2.)
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmsp1+xmsp2,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sdmsp=fnndpi(snew)*pfinal/pinitial*3./16.*(xnnfactor*2.)
            elseif(idxsec.eq.4) then
               sdmsp=fnndpi(snew)*pfinal/pinitial/6.
            endif
         elseif(idxsec.eq.3) then
            sdmsp=fs*pfinal/pinitial/6.
         endif
      endif
c
*     PP: DETERMINE THE CHARGE STATES OF PARTICLES IN THE FINAL STATE
      lbpp1=12+int(2*RANART(NSEED))
      lbpp2=12+int(2*RANART(NSEED))
      xmpp1=am1535
      xmpp2=am1535
      if(srt.gt.(xmpp1+xmpp2)) then
         pfinal=sqrt((s-(xmpp1+xmpp2)**2)*(s-(xmpp1-xmpp2)**2))/2./srt
         if(idxsec.eq.1) then
            sdmpp=fs*pfinal/pinitial*3./16.*xnnfactor
         elseif(idxsec.eq.2.or.idxsec.eq.4) then
            threshold=amax1(xmpp1+xmpp2,em1+em2)
            snew=(srt-threshold+srt0)**2
            if(idxsec.eq.2) then
               sdmpp=fnndpi(snew)*pfinal/pinitial*3./16.*xnnfactor
            elseif(idxsec.eq.4) then
               sdmpp=fnndpi(snew)*pfinal/pinitial/6.
            endif
         elseif(idxsec.eq.3) then
            sdmpp=fs*pfinal/pinitial/6.
         endif
      endif
c
      sdm=sdmel+sdmnn+sdmnd+sdmns+sdmnp+sdmdd+sdmds+sdmdp
     1     +sdmss+sdmsp+sdmpp
      if(ianti.eq.1) then
         lbnn1=-lbnn1
         lbnn2=-lbnn2
         lbnd1=-lbnd1
         lbnd2=-lbnd2
         lbns1=-lbns1
         lbns2=-lbns2
         lbnp1=-lbnp1
         lbnp2=-lbnp2
         lbdd1=-lbdd1
         lbdd2=-lbdd2
         lbds1=-lbds1
         lbds2=-lbds2
         lbdp1=-lbdp1
         lbdp2=-lbdp2
         lbss1=-lbss1
         lbss2=-lbss2
         lbsp1=-lbsp1
         lbsp2=-lbsp2
         lbpp1=-lbpp1
         lbpp2=-lbpp2
      endif
ctest off
c      write(98,100) srt,sdmnn,sdmnd,sdmns,sdmnp,sdmdd,sdmds,sdmdp,
c     1     sdmss,sdmsp,sdmpp,sdm
c 100  format(f5.2,11(1x,f5.1))
c
      return
      end
c
clin-9/2008 Deuteron+Meson ->B+B and elastic collisions
      SUBROUTINE crdmbb(PX,PY,PZ,SRT,I1,I2,IBLOCK,
     1     NTAG,sig,NT,ianti)
      PARAMETER (MAXSTR=150001,MAXR=1)
      COMMON /AA/R(3,MAXSTR)
      COMMON /BB/ P(3,MAXSTR)
      COMMON /BG/BETAX,BETAY,BETAZ,GAMMA
      COMMON /CC/ E(MAXSTR)
      COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
      COMMON /AREVT/ IAEVT, IARUN, MISS
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1     px1n,py1n,pz1n,dp1n
      common /dpi/em2,lb2
      common /para8/ idpert,npertd,idxsec
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      common /dpifsl/lbnn1,lbnn2,lbnd1,lbnd2,lbns1,lbns2,lbnp1,lbnp2,
     1     lbdd1,lbdd2,lbds1,lbds2,lbdp1,lbdp2,lbss1,lbss2,
     2     lbsp1,lbsp2,lbpp1,lbpp2
      common /dpifsm/xmnn1,xmnn2,xmnd1,xmnd2,xmns1,xmns2,xmnp1,xmnp2,
     1     xmdd1,xmdd2,xmds1,xmds2,xmdp1,xmdp2,xmss1,xmss2,
     2     xmsp1,xmsp2,xmpp1,xmpp2
      common /dpisig/sdmel,sdmnn,sdmnd,sdmns,sdmnp,sdmdd,sdmds,sdmdp,
     1     sdmss,sdmsp,sdmpp
      COMMON/RNDF77/NSEED
      SAVE   
*-----------------------------------------------------------------------
      IBLOCK=0
      NTAG=0
      EM1=E(I1)
      EM2=E(I2)
      s=srt**2
      if(sig.le.0) return
c
      if(iabs(lb1).eq.42) then
         ideut=i1
         lbm=lb2
         idm=i2
      else
         ideut=i2
         lbm=lb1
         idm=i1
      endif
cccc  Elastic collision or destruction of perturbatively-produced deuterons:
      if((idpert.eq.1.or.idpert.eq.2).and.dpertp(ideut).ne.1.) then
c     choose reaction channels:
         x1=RANART(NSEED)
         if(x1.le.sdmel/sig)then
c     Elastic collisions:
            if(ianti.eq.0) then
               write(91,*) '  d+',lbm,' (pert d M elastic) @nt=',nt
     1              ,' @prob=',dpertp(ideut)
            else
               write(91,*) '  d+',lbm,' (pert dbar M elastic) @nt=',nt
     1              ,' @prob=',dpertp(ideut)
            endif

clin-9/2012: check argument in sqrt():
            scheck=(s-(em1+em2)**2)*(s-(em1-em2)**2)
            if(scheck.lt.0) then
               write(99,*) 'scheck51: ', scheck
               scheck=0.
            endif
            pfinal=sqrt(scheck)/2./srt
c            pfinal=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt

            CALL dmelangle(pxn,pyn,pzn,pfinal)
            CALL ROTATE(PX,PY,PZ,Pxn,Pyn,Pzn)
            EdCM=SQRT(E(ideut)**2+Pxn**2+Pyn**2+Pzn**2)
            PdBETA=Pxn*BETAX+Pyn*BETAY+Pzn*BETAZ
            TRANSF=GAMMA*(GAMMA*PdBETA/(GAMMA+1.)+EdCM)
            Pt1d=BETAX*TRANSF+Pxn
            Pt2d=BETAY*TRANSF+Pyn
            Pt3d=BETAZ*TRANSF+Pzn
            p(1,ideut)=pt1d
            p(2,ideut)=pt2d
            p(3,ideut)=pt3d
            IBLOCK=504
            PX1=P(1,I1)
            PY1=P(2,I1)
            PZ1=P(3,I1)
            ID(I1)=2
            ID(I2)=2
c     Change the position of the perturbative deuteron to that of 
c     the meson to avoid consecutive collisions between them:
            R(1,ideut)=R(1,idm)
            R(2,ideut)=R(2,idm)
            R(3,ideut)=R(3,idm)
         else
c     Destruction of deuterons:
            if(ianti.eq.0) then
               write(91,*) '  d+',lbm,' ->BB (pert d destrn) @nt=',nt
     1              ,' @prob=',dpertp(ideut)
            else
               write(91,*) '  d+',lbm,' ->BB (pert dbar destrn) @nt=',nt
     1              ,' @prob=',dpertp(ideut)
            endif
            e(ideut)=0.
            IBLOCK=502
         endif
         return
      endif
c
cccc  Destruction of regularly-produced deuterons:
      IBLOCK=502
c     choose final state and assign masses here:
      x1=RANART(NSEED)
      if(x1.le.sdmnn/sig)then
         lbb1=lbnn1
         lbb2=lbnn2
         xmb1=xmnn1
         xmb2=xmnn2
      elseif(x1.le.(sdmnn+sdmnd)/sig)then
         lbb1=lbnd1
         lbb2=lbnd2
         xmb1=xmnd1
         xmb2=xmnd2
      elseif(x1.le.(sdmnn+sdmnd+sdmns)/sig)then
         lbb1=lbns1
         lbb2=lbns2
         xmb1=xmns1
         xmb2=xmns2
      elseif(x1.le.(sdmnn+sdmnd+sdmns+sdmnp)/sig)then
         lbb1=lbnp1
         lbb2=lbnp2
         xmb1=xmnp1
         xmb2=xmnp2
      elseif(x1.le.(sdmnn+sdmnd+sdmns+sdmnp+sdmdd)/sig)then
         lbb1=lbdd1
         lbb2=lbdd2
         xmb1=xmdd1
         xmb2=xmdd2
      elseif(x1.le.(sdmnn+sdmnd+sdmns+sdmnp+sdmdd+sdmds)/sig)then
         lbb1=lbds1
         lbb2=lbds2
         xmb1=xmds1
         xmb2=xmds2
      elseif(x1.le.(sdmnn+sdmnd+sdmns+sdmnp+sdmdd+sdmds+sdmdp)/sig)then
         lbb1=lbdp1
         lbb2=lbdp2
         xmb1=xmdp1
         xmb2=xmdp2
      elseif(x1.le.(sdmnn+sdmnd+sdmns+sdmnp+sdmdd+sdmds+sdmdp
     1        +sdmss)/sig)then
         lbb1=lbss1
         lbb2=lbss2
         xmb1=xmss1
         xmb2=xmss2
      elseif(x1.le.(sdmnn+sdmnd+sdmns+sdmnp+sdmdd+sdmds+sdmdp
     1        +sdmss+sdmsp)/sig)then
         lbb1=lbsp1
         lbb2=lbsp2
         xmb1=xmsp1
         xmb2=xmsp2
      elseif(x1.le.(sdmnn+sdmnd+sdmns+sdmnp+sdmdd+sdmds+sdmdp
     1        +sdmss+sdmsp+sdmpp)/sig)then
         lbb1=lbpp1
         lbb2=lbpp2
         xmb1=xmpp1
         xmb2=xmpp2
      else
c     Elastic collision:
         lbb1=lb1
         lbb2=lb2
         xmb1=em1
         xmb2=em2
         IBLOCK=504
      endif
      LB(I1)=lbb1
      E(i1)=xmb1
      LB(I2)=lbb2
      E(I2)=xmb2
      lb1=lb(i1)
      lb2=lb(i2)

clin-9/2012: check argument in sqrt():
      scheck=(s-(xmb1+xmb2)**2)*(s-(xmb1-xmb2)**2)
      if(scheck.lt.0) then
         write(99,*) 'scheck52: ', scheck
         scheck=0.
      endif
      pfinal=sqrt(scheck)/2./srt
c      pfinal=sqrt((s-(xmb1+xmb2)**2)*(s-(xmb1-xmb2)**2))/2./srt

      if(iblock.eq.502) then
         CALL dmangle(pxn,pyn,pzn,nt,ianti,pfinal,lbm)
      elseif(iblock.eq.504) then
         if(ianti.eq.0) then
            write (91,*) ' d+',lbm,' (regular d M elastic) @evt#',
     1           iaevt,' @nt=',nt,' lb1,2=',lb1,lb2
         else
            write (91,*) ' d+',lbm,' (regular dbar M elastic) @evt#',
     1           iaevt,' @nt=',nt,' lb1,2=',lb1,lb2
         endif
         CALL dmelangle(pxn,pyn,pzn,pfinal)
      else
         print *, 'Wrong iblock number in crdmbb()'
         stop
      endif
*     ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
c     (This is not needed for isotropic distributions)
      CALL ROTATE(PX,PY,PZ,Pxn,Pyn,Pzn)
*     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL STATE 
*     FROM THE NUCLEUS-NUCLEUS CMS. FRAME INTO LAB FRAME:
*     For the 1st baryon:
      E1CM=SQRT(E(I1)**2+Pxn**2+Pyn**2+Pzn**2)
      P1BETA=Pxn*BETAX+Pyn*BETAY+Pzn*BETAZ
      TRANSF=GAMMA*(GAMMA*P1BETA/(GAMMA+1.)+E1CM)
      Pt1i1=BETAX*TRANSF+Pxn
      Pt2i1=BETAY*TRANSF+Pyn
      Pt3i1=BETAZ*TRANSF+Pzn
c
      p(1,i1)=pt1i1
      p(2,i1)=pt2i1
      p(3,i1)=pt3i1
*     For the 2nd baryon:
      E2CM=SQRT(E(I2)**2+Pxn**2+Pyn**2+Pzn**2)
      P2BETA=-Pxn*BETAX-Pyn*BETAY-Pzn*BETAZ
      TRANSF=GAMMA*(GAMMA*P2BETA/(GAMMA+1.)+E2CM)
      Pt1I2=BETAX*TRANSF-Pxn
      Pt2I2=BETAY*TRANSF-Pyn
      Pt3I2=BETAZ*TRANSF-Pzn
c     
      p(1,i2)=pt1i2
      p(2,i2)=pt2i2
      p(3,i2)=pt3i2
c
      PX1=P(1,I1)
      PY1=P(2,I1)
      PZ1=P(3,I1)
      EM1=E(I1)
      EM2=E(I2)
      ID(I1)=2
      ID(I2)=2
      RETURN
      END
c
c     Generate angular distribution of BB from d+meson in the CMS frame:
      subroutine dmangle(pxn,pyn,pzn,nt,ianti,pfinal,lbm)
      PARAMETER (PI=3.1415926)
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1     px1n,py1n,pz1n,dp1n
      common /dpi/em2,lb2
      COMMON /AREVT/ IAEVT, IARUN, MISS
      COMMON/RNDF77/NSEED
      SAVE   
c     take isotropic distribution for now:
      C1=1.0-2.0*RANART(NSEED)
      T1=2.0*PI*RANART(NSEED)
      S1=SQRT(1.0-C1**2)
      CT1=COS(T1)
      ST1=SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      Pzn=pfinal*C1
      Pxn=pfinal*S1*CT1 
      Pyn=pfinal*S1*ST1
clin-5/2008 track the number of regularly-destructed deuterons:
      if(ianti.eq.0) then
         write (91,*) ' d+',lbm,' ->BB (regular d destrn) @evt#',
     1        iaevt,' @nt=',nt,' lb1,2=',lb1,lb2
      else
         write (91,*) ' d+',lbm,' ->BB (regular dbar destrn) @evt#',
     1        iaevt,' @nt=',nt,' lb1,2=',lb1,lb2
      endif
c
      return
      end
c
c     Angular distribution of d+meson elastic collisions in the CMS frame:
      subroutine dmelangle(pxn,pyn,pzn,pfinal)
      PARAMETER (PI=3.1415926)
      COMMON/RNDF77/NSEED
      SAVE   
c     take isotropic distribution for now:
      C1=1.0-2.0*RANART(NSEED)
      T1=2.0*PI*RANART(NSEED)
      S1=SQRT(1.0-C1**2)
      CT1=COS(T1)
      ST1=SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      Pzn=pfinal*C1
      Pxn=pfinal*S1*CT1 
      Pyn=pfinal*S1*ST1
      return
      end
c
clin-9/2008 Deuteron+Baryon elastic cross section (in mb)
      subroutine sdbelastic(SRT,sdb)
      PARAMETER (srt0=2.012)
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1     px1n,py1n,pz1n,dp1n
      common /dpi/em2,lb2
      common /para8/ idpert,npertd,idxsec
      SAVE   
c
      sdb=0.
      sdbel=0.
      if(srt.le.(em1+em2)) return
      s=srt**2
c     For elastic collisions:
      if(idxsec.eq.1.or.idxsec.eq.3) then
c     1/3: assume the same |matrix element|**2/s (after averaging over initial 
c     spins and isospins) for d+Baryon elastic at the same sqrt(s);
         sdbel=fdbel(s)
      elseif(idxsec.eq.2.or.idxsec.eq.4) then
c     2/4: assume the same |matrix element|**2/s (after averaging over initial 
c     spins and isospins) for d+Baryon elastic at the same sqrt(s)-threshold:
         threshold=em1+em2
         snew=(srt-threshold+srt0)**2
         sdbel=fdbel(snew)
      endif
      sdb=sdbel
      return
      end
clin-9/2008 Deuteron+Baryon elastic collisions
      SUBROUTINE crdbel(PX,PY,PZ,SRT,I1,I2,IBLOCK,
     1     NTAG,sig,NT,ianti)
      PARAMETER (MAXSTR=150001,MAXR=1)
      COMMON /AA/R(3,MAXSTR)
      COMMON /BB/ P(3,MAXSTR)
      COMMON /BG/BETAX,BETAY,BETAZ,GAMMA
      COMMON /CC/ E(MAXSTR)
      COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
      COMMON /AREVT/ IAEVT, IARUN, MISS
      common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1     px1n,py1n,pz1n,dp1n
      common /dpi/em2,lb2
      common /para8/ idpert,npertd,idxsec
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
      SAVE   
*-----------------------------------------------------------------------
      IBLOCK=0
      NTAG=0
      EM1=E(I1)
      EM2=E(I2)
      s=srt**2
      if(sig.le.0) return
      IBLOCK=503
c
      if(iabs(lb1).eq.42) then
         ideut=i1
         lbb=lb2
         idb=i2
      else
         ideut=i2
         lbb=lb1
         idb=i1
      endif
cccc  Elastic collision of perturbatively-produced deuterons:
      if((idpert.eq.1.or.idpert.eq.2).and.dpertp(ideut).ne.1.) then
         if(ianti.eq.0) then
            write(91,*) '  d+',lbb,' (pert d B elastic) @nt=',nt
     1           ,' @prob=',dpertp(ideut),p(1,idb),p(2,idb)
     2           ,p(1,ideut),p(2,ideut)
         else
            write(91,*) '  d+',lbb,' (pert dbar Bbar elastic) @nt=',nt
     1           ,' @prob=',dpertp(ideut),p(1,idb),p(2,idb)
     2           ,p(1,ideut),p(2,ideut)
         endif

clin-9/2012: check argument in sqrt():
         scheck=(s-(em1+em2)**2)*(s-(em1-em2)**2)
         if(scheck.lt.0) then
            write(99,*) 'scheck53: ', scheck
            scheck=0.
         endif
         pfinal=sqrt(scheck)/2./srt
c         pfinal=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt

         CALL dbelangle(pxn,pyn,pzn,pfinal)
         CALL ROTATE(PX,PY,PZ,Pxn,Pyn,Pzn)
         EdCM=SQRT(E(ideut)**2+Pxn**2+Pyn**2+Pzn**2)
         PdBETA=Pxn*BETAX+Pyn*BETAY+Pzn*BETAZ
         TRANSF=GAMMA*(GAMMA*PdBETA/(GAMMA+1.)+EdCM)
         Pt1d=BETAX*TRANSF+Pxn
         Pt2d=BETAY*TRANSF+Pyn
         Pt3d=BETAZ*TRANSF+Pzn
         p(1,ideut)=pt1d
         p(2,ideut)=pt2d
         p(3,ideut)=pt3d
         PX1=P(1,I1)
         PY1=P(2,I1)
         PZ1=P(3,I1)
         ID(I1)=2
         ID(I2)=2
c     Change the position of the perturbative deuteron to that of 
c     the baryon to avoid consecutive collisions between them:
         R(1,ideut)=R(1,idb)
         R(2,ideut)=R(2,idb)
         R(3,ideut)=R(3,idb)
         return
      endif
c
c     Elastic collision of regularly-produced deuterons:
      if(ianti.eq.0) then
         write (91,*) ' d+',lbb,' (regular d B elastic) @evt#',
     1        iaevt,' @nt=',nt,' lb1,2=',lb1,lb2
      else
         write (91,*) ' d+',lbb,' (regular dbar Bbar elastic) @evt#',
     1        iaevt,' @nt=',nt,' lb1,2=',lb1,lb2
      endif
clin-9/2012: check argument in sqrt():
      scheck=(s-(em1+em2)**2)*(s-(em1-em2)**2)
      if(scheck.lt.0) then
         write(99,*) 'scheck54: ', scheck
         scheck=0.
      endif
      pfinal=sqrt(scheck)/2./srt
c      pfinal=sqrt((s-(em1+em2)**2)*(s-(em1-em2)**2))/2./srt

      CALL dbelangle(pxn,pyn,pzn,pfinal)
*     ROTATE THE MOMENTA OF PARTICLES IN THE CMS OF P1+P2
c     (This is not needed for isotropic distributions)
      CALL ROTATE(PX,PY,PZ,Pxn,Pyn,Pzn)
*     LORENTZ-TRANSFORMATION OF THE MOMENTUM OF PARTICLES IN THE FINAL STATE 
*     FROM THE NUCLEUS-NUCLEUS CMS. FRAME INTO LAB FRAME:
*     For the 1st baryon:
      E1CM=SQRT(E(I1)**2+Pxn**2+Pyn**2+Pzn**2)
      P1BETA=Pxn*BETAX+Pyn*BETAY+Pzn*BETAZ
      TRANSF=GAMMA*(GAMMA*P1BETA/(GAMMA+1.)+E1CM)
      Pt1i1=BETAX*TRANSF+Pxn
      Pt2i1=BETAY*TRANSF+Pyn
      Pt3i1=BETAZ*TRANSF+Pzn
c
      p(1,i1)=pt1i1
      p(2,i1)=pt2i1
      p(3,i1)=pt3i1
*     For the 2nd baryon:
      E2CM=SQRT(E(I2)**2+Pxn**2+Pyn**2+Pzn**2)
      P2BETA=-Pxn*BETAX-Pyn*BETAY-Pzn*BETAZ
      TRANSF=GAMMA*(GAMMA*P2BETA/(GAMMA+1.)+E2CM)
      Pt1I2=BETAX*TRANSF-Pxn
      Pt2I2=BETAY*TRANSF-Pyn
      Pt3I2=BETAZ*TRANSF-Pzn
c     
      p(1,i2)=pt1i2
      p(2,i2)=pt2i2
      p(3,i2)=pt3i2
c
      PX1=P(1,I1)
      PY1=P(2,I1)
      PZ1=P(3,I1)
      EM1=E(I1)
      EM2=E(I2)
      ID(I1)=2
      ID(I2)=2
      RETURN
      END
c
c     Part of the cross section function of NN->Deuteron+Pi (in mb):
      function fnndpi(s)
      parameter(srt0=2.012)
      if(s.le.srt0**2) then
         fnndpi=0.
      else
         fnndpi=26.*exp(-(s-4.65)**2/0.1)+4.*exp(-(s-4.65)**2/2.)
     1        +0.28*exp(-(s-6.)**2/10.)
      endif
      return
      end
c
c     Angular distribution of d+baryon elastic collisions in the CMS frame:
      subroutine dbelangle(pxn,pyn,pzn,pfinal)
      PARAMETER (PI=3.1415926)
      COMMON/RNDF77/NSEED
      SAVE   
c     take isotropic distribution for now:
      C1=1.0-2.0*RANART(NSEED)
      T1=2.0*PI*RANART(NSEED)
      S1=SQRT(1.0-C1**2)
      CT1=COS(T1)
      ST1=SIN(T1)
* THE MOMENTUM IN THE CMS IN THE FINAL STATE
      Pzn=pfinal*C1
      Pxn=pfinal*S1*CT1 
      Pyn=pfinal*S1*ST1
      return
      end
c
c     Cross section of Deuteron+Pi elastic (in mb):
      function fdpiel(s)
      parameter(srt0=2.012)
      if(s.le.srt0**2) then
         fdpiel=0.
      else
         fdpiel=63.*exp(-(s-4.67)**2/0.15)+15.*exp(-(s-6.25)**2/0.3)
      endif
      return
      end
c
c     Cross section of Deuteron+N elastic (in mb):
      function fdbel(s)
      parameter(srt0=2.012)
      if(s.le.srt0**2) then
         fdbel=0.
      else
         fdbel=2500.*exp(-(s-7.93)**2/0.003)
     1        +300.*exp(-(s-7.93)**2/0.1)+10.
      endif
      return
      end
c.................... hijing1.383_ampt.f
c     Version 1.383
c     The variables isng in HIJSFT and JL in ATTRAD were not initialized.
c     The version initialize them. (as found by Fernando Marroquim)
c
c
c
c     Version 1.382
c     Nuclear distribution for deuteron is taken as the Hulthen wave
c     function as provided by Brian Cole (Columbia)
clin     used my own implementation of impact parameter 
clin     & proton-neutron distance within a deuteron.
c
c
c     Version 1.381
c
c     The parameters for Wood-Saxon distribution for deuteron are
c     constrained to give the right rms ratius 2.116 fm
c     (R=0.0, D=0.5882)
c
c
c     Version 1.38
c
c     The following common block is added to record the number of elastic
c     (NELT, NELP) and inelastic (NINT, NINP) participants
c
c        COMMON/HJGLBR/NELT,NINT,NELP,NINP
c        SAVE /HJGLBR/
c
c     Version 1.37
c
c     A bug in the quenching subroutine is corrected. When calculating the
c     distance between two wounded nucleons, the displacement of the
c     impact parameter was not inculded. This bug was discovered by
c     Dr. V.Uzhinskii JINR, Dubna, Russia
c
c
C     Version 1.36
c
c     Modification Oct. 8, 1998. In hijing, log(ran(nseed)) occasionally
c     causes overfloat. It is modified to log(max(ran(nseed),1.0e-20)).
c
c
C     Nothing important has been changed here. A few 'garbage' has been
C     cleaned up here, like common block HJJET3 for the sea quark strings
C     which were originally created to implement the DPM scheme which
C     later was abadoned in the final version. The lines which operate
C     on these data are also deleted in the program.
C
C
C     Version 1.35
C     There are some changes in the program: subroutine HARDJET is now
C     consolidated with HIJHRD. HARDJET is used to re-initiate PYTHIA
C     for the triggered hard processes. Now that is done  altogether
C     with other normal hard processes in modified JETINI. In the new
C     version one calls JETINI every time one calls HIJHRD. In the new
C     version the effect of the isospin of the nucleon on hard processes,
C     especially direct photons is correctly considered.
C     For A+A collisions, one has to initilize pythia
C     separately for each type of collisions, pp, pn,np and nn,
C     or hp and hn for hA collisions. In JETINI we use the following
C     catalogue for different types of collisions:
C     h+h: h+h (itype=1)
C     h+A: h+p (itype=1), h+n (itype=2)
C     A+h: p+h (itype=1), n+h (itype=2)
C     A+A: p+p (itype=1), p+n (itype=2), n+p (itype=3), n+n (itype=4)
C*****************************************************************
c
C
C     Version 1.34
C     Last modification on January 5, 1998. Two mistakes are corrected in
C     function G. A Mistake in the subroutine Parton is also corrected.
C     (These are pointed out by Ysushi Nara).
C
C
C       Last modifcation on April 10, 1996. To conduct final
C       state radiation, PYTHIA reorganize the two scattered
C       partons and their final momenta will be a little
C       different. The summed total momenta of the partons
C       from the final state radiation are stored in HINT1(26-29)
C       and HINT1(36-39) which are little different from 
C       HINT1(21-24) and HINT1(41-44).
C
C       Version 1.33
C
C       Last modfication  on September 11, 1995. When HIJING and
C       PYTHIA are initialized, the shadowing is evaluated at
C       b=0 which is the maximum. This will cause overestimate
C       of shadowing for peripheral interactions. To correct this
C       problem, shadowing is set to zero when initializing. Then
C       use these maximum  cross section without shadowing as a
C       normalization of the Monte Carlo. This however increase
C       the computing time. IHNT2(16) is used to indicate whether
C       the sturcture function is called for (IHNT2(16)=1) initialization
C       or for (IHNT2(16)=0)normal collisions simulation
C
C       Last modification on Aagust 28, 1994. Two bugs associate
C       with the impact parameter dependence of the shadowing is
C       corrected.
C
C
c       Last modification on October 14, 1994. One bug is corrected
c       in the direct photon production option in subroutine
C       HIJHRD.( this problem was reported by Jim Carroll and Mike Beddo).
C       Another bug associated with keeping the decay history
C       in the particle information is also corrected.(this problem
C       was reported by Matt Bloomer)
C
C
C       Last modification on July 15, 1994. The option to trig on
C       heavy quark production (charm IHPR2(18)=0 or beauty IHPR2(18)=1) 
C       is added. To do this, set IHPR2(3)=3. For inclusive production,
C       one should reset HIPR1(10)=0.0. One can also trig larger pt
C       QQbar production by giving HIPR1(10) a nonvanishing value.
C       The mass of the heavy quark in the calculation of the cross
C       section (HINT1(59)--HINT1(65)) is given by HIPR1(7) (the
C       default is the charm mass D=1.5). We also include a separate
C       K-factor for heavy quark and direct photon production by
C       HIPR1(23)(D=2.0).
C
C       Last modification on May 24, 1994.  The option to
C       retain the information of all particles including those
C       who have decayed is IHPR(21)=1 (default=0). KATT(I,3) is 
C       added to contain the line number of the parent particle 
C       of the current line which is produced via a decay. 
C       KATT(I,4) is the status number of the particle: 11=particle
C       which has decayed; 1=finally produced particle.
C
C
C       Last modification on May 24, 1994( in HIJSFT when valence quark
C       is quenched, the following error is corrected. 1.2*IHNT2(1) --> 
C       1.2*IHNT2(1)**0.333333, 1.2*IHNT2(3) -->1.2*IHNT(3)**0.333333)
C
C
C       Last modification on March 16, 1994 (heavy flavor production
C       processes MSUB(81)=1 MSUB(82)=1 have been switched on,
C       charm production is the default, B-quark option is
C       IHPR2(18), when it is switched on, charm quark is 
C       automatically off)
C
C
C       Last modification on March 23, 1994 (an error is corrected
C       in the impact parameter dependence of the jet cross section)
C
C       Last modification Oct. 1993 to comply with non-vax
C       machines' compiler 
C
C*********************************************
C	LAST MODIFICATION April 5, 1991
CQUARK DISTRIBUTIOIN (1-X)**A/(X**2+C**2/S)**B 
C(A=HIPR1(44),B=HIPR1(46),C=HIPR1(45))
C STRING FLIP, VENUS OPTION IHPR2(15)=1,IN WHICH ONE CAN HAVE ONE AND
C TWO COLOR CHANGES, (1-W)**2,W*(1-W),W*(1-W),AND W*2, W=HIPR1(18), 
C AMONG PT DISTRIBUTION OF SEA QUARKS IS CONTROLLED BY HIPR1(42)
C
C	gluon jets can form a single string system
C
C	initial state radiation is included
C	
C	all QCD subprocesses are included
c
c	direct particles production is included(currently only direct
C		photon)
c
C	Effect of high P_T trigger bias on multiple jets distribution
c
C******************************************************************
C	                        HIJING.10                         *
C	          Heavy Ion Jet INteraction Generator        	  *
C	                           by                       	  *
C		   X. N. Wang      and   M. Gyulassy           	  *
C	 	      Lawrence Berkeley Laboratory		  *
C								  *
C******************************************************************
C
C******************************************************************
C NFP(K,1),NFP(K,2)=flavor of q and di-q, NFP(K,3)=present ID of  *
C proj, NFP(K,4) original ID of proj.  NFP(K,5)=colli status(0=no,*
C 1=elastic,2=the diffrac one in single-diffrac,3= excited string.*
C |NFP(K,6)| is the total # of jet production, if NFP(K,6)<0 it   *
C can not produce jet anymore. NFP(K,10)=valence quarks scattering*
C (0=has not been,1=is going to be, -1=has already been scattered *
C NFP(k,11) total number of interactions this proj has suffered   *
C PP(K,1)=PX,PP(K,2)=PY,PP(K,3)=PZ,PP(K,4)=E,PP(K,5)=M(invariant  *
C mass), PP(K,6,7),PP(K,8,9)=transverse momentum of quark and     *
C diquark,PP(K,10)=PT of the hard scattering between the valence  *
C quarks; PP(K,14,15)=the mass of quark,diquark.       		  * 
C******************************************************************
C
C****************************************************************
C
C	SUBROUTINE HIJING
C
C****************************************************************
        SUBROUTINE HIJING(FRAME,BMIN0,BMAX0)

cbz1/25/99
        PARAMETER (MAXPTN=400001)
clin-4/20/01        PARAMETER (MAXSTR = 1600)
        PARAMETER (MAXSTR=150001)
cbz1/25/99end
clin-4/26/01:
        PARAMETER (MAXIDL=4001)

cbz1/31/99
        DOUBLE PRECISION  GX0, GY0, GZ0, FT0, PX0, PY0, PZ0, E0, XMASS0
        DOUBLE PRECISION  GX5, GY5, GZ5, FT5, PX5, PY5, PZ5, E5, XMASS5
        DOUBLE PRECISION  ATAUI, ZT1, ZT2, ZT3
        DOUBLE PRECISION  xnprod,etprod,xnfrz,etfrz,
     & dnprod,detpro,dnfrz,detfrz
clin-8/2015:
        DOUBLE PRECISION vxp0,vyp0,vzp0,xstrg0,ystrg0,xstrg,ystrg

cbz1/31/99end

        CHARACTER FRAME*8
        DIMENSION SCIP(300,300),RNIP(300,300),SJIP(300,300),JTP(3),
     &                        IPCOL(90000),ITCOL(90000)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
C
        COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
clin-7/16/03 NINT is a intrinsic fortran function, rename it to NINTHJ
c        COMMON/HJGLBR/NELT,NINT,NELP,NINP
        COMMON/HJGLBR/NELT,NINTHJ,NELP,NINP
cc      SAVE /HJGLBR/
        COMMON/HMAIN1/EATT,JATT,NATT,NT,NP,N0,N01,N10,N11
cc      SAVE /HMAIN1/
clin-4/26/01
c        COMMON/HMAIN2/KATT(130000,4),PATT(130000,4)
        COMMON/HMAIN2/KATT(MAXSTR,4),PATT(MAXSTR,4)
cc      SAVE /HMAIN2/
        COMMON/HSTRNG/NFP(300,15),PP(300,15),NFT(300,15),PT(300,15)
cc      SAVE /HSTRNG/
        COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &                PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &                PJPM(300,500),NTJ(300),KFTJ(300,500),
     &                PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &                PJTE(300,500),PJTM(300,500)
cc      SAVE /HJJET1/
clin-4/2008
c        COMMON/HJJET2/NSG,NJSG(900),IASG(900,3),K1SG(900,100),
c     &       K2SG(900,100),PXSG(900,100),PYSG(900,100),
c     &       PZSG(900,100),PESG(900,100),PMSG(900,100)
        COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &       K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &       PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
        COMMON/HJJET4/NDR,IADR(MAXSTR,2),KFDR(MAXSTR),PDR(MAXSTR,5)
clin-4/2008:
c        common/xydr/rtdr(900,2)
        common/xydr/rtdr(MAXSTR,2)
cc      SAVE /HJJET4/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
C
        COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)   
cc      SAVE /LUJETS/
        COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
cc      SAVE /LUDAT1/

clin-9/29/03 changed name in order to distinguish from /prec2/
        COMMON /ARPRC/ ITYPAR(MAXSTR),
     &       GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
     &       PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
     &       XMAR(MAXSTR)
ccbz11/11/98
c        COMMON /ARPRC/ ITYP(MAXSTR),
c     &     GX(MAXSTR), GY(MAXSTR), GZ(MAXSTR), FT(MAXSTR),
c     &     PX(MAXSTR), PY(MAXSTR), PZ(MAXSTR), EE(MAXSTR),
c     &     XM(MAXSTR)
cc      SAVE /ARPRC/
ccbz11/11/98end

cbz1/25/99
        COMMON /PARA1/ MUL
cc      SAVE /PARA1/
        COMMON /prec1/GX0(MAXPTN),GY0(MAXPTN),GZ0(MAXPTN),FT0(MAXPTN),
     &     PX0(MAXPTN), PY0(MAXPTN), PZ0(MAXPTN), E0(MAXPTN),
     &     XMASS0(MAXPTN), ITYP0(MAXPTN)
cc      SAVE /prec1/
        COMMON /prec2/GX5(MAXPTN),GY5(MAXPTN),GZ5(MAXPTN),FT5(MAXPTN),
     &       PX5(MAXPTN), PY5(MAXPTN), PZ5(MAXPTN), E5(MAXPTN),
     &       XMASS5(MAXPTN), ITYP5(MAXPTN)
cc      SAVE /prec2/
        COMMON /ilist7/ LSTRG0(MAXPTN), LPART0(MAXPTN)
cc      SAVE /ilist7/
        COMMON /ilist8/ LSTRG1(MAXPTN), LPART1(MAXPTN)
cc      SAVE /ilist8/
        COMMON /SREC1/ NSP, NST, NSI
cc      SAVE /SREC1/
        COMMON /SREC2/ATAUI(MAXSTR),ZT1(MAXSTR),ZT2(MAXSTR),ZT3(MAXSTR)
cc      SAVE /SREC2/
cbz1/25/99end

clin-2/25/00
        COMMON /frzout/ xnprod(30),etprod(30),xnfrz(30),etfrz(30),
     & dnprod(30),detpro(30),dnfrz(30),detfrz(30)
cc      SAVE /frzout/ 
clin-4/11/01 soft:
      common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
clin-4/25/01 soft3:
      DOUBLE PRECISION PXSGS,PYSGS,PZSGS,PESGS,PMSGS,
     1     GXSGS,GYSGS,GZSGS,FTSGS
      COMMON/SOFT/PXSGS(MAXSTR,3),PYSGS(MAXSTR,3),PZSGS(MAXSTR,3),
     &     PESGS(MAXSTR,3),PMSGS(MAXSTR,3),GXSGS(MAXSTR,3),
     &     GYSGS(MAXSTR,3),GZSGS(MAXSTR,3),FTSGS(MAXSTR,3),
     &     K1SGS(MAXSTR,3),K2SGS(MAXSTR,3),NJSGS(MAXSTR)
cc      SAVE /SOFT/
clin-4/26/01 lepton and photon info:
        COMMON /NOPREC/ NNOZPC, ITYPN(MAXIDL),
     &       GXN(MAXIDL), GYN(MAXIDL), GZN(MAXIDL), FTN(MAXIDL),
     &       PXN(MAXIDL), PYN(MAXIDL), PZN(MAXIDL), EEN(MAXIDL),
     &       XMN(MAXIDL)
cc      SAVE /NOPREC/
clin-6/22/01:
        common /lastt/itimeh,bimp
cc      SAVE /lastt/
        COMMON /AREVT/ IAEVT, IARUN, MISS
        common/phidcy/iphidcy,pttrig,ntrig,maxmiss,ipi0dcy
clin-7/2011 ioscar value is needed:
        common /para7/ ioscar,nsmbbbar,nsmmeson
clin-2/2012 allow random orientation of reaction plane:
        common /phiHJ/iphirp,phiRP
clin-8/2015:
        common /precpa/vxp0(MAXPTN),vyp0(MAXPTN),vzp0(MAXPTN),
     1       xstrg0(MAXPTN),ystrg0(MAXPTN),
     2       xstrg(MAXPTN),ystrg(MAXPTN),istrg0(MAXPTN),istrg(MAXPTN)
        SAVE   

        BMAX=MIN(BMAX0,HIPR1(34)+HIPR1(35))
        BMIN=MIN(BMIN0,BMAX)
        IF(IHNT2(1).LE.1 .AND. IHNT2(3).LE.1) THEN
                BMIN=0.0
                BMAX=2.5*SQRT(HIPR1(31)*0.1/HIPR1(40))
        ENDIF
C                        ********HIPR1(31) is in mb =0.1fm**2
C*******THE FOLLOWING IS TO SELECT THE COORDINATIONS OF NUCLEONS 
C       BOTH IN PROJECTILE AND TARGET NUCLEAR( in fm)
C
        YP(1,1)=0.0
        YP(2,1)=0.0
        YP(3,1)=0.0
        IF(IHNT2(1).LE.1) GO TO 14
        DO 10 KP=1,IHNT2(1)
5        R=HIRND(1)
        X=RANART(NSEED)
        CX=2.0*X-1.0
        SX=SQRT(1.0-CX*CX)
C                ********choose theta from uniform cos(theta) distr
        PHI=RANART(NSEED)*2.0*HIPR1(40)
C                ********choose phi form uniform phi distr 0 to 2*pi
        YP(1,KP)=R*SX*COS(PHI)
        YP(2,KP)=R*SX*SIN(PHI)
        YP(3,KP)=R*CX
        IF(HIPR1(29).EQ.0.0) GO TO 10
        DO 8  KP2=1,KP-1
                DNBP1=(YP(1,KP)-YP(1,KP2))**2
                DNBP2=(YP(2,KP)-YP(2,KP2))**2
                DNBP3=(YP(3,KP)-YP(3,KP2))**2
                DNBP=DNBP1+DNBP2+DNBP3
                IF(DNBP.LT.HIPR1(29)*HIPR1(29)) GO TO 5
C                        ********two neighbors cannot be closer than 
C                                HIPR1(29)
8        CONTINUE
10        CONTINUE

clin-1/27/03 Hulthen wavefn for deuteron borrowed from hijing1.382.f, 
c     but modified [divide by 2, & x(p)=-x(n)]: 
c     (Note: hijing1.383.f has corrected this bug in hijing1.382.f)
        if(IHNT2(1).EQ.2) then
           rnd1=max(RANART(NSEED),1.0e-20)
           rnd2=max(RANART(NSEED),1.0e-20)
           rnd3=max(RANART(NSEED),1.0e-20)
           R=-(log(rnd1)*4.38/2.0+log(rnd2)*0.85/2.0
     &          +4.38*0.85*log(rnd3)/(4.38+0.85))
           X=RANART(NSEED)
           CX=2.0*X-1.0
           SX=SQRT(1.0-CX*CX)
           PHI=RANART(NSEED)*2.0*HIPR1(40)
c     R above is the relative distance between p & n in a deuteron:
           R=R/2.
           YP(1,1)=R*SX*COS(PHI)
           YP(2,1)=R*SX*SIN(PHI)
           YP(3,1)=R*CX
c     p & n has opposite coordinates in the deuteron frame:
           YP(1,2)=-YP(1,1)
           YP(2,2)=-YP(2,1)
           YP(3,2)=-YP(3,1)
        endif

        DO 12 I=1,IHNT2(1)-1
        DO 12 J=I+1,IHNT2(1)
        IF(YP(3,I).GT.YP(3,J)) GO TO 12
        Y1=YP(1,I)
        Y2=YP(2,I)
        Y3=YP(3,I)
        YP(1,I)=YP(1,J)
        YP(2,I)=YP(2,J)
        YP(3,I)=YP(3,J)
        YP(1,J)=Y1
        YP(2,J)=Y2
        YP(3,J)=Y3
12        CONTINUE
C
C******************************
14        YT(1,1)=0.0
        YT(2,1)=0.0
        YT(3,1)=0.0
        IF(IHNT2(3).LE.1) GO TO 24
        DO 20 KT=1,IHNT2(3)
15        R=HIRND(2)
        X=RANART(NSEED)
        CX=2.0*X-1.0
        SX=SQRT(1.0-CX*CX)
C                ********choose theta from uniform cos(theta) distr
        PHI=RANART(NSEED)*2.0*HIPR1(40)
C                ********chose phi form uniform phi distr 0 to 2*pi
        YT(1,KT)=R*SX*COS(PHI)
        YT(2,KT)=R*SX*SIN(PHI)
        YT(3,KT)=R*CX
        IF(HIPR1(29).EQ.0.0) GO TO 20
        DO 18  KT2=1,KT-1
                DNBT1=(YT(1,KT)-YT(1,KT2))**2
                DNBT2=(YT(2,KT)-YT(2,KT2))**2
                DNBT3=(YT(3,KT)-YT(3,KT2))**2
                DNBT=DNBT1+DNBT2+DNBT3
                IF(DNBT.LT.HIPR1(29)*HIPR1(29)) GO TO 15
C                        ********two neighbors cannot be closer than 
C                                HIPR1(29)
18        CONTINUE
20        CONTINUE
c
clin-1/27/03 Hulthen wavefn for deuteron borrowed from hijing1.382.f, 
c     but modified [divide by 2, & x(p)=-x(n)]:
        if(IHNT2(3).EQ.2) then
           rnd1=max(RANART(NSEED),1.0e-20)
           rnd2=max(RANART(NSEED),1.0e-20)
           rnd3=max(RANART(NSEED),1.0e-20)
           R=-(log(rnd1)*4.38/2.0+log(rnd2)*0.85/2.0
     &          +4.38*0.85*log(rnd3)/(4.38+0.85))
           X=RANART(NSEED)
           CX=2.0*X-1.0
           SX=SQRT(1.0-CX*CX)
           PHI=RANART(NSEED)*2.0*HIPR1(40)
           R=R/2.
           YT(1,1)=R*SX*COS(PHI)
           YT(2,1)=R*SX*SIN(PHI)
           YT(3,1)=R*CX
           YT(1,2)=-YT(1,1)
           YT(2,2)=-YT(2,1)
           YT(3,2)=-YT(3,1)
        endif
c
        DO 22 I=1,IHNT2(3)-1
        DO 22 J=I+1,IHNT2(3)
        IF(YT(3,I).LT.YT(3,J)) GO TO 22
        Y1=YT(1,I)
        Y2=YT(2,I)
        Y3=YT(3,I)
        YT(1,I)=YT(1,J)
        YT(2,I)=YT(2,J)
        YT(3,I)=YT(3,J)
        YT(1,J)=Y1
        YT(2,J)=Y2
        YT(3,J)=Y3
22        CONTINUE

C********************
24        MISS=-1
50        MISS=MISS+1

clin-6/2009
c        IF(MISS.GT.50) THEN
        IF(MISS.GT.maxmiss) THEN
           WRITE(6,*) 'infinite loop happened in  HIJING'
           STOP
        ENDIF

clin-4/30/01:
        itest=0

        NATT=0
        JATT=0
        EATT=0.0
        CALL HIJINI
        NLOP=0
C                        ********Initialize for a new event
60        NT=0
        NP=0
        N0=0
        N01=0
        N10=0
        N11=0
        NELT=0
        NINTHJ=0
        NELP=0
        NINP=0
        NSG=0
        NCOLT=0

C****        BB IS THE ABSOLUTE VALUE OF IMPACT PARAMETER,BB**2 IS 
C       RANDOMLY GENERATED AND ITS ORIENTATION IS RANDOMLY SET 
C       BY THE ANGLE PHI  FOR EACH COLLISION.******************
C
        BB=SQRT(BMIN**2+RANART(NSEED)*(BMAX**2-BMIN**2))
cbz6/28/99 flow1
clin-2/2012:
        PHI=0.
        if(iphirp.eq.1) PHI=2.0*HIPR1(40)*RANART(NSEED)
        phiRP=phi
cbz6/28/99 flow1 end
        BBX=BB*COS(PHI)
        BBY=BB*SIN(PHI)
        HINT1(19)=BB
        HINT1(20)=PHI
C
        DO 70 JP=1,IHNT2(1)
        DO 70 JT=1,IHNT2(3)
           SCIP(JP,JT)=-1.0
           B2=(YP(1,JP)+BBX-YT(1,JT))**2+(YP(2,JP)+BBY-YT(2,JT))**2
           R2=B2*HIPR1(40)/HIPR1(31)/0.1
C                ********mb=0.1*fm, YP is in fm,HIPR1(31) is in mb
           RRB1=MIN((YP(1,JP)**2+YP(2,JP)**2)
     &          /1.2**2/REAL(IHNT2(1))**0.6666667,1.0)
           RRB2=MIN((YT(1,JT)**2+YT(2,JT)**2)
     &          /1.2**2/REAL(IHNT2(3))**0.6666667,1.0)
           APHX1=HIPR1(6)*4.0/3.0*(IHNT2(1)**0.3333333-1.0)
     &           *SQRT(1.0-RRB1)
           APHX2=HIPR1(6)*4.0/3.0*(IHNT2(3)**0.3333333-1.0)
     &           *SQRT(1.0-RRB2)
           HINT1(18)=HINT1(14)-APHX1*HINT1(15)
     &                        -APHX2*HINT1(16)+APHX1*APHX2*HINT1(17)
           IF(IHPR2(14).EQ.0.OR.
     &          (IHNT2(1).EQ.1.AND.IHNT2(3).EQ.1)) THEN
              GS=1.0-EXP(-(HIPR1(30)+HINT1(18))*ROMG(R2)/HIPR1(31))
              RANTOT=RANART(NSEED)
              IF(RANTOT.GT.GS) GO TO 70
              GO TO 65
           ENDIF
           GSTOT0=2.0*(1.0-EXP(-(HIPR1(30)+HINT1(18))
     &             /HIPR1(31)/2.0*ROMG(0.0)))
           R2=R2/GSTOT0
           GS=1.0-EXP(-(HIPR1(30)+HINT1(18))/HIPR1(31)*ROMG(R2))
           GSTOT=2.0*(1.0-SQRT(1.0-GS))
           RANTOT=RANART(NSEED)*GSTOT0
           IF(RANTOT.GT.GSTOT) GO TO 70
           IF(RANTOT.GT.GS) THEN
              CALL HIJCSC(JP,JT)
              GO TO 70
C                        ********perform elastic collisions
           ENDIF
 65           SCIP(JP,JT)=R2
           RNIP(JP,JT)=RANTOT
           SJIP(JP,JT)=HINT1(18)
           NCOLT=NCOLT+1
           IPCOL(NCOLT)=JP
           ITCOL(NCOLT)=JT
70        CONTINUE
C                ********total number interactions proj and targ has
C                                suffered

clin-5/22/01 write impact parameter:
        bimp=bb
        write(6,*) '#impact parameter,nlop,ncolt=',bimp,nlop,ncolt

        IF(NCOLT.EQ.0) THEN
           NLOP=NLOP+1
           IF(NLOP.LE.20.OR.
     &           (IHNT2(1).EQ.1.AND.IHNT2(3).EQ.1)) GO TO 60
           RETURN
        ENDIF
C               ********At large impact parameter, there maybe no
C                       interaction at all. For NN collision
C                       repeat the event until interaction happens
C
        IF(IHPR2(3).NE.0) THEN
           NHARD=1+INT(RANART(NSEED)*(NCOLT-1)+0.5)
           NHARD=MIN(NHARD,NCOLT)
           JPHARD=IPCOL(NHARD)
           JTHARD=ITCOL(NHARD)
clin-6/2009 ctest off:
c           write(99,*) IAEVT,NHARD,NCOLT,JPHARD,JTHARD
        ENDIF
C
        IF(IHPR2(9).EQ.1) THEN
                NMINI=1+INT(RANART(NSEED)*(NCOLT-1)+0.5)
                NMINI=MIN(NMINI,NCOLT)
                JPMINI=IPCOL(NMINI)
                JTMINI=ITCOL(NMINI)
        ENDIF
C                ********Specifying the location of the hard and
C                        minijet if they are enforced by user
C
        DO 200 JP=1,IHNT2(1)
        DO 200 JT=1,IHNT2(3)
        IF(SCIP(JP,JT).EQ.-1.0) GO TO 200
                NFP(JP,11)=NFP(JP,11)+1
                NFT(JT,11)=NFT(JT,11)+1
        IF(NFP(JP,5).LE.1 .AND. NFT(JT,5).GT.1) THEN
                NP=NP+1
                N01=N01+1
        ELSE IF(NFP(JP,5).GT.1 .AND. NFT(JT,5).LE.1) THEN
                NT=NT+1
                N10=N10+1
        ELSE IF(NFP(JP,5).LE.1 .AND. NFT(JT,5).LE.1) THEN
                NP=NP+1
                NT=NT+1
                N0=N0+1
        ELSE IF(NFP(JP,5).GT.1 .AND. NFT(JT,5).GT.1) THEN
                N11=N11+1
        ENDIF
        JOUT=0
        NFP(JP,10)=0
        NFT(JT,10)=0
C*****************************************************************
        IF(IHPR2(8).EQ.0 .AND. IHPR2(3).EQ.0) GO TO 160
C                ********When IHPR2(8)=0 no jets are produced
        IF(NFP(JP,6).LT.0 .OR. NFT(JT,6).LT.0) GO TO 160
C                ********jets can not be produced for (JP,JT)
C                        because not enough energy avaible for 
C                                JP or JT 
        R2=SCIP(JP,JT)
        HINT1(18)=SJIP(JP,JT)
        TT=ROMG(R2)*HINT1(18)/HIPR1(31)
        TTS=HIPR1(30)*ROMG(R2)/HIPR1(31)
        NJET=0

        IF(IHPR2(3).NE.0 .AND. JP.EQ.JPHARD .AND. JT.EQ.JTHARD) THEN
           CALL JETINI(JP,JT,1)
           CALL HIJHRD(JP,JT,0,JFLG,0)
           HINT1(26)=HINT1(47)
           HINT1(27)=HINT1(48)
           HINT1(28)=HINT1(49)
           HINT1(29)=HINT1(50)
           HINT1(36)=HINT1(67)
           HINT1(37)=HINT1(68)
           HINT1(38)=HINT1(69)
           HINT1(39)=HINT1(70)
C
           IF(ABS(HINT1(46)).GT.HIPR1(11).AND.JFLG.EQ.2) NFP(JP,7)=1
           IF(ABS(HINT1(56)).GT.HIPR1(11).AND.JFLG.EQ.2) NFT(JT,7)=1
           IF(MAX(ABS(HINT1(46)),ABS(HINT1(56))).GT.HIPR1(11).AND.
     &                                JFLG.GE.3) IASG(NSG,3)=1
           IHNT2(9)=IHNT2(14)
           IHNT2(10)=IHNT2(15)
           DO 105 I05=1,5
              HINT1(20+I05)=HINT1(40+I05)
              HINT1(30+I05)=HINT1(50+I05)
 105           CONTINUE
clin-6/2009 ctest off:
c           write(99,*) jp,jt,IHPR2(3),HIPR1(10),njet,
c     1          ihnt2(9),hint1(21),hint1(22),hint1(23),
c     2          ihnt2(10),hint1(31),hint1(32),hint1(33)
c           write(99,*) ' '
           JOUT=1
           IF(IHPR2(8).EQ.0) GO TO 160
           RRB1=MIN((YP(1,JP)**2+YP(2,JP)**2)/1.2**2
     &                /REAL(IHNT2(1))**0.6666667,1.0)
           RRB2=MIN((YT(1,JT)**2+YT(2,JT)**2)/1.2**2
     &                /REAL(IHNT2(3))**0.6666667,1.0)
           APHX1=HIPR1(6)*4.0/3.0*(IHNT2(1)**0.3333333-1.0)
     &           *SQRT(1.0-RRB1)
           APHX2=HIPR1(6)*4.0/3.0*(IHNT2(3)**0.3333333-1.0)
     &           *SQRT(1.0-RRB2)
           HINT1(65)=HINT1(61)-APHX1*HINT1(62)
     &                        -APHX2*HINT1(63)+APHX1*APHX2*HINT1(64)
           TTRIG=ROMG(R2)*HINT1(65)/HIPR1(31)
           NJET=-1
C                ********subtract the trigger jet from total number
C                        of jet production  to be done since it has
C                                already been produced here
           XR1=-ALOG(EXP(-TTRIG)+RANART(NSEED)*(1.0-EXP(-TTRIG)))
 106           NJET=NJET+1
           XR1=XR1-ALOG(max(RANART(NSEED),1.0e-20))
           IF(XR1.LT.TTRIG) GO TO 106
           XR=0.0
 107           NJET=NJET+1
           XR=XR-ALOG(max(RANART(NSEED),1.0e-20))
           IF(XR.LT.TT-TTRIG) GO TO 107
           NJET=NJET-1
           GO TO 112
        ENDIF
C                ********create a hard interaction with specified P_T
c                                 when IHPR2(3)>0
        IF(IHPR2(9).EQ.1.AND.JP.EQ.JPMINI.AND.JT.EQ.JTMINI) GO TO 110
C                ********create at least one pair of mini jets 
C                        when IHPR2(9)=1
C
clin-4/15/2010 changed .LT. to .LE. to avoid problem when two sides are equal; 
c     this problem may lead to a jet production when there should be none and 
c     crash the run; crashes at low energies were reported by P. Bhaduri.
c        IF(IHPR2(8).GT.0 .AND.RNIP(JP,JT).LT.EXP(-TT)*
c     &                (1.0-EXP(-TTS))) GO TO 160
        IF(IHPR2(8).GT.0 .AND.RNIP(JP,JT).LE.EXP(-TT)*
     &                 (1.0-EXP(-TTS))) GO TO 160
c
C                ********this is the probability for no jet production
110        XR=-ALOG(EXP(-TT)+RANART(NSEED)*(1.0-EXP(-TT)))
111        NJET=NJET+1
        XR=XR-ALOG(max(RANART(NSEED),1.0e-20))
        IF(XR.LT.TT) GO TO 111
112        NJET=MIN(NJET,IHPR2(8))
        IF(IHPR2(8).LT.0)  NJET=ABS(IHPR2(8))
C                ******** Determine number of mini jet production
C
        DO 150 ijet=1,NJET
           CALL JETINI(JP,JT,0)
           CALL HIJHRD(JP,JT,JOUT,JFLG,1)
C                ********JFLG=1 jets valence quarks, JFLG=2 with 
C                        gluon jet, JFLG=3 with q-qbar prod for
C                        (JP,JT). If JFLG=0 jets can not be produced 
C                        this time. If JFLG=-1, error occured abandon
C                        this event. JOUT is the total hard scat for
C                        (JP,JT) up to now.
           IF(JFLG.EQ.0) GO TO 160
           IF(JFLG.LT.0) THEN
              IF(IHPR2(10).NE.0) WRITE(6,*) 'error occured in HIJHRD'
              GO TO 50
           ENDIF
           JOUT=JOUT+1
           IF(ABS(HINT1(46)).GT.HIPR1(11).AND.JFLG.EQ.2) NFP(JP,7)=1
           IF(ABS(HINT1(56)).GT.HIPR1(11).AND.JFLG.EQ.2) NFT(JT,7)=1
           IF(MAX(ABS(HINT1(46)),ABS(HINT1(56))).GT.HIPR1(11).AND.
     &                        JFLG.GE.3) IASG(NSG,3)=1
C                ******** jet with PT>HIPR1(11) will be quenched
 150        CONTINUE
 160        CONTINUE

        CALL HIJSFT(JP,JT,JOUT,IERROR)
        IF(IERROR.NE.0) THEN
           IF(IHPR2(10).NE.0) WRITE(6,*) 'error occured in HIJSFT'
           GO TO 50
        ENDIF
C
C                ********conduct soft scattering between JP and JT
        JATT=JATT+JOUT
200        CONTINUE
c
c**************************
c
clin-6/2009 write out initial minijet information:
clin-2/2012:
c           call minijet_out(BB)
           call minijet_out(BB,phiRP)
           if(pttrig.gt.0.and.ntrig.eq.0) goto 50
clin-4/2012 
clin-6/2009 write out initial transverse positions of initial nucleons:
c           write(94,*) IAEVT,MISS,IHNT2(1),IHNT2(3)
        DO 201 JP=1,IHNT2(1)
clin-6/2009:
c           write(94,203) YP(1,JP)+0.5*BB, YP(2,JP), JP, NFP(JP,5)
clin-2/2012:
c       write(94,203) YP(1,JP)+0.5*BB, YP(2,JP), JP, NFP(JP,5),yp(3,jp)
clin-4/2012:
c           write(94,203) YP(1,JP)+0.5*BB*cos(phiRP), 
c     1 YP(2,JP)+0.5*BB*sin(phiRP), JP, NFP(JP,5),yp(3,jp)
           IF(NFP(JP,5).GT.2) THEN
              NINP=NINP+1
           ELSE IF(NFP(JP,5).EQ.2.OR.NFP(JP,5).EQ.1) THEN
              NELP=NELP+1
           ENDIF
 201    continue
        DO 202 JT=1,IHNT2(3)
clin-6/2009 target nucleon # has a minus sign for distinction from projectile:
c           write(94,203) YT(1,JT)-0.5*BB, YT(2,JT), -JT, NFT(JT,5)
clin-2/2012:
c       write(94,203) YT(1,JT)-0.5*BB, YT(2,JT), -JT, NFT(JT,5),yt(3,jt)
clin-4/2012:
c           write(94,203) YT(1,JT)-0.5*BB*cos(phiRP), 
c     1 YT(2,JT)-0.5*BB*sin(phiRP), -JT, NFT(JT,5),yt(3,jt)
           IF(NFT(JT,5).GT.2) THEN
              NINTHJ=NINTHJ+1
           ELSE IF(NFT(JT,5).EQ.2.OR.NFT(JT,5).EQ.1) THEN
              NELT=NELT+1
           ENDIF
 202    continue
c 203    format(f10.3,1x,f10.3,2(1x,I5))
c 203    format(f10.3,1x,f10.3,2(1x,I5),1x,f10.3)
c     
c*******************************


C********perform jet quenching for jets with PT>HIPR1(11)**********

        IF((IHPR2(8).NE.0.OR.IHPR2(3).NE.0).AND.IHPR2(4).GT.0.AND.
     &                        IHNT2(1).GT.1.AND.IHNT2(3).GT.1) THEN
                DO 271 I=1,IHNT2(1)
                        IF(NFP(I,7).EQ.1) CALL QUENCH(I,1)
271                CONTINUE
                DO 272 I=1,IHNT2(3)
                        IF(NFT(I,7).EQ.1) CALL QUENCH(I,2)
272                CONTINUE
                DO 273 ISG=1,NSG
                        IF(IASG(ISG,3).EQ.1) CALL QUENCH(ISG,3)
273                CONTINUE
        ENDIF

clin*****4/09/01-soft1, default way of treating strings:
        if(isoft.eq.1) then
clin-4/16/01 allow fragmentation:
           isflag=1

cbz1/25/99
c.....transfer data from HIJING to ZPC
        NSP = IHNT2(1)
        NST = IHNT2(3)
        NSI = NSG
        ISTR = 0
        NPAR = 0
        DO 1008 I = 1, IHNT2(1)
           ISTR = ISTR + 1
           DO 1007 J = 1, NPJ(I)
cbz1/27/99
c.....for now only consider gluon cascade
              IF (KFPJ(I, J) .EQ. 21) THEN
cbz1/27/99end

              NPAR = NPAR + 1
              LSTRG0(NPAR) = ISTR
              LPART0(NPAR) = J
              ITYP0(NPAR) = KFPJ(I, J)
cbz6/28/99 flow1
clin-7/20/01 add dble or sngl to make precisions consistent
c              GX0(NPAR) = YP(1, I)
clin-2/2012:
c              GX0(NPAR) = dble(YP(1, I) + 0.5 * BB)
              GX0(NPAR) = dble(YP(1, I)+0.5*BB*cos(phiRP))
cbz6/28/99 flow1 end
c              GY0(NPAR) = dble(YP(2, I))
              GY0(NPAR) = dble(YP(2, I)+0.5*BB*sin(phiRP))
              GZ0(NPAR) = 0d0
              FT0(NPAR) = 0d0
              PX0(NPAR) = dble(PJPX(I, J))
              PY0(NPAR) = dble(PJPY(I, J))
              PZ0(NPAR) = dble(PJPZ(I, J))
              XMASS0(NPAR) = dble(PJPM(I, J))
c              E0(NPAR) = dble(PJPE(I, J))
              E0(NPAR) = dsqrt(PX0(NPAR)**2+PY0(NPAR)**2
     1             +PZ0(NPAR)**2+XMASS0(NPAR)**2)
clin-7/20/01-end

cbz1/27/99
c.....end gluon selection
              END IF
cbz1/27/99end
 1007      CONTINUE
 1008   CONTINUE
        DO 1010 I = 1, IHNT2(3)
           ISTR = ISTR + 1
           DO 1009 J = 1, NTJ(I)
cbz1/27/99
c.....for now only consider gluon cascade
              IF (KFTJ(I, J) .EQ. 21) THEN
cbz1/27/99end
              NPAR = NPAR + 1
              LSTRG0(NPAR) = ISTR
              LPART0(NPAR) = J
              ITYP0(NPAR) = KFTJ(I, J)
cbz6/28/99 flow1
clin-7/20/01 add dble or sngl to make precisions consistent
c              GX0(NPAR) = YT(1, I)
clin-2/2012:
c              GX0(NPAR) = dble(YT(1, I) - 0.5 * BB)
              GX0(NPAR) = dble(YT(1, I)-0.5*BB*cos(phiRP))
cbz6/28/99 flow1 end
c              GY0(NPAR) = dble(YT(2, I))
              GY0(NPAR) = dble(YT(2, I)-0.5*BB*sin(phiRP))
              GZ0(NPAR) = 0d0
              FT0(NPAR) = 0d0
              PX0(NPAR) = dble(PJTX(I, J))
              PY0(NPAR) = dble(PJTY(I, J))
              PZ0(NPAR) = dble(PJTZ(I, J))
              XMASS0(NPAR) = dble(PJTM(I, J))
c              E0(NPAR) = dble(PJTE(I, J))
              E0(NPAR) = dsqrt(PX0(NPAR)**2+PY0(NPAR)**2
     1             +PZ0(NPAR)**2+XMASS0(NPAR)**2)

cbz1/27/99
c.....end gluon selection
              END IF
cbz1/27/99end
 1009      CONTINUE
 1010   CONTINUE
        DO 1012 I = 1, NSG
           ISTR = ISTR + 1
           DO 1011 J = 1, NJSG(I)
cbz1/27/99
c.....for now only consider gluon cascade
              IF (K2SG(I, J) .EQ. 21) THEN
cbz1/27/99end
              NPAR = NPAR + 1
              LSTRG0(NPAR) = ISTR
              LPART0(NPAR) = J
              ITYP0(NPAR) = K2SG(I, J)
clin-7/20/01 add dble or sngl to make precisions consistent:
              GX0(NPAR) = 0.5d0 * 
     1             dble(YP(1, IASG(I, 1)) + YT(1, IASG(I, 2)))
              GY0(NPAR) = 0.5d0 * 
     2             dble(YP(2, IASG(I, 1)) + YT(2, IASG(I, 2)))
              GZ0(NPAR) = 0d0
              FT0(NPAR) = 0d0
              PX0(NPAR) = dble(PXSG(I, J))
              PY0(NPAR) = dble(PYSG(I, J))
              PZ0(NPAR) = dble(PZSG(I, J))
              XMASS0(NPAR) = dble(PMSG(I, J))
c              E0(NPAR) = dble(PESG(I, J))
              E0(NPAR) = dsqrt(PX0(NPAR)**2+PY0(NPAR)**2
     1             +PZ0(NPAR)**2+XMASS0(NPAR)**2)
cbz1/27/99
c.....end gluon selection
              END IF
cbz1/27/99end
 1011      CONTINUE
 1012   CONTINUE
        MUL = NPAR

cbz2/4/99
        CALL HJANA1
cbz2/4/99end

clin-6/2009:
        if(ioscar.eq.3) WRITE (95, *) IAEVT, mul
c.....call ZPC for parton cascade
        CALL ZPCMN

c     write out parton and wounded nucleon information to ana/zpc1.mom:
clin-6/2009:
c        WRITE (14, 395) ITEST, MUL, bimp, NELP,NINP,NELT,NINTHJ
        WRITE (14, 395) IAEVT, MISS, MUL, bimp, NELP,NINP,NELT,NINTHJ
        DO 1013 I = 1, MUL
cc           WRITE (14, 411) PX5(I), PY5(I), PZ5(I), ITYP5(I),
c     &        XMASS5(I), E5(I)
           if(dmax1(abs(GX5(I)),abs(GY5(I)),abs(GZ5(I)),abs(FT5(I)))
     1          .lt.9999) then
              write(14,210) ITYP5(I), PX5(I), PY5(I), PZ5(I), XMASS5(I),
     1             GX5(I), GY5(I), GZ5(I), FT5(I)
           else
c     change format for large numbers:
              write(14,211) ITYP5(I), PX5(I), PY5(I), PZ5(I), XMASS5(I),
     1             GX5(I), GY5(I), GZ5(I), FT5(I)
           endif

 1013   CONTINUE
 210    format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,f8.2))
 211    format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,e8.2))
 395    format(3I8,f10.4,4I5)

clin-4/09/01:
        itest=itest+1
c 411    FORMAT(1X, 3F10.3, I6, 2F10.3)
cbz3/19/99 end

clin-5/2009 ctest off:
c        call frztm(1,1)

c.....transfer data back from ZPC to HIJING
        DO 1014 I = 1, MUL
           IF (LSTRG1(I) .LE. NSP) THEN
              NSTRG = LSTRG1(I)
              NPART = LPART1(I)
              KFPJ(NSTRG, NPART) = ITYP5(I)
clin-7/20/01 add dble or sngl to make precisions consistent
              PJPX(NSTRG, NPART) = sngl(PX5(I))
              PJPY(NSTRG, NPART) = sngl(PY5(I))
              PJPZ(NSTRG, NPART) = sngl(PZ5(I))
              PJPE(NSTRG, NPART) = sngl(E5(I))
              PJPM(NSTRG, NPART) = sngl(XMASS5(I))
           ELSE IF (LSTRG1(I) .LE. NSP + NST) THEN
              NSTRG = LSTRG1(I) - NSP
              NPART = LPART1(I)
              KFTJ(NSTRG, NPART) = ITYP5(I)
              PJTX(NSTRG, NPART) = sngl(PX5(I))
              PJTY(NSTRG, NPART) = sngl(PY5(I))
              PJTZ(NSTRG, NPART) = sngl(PZ5(I))
              PJTE(NSTRG, NPART) = sngl(E5(I))
              PJTM(NSTRG, NPART) = sngl(XMASS5(I))
           ELSE
              NSTRG = LSTRG1(I) - NSP - NST
              NPART = LPART1(I)
              K2SG(NSTRG, NPART) = ITYP5(I)
              PXSG(NSTRG, NPART) = sngl(PX5(I))
              PYSG(NSTRG, NPART) = sngl(PY5(I))
              PZSG(NSTRG, NPART) = sngl(PZ5(I))
              PESG(NSTRG, NPART) = sngl(E5(I))
              PMSG(NSTRG, NPART) = sngl(XMASS5(I))
           END IF
 1014   CONTINUE
cbz1/25/99end

cbz2/4/99
        CALL HJANA2
cbz2/4/99end

clin*****4/09/01-soft2, put q+dq+X in strings into ZPC:
        elseif(isoft.eq.2) then
        NSP = IHNT2(1)
        NST = IHNT2(3)
clin-4/27/01:
        NSI = NSG
        NPAR=0
        ISTR=0
C
clin  No fragmentation to hadrons, only on parton level, 
c     and transfer minijet and string data from HIJING to ZPC:
        MSTJ(1)=0
clin-4/12/01 forbid soft radiation before ZPC to avoid small-mass strings,
c     and forbid jet order reversal before ZPC to avoid unphysical flavors:
        IHPR2(1)=0
        isflag=0

        IF(IHPR2(20).NE.0) THEN
           DO 320 NTP=1,2
              DO 310 jjtp=1,IHNT2(2*NTP-1)
                 ISTR = ISTR + 1
c change: do gluon kink only once: either here or in fragmentation.
                 CALL HIJFRG(jjtp,NTP,IERROR)
c                 call lulist(1)
                 if(NTP.eq.1) then
c 354                continue
                    NPJ(jjtp)=MAX0(N-2,0)

clin-4/12/01:                    NPJ(jjtp)=MAX0(ipartn-2,0)
                 else
c 355                continue
                    NTJ(jjtp)=MAX0(N-2,0)
clin-4/12/01:                    NTJ(jjtp)=MAX0(ipartn-2,0)
                 endif

                 do 300 ii=1,N
                 NPAR = NPAR + 1
                 LSTRG0(NPAR) = ISTR
                 LPART0(NPAR) = II
                 ITYP0(NPAR) = K(II,2)
                 GZ0(NPAR) = 0d0
                 FT0(NPAR) = 0d0
clin-7/20/01 add dble or sngl to make precisions consistent
                 PX0(NPAR) = dble(P(II,1))
                 PY0(NPAR) = dble(P(II,2))
                 PZ0(NPAR) = dble(P(II,3))
                 XMASS0(NPAR) = dble(P(II,5))
c                 E0(NPAR) = dble(P(II,4))
                 E0(NPAR) = dsqrt(PX0(NPAR)**2+PY0(NPAR)**2
     1                +PZ0(NPAR)**2+XMASS0(NPAR)**2)
                 IF (NTP .EQ. 1) THEN
clin-7/20/01 add dble or sngl to make precisions consistent
clin-2/2012:
c                    GX0(NPAR) = dble(YP(1, jjtp)+0.5 * BB)
c                    GY0(NPAR) = dble(YP(2, jjtp))
                    GX0(NPAR) = dble(YP(1, jjtp)+0.5*BB*cos(phiRP))
                    GY0(NPAR) = dble(YP(2, jjtp)+0.5*BB*sin(phiRP))

                    IITYP=ITYP0(NPAR)
                    nstrg=LSTRG0(NPAR)
                    if(IITYP.eq.2112.or.IITYP.eq.2212) then
                    elseif((IITYP.eq.1.or.IITYP.eq.2).and.
     1 (II.eq.1.or.II.eq.N)) then
                       PP(nstrg,6)=sngl(PX0(NPAR))
                       PP(nstrg,7)=sngl(PY0(NPAR))
                       PP(nstrg,14)=sngl(XMASS0(NPAR))
                    elseif((IITYP.eq.1103.or.IITYP.eq.2101
     1 .or.IITYP.eq.2103.or.IITYP.eq.2203.
     2 .or.IITYP.eq.3101.or.IITYP.eq.3103.
     3 .or.IITYP.eq.3201.or.IITYP.eq.3203.or.IITYP.eq.3303)
     4 .and.(II.eq.1.or.II.eq.N)) then
                       PP(nstrg,8)=sngl(PX0(NPAR))
                       PP(nstrg,9)=sngl(PY0(NPAR))
                       PP(nstrg,15)=sngl(XMASS0(NPAR))
                    else
                       NPART = LPART0(NPAR)-1
                       KFPJ(NSTRG, NPART) = ITYP0(NPAR)
                       PJPX(NSTRG, NPART) = sngl(PX0(NPAR))
                       PJPY(NSTRG, NPART) = sngl(PY0(NPAR))
                       PJPZ(NSTRG, NPART) = sngl(PZ0(NPAR))
                       PJPE(NSTRG, NPART) = sngl(E0(NPAR))
                       PJPM(NSTRG, NPART) = sngl(XMASS0(NPAR))
                    endif
                 ELSE
clin-2/2012:
c                    GX0(NPAR) = dble(YT(1, jjtp)-0.5 * BB)
c                    GY0(NPAR) = dble(YT(2, jjtp)) 
                    GX0(NPAR) = dble(YT(1, jjtp)-0.5*BB*cos(phiRP))
                    GY0(NPAR) = dble(YT(2, jjtp)-0.5*BB*sin(phiRP))
                    IITYP=ITYP0(NPAR)
                    nstrg=LSTRG0(NPAR)-NSP
                    if(IITYP.eq.2112.or.IITYP.eq.2212) then
                    elseif((IITYP.eq.1.or.IITYP.eq.2).and.
     1 (II.eq.1.or.II.eq.N)) then
                       PT(nstrg,6)=sngl(PX0(NPAR))
                       PT(nstrg,7)=sngl(PY0(NPAR))
                       PT(nstrg,14)=sngl(XMASS0(NPAR))
                    elseif((IITYP.eq.1103.or.IITYP.eq.2101
     1 .or.IITYP.eq.2103.or.IITYP.eq.2203.
     2 .or.IITYP.eq.3101.or.IITYP.eq.3103.
     3 .or.IITYP.eq.3201.or.IITYP.eq.3203.or.IITYP.eq.3303)
     4 .and.(II.eq.1.or.II.eq.N)) then
                       PT(nstrg,8)=sngl(PX0(NPAR))
                       PT(nstrg,9)=sngl(PY0(NPAR))
                       PT(nstrg,15)=sngl(XMASS0(NPAR))
                    else
                       NPART = LPART0(NPAR)-1
                       KFTJ(NSTRG, NPART) = ITYP0(NPAR)
                       PJTX(NSTRG, NPART) = sngl(PX0(NPAR))
                       PJTY(NSTRG, NPART) = sngl(PY0(NPAR))
                       PJTZ(NSTRG, NPART) = sngl(PZ0(NPAR))
                       PJTE(NSTRG, NPART) = sngl(E0(NPAR))
                       PJTM(NSTRG, NPART) = sngl(XMASS0(NPAR))
                    endif
                 END IF
 300          continue
 310          continue
 320       continue
           DO 330 ISG=1,NSG
              ISTR = ISTR + 1
              CALL HIJFRG(ISG,3,IERROR)
c              call lulist(2)
c
              NJSG(ISG)=N
c
              do 1001 ii=1,N
                 NPAR = NPAR + 1
                 LSTRG0(NPAR) = ISTR
                 LPART0(NPAR) = II
                 ITYP0(NPAR) = K(II,2)
                 GX0(NPAR)=0.5d0*
     1                dble(YP(1,IASG(ISG,1))+YT(1,IASG(ISG,2)))
                 GY0(NPAR)=0.5d0*
     2                dble(YP(2,IASG(ISG,1))+YT(2,IASG(ISG,2)))
                 GZ0(NPAR) = 0d0
                 FT0(NPAR) = 0d0
                 PX0(NPAR) = dble(P(II,1))
                 PY0(NPAR) = dble(P(II,2))
                 PZ0(NPAR) = dble(P(II,3))
                 XMASS0(NPAR) = dble(P(II,5))
c                 E0(NPAR) = dble(P(II,4))
                 E0(NPAR) = dsqrt(PX0(NPAR)**2+PY0(NPAR)**2
     1                +PZ0(NPAR)**2+XMASS0(NPAR)**2)
 1001         continue
 330       continue
        endif

        MUL = NPAR
cbz2/4/99
        CALL HJANA1
cbz2/4/99end
clin-6/2009:
        if(ioscar.eq.3) WRITE (95, *) IAEVT, mul
c.....call ZPC for parton cascade
        CALL ZPCMN
cbz3/19/99
clin-6/2009:
c        WRITE (14, 395) ITEST, MUL, bimp, NELP,NINP,NELT,NINTHJ
        WRITE (14, 395) IAEVT, MISS, MUL, bimp, NELP,NINP,NELT,NINTHJ
        itest=itest+1

        DO 1015 I = 1, MUL
c           WRITE (14, 311) PX5(I), PY5(I), PZ5(I), ITYP5(I),
c     &        XMASS5(I), E5(I)
clin-4/2012 write parton freeze-out position in zpc.dat for this test scenario:
c           WRITE (14, 312) PX5(I), PY5(I), PZ5(I), ITYP5(I),
c     &        XMASS5(I), E5(I),LSTRG1(I), LPART1(I)
           if(dmax1(abs(GX5(I)),abs(GY5(I)),abs(GZ5(I)),abs(FT5(I)))
     1          .lt.9999) then
              write(14,210) ITYP5(I), PX5(I), PY5(I), PZ5(I), XMASS5(I),
     1             GX5(I), GY5(I), GZ5(I), FT5(I)
           else
              write(14,211) ITYP5(I), PX5(I), PY5(I), PZ5(I), XMASS5(I),
     1             GX5(I), GY5(I), GZ5(I), FT5(I)
           endif
c
 1015   CONTINUE
c 311    FORMAT(1X, 3F10.4, I6, 2F10.4)
c 312    FORMAT(1X, 3F10.3, I6, 2F10.3,1X,I6,1X,I3)
cbz3/19/99 end

clin-5/2009 ctest off:
c        call frztm(1,1)

clin-4/13/01 initialize four momenta and invariant mass of strings after ZPC:
        do 1004 nmom=1,5
           do 1002 nstrg=1,nsp
              PP(nstrg,nmom)=0.
 1002      continue
           do 1003 nstrg=1,nst
              PT(nstrg,nmom)=0.
 1003      continue
 1004   continue
clin-4/13/01-end

        DO 1005 I = 1, MUL
           IITYP=ITYP5(I)
           IF (LSTRG1(I) .LE. NSP) THEN
              NSTRG = LSTRG1(I)
c     nucleons without interactions:
              if(IITYP.eq.2112.or.IITYP.eq.2212) then
clin-7/20/01 add dble or sngl to make precisions consistent
                 PP(nstrg,1)=sngl(PX5(I))
                 PP(nstrg,2)=sngl(PY5(I))
                 PP(nstrg,3)=sngl(PZ5(I))
                 PP(nstrg,4)=sngl(E5(I))
                 PP(nstrg,5)=sngl(XMASS5(I))
c     valence quark:
              elseif((IITYP.eq.1.or.IITYP.eq.2).and.
     1 (LPART1(I).eq.1.or.LPART1(I).eq.(NPJ(NSTRG)+2))) then
                 PP(nstrg,6)=sngl(PX5(I))
                 PP(nstrg,7)=sngl(PY5(I))
                 PP(nstrg,14)=sngl(XMASS5(I))
                 PP(nstrg,1)=PP(nstrg,1)+sngl(PX5(I))
                 PP(nstrg,2)=PP(nstrg,2)+sngl(PY5(I))
                 PP(nstrg,3)=PP(nstrg,3)+sngl(PZ5(I))
                 PP(nstrg,4)=PP(nstrg,4)+sngl(E5(I))
                 PP(nstrg,5)=sqrt(PP(nstrg,4)**2-PP(nstrg,1)**2
     1                -PP(nstrg,2)**2-PP(nstrg,3)**2)
c     diquark:
              elseif((IITYP.eq.1103.or.IITYP.eq.2101
     1 .or.IITYP.eq.2103.or.IITYP.eq.2203.
     2 .or.IITYP.eq.3101.or.IITYP.eq.3103.
     3 .or.IITYP.eq.3201.or.IITYP.eq.3203.or.IITYP.eq.3303)
     4 .and.(LPART1(I).eq.1.or.LPART1(I).eq.(NPJ(NSTRG)+2))) then
                 PP(nstrg,8)=sngl(PX5(I))
                 PP(nstrg,9)=sngl(PY5(I))
                 PP(nstrg,15)=sngl(XMASS5(I))
                 PP(nstrg,1)=PP(nstrg,1)+sngl(PX5(I))
                 PP(nstrg,2)=PP(nstrg,2)+sngl(PY5(I))
                 PP(nstrg,3)=PP(nstrg,3)+sngl(PZ5(I))
                 PP(nstrg,4)=PP(nstrg,4)+sngl(E5(I))
                 PP(nstrg,5)=sqrt(PP(nstrg,4)**2-PP(nstrg,1)**2
     1                -PP(nstrg,2)**2-PP(nstrg,3)**2)
c     partons in projectile or target strings:
              else
                 NPART = LPART1(I)-1
                 KFPJ(NSTRG, NPART) = ITYP5(I)
                 PJPX(NSTRG, NPART) = sngl(PX5(I))
                 PJPY(NSTRG, NPART) = sngl(PY5(I))
                 PJPZ(NSTRG, NPART) = sngl(PZ5(I))
                 PJPE(NSTRG, NPART) = sngl(E5(I))
                 PJPM(NSTRG, NPART) = sngl(XMASS5(I))
              endif
           ELSE IF (LSTRG1(I) .LE. NSP + NST) THEN
              NSTRG = LSTRG1(I) - NSP
              if(IITYP.eq.2112.or.IITYP.eq.2212) then
                 PT(nstrg,1)=sngl(PX5(I))
                 PT(nstrg,2)=sngl(PY5(I))
                 PT(nstrg,3)=sngl(PZ5(I))
                 PT(nstrg,4)=sngl(E5(I))
                 PT(nstrg,5)=sngl(XMASS5(I))
              elseif((IITYP.eq.1.or.IITYP.eq.2).and.
     1 (LPART1(I).eq.1.or.LPART1(I).eq.(NTJ(NSTRG)+2))) then
                 PT(nstrg,6)=sngl(PX5(I))
                 PT(nstrg,7)=sngl(PY5(I))
                 PT(nstrg,14)=sngl(XMASS5(I))
                 PT(nstrg,1)=PT(nstrg,1)+sngl(PX5(I))
                 PT(nstrg,2)=PT(nstrg,2)+sngl(PY5(I))
                 PT(nstrg,3)=PT(nstrg,3)+sngl(PZ5(I))
                 PT(nstrg,4)=PT(nstrg,4)+sngl(E5(I))
                 PT(nstrg,5)=sqrt(PT(nstrg,4)**2-PT(nstrg,1)**2
     1                -PT(nstrg,2)**2-PT(nstrg,3)**2)
              elseif((IITYP.eq.1103.or.IITYP.eq.2101
     1 .or.IITYP.eq.2103.or.IITYP.eq.2203.
     2 .or.IITYP.eq.3101.or.IITYP.eq.3103.
     3 .or.IITYP.eq.3201.or.IITYP.eq.3203.or.IITYP.eq.3303)
     4 .and.(LPART1(I).eq.1.or.LPART1(I).eq.(NTJ(NSTRG)+2))) then
                 PT(nstrg,8)=sngl(PX5(I))
                 PT(nstrg,9)=sngl(PY5(I))
                 PT(nstrg,15)=sngl(XMASS5(I))
                 PT(nstrg,1)=PT(nstrg,1)+sngl(PX5(I))
                 PT(nstrg,2)=PT(nstrg,2)+sngl(PY5(I))
                 PT(nstrg,3)=PT(nstrg,3)+sngl(PZ5(I))
                 PT(nstrg,4)=PT(nstrg,4)+sngl(E5(I))
                 PT(nstrg,5)=sqrt(PT(nstrg,4)**2-PT(nstrg,1)**2
     1                -PT(nstrg,2)**2-PT(nstrg,3)**2)
              else
                 NPART = LPART1(I)-1
                 KFTJ(NSTRG, NPART) = ITYP5(I)
                 PJTX(NSTRG, NPART) = sngl(PX5(I))
                 PJTY(NSTRG, NPART) = sngl(PY5(I))
                 PJTZ(NSTRG, NPART) = sngl(PZ5(I))
                 PJTE(NSTRG, NPART) = sngl(E5(I))
                 PJTM(NSTRG, NPART) = sngl(XMASS5(I))
              endif
           ELSE
              NSTRG = LSTRG1(I) - NSP - NST
              NPART = LPART1(I)
              K2SG(NSTRG, NPART) = ITYP5(I)
              PXSG(NSTRG, NPART) = sngl(PX5(I))
              PYSG(NSTRG, NPART) = sngl(PY5(I))
              PZSG(NSTRG, NPART) = sngl(PZ5(I))
              PESG(NSTRG, NPART) = sngl(E5(I))
              PMSG(NSTRG, NPART) = sngl(XMASS5(I))
           END IF
 1005   CONTINUE
cbz1/25/99end

clin-4/09/01  turn on fragmentation with soft radiation 
c     and jet order reversal to form hadrons after ZPC:
        MSTJ(1)=1
        IHPR2(1)=1
        isflag=1
clin-4/13/01 allow small mass strings (D=1.5GeV):
        HIPR1(1)=0.94

cbz2/4/99
        CALL HJANA2
cbz2/4/99end

clin-4/19/01-soft3, fragment strings, then convert hadrons to partons 
c     and input to ZPC:
        elseif(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) then
clin-4/24/01 normal fragmentation first:
        isflag=0
c        write(99,*) 'IAEVT,NSG,NDR=',IAEVT,NSG,NDR

        IF(IHPR2(20).NE.0) THEN
           DO 560 ISG=1,NSG
                CALL HIJFRG(ISG,3,IERROR)
C
                nsbst=1
                IDSTR=92
                IF(IHPR2(21).EQ.0) THEN
                   CALL LUEDIT(2)
                ELSE
 551                   nsbst=nsbst+1
                   IF(K(nsbst,2).LT.91.OR.K(nsbst,2).GT.93) GO TO  551
                   IDSTR=K(nsbst,2)
                   nsbst=nsbst+1
                ENDIF

                IF(FRAME.EQ.'LAB') THEN
                        CALL HBOOST
                ENDIF
C                ******** boost back to lab frame(if it was in)
C
                nsbstR=0
                DO 560 I=nsbst,N
                   IF(K(I,2).EQ.IDSTR) THEN
                      nsbstR=nsbstR+1
                      GO TO 560
                   ENDIF
                   K(I,4)=nsbstR
                   NATT=NATT+1
                   KATT(NATT,1)=K(I,2)
                   KATT(NATT,2)=20
                   KATT(NATT,4)=K(I,1)
c     from Yasushi, to avoid violation of array limits:
c                   IF(K(I,3).EQ.0 .OR. K(K(I,3),2).EQ.IDSTR) THEN
clin-4/2008 to avoid out-of-bound error in K():
c                   IF(K(I,3).EQ.0 .OR. 
c     1 (K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR)) THEN
c                      KATT(NATT,3)=0
                   IF(K(I,3).EQ.0) THEN
                      KATT(NATT,3)=0
                   ELSEIF(K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR) THEN
                      KATT(NATT,3)=0
clin-4/2008-end
                   ELSE
                      KATT(NATT,3)=NATT-I+K(I,3)+nsbstR-K(K(I,3),4)
                   ENDIF

C       ****** identify the mother particle
                   PATT(NATT,1)=P(I,1)
                   PATT(NATT,2)=P(I,2)
                   PATT(NATT,3)=P(I,3)
                   PATT(NATT,4)=P(I,4)
                   EATT=EATT+P(I,4)
                   GXAR(NATT) = 0.5 * (YP(1, IASG(ISG, 1)) +
     &                YT(1, IASG(ISG, 2)))
                   GYAR(NATT) = 0.5 * (YP(2, IASG(ISG, 1)) +
     &                YT(2, IASG(ISG, 2)))
                   GZAR(NATT) = 0.
                   FTAR(NATT) = 0.
                   ITYPAR(NATT) = K(I, 2)
                   PXAR(NATT) = P(I, 1)
                   PYAR(NATT) = P(I, 2)
                   PZAR(NATT) = P(I, 3)
                   PEAR(NATT) = P(I, 4)
                   XMAR(NATT) = P(I, 5)
clin-8/2015: record hadron information, to be used for its constituent partons:
                   xstrg0(NATT)=dble(GXAR(NATT))
                   ystrg0(NATT)=dble(GYAR(NATT))
                   istrg0(NATT)=ISG
c                   write(99,*) xstrg0(NATT),ystrg0(NATT),istrg0(NATT),
c     1                  K(I,2),P(I, 1),P(I, 2),P(I, 3)
cbz11/11/98end

 560            CONTINUE
C                ********Fragment the q-qbar jets systems *****
C
           JTP(1)=IHNT2(1)
           JTP(2)=IHNT2(3)
           DO 600 NTP=1,2
           DO 600 jjtp=1,JTP(NTP)
                CALL HIJFRG(jjtp,NTP,IERROR)
C
                nsbst=1
                IDSTR=92
                IF(IHPR2(21).EQ.0) THEN
                   CALL LUEDIT(2)
                ELSE
 581                   nsbst=nsbst+1
                   IF(K(nsbst,2).LT.91.OR.K(nsbst,2).GT.93) GO TO  581
                   IDSTR=K(nsbst,2)
                   nsbst=nsbst+1
                ENDIF
                IF(FRAME.EQ.'LAB') THEN
                        CALL HBOOST
                ENDIF
C                ******** boost back to lab frame(if it was in)
C
                NFTP=NFP(jjtp,5)
                IF(NTP.EQ.2) NFTP=10+NFT(jjtp,5)
                nsbstR=0
                DO 590 I=nsbst,N
                   IF(K(I,2).EQ.IDSTR) THEN
                      nsbstR=nsbstR+1
                      GO TO 590
                   ENDIF
                   K(I,4)=nsbstR
                   NATT=NATT+1
                   KATT(NATT,1)=K(I,2)
                   KATT(NATT,2)=NFTP
                   KATT(NATT,4)=K(I,1)
c                   IF(K(I,3).EQ.0 .OR. K(K(I,3),2).EQ.IDSTR) THEN
clin-4/2008
c                   IF(K(I,3).EQ.0 .OR.
c     1 (K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR)) THEN
c                      KATT(NATT,3)=0
                   IF(K(I,3).EQ.0) THEN
                      KATT(NATT,3)=0
                   ELSEIF(K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR) THEN
                      KATT(NATT,3)=0
clin-4/2008-end
                   ELSE
                      KATT(NATT,3)=NATT-I+K(I,3)+nsbstR-K(K(I,3),4)
                   ENDIF

C       ****** identify the mother particle
                   PATT(NATT,1)=P(I,1)
                   PATT(NATT,2)=P(I,2)
                   PATT(NATT,3)=P(I,3)
                   PATT(NATT,4)=P(I,4)
                   EATT=EATT+P(I,4)
                   IF (NTP .EQ. 1) THEN
clin-2/2012:
c                      GXAR(NATT) = YP(1, jjtp)+0.5 * BB
c                      GYAR(NATT) = YP(2, jjtp)
                      GXAR(NATT) = YP(1, jjtp)+0.5*BB*cos(phiRP)
                      GYAR(NATT) = YP(2, jjtp)+0.5*BB*sin(phiRP)

                   ELSE
clin-2/2012:
c                      GXAR(NATT) = YT(1, jjtp)-0.5 * BB
c                      GYAR(NATT) = YT(2, jjtp)
                      GXAR(NATT) = YT(1, jjtp)-0.5*BB*cos(phiRP)
                      GYAR(NATT) = YT(2, jjtp)-0.5*BB*sin(phiRP)
                   END IF
                   GZAR(NATT) = 0.
                   FTAR(NATT) = 0.
                   ITYPAR(NATT) = K(I, 2)
                   PXAR(NATT) = P(I, 1)
                   PYAR(NATT) = P(I, 2)
                   PZAR(NATT) = P(I, 3)
                   PEAR(NATT) = P(I, 4)
                   XMAR(NATT) = P(I, 5)
clin-8/2015: record hadron information, to be used for its constituent partons:
                   xstrg0(NATT)=dble(GXAR(NATT))
                   ystrg0(NATT)=dble(GYAR(NATT))
c     String ID is separated for projectile/target strings:
                   istrg0(NATT)=NTP*10000+jjtp
c              if(N.eq.nsbst.and.(K(I,2).eq.2112.or.K(I,2).eq.2212)) then
c                      write(99,*) xstrg0(NATT),ystrg0(NATT),istrg0(NATT)
c     1                  ,K(I,2),P(I, 1),P(I, 2),P(I, 3),'spectator'
c                   else
c                      write(99,*) xstrg0(NATT),ystrg0(NATT),istrg0(NATT)
c     1                  ,K(I,2),P(I, 1),P(I, 2),P(I, 3)
c                   endif
cbz11/11/98end

 590                CONTINUE 
 600           CONTINUE
C     ********Fragment the q-qq related string systems
        ENDIF
clin-4/2008 check for zero NDR value:
        if(NDR.ge.1) then
c
        DO 650 I=1,NDR
                NATT=NATT+1
                KATT(NATT,1)=KFDR(I)
                KATT(NATT,2)=40
                KATT(NATT,3)=0
                PATT(NATT,1)=PDR(I,1)
                PATT(NATT,2)=PDR(I,2)
                PATT(NATT,3)=PDR(I,3)
                PATT(NATT,4)=PDR(I,4)
                EATT=EATT+PDR(I,4)
clin-11/11/03     set direct photons positions and time at formation:
                GXAR(NATT) = rtdr(I,1)
                GYAR(NATT) = rtdr(I,2)
                GZAR(NATT) = 0.
                FTAR(NATT) = 0.
                ITYPAR(NATT) =KATT(NATT,1) 
                PXAR(NATT) = PATT(NATT,1)
                PYAR(NATT) = PATT(NATT,2)
                PZAR(NATT) = PATT(NATT,3)
                PEAR(NATT) = PATT(NATT,4)
                XMAR(NATT) = PDR(I,5)
 650        CONTINUE
clin-4/2008:
         endif
clin-6/2009
         call embedHighPt
c
        CALL HJANA1

clin-4/19/01 convert hadrons to partons for ZPC (with GX0 given):
        call htop

clin-7/03/01 move up, used in zpstrg (otherwise not set and incorrect):
        nsp=0
        nst=0
        nsg=natt
        NSI=NSG
clin-7/03/01-end

clin-6/2009:
        if(ioscar.eq.3) WRITE (95, *) IAEVT, mul

c.....call ZPC for parton cascade
        CALL ZPCMN
clin-6/2009:
c        WRITE (14, 395) ITEST, MUL, bimp, NELP,NINP,NELT,NINTHJ
        WRITE (14, 395) IAEVT, MISS, MUL, bimp, NELP,NINP,NELT,NINTHJ
        itest=itest+1

        DO 1016 I = 1, MUL
c           WRITE (14, 511) PX5(I), PY5(I), PZ5(I), ITYP5(I),
c     &        XMASS5(I), E5(I)
clin-4/2012 write parton freeze-out position in zpc.dat 
c     for string melting version:
c           WRITE (14, 512) ITYP5(I), PX5(I), PY5(I), PZ5(I), 
c     &        XMASS5(I), LSTRG1(I), LPART1(I), FT5(I)
           if(dmax1(abs(GX5(I)),abs(GY5(I)),abs(GZ5(I)),abs(FT5(I)))
     1          .lt.9999) then
              write(14,210) ITYP5(I), PX5(I), PY5(I), PZ5(I), XMASS5(I),
     1             GX5(I), GY5(I), GZ5(I), FT5(I)
           else
              write(14,211) ITYP5(I), PX5(I), PY5(I), PZ5(I), XMASS5(I),
     1             GX5(I), GY5(I), GZ5(I), FT5(I)
           endif
c
 1016   CONTINUE
c 511    FORMAT(1X, 3F10.4, I6, 2F10.4)
c 512    FORMAT(I6,4(1X,F10.3),1X,I6,1X,I3,1X,F10.3)
c 513    FORMAT(1X, 4F10.4)

clin-5/2009 ctest off:
c        call frztm(1,1)

clin  save data after ZPC for fragmentation purpose:
c.....transfer data back from ZPC to HIJING
        DO 1018 I = 1, MAXSTR
           DO 1017 J = 1, 3
              K1SGS(I, J) = 0
              K2SGS(I, J) = 0
              PXSGS(I, J) = 0d0
              PYSGS(I, J) = 0d0
              PZSGS(I, J) = 0d0
              PESGS(I, J) = 0d0
              PMSGS(I, J) = 0d0
              GXSGS(I, J) = 0d0
              GYSGS(I, J) = 0d0
              GZSGS(I, J) = 0d0
              FTSGS(I, J) = 0d0
 1017      CONTINUE
 1018   CONTINUE
        DO 1019 I = 1, MUL
           IITYP=ITYP5(I)
           NSTRG = LSTRG1(I)
           NPART = LPART1(I)
           K2SGS(NSTRG, NPART) = ITYP5(I)
           PXSGS(NSTRG, NPART) = PX5(I)
           PYSGS(NSTRG, NPART) = PY5(I)
           PZSGS(NSTRG, NPART) = PZ5(I)
           PMSGS(NSTRG, NPART) = XMASS5(I)
clin-7/20/01 E5(I) does no include the finite parton mass XMASS5(I), 
c     so define it anew:
c           PESGS(NSTRG, NPART) = E5(I)
c           if(abs(PZ5(i)/E5(i)).gt.0.9999999d0) 
c     1          write(91,*) 'a',PX5(i),PY5(i),XMASS5(i),PZ5(i),E5(i)
           E5(I)=dsqrt(PX5(I)**2+PY5(I)**2+PZ5(I)**2+XMASS5(I)**2)
           PESGS(NSTRG, NPART) = E5(I)
c           if(abs(PZ5(i)/E5(i)).gt.0.9999999d0) 
c     1          write(91,*) 'b: new E5(I)=',E5(i)
clin-7/20/01-end
           GXSGS(NSTRG, NPART) = GX5(I)
           GYSGS(NSTRG, NPART) = GY5(I)
           GZSGS(NSTRG, NPART) = GZ5(I)
           FTSGS(NSTRG, NPART) = FT5(I)
 1019   CONTINUE
        CALL HJANA2

clin-4/19/01-end

        endif
clin-4/09/01-end

C
C**************fragment all the string systems in the following*****
C
C********nsbst is where particle information starts
C********nsbstR+1 is the number of strings in fragmentation
C********the number of strings before a line is stored in K(I,4)
C********IDSTR is id number of the string system (91,92 or 93)
C
clin-4/30/01 convert partons to hadrons after ZPC:
        if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) then
           NATT=0
           EATT=0.
           call ptoh
           do 1006 I=1,nnozpc
              NATT=NATT+1
              KATT(NATT,1)=ITYPN(I)
              PATT(NATT,1)=PXN(I)
              PATT(NATT,2)=PYN(I)
              PATT(NATT,3)=PZN(I)
              PATT(NATT,4)=EEN(I)
              EATT=EATT+EEN(I)
              GXAR(NATT)=GXN(I)
              GYAR(NATT)=GYN(I)
              GZAR(NATT)=GZN(I)
              FTAR(NATT)=FTN(I)
              ITYPAR(NATT)=ITYPN(I)
              PXAR(NATT)=PXN(I)
              PYAR(NATT)=PYN(I)
              PZAR(NATT)=PZN(I)
              PEAR(NATT)=EEN(I)
              XMAR(NATT)=XMN(I)
 1006      continue
           goto 565
        endif
clin-4/30/01-end        
        IF(IHPR2(20).NE.0) THEN
           DO 360 ISG=1,NSG
                CALL HIJFRG(ISG,3,IERROR)
                IF(MSTU(24).NE.0 .OR.IERROR.GT.0) THEN
                   MSTU(24)=0
                   MSTU(28)=0
                   IF(IHPR2(10).NE.0) THEN
c                      call lulist(2)
                      WRITE(6,*) 'error occured ISG, repeat the event'
                  write(6,*) ISG

                   ENDIF
                   GO TO 50
                ENDIF
C                        ********Check errors
C
                nsbst=1
                IDSTR=92
                IF(IHPR2(21).EQ.0) THEN
                   CALL LUEDIT(2)
                ELSE
351                   nsbst=nsbst+1
                   IF(K(nsbst,2).LT.91.OR.K(nsbst,2).GT.93) GO TO  351
                   IDSTR=K(nsbst,2)
                   nsbst=nsbst+1
                ENDIF
C
                IF(FRAME.EQ.'LAB') THEN
                        CALL HBOOST
                ENDIF
C                ******** boost back to lab frame(if it was in)
C
                nsbstR=0
                DO 360 I=nsbst,N
                   IF(K(I,2).EQ.IDSTR) THEN
                      nsbstR=nsbstR+1
                      GO TO 360
                   ENDIF
                   K(I,4)=nsbstR
                   NATT=NATT+1
                   KATT(NATT,1)=K(I,2)
                   KATT(NATT,2)=20
                   KATT(NATT,4)=K(I,1)
c                   IF(K(I,3).EQ.0 .OR. K(K(I,3),2).EQ.IDSTR) THEN
clin-4/2008:
c                   IF(K(I,3).EQ.0 .OR. 
c     1 (K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR)) THEN
c                      KATT(NATT,3)=0
                   IF(K(I,3).EQ.0) THEN
                      KATT(NATT,3)=0
                   ELSEIF(K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR) THEN
                      KATT(NATT,3)=0
clin-4/2008-end
                   ELSE
                      KATT(NATT,3)=NATT-I+K(I,3)+nsbstR-K(K(I,3),4)
                   ENDIF

C       ****** identify the mother particle
                   PATT(NATT,1)=P(I,1)
                   PATT(NATT,2)=P(I,2)
                   PATT(NATT,3)=P(I,3)
                   PATT(NATT,4)=P(I,4)
                   EATT=EATT+P(I,4)

cbz11/11/98
cbz1/25/99
c                   GXAR(NATT) = 0.5 * (YP(1, IASG(ISG, 1)) +
c     &                YT(1, IASG(ISG, 2)))
c                   GYAR(NATT) = 0.5 * (YP(2, IASG(ISG, 1)) +
c     &                YT(2, IASG(ISG, 2)))
                   LSG = NSP + NST + ISG
                   GXAR(NATT) = sngl(ZT1(LSG))
                   GYAR(NATT) = sngl(ZT2(LSG))
                   GZAR(NATT) = sngl(ZT3(LSG))
                   FTAR(NATT) = sngl(ATAUI(LSG))
cbz1/25/99end
                   ITYPAR(NATT) = K(I, 2)
                   PXAR(NATT) = P(I, 1)
                   PYAR(NATT) = P(I, 2)
                   PZAR(NATT) = P(I, 3)
                   PEAR(NATT) = P(I, 4)
                   XMAR(NATT) = P(I, 5)
cbz11/11/98end

360           CONTINUE
C                ********Fragment the q-qbar jets systems *****
C
           JTP(1)=IHNT2(1)
           JTP(2)=IHNT2(3)
           DO 400 NTP=1,2
           DO 400 jjtp=1,JTP(NTP)
                CALL HIJFRG(jjtp,NTP,IERROR)
                IF(MSTU(24).NE.0 .OR. IERROR.GT.0) THEN
                   MSTU(24)=0
                   MSTU(28)=0
                   IF(IHPR2(10).NE.0) THEN
c                  call lulist(2)
                  WRITE(6,*) 'error occured P&T, repeat the event'
                  WRITE(6,*) NTP,jjtp
clin-6/2009 when this happens, the event will be repeated, 
c     and another record for the same event number will be written into
c     zpc.dat, zpc.res, minijet-initial-beforePropagation.dat,
c     parton-initial-afterPropagation.dat, parton-after-coalescence.dat, 
c     and parton-collisionsHistory.dat. 
                   ENDIF
                   GO TO 50
                ENDIF
C                        ********check errors
C
                nsbst=1
                IDSTR=92
                IF(IHPR2(21).EQ.0) THEN
                   CALL LUEDIT(2)
                ELSE
381                   nsbst=nsbst+1
                   IF(K(nsbst,2).LT.91.OR.K(nsbst,2).GT.93) GO TO  381
                   IDSTR=K(nsbst,2)
                   nsbst=nsbst+1
                ENDIF
                IF(FRAME.EQ.'LAB') THEN
                        CALL HBOOST
                ENDIF
C                ******** boost back to lab frame(if it was in)
C
                NFTP=NFP(jjtp,5)
                IF(NTP.EQ.2) NFTP=10+NFT(jjtp,5)
                nsbstR=0
                DO 390 I=nsbst,N
                   IF(K(I,2).EQ.IDSTR) THEN
                      nsbstR=nsbstR+1
                      GO TO 390
                   ENDIF
                   K(I,4)=nsbstR
                   NATT=NATT+1
                   KATT(NATT,1)=K(I,2)
                   KATT(NATT,2)=NFTP
                   KATT(NATT,4)=K(I,1)
c                   IF(K(I,3).EQ.0 .OR. K(K(I,3),2).EQ.IDSTR) THEN
clin-4/2008:
c                   IF(K(I,3).EQ.0 .OR. 
c     1 (K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR)) THEN
c                      KATT(NATT,3)=0
                   IF(K(I,3).EQ.0) THEN
                      KATT(NATT,3)=0
                   ELSEIF(K(I,3).ne.0.and.K(K(I,3),2).EQ.IDSTR) THEN
                      KATT(NATT,3)=0
clin-4/2008-end
                   ELSE
                      KATT(NATT,3)=NATT-I+K(I,3)+nsbstR-K(K(I,3),4)
                   ENDIF
C       ****** identify the mother particle
                   PATT(NATT,1)=P(I,1)
                   PATT(NATT,2)=P(I,2)
                   PATT(NATT,3)=P(I,3)
                   PATT(NATT,4)=P(I,4)
                   EATT=EATT+P(I,4)
cbz11/11/98
cbz1/25/99
c                   IF (NTP .EQ. 1) THEN
c                      GXAR(NATT) = YP(1, jjtp)
c                   ELSE
c                      GXAR(NATT) = YT(1, jjtp)
c                   END IF
c                   IF (NTP .EQ. 1) THEN
c                      GYAR(NATT) = YP(2, jjtp)
c                   ELSE
c                      GYAR(NATT) = YT(2, jjtp)
c                   END IF
                   IF (NTP .EQ. 1) THEN
                      LSG = jjtp
                   ELSE
                      LSG = jjtp + NSP
                   END IF
                   GXAR(NATT) = sngl(ZT1(LSG))
                   GYAR(NATT) = sngl(ZT2(LSG))
                   GZAR(NATT) = sngl(ZT3(LSG))
                   FTAR(NATT) = sngl(ATAUI(LSG))
cbz1/25/99end
                   ITYPAR(NATT) = K(I, 2)
                   PXAR(NATT) = P(I, 1)
                   PYAR(NATT) = P(I, 2)
                   PZAR(NATT) = P(I, 3)
                   PEAR(NATT) = P(I, 4)
                   XMAR(NATT) = P(I, 5)
cbz11/11/98end

390                CONTINUE 
400           CONTINUE
C     ********Fragment the q-qq related string systems
        ENDIF

        DO 450 I=1,NDR
           NATT=NATT+1
           KATT(NATT,1)=KFDR(I)
           KATT(NATT,2)=40
           KATT(NATT,3)=0
           PATT(NATT,1)=PDR(I,1)
           PATT(NATT,2)=PDR(I,2)
           PATT(NATT,3)=PDR(I,3)
           PATT(NATT,4)=PDR(I,4)
           EATT=EATT+PDR(I,4)
clin-11/11/03     set direct photons positions and time at formation:
           GXAR(NATT) = rtdr(I,1)
           GYAR(NATT) = rtdr(I,2)
           GZAR(NATT) = 0.
           FTAR(NATT) = 0.
           ITYPAR(NATT) =KATT(NATT,1) 
           PXAR(NATT) = PATT(NATT,1)
           PYAR(NATT) = PATT(NATT,2)
           PZAR(NATT) = PATT(NATT,3)
           PEAR(NATT) = PATT(NATT,4)
           XMAR(NATT) = PDR(I,5)
 450    CONTINUE

C                        ********store the direct-produced particles
C

clin-4/19/01 soft3:
 565    continue

        DENGY=EATT/(IHNT2(1)*HINT1(6)+IHNT2(3)*HINT1(7))-1.0
        IF(ABS(DENGY).GT.HIPR1(43).AND.IHPR2(20).NE.0
     &     .AND.IHPR2(21).EQ.0) THEN
         IF(IHPR2(10).NE.0) 
     &        WRITE(6,*) 'Energy not conserved, repeat the event'
c                call lulist(1)
         write(6,*) 'violated:EATT(GeV),NATT,B(fm)=',EATT,NATT,bimp
         GO TO 50
        ENDIF
        write(6,*) 'satisfied:EATT(GeV),NATT,B(fm)=',EATT,NATT,bimp
        write(6,*) ' '
c
clin-4/2012 write out initial transverse positions of initial nucleons:
        write(94,*) IAEVT,MISS,IHNT2(1),IHNT2(3),bimp
        DO JP=1,IHNT2(1)
clin-12/2012 write out present and original flavor code of nucleons:
c           write(94,243) YP(1,JP)+0.5*BB*cos(phiRP), 
c     1 YP(2,JP)+0.5*BB*sin(phiRP), JP, NFP(JP,5),yp(3,jp)
           write(94,243) YP(1,JP)+0.5*BB*cos(phiRP), 
     1 YP(2,JP)+0.5*BB*sin(phiRP),JP, NFP(JP,5),yp(3,jp),
     2 NFP(JP,3),NFP(JP,4)
        ENDDO
        DO JT=1,IHNT2(3)
c target nucleon # has a minus sign for distinction from projectile:
clin-12/2012 write out present and original flavor code of nucleons:
c           write(94,243) YT(1,JT)-0.5*BB*cos(phiRP), 
c     1 YT(2,JT)-0.5*BB*sin(phiRP), -JT, NFT(JT,5),yt(3,jt)
           write(94,243) YT(1,JT)-0.5*BB*cos(phiRP), 
     1 YT(2,JT)-0.5*BB*sin(phiRP), -JT, NFT(JT,5),yt(3,jt),
     2 NFT(JT,3),NFT(JT,4)
        ENDDO
clin-12/2012 write out present and original flavor code of nucleons:
c 243    format(f10.3,1x,f10.3,2(1x,I5),1x,f10.3)
 243    format(f10.3,1x,f10.3,2(1x,I5),1x,f10.3,2(1x,I5))
clin-4/2012-end

        RETURN
        END
C
C
C
        SUBROUTINE HIJSET(EFRM,FRAME,PROJ,TARG,IAP,IZP,IAT,IZT)
        CHARACTER FRAME*4,PROJ*4,TARG*4,EFRAME*4
        DOUBLE PRECISION  DD1,DD2,DD3,DD4
        COMMON/HSTRNG/NFP(300,15),PP(300,15),NFT(300,15),PT(300,15)
cc      SAVE /HSTRNG/
        COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/HIJDAT/HIDAT0(10,10),HIDAT(10)
cc      SAVE /HIJDAT/
        COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
cc      SAVE /LUDAT1/
        EXTERNAL FNKICK,FNKC2,FNSTRU,FNSTRM,FNSTRS
        SAVE   

        CALL TITLE
        IHNT2(1)=IAP
        IHNT2(2)=IZP
        IHNT2(3)=IAT
        IHNT2(4)=IZT
        IHNT2(5)=0
        IHNT2(6)=0
C
        HINT1(8)=MAX(ULMASS(2112),ULMASS(2212))
        HINT1(9)=HINT1(8)
C
        IF(PROJ.NE.'A') THEN
                IF(PROJ.EQ.'P') THEN
                    IHNT2(5)=2212
                ELSE IF(PROJ.EQ.'PBAR') THEN 
                    IHNT2(5)=-2212
                ELSE IF(PROJ.EQ.'PI+') THEN
                    IHNT2(5)=211
                ELSE IF(PROJ.EQ.'PI-') THEN
                    IHNT2(5)=-211
                ELSE IF(PROJ.EQ.'K+') THEN
                    IHNT2(5)=321
                ELSE IF(PROJ.EQ.'K-') THEN
                    IHNT2(5)=-321
                ELSE IF(PROJ.EQ.'N') THEN
                    IHNT2(5)=2112
                ELSE IF(PROJ.EQ.'NBAR') THEN
                    IHNT2(5)=-2112
                ELSE
                    WRITE(6,*) PROJ, 'wrong or unavailable proj name'
                    STOP
                ENDIF
                HINT1(8)=ULMASS(IHNT2(5))
        ENDIF
        IF(TARG.NE.'A') THEN
                IF(TARG.EQ.'P') THEN
                    IHNT2(6)=2212
                ELSE IF(TARG.EQ.'PBAR') THEN 
                    IHNT2(6)=-2212
                ELSE IF(TARG.EQ.'PI+') THEN
                    IHNT2(6)=211
                ELSE IF(TARG.EQ.'PI-') THEN
                    IHNT2(6)=-211
                ELSE IF(TARG.EQ.'K+') THEN
                    IHNT2(6)=321
                ELSE IF(TARG.EQ.'K-') THEN
                    IHNT2(6)=-321
                ELSE IF(TARG.EQ.'N') THEN
                    IHNT2(6)=2112
                ELSE IF(TARG.EQ.'NBAR') THEN
                    IHNT2(6)=-2112
                ELSE
                    WRITE(6,*) TARG,'wrong or unavailable targ name'
                    STOP
                ENDIF
                HINT1(9)=ULMASS(IHNT2(6))
        ENDIF

C...Switch off decay of pi0, K0S, Lambda, Sigma+-, Xi0-, Omega-.
        IF(IHPR2(12).GT.0) THEN
        CALL LUGIVE('MDCY(C221,1)=0')
clin-11/07/00 no K* decays:
        CALL LUGIVE('MDCY(C313,1)=0')
        CALL LUGIVE('MDCY(C-313,1)=0')
        CALL LUGIVE('MDCY(C323,1)=0')
        CALL LUGIVE('MDCY(C-323,1)=0')
clin-1/04/01 no K0 and K0bar decays so K0L and K0S do not appear,
c     this way the K/Kbar difference is accounted for exactly:
        CALL LUGIVE('MDCY(C311,1)=0')
        CALL LUGIVE('MDCY(C-311,1)=0')
clin-11/08/00 no Delta decays:
        CALL LUGIVE('MDCY(C1114,1)=0')
        CALL LUGIVE('MDCY(C2114,1)=0')
        CALL LUGIVE('MDCY(C2214,1)=0')
        CALL LUGIVE('MDCY(C2224,1)=0')
        CALL LUGIVE('MDCY(C-1114,1)=0')
        CALL LUGIVE('MDCY(C-2114,1)=0')
        CALL LUGIVE('MDCY(C-2214,1)=0')
        CALL LUGIVE('MDCY(C-2224,1)=0')
clin-11/07/00-end
cbz12/4/98
        CALL LUGIVE('MDCY(C213,1)=0')
        CALL LUGIVE('MDCY(C-213,1)=0')
        CALL LUGIVE('MDCY(C113,1)=0')
        CALL LUGIVE('MDCY(C223,1)=0')
        CALL LUGIVE('MDCY(C333,1)=0')
cbz12/4/98end
        CALL LUGIVE('MDCY(C111,1)=0')
        CALL LUGIVE('MDCY(C310,1)=0')
        CALL LUGIVE('MDCY(C411,1)=0;MDCY(C-411,1)=0')
        CALL LUGIVE('MDCY(C421,1)=0;MDCY(C-421,1)=0')
        CALL LUGIVE('MDCY(C431,1)=0;MDCY(C-431,1)=0')
        CALL LUGIVE('MDCY(C511,1)=0;MDCY(C-511,1)=0')
        CALL LUGIVE('MDCY(C521,1)=0;MDCY(C-521,1)=0')
        CALL LUGIVE('MDCY(C531,1)=0;MDCY(C-531,1)=0')
        CALL LUGIVE('MDCY(C3122,1)=0;MDCY(C-3122,1)=0')
        CALL LUGIVE('MDCY(C3112,1)=0;MDCY(C-3112,1)=0')
        CALL LUGIVE('MDCY(C3212,1)=0;MDCY(C-3212,1)=0')
        CALL LUGIVE('MDCY(C3222,1)=0;MDCY(C-3222,1)=0')
        CALL LUGIVE('MDCY(C3312,1)=0;MDCY(C-3312,1)=0')
        CALL LUGIVE('MDCY(C3322,1)=0;MDCY(C-3322,1)=0')
        CALL LUGIVE('MDCY(C3334,1)=0;MDCY(C-3334,1)=0')
clin-7/2011-no HQ(charm or bottom) decays in order to get net-HQ conservation:
        CALL LUGIVE('MDCY(C441,1)=0')
        CALL LUGIVE('MDCY(C443,1)=0')
        CALL LUGIVE('MDCY(C413,1)=0;MDCY(C-413,1)=0')
        CALL LUGIVE('MDCY(C423,1)=0;MDCY(C-423,1)=0')
        CALL LUGIVE('MDCY(C433,1)=0;MDCY(C-433,1)=0')
        CALL LUGIVE('MDCY(C4112,1)=0;MDCY(C-4112,1)=0')
        CALL LUGIVE('MDCY(C4114,1)=0;MDCY(C-4114,1)=0')
        CALL LUGIVE('MDCY(C4122,1)=0;MDCY(C-4122,1)=0')
        CALL LUGIVE('MDCY(C4212,1)=0;MDCY(C-4212,1)=0')
        CALL LUGIVE('MDCY(C4214,1)=0;MDCY(C-4214,1)=0')
        CALL LUGIVE('MDCY(C4222,1)=0;MDCY(C-4222,1)=0')
        CALL LUGIVE('MDCY(C4224,1)=0;MDCY(C-4224,1)=0')
        CALL LUGIVE('MDCY(C4132,1)=0;MDCY(C-4132,1)=0')
        CALL LUGIVE('MDCY(C4312,1)=0;MDCY(C-4312,1)=0')
        CALL LUGIVE('MDCY(C4314,1)=0;MDCY(C-4314,1)=0')
        CALL LUGIVE('MDCY(C4232,1)=0;MDCY(C-4232,1)=0')
        CALL LUGIVE('MDCY(C4322,1)=0;MDCY(C-4322,1)=0')
        CALL LUGIVE('MDCY(C4324,1)=0;MDCY(C-4324,1)=0')
        CALL LUGIVE('MDCY(C4332,1)=0;MDCY(C-4332,1)=0')
        CALL LUGIVE('MDCY(C4334,1)=0;MDCY(C-4334,1)=0')
        CALL LUGIVE('MDCY(C551,1)=0')
        CALL LUGIVE('MDCY(C553,1)=0')
        CALL LUGIVE('MDCY(C513,1)=0;MDCY(C-513,1)=0')
        CALL LUGIVE('MDCY(C523,1)=0;MDCY(C-523,1)=0')
        CALL LUGIVE('MDCY(C533,1)=0;MDCY(C-533,1)=0')
        CALL LUGIVE('MDCY(C5112,1)=0;MDCY(C-5112,1)=0')
        CALL LUGIVE('MDCY(C5114,1)=0;MDCY(C-5114,1)=0')
        CALL LUGIVE('MDCY(C5122,1)=0;MDCY(C-5122,1)=0')
        CALL LUGIVE('MDCY(C5212,1)=0;MDCY(C-5212,1)=0')
        CALL LUGIVE('MDCY(C5214,1)=0;MDCY(C-5214,1)=0')
        CALL LUGIVE('MDCY(C5222,1)=0;MDCY(C-5222,1)=0')
        CALL LUGIVE('MDCY(C5224,1)=0;MDCY(C-5224,1)=0')
clin-7/2011-end
        ENDIF
        MSTU(12)=0
        MSTU(21)=1
        IF(IHPR2(10).EQ.0) THEN
                MSTU(22)=0
                MSTU(25)=0
                MSTU(26)=0
        ENDIF

clin    parj(41) and (42) are a, b parameters in Lund, read from input.ampt:
c        PARJ(41)=HIPR1(3)
c        PARJ(42)=HIPR1(4)
c        PARJ(41)=2.2
c        PARJ(42)=0.5

clin  2 popcorn parameters read from input.ampt:
c        IHPR2(11) = 3
c        PARJ(5) = 0.5
        MSTJ(12)=IHPR2(11)

clin  parj(21) gives the mean gaussian width for hadron Pt:
        PARJ(21)=HIPR1(2)
clin  parj(2) is gamma_s=P(s)/P(u), kappa propto 1/b/(2+a) assumed.
        rkp=HIPR1(4)*(2+HIPR1(3))/PARJ(42)/(2+PARJ(41))
        PARJ(2)=PARJ(2)**(1./rkp)
        PARJ(21)=PARJ(21)*sqrt(rkp)
clin-10/31/00 update when string tension is changed:
        HIPR1(2)=PARJ(21)

clin-4/2015: set upper limit for gamma_s=P(s)/P(u) to 0.4
c     (to limit strangeness enhancement when string tension is strongly 
c     increased due to using a very low value of parameter b in Lund 
c     symmetric splitting function as done in arXiv:1403.6321):
        PARJ(2)=min(PARJ(2),0.4)

C                        ******** set up for jetset
        IF(FRAME.EQ.'LAB') THEN
           DD1=dble(EFRM)
           DD2=dble(HINT1(8))
           DD3=dble(HINT1(9))
           HINT1(1)=SQRT(HINT1(8)**2+2.0*HINT1(9)*EFRM+HINT1(9)**2)
           DD4=DSQRT(DD1**2-DD2**2)/(DD1+DD3)
           HINT1(2)=sngl(DD4)
           HINT1(3)=0.5*sngl(DLOG((1.D0+DD4)/(1.D0-DD4)))
           DD4=DSQRT(DD1**2-DD2**2)/DD1
           HINT1(4)=0.5*sngl(DLOG((1.D0+DD4)/(1.D0-DD4)))
           HINT1(5)=0.0
           HINT1(6)=EFRM
           HINT1(7)=HINT1(9)
        ELSE IF(FRAME.EQ.'CMS') THEN
           HINT1(1)=EFRM
           HINT1(2)=0.0
           HINT1(3)=0.0
           DD1=dble(HINT1(1))
           DD2=dble(HINT1(8))
           DD3=dble(HINT1(9))
           DD4=DSQRT(1.D0-4.D0*DD2**2/DD1**2)
           HINT1(4)=0.5*sngl(DLOG((1.D0+DD4)/(1.D0-DD4)))
           DD4=DSQRT(1.D0-4.D0*DD3**2/DD1**2)
           HINT1(5)=-0.5*sngl(DLOG((1.D0+DD4)/(1.D0-DD4)))
           HINT1(6)=HINT1(1)/2.0
           HINT1(7)=HINT1(1)/2.0
        ENDIF
C                ********define Lorentz transform to lab frame
c
C                ********calculate the cross sections involved with
C                        nucleon collisions.
        IF(IHNT2(1).GT.1) THEN
                CALL HIJWDS(IHNT2(1),1,RMAX)
                HIPR1(34)=RMAX
C                        ********set up Wood-Sax distr for proj.
        ENDIF
        IF(IHNT2(3).GT.1) THEN
                CALL HIJWDS(IHNT2(3),2,RMAX)
                HIPR1(35)=RMAX
C                        ********set up Wood-Sax distr for  targ.
        ENDIF
C
C
        I=0
20        I=I+1
        IF(I.EQ.10) GO TO 30
        IF(HIDAT0(10,I).LE.HINT1(1)) GO TO 20
30        IF(I.EQ.1) I=2
        DO 40 J=1,9
           HIDAT(J)=HIDAT0(J,I-1)+(HIDAT0(J,I)-HIDAT0(J,I-1))
     &          *(HINT1(1)-HIDAT0(10,I-1))/(HIDAT0(10,I)-HIDAT0(10,I-1))
40        CONTINUE
        HIPR1(31)=HIDAT(5)
        HIPR1(30)=2.0*HIDAT(5)
C
C
        CALL HIJCRS
C
        IF(IHPR2(5).NE.0) THEN
                CALL HIFUN(3,0.0,36.0,FNKICK)
C                ********booking for generating pt**2 for pt kick
        ENDIF
        CALL HIFUN(7,0.0,6.0,FNKC2)
        CALL HIFUN(4,0.0,1.0,FNSTRU)
        CALL HIFUN(5,0.0,1.0,FNSTRM)
        CALL HIFUN(6,0.0,1.0,FNSTRS)
C                ********booking for x distribution of valence quarks
        EFRAME='Ecm'
        IF(FRAME.EQ.'LAB') EFRAME='Elab'
        WRITE(6,100) EFRAME,EFRM,PROJ,IHNT2(1),IHNT2(2),
     &               TARG,IHNT2(3),IHNT2(4) 
100        FORMAT(
     &        10X,'**************************************************'/
     &        10X,'*',48X,'*'/
     &        10X,'*         HIJING has been initialized at         *'/
     &        10X,'*',13X,A4,'= ',F10.2,' GeV/n',13X,'*'/
     &        10X,'*',48X,'*'/
     &        10X,'*',8X,'for ',
     &        A4,'(',I3,',',I3,')',' + ',A4,'(',I3,',',I3,')',7X,'*'/
     &        10X,'**************************************************')
        RETURN
        END
C
C
C
        FUNCTION FNKICK(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        SAVE   
        FNKICK=1.0/(X+HIPR1(19)**2)/(X+HIPR1(20)**2)
     &                /(1+EXP((SQRT(X)-HIPR1(20))/0.4))
        RETURN
        END
C
C
        FUNCTION FNKC2(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        SAVE   
        FNKC2=X*EXP(-2.0*X/HIPR1(42))
        RETURN
        END
C
C
C
        FUNCTION FNSTRU(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        SAVE   
        FNSTRU=(1.0-X)**HIPR1(44)/
     &                (X**2+HIPR1(45)**2/HINT1(1)**2)**HIPR1(46)
        RETURN
        END
C
C
C
        FUNCTION FNSTRM(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        SAVE   
        FNSTRM=1.0/((1.0-X)**2+HIPR1(45)**2/HINT1(1)**2)**HIPR1(46)
     &          /(X**2+HIPR1(45)**2/HINT1(1)**2)**HIPR1(46)
        RETURN
        END
C
C
        FUNCTION FNSTRS(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        SAVE   
        FNSTRS=(1.0-X)**HIPR1(47)/
     &                (X**2+HIPR1(45)**2/HINT1(1)**2)**HIPR1(48)
        RETURN
        END
C
C
C
C
        SUBROUTINE HBOOST
              IMPLICIT DOUBLE PRECISION(D)  
              COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5) 
cc      SAVE /LUJETS/ 
              COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
cc      SAVE /LUDAT1/ 
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        SAVE   
        DO 100 I=1,N
           DBETA=dble(P(I,3)/P(I,4))
           IF(ABS(DBETA).GE.1.D0) THEN
              DB=dble(HINT1(2))
              IF(DB.GT.0.99999999D0) THEN 
C                ********Rescale boost vector if too close to unity. 
                 WRITE(6,*) '(HIBOOT:) boost vector too large' 
                 DB=0.99999999D0
              ENDIF 
              DGA=1D0/SQRT(1D0-DB**2)
              DP3=dble(P(I,3))
              DP4=dble(P(I,4))
              P(I,3)=sngl((DP3+DB*DP4)*DGA)
              P(I,4)=sngl((DP4+DB*DP3)*DGA)
              GO TO 100
           ENDIF
           Y=0.5*sngl(DLOG((1.D0+DBETA)/(1.D0-DBETA)))
           AMT=SQRT(P(I,1)**2+P(I,2)**2+P(I,5)**2)
           P(I,3)=AMT*SINH(Y+HINT1(3))
           P(I,4)=AMT*COSH(Y+HINT1(3))
100        CONTINUE
        RETURN
        END
C
C
C
C
        SUBROUTINE QUENCH(JPJT,NTP)
        PARAMETER (MAXSTR=150001)
        DIMENSION RDP(300),LQP(300),RDT(300),LQT(300)
        COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
C
        COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &                PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &                PJPM(300,500),NTJ(300),KFTJ(300,500),
     &                PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &                PJTE(300,500),PJTM(300,500)
cc      SAVE /HJJET1/
        COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &       K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &       PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
        COMMON/HSTRNG/NFP(300,15),PP(300,15),NFT(300,15),PT(300,15)
cc      SAVE /HSTRNG/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   
C
c     Uzhi:
        BB=HINT1(19)
        PHI=HINT1(20)
        BBX=BB*COS(PHI)
        BBY=BB*SIN(PHI)
c
        IF(NTP.EQ.2) GO TO 400
        IF(NTP.EQ.3) GO TO 2000 
C*******************************************************
C Jet interaction for proj jet in the direction PHIP
C******************************************************
C
        IF(NFP(JPJT,7).NE.1) RETURN

        JP=JPJT
        DO 290 I=1,NPJ(JP)
           PTJET0=SQRT(PJPX(JP,I)**2+PJPY(JP,I)**2)
           IF(PTJET0.LE.HIPR1(11)) GO TO 290
           PTOT=SQRT(PTJET0*PTJET0+PJPZ(JP,I)**2)
           IF(PTOT.LT.HIPR1(8)) GO TO 290
           PHIP=ULANGL(PJPX(JP,I),PJPY(JP,I))
C******* find the wounded proj which can interact with jet***
           KP=0
           DO 100 I2=1,IHNT2(1)
              IF(NFP(I2,5).NE.3 .OR. I2.EQ.JP) GO TO 100
              DX=YP(1,I2)-YP(1,JP)
              DY=YP(2,I2)-YP(2,JP)
              PHI=ULANGL(DX,DY)
              DPHI=ABS(PHI-PHIP)
c     Uzhi:
              IF(DPHI.GE.HIPR1(40)) DPHI=2.*HIPR1(40)-DPHI
              IF(DPHI.GE.HIPR1(40)/2.0) GO TO 100
              RD0=SQRT(DX*DX+DY*DY)
              IF(RD0*SIN(DPHI).GT.HIPR1(12)) GO TO 100
              KP=KP+1
              LQP(KP)=I2
              RDP(KP)=COS(DPHI)*RD0
 100           CONTINUE
C*******        rearrange according decending rd************
           DO 110 I2=1,KP-1
              DO 110 J2=I2+1,KP
                 IF(RDP(I2).LT.RDP(J2)) GO TO 110
                 RD=RDP(I2)
                 LQ=LQP(I2)
                 RDP(I2)=RDP(J2)
                 LQP(I2)=LQP(J2)
                 RDP(J2)=RD
                 LQP(J2)=LQ
 110              CONTINUE
C****** find wounded targ which can interact with jet********
              KT=0
              DO 120 I2=1,IHNT2(3)
                 IF(NFT(I2,5).NE.3) GO TO 120
                 DX=YT(1,I2)-YP(1,JP)-BBX
                 DY=YT(2,I2)-YP(2,JP)-BBY
                 PHI=ULANGL(DX,DY)
                 DPHI=ABS(PHI-PHIP)
c     Uzhi:
                 IF(DPHI.GE.HIPR1(40)) DPHI=2.*HIPR1(40)-DPHI
                 IF(DPHI.GT.HIPR1(40)/2.0) GO TO 120
                 RD0=SQRT(DX*DX+DY*DY)
                 IF(RD0*SIN(DPHI).GT.HIPR1(12)) GO TO 120
                 KT=KT+1
                 LQT(KT)=I2
                 RDT(KT)=COS(DPHI)*RD0
 120              CONTINUE
C*******        rearrange according decending rd************
              DO 130 I2=1,KT-1
                 DO 130 J2=I2+1,KT
                    IF(RDT(I2).LT.RDT(J2)) GO TO 130
                    RD=RDT(I2)
                    LQ=LQT(I2)
                    RDT(I2)=RDT(J2)
                    LQT(I2)=LQT(J2)
                    RDT(J2)=RD
                    LQT(J2)=LQ
 130                 CONTINUE
                
                 MP=0
                 MT=0
                 R0=0.0
                 NQ=0
                 DP=0.0
                 PTOT=SQRT(PJPX(JP,I)**2+PJPY(JP,I)**2+PJPZ(JP,I)**2)
                 V1=PJPX(JP,I)/PTOT
                 V2=PJPY(JP,I)/PTOT
                 V3=PJPZ(JP,I)/PTOT

 200                 RN=RANART(NSEED)
 210                 IF(MT.GE.KT .AND. MP.GE.KP) GO TO 290
                 IF(MT.GE.KT) GO TO 220
                 IF(MP.GE.KP) GO TO 240
                 IF(RDP(MP+1).GT.RDT(MT+1)) GO TO 240
 220                 MP=MP+1
                 DRR=RDP(MP)-R0
                 IF(RN.GE.1.0-EXP(-DRR/HIPR1(13))) GO TO 210
                 DP=DRR*HIPR1(14)
                 IF(KFPJ(JP,I).NE.21) DP=0.5*DP
C        ********string tension of quark jet is 0.5 of gluon's 
                 IF(DP.LE.0.2) GO TO 210
                 IF(PTOT.LE.0.4) GO TO 290
                 IF(PTOT.LE.DP) DP=PTOT-0.2
                 DE=DP

                 IF(KFPJ(JP,I).NE.21) THEN
                    PRSHU=PP(LQP(MP),1)**2+PP(LQP(MP),2)**2
     &                   +PP(LQP(MP),3)**2
                    DE=SQRT(PJPM(JP,I)**2+PTOT**2)
     &                        -SQRT(PJPM(JP,I)**2+(PTOT-DP)**2)
                    ERSHU=(PP(LQP(MP),4)+DE-DP)**2
                    AMSHU=ERSHU-PRSHU
                    IF(AMSHU.LT.HIPR1(1)*HIPR1(1)) GO TO 210
                    PP(LQP(MP),4)=SQRT(ERSHU)
                    PP(LQP(MP),5)=SQRT(AMSHU)
                 ENDIF
C                ********reshuffle the energy when jet has mass
                 R0=RDP(MP)
                 DP1=DP*V1
                 DP2=DP*V2
                 DP3=DP*V3
C                ********momentum and energy transfer from jet
                 
                 NPJ(LQP(MP))=NPJ(LQP(MP))+1
                 KFPJ(LQP(MP),NPJ(LQP(MP)))=21
                 PJPX(LQP(MP),NPJ(LQP(MP)))=DP1
                 PJPY(LQP(MP),NPJ(LQP(MP)))=DP2
                 PJPZ(LQP(MP),NPJ(LQP(MP)))=DP3
                 PJPE(LQP(MP),NPJ(LQP(MP)))=DP
                 PJPM(LQP(MP),NPJ(LQP(MP)))=0.0
                 GO TO 260

 240                 MT=MT+1
                 DRR=RDT(MT)-R0
                 IF(RN.GE.1.0-EXP(-DRR/HIPR1(13))) GO TO 210
                 DP=DRR*HIPR1(14)
                 IF(DP.LE.0.2) GO TO 210
                 IF(PTOT.LE.0.4) GO TO 290
                 IF(PTOT.LE.DP) DP=PTOT-0.2
                 DE=DP

                 IF(KFPJ(JP,I).NE.21) THEN
                    PRSHU=PT(LQT(MT),1)**2+PT(LQT(MT),2)**2
     &                   +PT(LQT(MT),3)**2
                    DE=SQRT(PJPM(JP,I)**2+PTOT**2)
     &                        -SQRT(PJPM(JP,I)**2+(PTOT-DP)**2)
                    ERSHU=(PT(LQT(MT),4)+DE-DP)**2
                    AMSHU=ERSHU-PRSHU
                    IF(AMSHU.LT.HIPR1(1)*HIPR1(1)) GO TO 210
                    PT(LQT(MT),4)=SQRT(ERSHU)
                    PT(LQT(MT),5)=SQRT(AMSHU)
                 ENDIF
C                ********reshuffle the energy when jet has mass

                 R0=RDT(MT)
                 DP1=DP*V1
                 DP2=DP*V2
                 DP3=DP*V3
C                ********momentum and energy transfer from jet
                 NTJ(LQT(MT))=NTJ(LQT(MT))+1
                 KFTJ(LQT(MT),NTJ(LQT(MT)))=21
                 PJTX(LQT(MT),NTJ(LQT(MT)))=DP1
                 PJTY(LQT(MT),NTJ(LQT(MT)))=DP2
                 PJTZ(LQT(MT),NTJ(LQT(MT)))=DP3
                 PJTE(LQT(MT),NTJ(LQT(MT)))=DP
                 PJTM(LQT(MT),NTJ(LQT(MT)))=0.0

 260                 PJPX(JP,I)=(PTOT-DP)*V1
                 PJPY(JP,I)=(PTOT-DP)*V2
                 PJPZ(JP,I)=(PTOT-DP)*V3
                 PJPE(JP,I)=PJPE(JP,I)-DE

                 PTOT=PTOT-DP
                 NQ=NQ+1
                 GO TO 200
 290              CONTINUE

              RETURN

C*******************************************************
C Jet interaction for target jet in the direction PHIT
C******************************************************
C
C******* find the wounded proj which can interact with jet***

 400              IF(NFT(JPJT,7).NE.1) RETURN
              JT=JPJT
              DO 690 I=1,NTJ(JT)
                 PTJET0=SQRT(PJTX(JT,I)**2+PJTY(JT,I)**2)
                 IF(PTJET0.LE.HIPR1(11)) GO TO 690
                 PTOT=SQRT(PTJET0*PTJET0+PJTZ(JT,I)**2)
                 IF(PTOT.LT.HIPR1(8)) GO TO 690
                 PHIT=ULANGL(PJTX(JT,I),PJTY(JT,I))
                 KP=0
                 DO 500 I2=1,IHNT2(1)
                    IF(NFP(I2,5).NE.3) GO TO 500
                    DX=YP(1,I2)+BBX-YT(1,JT)
                    DY=YP(2,I2)+BBY-YT(2,JT)
                    PHI=ULANGL(DX,DY)
                    DPHI=ABS(PHI-PHIT)
c     Uzhi:
                    IF(DPHI.GE.HIPR1(40)) DPHI=2.*HIPR1(40)-DPHI
                    IF(DPHI.GT.HIPR1(40)/2.0) GO TO 500
                    RD0=SQRT(DX*DX+DY*DY)
                    IF(RD0*SIN(DPHI).GT.HIPR1(12)) GO TO 500
                    KP=KP+1
                    LQP(KP)=I2
                    RDP(KP)=COS(DPHI)*RD0
 500                 CONTINUE
C*******        rearrange according to decending rd************
                 DO 510 I2=1,KP-1
                    DO 510 J2=I2+1,KP
                       IF(RDP(I2).LT.RDP(J2)) GO TO 510
                       RD=RDP(I2)
                       LQ=LQP(I2)
                       RDP(I2)=RDP(J2)
                       LQP(I2)=LQP(J2)
                       RDP(J2)=RD
                       LQP(J2)=LQ
 510                    CONTINUE
C****** find wounded targ which can interact with jet********
                    KT=0
                    DO 520 I2=1,IHNT2(3)
                       IF(NFT(I2,5).NE.3 .OR. I2.EQ.JT) GO TO 520
                       DX=YT(1,I2)-YT(1,JT)
                       DY=YT(2,I2)-YT(2,JT)
                       PHI=ULANGL(DX,DY)
                       DPHI=ABS(PHI-PHIT)
c     Uzhi:
                       IF(DPHI.GE.HIPR1(40)) DPHI=2.*HIPR1(40)-DPHI
                       IF(DPHI.GT.HIPR1(40)/2.0) GO TO 520
                       RD0=SQRT(DX*DX+DY*DY)
                       IF(RD0*SIN(DPHI).GT.HIPR1(12)) GO TO 520
                       KT=KT+1
                       LQT(KT)=I2
                       RDT(KT)=COS(DPHI)*RD0
 520                    CONTINUE
C*******        rearrange according to decending rd************
                    DO 530 I2=1,KT-1
                       DO 530 J2=I2+1,KT
                          IF(RDT(I2).LT.RDT(J2)) GO TO 530
                          RD=RDT(I2)
                          LQ=LQT(I2)
                          RDT(I2)=RDT(J2)
                          LQT(I2)=LQT(J2)
                          RDT(J2)=RD
                          LQT(J2)=LQ
 530                       CONTINUE
                       
                       MP=0
                       MT=0
                       NQ=0
                       DP=0.0
                       R0=0.0
                PTOT=SQRT(PJTX(JT,I)**2+PJTY(JT,I)**2+PJTZ(JT,I)**2)
                V1=PJTX(JT,I)/PTOT
                V2=PJTY(JT,I)/PTOT
                V3=PJTZ(JT,I)/PTOT

 600                RN=RANART(NSEED)
 610                IF(MT.GE.KT .AND. MP.GE.KP) GO TO 690
                IF(MT.GE.KT) GO TO 620
                IF(MP.GE.KP) GO TO 640
                IF(RDP(MP+1).GT.RDT(MT+1)) GO TO 640
620                MP=MP+1
                DRR=RDP(MP)-R0
                IF(RN.GE.1.0-EXP(-DRR/HIPR1(13))) GO TO 610
                DP=DRR*HIPR1(14)
                IF(KFTJ(JT,I).NE.21) DP=0.5*DP
C        ********string tension of quark jet is 0.5 of gluon's 
                IF(DP.LE.0.2) GO TO 610
                IF(PTOT.LE.0.4) GO TO 690
                IF(PTOT.LE.DP) DP=PTOT-0.2
                DE=DP
C
                IF(KFTJ(JT,I).NE.21) THEN
                   PRSHU=PP(LQP(MP),1)**2+PP(LQP(MP),2)**2
     &                   +PP(LQP(MP),3)**2
                   DE=SQRT(PJTM(JT,I)**2+PTOT**2)
     &                     -SQRT(PJTM(JT,I)**2+(PTOT-DP)**2)
                   ERSHU=(PP(LQP(MP),4)+DE-DP)**2
                   AMSHU=ERSHU-PRSHU
                   IF(AMSHU.LT.HIPR1(1)*HIPR1(1)) GO TO 610
                   PP(LQP(MP),4)=SQRT(ERSHU)
                   PP(LQP(MP),5)=SQRT(AMSHU)
                ENDIF
C                ********reshuffle the energy when jet has mass
C
                R0=RDP(MP)
                DP1=DP*V1
                DP2=DP*V2
                DP3=DP*V3
C                ********momentum and energy transfer from jet
                NPJ(LQP(MP))=NPJ(LQP(MP))+1
                KFPJ(LQP(MP),NPJ(LQP(MP)))=21
                PJPX(LQP(MP),NPJ(LQP(MP)))=DP1
                PJPY(LQP(MP),NPJ(LQP(MP)))=DP2
                PJPZ(LQP(MP),NPJ(LQP(MP)))=DP3
                PJPE(LQP(MP),NPJ(LQP(MP)))=DP
                PJPM(LQP(MP),NPJ(LQP(MP)))=0.0

                GO TO 660

640                MT=MT+1
                DRR=RDT(MT)-R0
                IF(RN.GE.1.0-EXP(-DRR/HIPR1(13))) GO TO 610
                DP=DRR*HIPR1(14)
                IF(DP.LE.0.2) GO TO 610
                IF(PTOT.LE.0.4) GO TO 690
                IF(PTOT.LE.DP) DP=PTOT-0.2
                DE=DP

                IF(KFTJ(JT,I).NE.21) THEN
                   PRSHU=PT(LQT(MT),1)**2+PT(LQT(MT),2)**2
     &                   +PT(LQT(MT),3)**2
                   DE=SQRT(PJTM(JT,I)**2+PTOT**2)
     &                     -SQRT(PJTM(JT,I)**2+(PTOT-DP)**2)
                   ERSHU=(PT(LQT(MT),4)+DE-DP)**2
                   AMSHU=ERSHU-PRSHU
                   IF(AMSHU.LT.HIPR1(1)*HIPR1(1)) GO TO 610
                   PT(LQT(MT),4)=SQRT(ERSHU)
                   PT(LQT(MT),5)=SQRT(AMSHU)
                ENDIF
C                ********reshuffle the energy when jet has mass

                R0=RDT(MT)
                DP1=DP*V1
                DP2=DP*V2
                DP3=DP*V3
C                ********momentum and energy transfer from jet
                NTJ(LQT(MT))=NTJ(LQT(MT))+1
                KFTJ(LQT(MT),NTJ(LQT(MT)))=21
                PJTX(LQT(MT),NTJ(LQT(MT)))=DP1
                PJTY(LQT(MT),NTJ(LQT(MT)))=DP2
                PJTZ(LQT(MT),NTJ(LQT(MT)))=DP3
                PJTE(LQT(MT),NTJ(LQT(MT)))=DP
                PJTM(LQT(MT),NTJ(LQT(MT)))=0.0

660                PJTX(JT,I)=(PTOT-DP)*V1
                PJTY(JT,I)=(PTOT-DP)*V2
                PJTZ(JT,I)=(PTOT-DP)*V3
                PJTE(JT,I)=PJTE(JT,I)-DE

                PTOT=PTOT-DP
                NQ=NQ+1
                GO TO 600
690        CONTINUE
        RETURN
C********************************************************
C        Q-QBAR jet interaction
C********************************************************
2000        ISG=JPJT
        IF(IASG(ISG,3).NE.1) RETURN
C
        JP=IASG(ISG,1)
        JT=IASG(ISG,2)
        XJ=(YP(1,JP)+BBX+YT(1,JT))/2.0
        YJ=(YP(2,JP)+BBY+YT(2,JT))/2.0
        DO 2690 I=1,NJSG(ISG)
           PTJET0=SQRT(PXSG(ISG,I)**2+PYSG(ISG,I)**2)
           IF(PTJET0.LE.HIPR1(11).OR.PESG(ISG,I).LT.HIPR1(1))
     &            GO TO 2690
           PTOT=SQRT(PTJET0*PTJET0+PZSG(ISG,I)**2)
           IF(PTOT.LT.MAX(HIPR1(1),HIPR1(8))) GO TO 2690
           PHIQ=ULANGL(PXSG(ISG,I),PYSG(ISG,I))
           KP=0
           DO 2500 I2=1,IHNT2(1)
              IF(NFP(I2,5).NE.3.OR.I2.EQ.JP) GO TO 2500
              DX=YP(1,I2)+BBX-XJ
              DY=YP(2,I2)+BBY-YJ
              PHI=ULANGL(DX,DY)
              DPHI=ABS(PHI-PHIQ)
c     Uzhi:
              IF(DPHI.GE.HIPR1(40)) DPHI=2.*HIPR1(40)-DPHI
              IF(DPHI.GT.HIPR1(40)/2.0) GO TO 2500
              RD0=SQRT(DX*DX+DY*DY)
              IF(RD0*SIN(DPHI).GT.HIPR1(12)) GO TO 2500
              KP=KP+1
              LQP(KP)=I2
              RDP(KP)=COS(DPHI)*RD0
 2500           CONTINUE
C*******        rearrange according to decending rd************
           DO 2510 I2=1,KP-1
              DO 2510 J2=I2+1,KP
                 IF(RDP(I2).LT.RDP(J2)) GO TO 2510
                 RD=RDP(I2)
                 LQ=LQP(I2)
                 RDP(I2)=RDP(J2)
                 LQP(I2)=LQP(J2)
                 RDP(J2)=RD
                 LQP(J2)=LQ
 2510              CONTINUE
C****** find wounded targ which can interact with jet********
              KT=0
              DO 2520 I2=1,IHNT2(3)
                 IF(NFT(I2,5).NE.3 .OR. I2.EQ.JT) GO TO 2520
                 DX=YT(1,I2)-XJ
                 DY=YT(2,I2)-YJ
                 PHI=ULANGL(DX,DY)
                 DPHI=ABS(PHI-PHIQ)
c     Uzhi:
                 IF(DPHI.GE.HIPR1(40)) DPHI=2.*HIPR1(40)-DPHI
                 IF(DPHI.GT.HIPR1(40)/2.0) GO TO 2520
                 RD0=SQRT(DX*DX+DY*DY)
                 IF(RD0*SIN(DPHI).GT.HIPR1(12)) GO TO 2520
                 KT=KT+1
                 LQT(KT)=I2
                 RDT(KT)=COS(DPHI)*RD0
 2520              CONTINUE
C*******        rearrange according to decending rd************
              DO 2530 I2=1,KT-1
                 DO 2530 J2=I2+1,KT
                    IF(RDT(I2).LT.RDT(J2)) GO TO 2530
                    RD=RDT(I2)
                    LQ=LQT(I2)
                    RDT(I2)=RDT(J2)
                    LQT(I2)=LQT(J2)
                    RDT(J2)=RD
                    LQT(J2)=LQ
 2530                 CONTINUE
                
                 MP=0
                 MT=0
                 NQ=0
                 DP=0.0
                 R0=0.0
                 PTOT=SQRT(PXSG(ISG,I)**2+PYSG(ISG,I)**2
     &                +PZSG(ISG,I)**2)
                 V1=PXSG(ISG,I)/PTOT
                 V2=PYSG(ISG,I)/PTOT
                 V3=PZSG(ISG,I)/PTOT

 2600                 RN=RANART(NSEED)
 2610                 IF(MT.GE.KT .AND. MP.GE.KP) GO TO 2690
                 IF(MT.GE.KT) GO TO 2620
                 IF(MP.GE.KP) GO TO 2640
                 IF(RDP(MP+1).GT.RDT(MT+1)) GO TO 2640
 2620                 MP=MP+1
                 DRR=RDP(MP)-R0
                 IF(RN.GE.1.0-EXP(-DRR/HIPR1(13))) GO TO 2610
                 DP=DRR*HIPR1(14)/2.0
                 IF(DP.LE.0.2) GO TO 2610
                 IF(PTOT.LE.0.4) GO TO 2690
                 IF(PTOT.LE.DP) DP=PTOT-0.2
                 DE=DP
C
                 IF(K2SG(ISG,I).NE.21) THEN
                    IF(PTOT.LT.DP+HIPR1(1)) GO TO 2690
                    PRSHU=PP(LQP(MP),1)**2+PP(LQP(MP),2)**2
     &                    +PP(LQP(MP),3)**2
                    DE=SQRT(PMSG(ISG,I)**2+PTOT**2)
     &                       -SQRT(PMSG(ISG,I)**2+(PTOT-DP)**2)
                    ERSHU=(PP(LQP(MP),4)+DE-DP)**2
                    AMSHU=ERSHU-PRSHU
                    IF(AMSHU.LT.HIPR1(1)*HIPR1(1)) GO TO 2610
                    PP(LQP(MP),4)=SQRT(ERSHU)
                    PP(LQP(MP),5)=SQRT(AMSHU)
                 ENDIF
C                ********reshuffle the energy when jet has mass
C
                 R0=RDP(MP)
                 DP1=DP*V1
                 DP2=DP*V2
                 DP3=DP*V3
C                ********momentum and energy transfer from jet
                 NPJ(LQP(MP))=NPJ(LQP(MP))+1
                 KFPJ(LQP(MP),NPJ(LQP(MP)))=21
                 PJPX(LQP(MP),NPJ(LQP(MP)))=DP1
                 PJPY(LQP(MP),NPJ(LQP(MP)))=DP2
                 PJPZ(LQP(MP),NPJ(LQP(MP)))=DP3
                 PJPE(LQP(MP),NPJ(LQP(MP)))=DP
                 PJPM(LQP(MP),NPJ(LQP(MP)))=0.0

                 GO TO 2660

 2640                 MT=MT+1
                 DRR=RDT(MT)-R0
                 IF(RN.GE.1.0-EXP(-DRR/HIPR1(13))) GO TO 2610
                 DP=DRR*HIPR1(14)
                 IF(DP.LE.0.2) GO TO 2610
                 IF(PTOT.LE.0.4) GO TO 2690
                 IF(PTOT.LE.DP) DP=PTOT-0.2
                 DE=DP

                 IF(K2SG(ISG,I).NE.21) THEN
                    IF(PTOT.LT.DP+HIPR1(1)) GO TO 2690
                    PRSHU=PT(LQT(MT),1)**2+PT(LQT(MT),2)**2
     &                    +PT(LQT(MT),3)**2
                    DE=SQRT(PMSG(ISG,I)**2+PTOT**2)
     &                       -SQRT(PMSG(ISG,I)**2+(PTOT-DP)**2)
                    ERSHU=(PT(LQT(MT),4)+DE-DP)**2
                    AMSHU=ERSHU-PRSHU
                    IF(AMSHU.LT.HIPR1(1)*HIPR1(1)) GO TO 2610
                    PT(LQT(MT),4)=SQRT(ERSHU)
                    PT(LQT(MT),5)=SQRT(AMSHU)
                 ENDIF
C               ********reshuffle the energy when jet has mass

                 R0=RDT(MT)
                 DP1=DP*V1
                 DP2=DP*V2
                 DP3=DP*V3
C                ********momentum and energy transfer from jet
                 NTJ(LQT(MT))=NTJ(LQT(MT))+1
                 KFTJ(LQT(MT),NTJ(LQT(MT)))=21
                 PJTX(LQT(MT),NTJ(LQT(MT)))=DP1
                 PJTY(LQT(MT),NTJ(LQT(MT)))=DP2
                 PJTZ(LQT(MT),NTJ(LQT(MT)))=DP3
                 PJTE(LQT(MT),NTJ(LQT(MT)))=DP
                 PJTM(LQT(MT),NTJ(LQT(MT)))=0.0

 2660                 PXSG(ISG,I)=(PTOT-DP)*V1
                 PYSG(ISG,I)=(PTOT-DP)*V2
                 PZSG(ISG,I)=(PTOT-DP)*V3
                 PESG(ISG,I)=PESG(ISG,I)-DE

                 PTOT=PTOT-DP
                 NQ=NQ+1
                 GO TO 2600
 2690        CONTINUE
        RETURN
        END

C
C
C
C
        SUBROUTINE HIJFRG(JTP,NTP,IERROR)
C        NTP=1, fragment proj string, NTP=2, targ string, 
C       NTP=3, independent 
C        strings from jets.  JTP is the line number of the string
C*******Fragment all leadng strings of proj and targ**************
C        IHNT2(1)=atomic #, IHNT2(2)=proton #(=-1 if anti-proton)  *
C******************************************************************
        PARAMETER (MAXSTR=150001)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/HIJDAT/HIDAT0(10,10),HIDAT(10)
cc      SAVE /HIJDAT/
        COMMON/HSTRNG/NFP(300,15),PP(300,15),NFT(300,15),PT(300,15)
cc      SAVE /HSTRNG/
        COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &                PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &                PJPM(300,500),NTJ(300),KFTJ(300,500),
     &                PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &                PJTE(300,500),PJTM(300,500)
cc      SAVE /HJJET1/
        COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &       K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &       PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
C
        COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
cc      SAVE /LUJETS/
        COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
cc      SAVE /LUDAT1/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
clin-4/11/01 soft:
      common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
        SAVE   
        
cbz3/12/99
c.....set up fragmentation function according to the number of collisions
c.....a wounded nucleon has suffered
c        IF (NTP .EQ. 1) THEN
c           NCOLL = NFP(JTP, 11)
c        ELSE IF (NTP .EQ. 2) THEN
c           NCOLL = NFT(JTP, 11)
c        ELSE IF (NTP .EQ. 3) THEN
c           NCOLL = (NFP(IASG(JTP,1), 11) + NFT(IASG(JTP,2), 11)) / 2
c        END IF
c        IF (NCOLL .LE. 1) THEN
c           PARJ(5) = 0.5
c        ELSE IF (NCOLL .EQ. 2) THEN
c           PARJ(5) = 0.75
c        ELSE IF (NCOLL .EQ. 3) THEN
c           PARJ(5) = 1.17
c        ELSE IF (NCOLL .EQ. 4) THEN
c           PARJ(5) = 2.0
c        ELSE IF (NCOLL .EQ. 5) THEN
c           PARJ(5) = 4.5
c        ELSE IF (NCOLL .GE. 6) THEN
c           PARJ(5) = 49.5
c        END IF
c        PARJ(5) = 0.5
cbz3/12/99 end

        IERROR=0
        CALL LUEDIT(0)
        N=0
C                        ********initialize the document lines
        IF(NTP.EQ.3) THEN
                ISG=JTP
                N=NJSG(ISG)
                DO 100 I=1,NJSG(ISG)
                   K(I,1)=K1SG(ISG,I)
                   K(I,2)=K2SG(ISG,I)
                   P(I,1)=PXSG(ISG,I)
                   P(I,2)=PYSG(ISG,I)
                   P(I,3)=PZSG(ISG,I)
                   P(I,4)=PESG(ISG,I)
                   P(I,5)=PMSG(ISG,I)
 100            CONTINUE

C                IF(IHPR2(1).GT.0) CALL ATTRAD(IERROR)
c                IF(IERROR.NE.0) RETURN
C                CALL LULIST(1)
                if(isoft.ne.2.or.isflag.ne.0) CALL LUEXEC
             RETURN
        ENDIF
C
        IF(NTP.EQ.2) GO TO 200
        IF(JTP.GT.IHNT2(1))   RETURN
        IF(NFP(JTP,5).NE.3.AND.NFP(JTP,3).NE.0
     &            .AND.NPJ(JTP).EQ.0.AND.NFP(JTP,10).EQ.0) GO TO 1000
        IF(NFP(JTP,15).EQ.-1) THEN
                KF1=NFP(JTP,2)
                KF2=NFP(JTP,1)
                PQ21=PP(JTP,6)
                PQ22=PP(JTP,7)
                PQ11=PP(JTP,8)
                PQ12=PP(JTP,9)
                AM1=PP(JTP,15)
                AM2=PP(JTP,14)
        ELSE
                KF1=NFP(JTP,1)
                KF2=NFP(JTP,2)
                PQ21=PP(JTP,8)
                PQ22=PP(JTP,9)
                PQ11=PP(JTP,6)
                PQ12=PP(JTP,7)
                AM1=PP(JTP,14)
                AM2=PP(JTP,15)        
        ENDIF

C        ********for NFP(JTP,15)=-1 NFP(JTP,1) IS IN -Z DIRECTION
        PB1=PQ11+PQ21
        PB2=PQ12+PQ22
        PB3=PP(JTP,3)
        PECM=PP(JTP,5)
        BTZ=PB3/PP(JTP,4)
        IF((ABS(PB1-PP(JTP,1)).GT.0.01.OR.
     &     ABS(PB2-PP(JTP,2)).GT.0.01).AND.IHPR2(10).NE.0)
     &     WRITE(6,*) '  Pt of Q and QQ do not sum to the total',jtp
     &     ,ntp,pq11,pq21,pb1,'*',pq12,pq22,pb2,'*',pp(JTP,1),pp(JTP,2)
        GO TO 300

200        IF(JTP.GT.IHNT2(3))  RETURN
        IF(NFT(JTP,5).NE.3.AND.NFT(JTP,3).NE.0
     &           .AND.NTJ(JTP).EQ.0.AND.NFT(JTP,10).EQ.0) GO TO 1200
        IF(NFT(JTP,15).EQ.1) THEN
                KF1=NFT(JTP,1)
                KF2=NFT(JTP,2)
                PQ11=PT(JTP,6)
                PQ12=PT(JTP,7)
                PQ21=PT(JTP,8)
                PQ22=PT(JTP,9)
                AM1=PT(JTP,14)
                AM2=PT(JTP,15)
        ELSE
                KF1=NFT(JTP,2)
                KF2=NFT(JTP,1)
                PQ11=PT(JTP,8)
                PQ12=PT(JTP,9)
                PQ21=PT(JTP,6)
                PQ22=PT(JTP,7)
                AM1=PT(JTP,15)
                AM2=PT(JTP,14)
        ENDIF        
C        ********for NFT(JTP,15)=1 NFT(JTP,1) IS IN +Z DIRECTION
        PB1=PQ11+PQ21
        PB2=PQ12+PQ22
        PB3=PT(JTP,3)
        PECM=PT(JTP,5)
        BTZ=PB3/PT(JTP,4)

        IF((ABS(PB1-PT(JTP,1)).GT.0.01.OR.
     &     ABS(PB2-PT(JTP,2)).GT.0.01).AND.IHPR2(10).NE.0)
     &     WRITE(6,*) '  Pt of Q and QQ do not sum to the total',jtp
     &     ,ntp,pq11,pq21,pb1,'*',pq12,pq22,pb2,'*',pt(JTP,1),pt(JTP,2)
300        IF(PECM.LT.HIPR1(1)) THEN
           IERROR=1
           IF(IHPR2(10).EQ.0) RETURN
           WRITE(6,*) ' ECM=',PECM,' energy of the string is too small'
clin:
           write (6,*) 'JTP,NTP,pq=',JTP,NTP,pq11,pq12,pq21,pq22
           RETURN
        ENDIF
        AMT=PECM**2+PB1**2+PB2**2
        AMT1=AM1**2+PQ11**2+PQ12**2
        AMT2=AM2**2+PQ21**2+PQ22**2
        PZCM=SQRT(ABS(AMT**2+AMT1**2+AMT2**2-2.0*AMT*AMT1
     &       -2.0*AMT*AMT2-2.0*AMT1*AMT2))/2.0/SQRT(AMT)
C                *******PZ of end-partons in c.m. frame of the string
        K(1,1)=2
        K(1,2)=KF1
        P(1,1)=PQ11
        P(1,2)=PQ12
        P(1,3)=PZCM
        P(1,4)=SQRT(AMT1+PZCM**2)
        P(1,5)=AM1
        K(2,1)=1
        K(2,2)=KF2
        P(2,1)=PQ21
        P(2,2)=PQ22
        P(2,3)=-PZCM
        P(2,4)=SQRT(AMT2+PZCM**2)
        P(2,5)=AM2
        N=2
C*****
        CALL HIROBO(0.0,0.0,0.0,0.0,BTZ)
        JETOT=0
        IF((PQ21**2+PQ22**2).GT.(PQ11**2+PQ12**2)) THEN
                PMAX1=P(2,1)
                PMAX2=P(2,2)
                PMAX3=P(2,3)
        ELSE
                PMAX1=P(1,1)
                PMAX2=P(1,2)
                PMAX3=P(1,3)
        ENDIF
        IF(NTP.EQ.1) THEN
                PP(JTP,10)=PMAX1
                PP(JTP,11)=PMAX2
                PP(JTP,12)=PMAX3
        ELSE IF(NTP.EQ.2) THEN
                PT(JTP,10)=PMAX1
                PT(JTP,11)=PMAX2
                PT(JTP,12)=PMAX3
        ENDIF
C*******************attach produced jets to the leadng partons****
        IF(NTP.EQ.1.AND.NPJ(JTP).NE.0) THEN
                JETOT=NPJ(JTP)
C                IF(NPJ(JTP).GE.2) CALL HIJSRT(JTP,1)
C                        ********sort jets in order of y
                IEX=0
                IF((ABS(KF1).GT.1000.AND.KF1.LT.0)
     &                        .OR.(ABS(KF1).LT.1000.AND.KF1.GT.0)) IEX=1
                DO 520 I=N,2,-1
                DO 520 J=1,5
                        II=NPJ(JTP)+I
                        K(II,J)=K(I,J)
                        P(II,J)=P(I,J)
                        V(II,J)=V(I,J)
520                CONTINUE

                DO 540 I=1,NPJ(JTP)
                        DO 542 J=1,5
                                K(I+1,J)=0
                                V(I+1,J)=0
542                        CONTINUE                                
                        I0=I
clin-4/12/01:                        IF(IEX.EQ.1) I0=NPJ(JTP)-I+1
                        IF(IEX.EQ.1.and.(isoft.ne.2.or.isflag.ne.0))
     1 I0=NPJ(JTP)-I+1
C                                ********reverse the order of jets
                        KK1=KFPJ(JTP,I0)
                        K(I+1,1)=2
                        K(I+1,2)=KK1
                        IF(KK1.NE.21 .AND. KK1.NE.0)  K(I+1,1)=
     &                          1+(ABS(KK1)+(2*IEX-1)*KK1)/2/ABS(KK1)
                        P(I+1,1)=PJPX(JTP,I0)
                        P(I+1,2)=PJPY(JTP,I0)
                        P(I+1,3)=PJPZ(JTP,I0)
                        P(I+1,4)=PJPE(JTP,I0)
                        P(I+1,5)=PJPM(JTP,I0)
540                CONTINUE
                N=N+NPJ(JTP)
        ELSE IF(NTP.EQ.2.AND.NTJ(JTP).NE.0) THEN
                JETOT=NTJ(JTP)
c                IF(NTJ(JTP).GE.2)  CALL HIJSRT(JTP,2)
C                        ********sort jets in order of y
                IEX=1
                IF((ABS(KF2).GT.1000.AND.KF2.LT.0)
     &                        .OR.(ABS(KF2).LT.1000.AND.KF2.GT.0)) IEX=0
                DO 560 I=N,2,-1
                DO 560 J=1,5
                        II=NTJ(JTP)+I
                        K(II,J)=K(I,J)
                        P(II,J)=P(I,J)
                        V(II,J)=V(I,J)
560                CONTINUE
                DO 580 I=1,NTJ(JTP)
                        DO 582 J=1,5
                                K(I+1,J)=0
                                V(I+1,J)=0
582                        CONTINUE                                
                        I0=I
clin-4/12/01:                        IF(IEX.EQ.1) I0=NTJ(JTP)-I+1
                        IF(IEX.EQ.1.and.(isoft.ne.2.or.isflag.ne.0))
     1 I0=NTJ(JTP)-I+1
C                                ********reverse the order of jets
                        KK1=KFTJ(JTP,I0)
                        K(I+1,1)=2
                        K(I+1,2)=KK1
                        IF(KK1.NE.21 .AND. KK1.NE.0) K(I+1,1)=
     &                           1+(ABS(KK1)+(2*IEX-1)*KK1)/2/ABS(KK1)
                        P(I+1,1)=PJTX(JTP,I0)
                        P(I+1,2)=PJTY(JTP,I0)
                        P(I+1,3)=PJTZ(JTP,I0)
                        P(I+1,4)=PJTE(JTP,I0)
                        P(I+1,5)=PJTM(JTP,I0)
580                CONTINUE
                N=N+NTJ(JTP)
        ENDIF
        IF(IHPR2(1).GT.0.AND.RANART(NSEED).LE.HIDAT(3)) THEN
             HDAT20=HIDAT(2)
             HPR150=HIPR1(5)
             IF(IHPR2(8).EQ.0.AND.IHPR2(3).EQ.0.AND.IHPR2(9).EQ.0)
     &                        HIDAT(2)=2.0
             IF(HINT1(1).GE.1000.0.AND.JETOT.EQ.0)THEN
                HIDAT(2)=3.0
                HIPR1(5)=5.0
             ENDIF
             CALL ATTRAD(IERROR)
             HIDAT(2)=HDAT20
             HIPR1(5)=HPR150
        ELSE IF(JETOT.EQ.0.AND.IHPR2(1).GT.0.AND.
     &                       HINT1(1).GE.1000.0.AND.
     &                RANART(NSEED).LE.0.8) THEN
                HDAT20=HIDAT(2)
                HPR150=HIPR1(5)
                HIDAT(2)=3.0
                HIPR1(5)=5.0
             IF(IHPR2(8).EQ.0.AND.IHPR2(3).EQ.0.AND.IHPR2(9).EQ.0)
     &                        HIDAT(2)=2.0
                CALL ATTRAD(IERROR)
                HIDAT(2)=HDAT20
                HIPR1(5)=HPR150
        ENDIF
        IF(IERROR.NE.0) RETURN
C                ******** conduct soft radiations
C****************************
C
C
clin-4/11/01 soft:
c        CALL LUEXEC
        if(isoft.ne.2.or.isflag.ne.0) CALL LUEXEC

        RETURN

1000        N=1
        K(1,1)=1
               K(1,2)=NFP(JTP,3)
        DO 1100 JJ=1,5
                       P(1,JJ)=PP(JTP,JJ)
1100                CONTINUE
C                        ********proj remain as a nucleon or delta
clin-4/11/01 soft:
c        CALL LUEXEC
        if(isoft.ne.2.or.isflag.ne.0) CALL LUEXEC

C        call lulist(1)
        RETURN
C
1200        N=1
        K(1,1)=1
        K(1,2)=NFT(JTP,3)
        DO 1300 JJ=1,5
                P(1,JJ)=PT(JTP,JJ)
1300        CONTINUE
C                        ********targ remain as a nucleon or delta
clin-4/11/01 soft:
c        CALL LUEXEC
        if(isoft.ne.2.or.isflag.ne.0) CALL LUEXEC

C        call lulist(1)
        RETURN
        END
C
C
C
C
C****************************************************************
C        conduct soft radiation according to dipole approxiamtion
C****************************************************************
        SUBROUTINE ATTRAD(IERROR)
C
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/HIJDAT/HIDAT0(10,10),HIDAT(10)
cc      SAVE /HIJDAT/
        COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
cc      SAVE /LUJETS/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   
        IERROR=0

C.....S INVARIANT MASS-SQUARED BETWEEN PARTONS I AND I+1......
C.....SM IS THE LARGEST MASS-SQUARED....

40        SM=0.
        JL=1
        DO 30 I=1,N-1
           S=2.*(P(I,4)*P(I+1,4)-P(I,1)*P(I+1,1)-P(I,2)*P(I+1,2)
     &                -P(I,3)*P(I+1,3))+P(I,5)**2+P(I+1,5)**2
           IF(S.LT.0.) S=0.
           WP=SQRT(S)-1.5*(P(I,5)+P(I+1,5))
           IF(WP.GT.SM) THEN
              PBT1=P(I,1)+P(I+1,1)
              PBT2=P(I,2)+P(I+1,2)
              PBT3=P(I,3)+P(I+1,3)
              PBT4=P(I,4)+P(I+1,4)
              BTT=(PBT1**2+PBT2**2+PBT3**2)/PBT4**2
              IF(BTT.GE.1.0-1.0E-10) GO TO 30
              IF((I.NE.1.OR.I.NE.N-1).AND.
     &             (K(I,2).NE.21.AND.K(I+1,2).NE.21)) GO TO 30
              JL=I
              SM=WP
           ENDIF
30        CONTINUE
        S=(SM+1.5*(P(JL,5)+P(JL+1,5)))**2
              IF(SM.LT.HIPR1(5)) GOTO 2
     
C.....MAKE PLACE FOR ONE GLUON.....
              IF(JL+1.EQ.N) GOTO 190
              DO 160 J=N,JL+2,-1
                      K(J+1,1)=K(J,1)
                K(J+1,2)=K(J,2)
                      DO 150 M=1,5
150                           P(J+1,M)=P(J,M)
160                   CONTINUE
190           N=N+1
     
C.....BOOST TO REST SYSTEM FOR PARTICLES JL AND JL+1.....
              P1=P(JL,1)+P(JL+1,1)
              P2=P(JL,2)+P(JL+1,2)
              P3=P(JL,3)+P(JL+1,3)
              P4=P(JL,4)+P(JL+1,4)
              BEX=-P1/P4
              BEY=-P2/P4
              BEZ=-P3/P4
        IMIN=JL
        IMAX=JL+1
              CALL ATROBO(0.,0.,BEX,BEY,BEZ,IMIN,IMAX,IERROR)
        IF(IERROR.NE.0) RETURN
C.....ROTATE TO Z-AXIS....
              CTH=P(JL,3)/SQRT(P(JL,4)**2-P(JL,5)**2)
              IF(ABS(CTH).GT.1.0)  CTH=MAX(-1.,MIN(1.,CTH))
              THETA=ACOS(CTH)
              PHI=ULANGL(P(JL,1),P(JL,2))
              CALL ATROBO(0.,-PHI,0.,0.,0.,IMIN,IMAX,IERROR)
              CALL ATROBO(-THETA,0.,0.,0.,0.,IMIN,IMAX,IERROR)
     
C.....CREATE ONE GLUON AND ORIENTATE.....
     
1        CALL AR3JET(S,X1,X3,JL)
              CALL ARORIE(S,X1,X3,JL)                
        IF(HIDAT(2).GT.0.0) THEN
                 PTG1=SQRT(P(JL,1)**2+P(JL,2)**2)
                 PTG2=SQRT(P(JL+1,1)**2+P(JL+1,2)**2)
                 PTG3=SQRT(P(JL+2,1)**2+P(JL+2,2)**2)
           PTG=MAX(PTG1,PTG2,PTG3)
           IF(PTG.GT.HIDAT(2)) THEN
              FMFACT=EXP(-(PTG**2-HIDAT(2)**2)/HIPR1(2)**2)
              IF(RANART(NSEED).GT.FMFACT) GO TO 1
           ENDIF
        ENDIF
C.....ROTATE AND BOOST BACK.....
        IMIN=JL
        IMAX=JL+2
              CALL ATROBO(THETA,PHI,-BEX,-BEY,-BEZ,IMIN,IMAX,IERROR)
        IF(IERROR.NE.0) RETURN
C.....ENUMERATE THE GLUONS.....
              K(JL+2,1)=K(JL+1,1)
        K(JL+2,2)=K(JL+1,2)
        K(JL+2,3)=K(JL+1,3)
        K(JL+2,4)=K(JL+1,4)
        K(JL+2,5)=K(JL+1,5)
              P(JL+2,5)=P(JL+1,5)
              K(JL+1,1)=2
        K(JL+1,2)=21
        K(JL+1,3)=0
        K(JL+1,4)=0
        K(JL+1,5)=0
              P(JL+1,5)=0.
C----THETA FUNCTION DAMPING OF THE EMITTED GLUONS. FOR HADRON-HADRON.
C----R0=VFR(2)
C              IF(VFR(2).GT.0.) THEN
C              PTG=SQRT(P(JL+1,1)**2+P(JL+1,2)**2)
C              PTGMAX=WSTRI/2.
C              DOPT=SQRT((4.*PAR(71)*VFR(2))/WSTRI)
C              PTOPT=(DOPT*WSTRI)/(2.*VFR(2))
C              IF(PTG.GT.PTOPT) IORDER=IORDER-1
C              IF(PTG.GT.PTOPT) GOTO 1
C              ENDIF
C-----
             IF(SM.GE.HIPR1(5)) GOTO 40

2              K(1,1)=2
        K(1,3)=0
        K(1,4)=0
        K(1,5)=0
              K(N,1)=1
        K(N,3)=0
        K(N,4)=0
        K(N,5)=0

              RETURN
              END


        SUBROUTINE AR3JET(S,X1,X3,JL)
C     
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
cc      SAVE /LUJETS/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   
C     
        C=1./3.
              IF(K(JL,2).NE.21 .AND. K(JL+1,2).NE.21) C=8./27.
              EXP1=3
              EXP3=3
              IF(K(JL,2).NE.21) EXP1=2
              IF(K(JL+1,2).NE.21) EXP3=2
              A=0.24**2/S
              YMA=ALOG(.5/SQRT(A)+SQRT(.25/A-1))
              D=4.*C*YMA
              SM1=P(JL,5)**2/S
              SM3=P(JL+1,5)**2/S
              XT2M=(1.-2.*SQRT(SM1)+SM1-SM3)*(1.-2.*SQRT(SM3)-SM1+SM3)
              XT2M=MIN(.25,XT2M)
              NTRY=0
1             IF(NTRY.EQ.5000) THEN
                X1=.5*(2.*SQRT(SM1)+1.+SM1-SM3)
                X3=.5*(2.*SQRT(SM3)+1.-SM1+SM3)
                RETURN
              ENDIF
              NTRY=NTRY+1
     
              XT2=A*(XT2M/A)**(RANART(NSEED)**(1./D))
     
              YMAX=ALOG(.5/SQRT(XT2)+SQRT(.25/XT2-1.))
              Y=(2.*RANART(NSEED)-1.)*YMAX
              X1=1.-SQRT(XT2)*EXP(Y)
              X3=1.-SQRT(XT2)*EXP(-Y)
              X2=2.-X1-X3
              NEG=0
              IF(K(JL,2).NE.21 .OR. K(JL+1,2).NE.21) THEN
        IF((1.-X1)*(1.-X2)*(1.-X3)-X2*SM1*(1.-X1)-X2*SM3*(1.-X3).
     &  LE.0..OR.X1.LE.2.*SQRT(SM1)-SM1+SM3.OR.X3.LE.2.*SQRT(SM3)
     &  -SM3+SM1) NEG=1
        X1=X1+SM1-SM3
        X3=X3-SM1+SM3
             ENDIF
              IF(NEG.EQ.1) GOTO 1
     
              FG=2.*YMAX*C*(X1**EXP1+X3**EXP3)/D
              XT2M=XT2
              IF(FG.LT.RANART(NSEED)) GOTO 1
     
              RETURN
              END
C*************************************************************


        SUBROUTINE ARORIE(S,X1,X3,JL)
C     
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
cc      SAVE /LUJETS/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   
C     
             W=SQRT(S)
             X2=2.-X1-X3
             E1=.5*X1*W
             E3=.5*X3*W
             P1=SQRT(E1**2-P(JL,5)**2)
        P3=SQRT(E3**2-P(JL+1,5)**2)
        CBET=1.
        IF(P1.GT.0..AND.P3.GT.0.) CBET=(P(JL,5)**2
     &           +P(JL+1,5)**2+2.*E1*E3-S*(1.-X2))/(2.*P1*P3)
              IF(ABS(CBET).GT.1.0) CBET=MAX(-1.,MIN(1.,CBET))
              BET=ACOS(CBET)
     
C.....MINIMIZE PT1-SQUARED PLUS PT3-SQUARED.....
              IF(P1.GE.P3) THEN
           PSI=.5*ULANGL(P1**2+P3**2*COS(2.*BET),-P3**2*SIN(2.*BET))
           PT1=P1*SIN(PSI)
           PZ1=P1*COS(PSI)
           PT3=P3*SIN(PSI+BET)
           PZ3=P3*COS(PSI+BET)
              ELSE IF(P3.GT.P1) THEN
           PSI=.5*ULANGL(P3**2+P1**2*COS(2.*BET),-P1**2*SIN(2.*BET))
           PT1=P1*SIN(BET+PSI)
           PZ1=-P1*COS(BET+PSI)
           PT3=P3*SIN(PSI)
           PZ3=-P3*COS(PSI)
              ENDIF
     
              DEL=2.0*HIPR1(40)*RANART(NSEED)
              P(JL,4)=E1
              P(JL,1)=PT1*SIN(DEL)
              P(JL,2)=-PT1*COS(DEL)
              P(JL,3)=PZ1
              P(JL+2,4)=E3
              P(JL+2,1)=PT3*SIN(DEL)
              P(JL+2,2)=-PT3*COS(DEL)
              P(JL+2,3)=PZ3
              P(JL+1,4)=W-E1-E3
              P(JL+1,1)=-P(JL,1)-P(JL+2,1)
              P(JL+1,2)=-P(JL,2)-P(JL+2,2)
              P(JL+1,3)=-P(JL,3)-P(JL+2,3)
              RETURN
              END


C
C*******************************************************************
C        make  boost and rotation to entries from IMIN to IMAX
C*******************************************************************
        SUBROUTINE ATROBO(THE,PHI,BEX,BEY,BEZ,IMIN,IMAX,IERROR)
        COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
cc      SAVE /LUJETS/
        DIMENSION ROT(3,3),PV(3)
        DOUBLE PRECISION DP(4),DBEX,DBEY,DBEZ,DGA,DGA2,DBEP,DGABEP
        SAVE   
        IERROR=0
     
              IF(IMIN.LE.0 .OR. IMAX.GT.N .OR. IMIN.GT.IMAX) RETURN

              IF(THE**2+PHI**2.GT.1E-20) THEN
C...ROTATE (TYPICALLY FROM Z AXIS TO DIRECTION THETA,PHI)
           ROT(1,1)=COS(THE)*COS(PHI)
           ROT(1,2)=-SIN(PHI)
           ROT(1,3)=SIN(THE)*COS(PHI)
           ROT(2,1)=COS(THE)*SIN(PHI)
           ROT(2,2)=COS(PHI)
           ROT(2,3)=SIN(THE)*SIN(PHI)
           ROT(3,1)=-SIN(THE)
           ROT(3,2)=0.
           ROT(3,3)=COS(THE)
           DO 120 I=IMIN,IMAX
C**************           IF(MOD(K(I,1)/10000,10).GE.6) GOTO 120
              DO 100 J=1,3
 100                 PV(J)=P(I,J)
                 DO 110 J=1,3
 110                    P(I,J)=ROT(J,1)*PV(1)+ROT(J,2)*PV(2)
     &                     +ROT(J,3)*PV(3)
 120                 CONTINUE
        ENDIF
     
              IF(BEX**2+BEY**2+BEZ**2.GT.1E-20) THEN
C...LORENTZ BOOST (TYPICALLY FROM REST TO MOMENTUM/ENERGY=BETA)
                DBEX=dble(BEX)
                DBEY=dble(BEY)
                DBEZ=dble(BEZ)
                DGA2=1D0-DBEX**2-DBEY**2-DBEZ**2
                IF(DGA2.LE.0D0) THEN
                        IERROR=1
                        RETURN
                ENDIF
                DGA=1D0/DSQRT(DGA2)
                DO 140 I=IMIN,IMAX
C*************           IF(MOD(K(I,1)/10000,10).GE.6) GOTO 140
                   DO 130 J=1,4
 130                  DP(J)=dble(P(I,J))
                   DBEP=DBEX*DP(1)+DBEY*DP(2)+DBEZ*DP(3)
                   DGABEP=DGA*(DGA*DBEP/(1D0+DGA)+DP(4))
                   P(I,1)=sngl(DP(1)+DGABEP*DBEX)
                   P(I,2)=sngl(DP(2)+DGABEP*DBEY)
                   P(I,3)=sngl(DP(3)+DGABEP*DBEZ)
                   P(I,4)=sngl(DGA*(DP(4)+DBEP))
140                   CONTINUE
              ENDIF
     
              RETURN
              END
C
C
C
        SUBROUTINE HIJHRD(JP,JT,JOUT,JFLG,IOPJT0)
C
C        IOPTJET=1, ALL JET WILL FORM SINGLE STRING SYSTEM
C                0, ONLY Q-QBAR JET FORM SINGLE STRING SYSTEM
C*******Perform jets production and fragmentation when JP JT *******
C     scatter. JOUT-> number of hard scatterings precede this one  *
C     for the the same pair(JP,JT). JFLG->a flag to show whether   *
C     jets can be produced (with valence quark=1,gluon=2, q-qbar=3)*
C     or not(0). Information of jets are in  COMMON/ATTJET and     *
C     /MINJET. ABS(NFP(JP,6)) is the total number jets produced by *
C    JP. If NFP(JP,6)<0 JP can not produce jet anymore.                   *
C*******************************************************************
        PARAMETER (MAXSTR=150001)
        DIMENSION IP(100,2),IPQ(50),IPB(50),IT(100,2),ITQ(50),ITB(50)
        COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/HIJDAT/HIDAT0(10,10),HIDAT(10)
cc      SAVE /HIJDAT/
        COMMON/HSTRNG/NFP(300,15),PP(300,15),NFT(300,15),PT(300,15)
cc      SAVE /HSTRNG/
        COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &                PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &                PJPM(300,500),NTJ(300),KFTJ(300,500),
     &                PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &                PJTE(300,500),PJTM(300,500)
cc      SAVE /HJJET1/
        COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &       K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &       PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
c        COMMON/HJJET4/NDR,IADR(900,2),KFDR(900),PDR(900,5)
        COMMON/HJJET4/NDR,IADR(MAXSTR,2),KFDR(MAXSTR),PDR(MAXSTR,5)
        common/xydr/rtdr(MAXSTR,2)
cc      SAVE /HJJET4/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
C************************************ HIJING common block
        COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
cc      SAVE /LUJETS/
        COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
cc      SAVE /LUDAT1/
        COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200)
cc      SAVE /PYSUBS/
        COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200)
cc      SAVE /PYPARS/
        COMMON/PYINT1/MINT(400),VINT(400)
cc      SAVE /PYINT1/
        COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2)
cc      SAVE /PYINT2/
        COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3)
cc      SAVE /PYINT5/
        COMMON/HPINT/MINT4,MINT5,ATCO(200,20),ATXS(0:200)
cc      SAVE /HPINT/
clin-2/2012 correction:
        common/phidcy/iphidcy,pttrig,ntrig,maxmiss,ipi0dcy
        SAVE   
C*********************************** LU common block
        MXJT=500
C                SIZE OF COMMON BLOCK FOR # OF PARTON PER STRING
        MXSG=900
C                SIZE OF COMMON BLOCK FOR # OF SINGLE STRINGS
        MXSJ=100
C                SIZE OF COMMON BLOCK FOR # OF PARTON PER SINGLE
C                STRING
        JFLG=0
        IHNT2(11)=JP
        IHNT2(12)=JT
C
        IOPJET=IOPJT0
        IF(IOPJET.EQ.1.AND.(NFP(JP,6).NE.0.OR.NFT(JT,6).NE.0))
     &                   IOPJET=0
        IF(JP.GT.IHNT2(1) .OR. JT.GT.IHNT2(3)) RETURN
        IF(NFP(JP,6).LT.0 .OR. NFT(JT,6).LT.0) RETURN
C                ******** JP or JT can not produce jet anymore
C
        IF(JOUT.EQ.0) THEN
                EPP=PP(JP,4)+PP(JP,3)
                EPM=PP(JP,4)-PP(JP,3)
                ETP=PT(JT,4)+PT(JT,3)
                ETM=PT(JT,4)-PT(JT,3)
                IF(EPP.LT.0.0) GO TO 1000
                IF(EPM.LT.0.0) GO TO 1000
                IF(ETP.LT.0.0) GO TO 1000
                IF(ETM.LT.0.0) GO TO 1000
                IF(EPP/(EPM+0.01).LE.ETP/(ETM+0.01)) RETURN
        ENDIF
C                ********for the first hard scattering of (JP,JT)
C                        have collision only when Ycm(JP)>Ycm(JT)

        ECUT1=HIPR1(1)+HIPR1(8)+PP(JP,14)+PP(JP,15)
        ECUT2=HIPR1(1)+HIPR1(8)+PT(JT,14)+PT(JT,15)
        IF(PP(JP,4).LE.ECUT1) THEN
                NFP(JP,6)=-ABS(NFP(JP,6))
                RETURN
        ENDIF
        IF(PT(JT,4).LE.ECUT2) THEN
                NFT(JT,6)=-ABS(NFT(JT,6))
                RETURN
        ENDIF
C                *********must have enough energy to produce jets

        MISS=0
        MISP=0
        MIST=0
C
        IF(NFP(JP,10).EQ.0 .AND. NFT(JT,10).EQ.0) THEN
                MINT(44)=MINT4
                MINT(45)=MINT5
                XSEC(0,1)=ATXS(0)
                XSEC(11,1)=ATXS(11)
                XSEC(12,1)=ATXS(12)
                XSEC(28,1)=ATXS(28)
                DO 120 I=1,20
                COEF(11,I)=ATCO(11,I)
                COEF(12,I)=ATCO(12,I)
                COEF(28,I)=ATCO(28,I)
120                CONTINUE
        ELSE
                ISUB11=0
                ISUB12=0
                ISUB28=0
                IF(XSEC(11,1).NE.0) ISUB11=1
                IF(XSEC(12,1).NE.0) ISUB12=1
                IF(XSEC(28,1).NE.0) ISUB28=1                
                MINT(44)=MINT4-ISUB11-ISUB12-ISUB28
                MINT(45)=MINT5-ISUB11-ISUB12-ISUB28
                XSEC(0,1)=ATXS(0)-ATXS(11)-ATXS(12)-ATXS(28)
                XSEC(11,1)=0.0
                XSEC(12,1)=0.0
                XSEC(28,1)=0.0        
                DO 110 I=1,20
                COEF(11,I)=0.0
                COEF(12,I)=0.0
                COEF(28,I)=0.0
110                CONTINUE
        ENDIF                
C        ********Scatter the valence quarks only once per NN 
C       collision,
C                afterwards only gluon can have hard scattering.
 155        CALL PYTHIA
        JJ=MINT(31)
        IF(JJ.NE.1) GO TO 155
C                *********one hard collision at a time
        IF(K(7,2).EQ.-K(8,2)) THEN
                QMASS2=(P(7,4)+P(8,4))**2-(P(7,1)+P(8,1))**2
     &                        -(P(7,2)+P(8,2))**2-(P(7,3)+P(8,3))**2
                QM=ULMASS(K(7,2))
                IF(QMASS2.LT.(2.0*QM+HIPR1(1))**2) GO TO 155
        ENDIF
C                ********q-qbar jets must has minimum mass HIPR1(1)
        PXP=PP(JP,1)-P(3,1)
        PYP=PP(JP,2)-P(3,2)
        PZP=PP(JP,3)-P(3,3)
        PEP=PP(JP,4)-P(3,4)
        PXT=PT(JT,1)-P(4,1)
        PYT=PT(JT,2)-P(4,2)
        PZT=PT(JT,3)-P(4,3)
        PET=PT(JT,4)-P(4,4)

        IF(PEP.LE.ECUT1) THEN
                MISP=MISP+1
                IF(MISP.LT.50) GO TO 155
                NFP(JP,6)=-ABS(NFP(JP,6))
                RETURN
        ENDIF
        IF(PET.LE.ECUT2) THEN
                MIST=MIST+1
                IF(MIST.LT.50) GO TO 155
                NFT(JT,6)=-ABS(NFT(JT,6))
                RETURN
        ENDIF
C                ******** if the remain energy<ECUT the proj or targ
C                         can not produce jet anymore

        WP=PEP+PZP+PET+PZT
        WM=PEP-PZP+PET-PZT
        IF(WP.LT.0.0 .OR. WM.LT.0.0) THEN
                MISS=MISS+1
clin-6/2009 Let user set the limit when selecting high-Pt events 
c     because more attempts may be needed:
c                IF(MISS.LT.50) GO TO 155
                if(pttrig.gt.0) then
                   if(MISS.LT.maxmiss) then
                write(6,*) 'Failed to generate minijet Pt>',pttrig,'GeV'
                      GO TO 155
                   endif
                else
                   IF(MISS.LT.50) GO TO 155
                endif

                RETURN
        ENDIF
C                ********the total W+, W- must be positive
        SW=WP*WM
        AMPX=SQRT((ECUT1-HIPR1(8))**2+PXP**2+PYP**2+0.01)
        AMTX=SQRT((ECUT2-HIPR1(8))**2+PXT**2+PYT**2+0.01)
        SXX=(AMPX+AMTX)**2
        IF(SW.LT.SXX.OR.VINT(43).LT.HIPR1(1)) THEN
                MISS=MISS+1
clin-6/2009
c                IF(MISS.LT.50) GO TO 155
                IF(MISS.GT.maxmiss) GO TO 155
                RETURN
        ENDIF  
C                ********the proj and targ remnants must have at least
C                        a CM energy that can produce two strings
C                        with minimum mass HIPR1(1)(see HIJSFT HIJFRG)
C
        HINT1(41)=P(7,1)
        HINT1(42)=P(7,2)
        HINT1(43)=P(7,3)
        HINT1(44)=P(7,4)
        HINT1(45)=P(7,5)
        HINT1(46)=SQRT(P(7,1)**2+P(7,2)**2)
        HINT1(51)=P(8,1)
        HINT1(52)=P(8,2)
        HINT1(53)=P(8,3)
        HINT1(54)=P(8,4)
        HINT1(55)=P(8,5)
        HINT1(56)=SQRT(P(8,1)**2+P(8,2)**2) 
        IHNT2(14)=K(7,2)
        IHNT2(15)=K(8,2)
C
        PINIRD=(1.0-EXP(-2.0*(VINT(47)-HIDAT(1))))
     &                /(1.0+EXP(-2.0*(VINT(47)-HIDAT(1))))
        IINIRD=0
        IF(RANART(NSEED).LE.PINIRD) IINIRD=1
        IF(K(7,2).EQ.-K(8,2)) GO TO 190
        IF(K(7,2).EQ.21.AND.K(8,2).EQ.21.AND.IOPJET.EQ.1) GO TO 190
C*******************************************************************
C        gluon  jets are going to be connectd with
C        the final leadng string of quark-aintquark
C*******************************************************************
        JFLG=2
        JPP=0
        LPQ=0
        LPB=0
        JTT=0
        LTQ=0
        LTB=0
        IS7=0
        IS8=0
        HINT1(47)=0.0
        HINT1(48)=0.0
        HINT1(49)=0.0
        HINT1(50)=0.0
        HINT1(67)=0.0
        HINT1(68)=0.0
        HINT1(69)=0.0
        HINT1(70)=0.0
        DO 180 I=9,N
           IF(K(I,3).EQ.1 .OR. K(I,3).EQ.2.OR.
     &                   ABS(K(I,2)).GT.30) GO TO 180
C************************************************************
           IF(K(I,3).EQ.7) THEN
              HINT1(47)=HINT1(47)+P(I,1)
              HINT1(48)=HINT1(48)+P(I,2)
              HINT1(49)=HINT1(49)+P(I,3)
              HINT1(50)=HINT1(50)+P(I,4)
           ENDIF
           IF(K(I,3).EQ.8) THEN
              HINT1(67)=HINT1(67)+P(I,1)
              HINT1(68)=HINT1(68)+P(I,2)
              HINT1(69)=HINT1(69)+P(I,3)
              HINT1(70)=HINT1(70)+P(I,4)
           ENDIF
C************************modifcation made on Apr 10. 1996*****
           IF(K(I,2).GT.21.AND.K(I,2).LE.30) THEN
              NDR=NDR+1
              IADR(NDR,1)=JP
              IADR(NDR,2)=JT
              KFDR(NDR)=K(I,2)
              PDR(NDR,1)=P(I,1)
              PDR(NDR,2)=P(I,2)
              PDR(NDR,3)=P(I,3)
              PDR(NDR,4)=P(I,4)
              PDR(NDR,5)=P(I,5)
              rtdr(NDR,1)=0.5*(YP(1,JP)+YT(1,JT))
              rtdr(NDR,2)=0.5*(YP(2,JP)+YT(2,JT))
C************************************************************
              GO TO 180
C************************correction made on Oct. 14,1994*****
           ENDIF
           IF(K(I,3).EQ.7.OR.K(I,3).EQ.3) THEN
              IF(K(I,3).EQ.7.AND.K(I,2).NE.21.AND.K(I,2).EQ.K(7,2)
     &                     .AND.IS7.EQ.0) THEN
                 PP(JP,10)=P(I,1)
                 PP(JP,11)=P(I,2)
                 PP(JP,12)=P(I,3)
                 PZP=PZP+P(I,3)
                 PEP=PEP+P(I,4)
                 NFP(JP,10)=1
                 IS7=1
                 GO TO 180
              ENDIF
              IF(K(I,3).EQ.3.AND.(K(I,2).NE.21.OR.
     &                               IINIRD.EQ.0)) THEN
                 PXP=PXP+P(I,1)
                 PYP=PYP+P(I,2)
                 PZP=PZP+P(I,3)
                 PEP=PEP+P(I,4)
                 GO TO 180 
              ENDIF
              JPP=JPP+1
              IP(JPP,1)=I
              IP(JPP,2)=0
              IF(K(I,2).NE.21) THEN
                 IF(K(I,2).GT.0) THEN
                    LPQ=LPQ+1
                    IPQ(LPQ)=JPP
                    IP(JPP,2)=LPQ
                 ELSE IF(K(I,2).LT.0) THEN
                    LPB=LPB+1
                    IPB(LPB)=JPP
                    IP(JPP,2)=-LPB
                 ENDIF
              ENDIF
           ELSE IF(K(I,3).EQ.8.OR.K(I,3).EQ.4) THEN
              IF(K(I,3).EQ.8.AND.K(I,2).NE.21.AND.K(I,2).EQ.K(8,2)
     &                                .AND.IS8.EQ.0) THEN
                 PT(JT,10)=P(I,1)
                 PT(JT,11)=P(I,2)
                 PT(JT,12)=P(I,3)
                 PZT=PZT+P(I,3)
                 PET=PET+P(I,4)
                 NFT(JT,10)=1
                 IS8=1
                 GO TO 180
              ENDIF                        
              IF(K(I,3).EQ.4.AND.(K(I,2).NE.21.OR.
     &                             IINIRD.EQ.0)) THEN
                 PXT=PXT+P(I,1)
                 PYT=PYT+P(I,2)
                 PZT=PZT+P(I,3)
                 PET=PET+P(I,4)
                 GO TO 180
              ENDIF
              JTT=JTT+1
              IT(JTT,1)=I
              IT(JTT,2)=0
              IF(K(I,2).NE.21) THEN
                 IF(K(I,2).GT.0) THEN
                    LTQ=LTQ+1
                    ITQ(LTQ)=JTT
                    IT(JTT,2)=LTQ
                 ELSE IF(K(I,2).LT.0) THEN
                    LTB=LTB+1
                    ITB(LTB)=JTT
                    IT(JTT,2)=-LTB
                 ENDIF
              ENDIF
           ENDIF
 180        CONTINUE
c
c
        IF(LPQ.NE.LPB .OR. LTQ.NE.LTB) THEN
                MISS=MISS+1
clin-6/2009
c                IF(MISS.LE.50) GO TO 155
                IF(MISS.LE.maxmiss) GO TO 155
                WRITE(6,*) ' Q -QBAR NOT MATCHED IN HIJHRD'
                JFLG=0
                RETURN
        ENDIF
C****The following will rearrange the partons so that a quark is***
C****allways followed by an anti-quark ****************************

        J=0
181        J=J+1
        IF(J.GT.JPP) GO TO 182
        IF(IP(J,2).EQ.0) THEN
                GO TO 181
        ELSE IF(IP(J,2).NE.0) THEN
                LP=ABS(IP(J,2))
                IP1=IP(J,1)
                IP2=IP(J,2)
                IP(J,1)=IP(IPQ(LP),1)
                IP(J,2)=IP(IPQ(LP),2)
                IP(IPQ(LP),1)=IP1
                IP(IPQ(LP),2)=IP2
                IF(IP2.GT.0) THEN
                        IPQ(IP2)=IPQ(LP)
                ELSE IF(IP2.LT.0) THEN
                        IPB(-IP2)=IPQ(LP)
                ENDIF
C                ********replace J with a quark
                IP1=IP(J+1,1)
                IP2=IP(J+1,2)
                IP(J+1,1)=IP(IPB(LP),1)
                IP(J+1,2)=IP(IPB(LP),2)
                IP(IPB(LP),1)=IP1
                IP(IPB(LP),2)=IP2
                IF(IP2.GT.0) THEN
                        IPQ(IP2)=IPB(LP)
                ELSE IF(IP2.LT.0) THEN
                        IPB(-IP2)=IPB(LP)
                ENDIF
C                ******** replace J+1 with anti-quark
                J=J+1
                GO TO 181
        ENDIF

182        J=0
183        J=J+1
        IF(J.GT.JTT) GO TO 184
        IF(IT(J,2).EQ.0) THEN
                GO TO 183
        ELSE IF(IT(J,2).NE.0) THEN
                LT=ABS(IT(J,2))
                IT1=IT(J,1)
                IT2=IT(J,2)
                IT(J,1)=IT(ITQ(LT),1)
                IT(J,2)=IT(ITQ(LT),2)
                IT(ITQ(LT),1)=IT1
                IT(ITQ(LT),2)=IT2
                IF(IT2.GT.0) THEN
                        ITQ(IT2)=ITQ(LT)
                ELSE IF(IT2.LT.0) THEN
                        ITB(-IT2)=ITQ(LT)
                ENDIF
C                ********replace J with a quark
                IT1=IT(J+1,1)
                IT2=IT(J+1,2)
                IT(J+1,1)=IT(ITB(LT),1)
                IT(J+1,2)=IT(ITB(LT),2)
                IT(ITB(LT),1)=IT1
                IT(ITB(LT),2)=IT2
                IF(IT2.GT.0) THEN
                        ITQ(IT2)=ITB(LT)
                ELSE IF(IT2.LT.0) THEN
                        ITB(-IT2)=ITB(LT)
                ENDIF
C                ******** replace J+1 with anti-quark
                J=J+1
                GO TO 183

        ENDIF

184        CONTINUE
        IF(NPJ(JP)+JPP.GT.MXJT.OR.NTJ(JT)+JTT.GT.MXJT) THEN
                JFLG=0
                WRITE(6,*) 'number of partons per string exceeds'
                WRITE(6,*) 'the common block size'
                RETURN
        ENDIF
C                        ********check the bounds of common blocks
        DO 186 J=1,JPP
                KFPJ(JP,NPJ(JP)+J)=K(IP(J,1),2)
                PJPX(JP,NPJ(JP)+J)=P(IP(J,1),1)
                PJPY(JP,NPJ(JP)+J)=P(IP(J,1),2)
                PJPZ(JP,NPJ(JP)+J)=P(IP(J,1),3)
                PJPE(JP,NPJ(JP)+J)=P(IP(J,1),4)
                PJPM(JP,NPJ(JP)+J)=P(IP(J,1),5)
186        CONTINUE
        NPJ(JP)=NPJ(JP)+JPP
        DO 188 J=1,JTT
                KFTJ(JT,NTJ(JT)+J)=K(IT(J,1),2)
                PJTX(JT,NTJ(JT)+J)=P(IT(J,1),1)
                PJTY(JT,NTJ(JT)+J)=P(IT(J,1),2)
                PJTZ(JT,NTJ(JT)+J)=P(IT(J,1),3)
                PJTE(JT,NTJ(JT)+J)=P(IT(J,1),4)
                PJTM(JT,NTJ(JT)+J)=P(IT(J,1),5)
188        CONTINUE
        NTJ(JT)=NTJ(JT)+JTT
        GO TO 900
C*****************************************************************
CThis is the case of a quark-antiquark jet it will fragment alone
C****************************************************************
190        JFLG=3
        IF(K(7,2).NE.21.AND.K(8,2).NE.21.AND.
     &                   K(7,2)*K(8,2).GT.0) GO TO 155
        JPP=0
        LPQ=0
        LPB=0
        DO 200 I=9,N
           IF(K(I,3).EQ.1.OR.K(I,3).EQ.2.OR.
     &                  ABS(K(I,2)).GT.30) GO TO 200
                IF(K(I,2).GT.21.AND.K(I,2).LE.30) THEN
                        NDR=NDR+1
                        IADR(NDR,1)=JP
                        IADR(NDR,2)=JT
                        KFDR(NDR)=K(I,2)
                        PDR(NDR,1)=P(I,1)
                        PDR(NDR,2)=P(I,2)
                        PDR(NDR,3)=P(I,3)
                        PDR(NDR,4)=P(I,4)
                        PDR(NDR,5)=P(I,5)
                        rtdr(NDR,1)=0.5*(YP(1,JP)+YT(1,JT))
                        rtdr(NDR,2)=0.5*(YP(2,JP)+YT(2,JT))
C************************************************************
                        GO TO 200
C************************correction made on Oct. 14,1994*****
                ENDIF
                IF(K(I,3).EQ.3.AND.(K(I,2).NE.21.OR.
     &                              IINIRD.EQ.0)) THEN
                        PXP=PXP+P(I,1)
                        PYP=PYP+P(I,2)
                        PZP=PZP+P(I,3)
                        PEP=PEP+P(I,4)
                        GO TO 200
                ENDIF
                IF(K(I,3).EQ.4.AND.(K(I,2).NE.21.OR.
     &                                IINIRD.EQ.0)) THEN
                        PXT=PXT+P(I,1)
                        PYT=PYT+P(I,2)
                        PZT=PZT+P(I,3)
                        PET=PET+P(I,4)
                        GO TO 200
                ENDIF
                JPP=JPP+1
                IP(JPP,1)=I
                IP(JPP,2)=0
                IF(K(I,2).NE.21) THEN
                        IF(K(I,2).GT.0) THEN
                                LPQ=LPQ+1
                                IPQ(LPQ)=JPP
                                IP(JPP,2)=LPQ
                        ELSE IF(K(I,2).LT.0) THEN
                                LPB=LPB+1
                                IPB(LPB)=JPP
                                IP(JPP,2)=-LPB
                        ENDIF
                ENDIF
200        CONTINUE
        IF(LPQ.NE.LPB) THEN
           MISS=MISS+1
clin-6/2009
c           IF(MISS.LE.50) GO TO 155
           IF(MISS.LE.maxmiss) GO TO 155
           WRITE(6,*) LPQ,LPB, 'Q-QBAR NOT CONSERVED OR NOT MATCHED'
           JFLG=0
           RETURN
        ENDIF

C**** The following will rearrange the partons so that a quark is***
C**** allways followed by an anti-quark ****************************
        J=0
220        J=J+1
        IF(J.GT.JPP) GO TO 222
        IF(IP(J,2).EQ.0) GO TO 220
                LP=ABS(IP(J,2))
                IP1=IP(J,1)
                IP2=IP(J,2)
                IP(J,1)=IP(IPQ(LP),1)
                IP(J,2)=IP(IPQ(LP),2)
                IP(IPQ(LP),1)=IP1
                IP(IPQ(LP),2)=IP2
                IF(IP2.GT.0) THEN
                        IPQ(IP2)=IPQ(LP)
                ELSE IF(IP2.LT.0) THEN
                        IPB(-IP2)=IPQ(LP)
                ENDIF
                IPQ(LP)=J
C                ********replace J with a quark
                IP1=IP(J+1,1)
                IP2=IP(J+1,2)
                IP(J+1,1)=IP(IPB(LP),1)
                IP(J+1,2)=IP(IPB(LP),2)
                IP(IPB(LP),1)=IP1
                IP(IPB(LP),2)=IP2
                IF(IP2.GT.0) THEN
                        IPQ(IP2)=IPB(LP)
                ELSE IF(IP2.LT.0) THEN
                        IPB(-IP2)=IPB(LP)
                ENDIF
C                ******** replace J+1 with an anti-quark
                IPB(LP)=J+1
                J=J+1
                GO TO 220

222        CONTINUE
        IF(LPQ.GE.1) THEN
                DO 240 L0=2,LPQ
                        IP1=IP(2*L0-3,1)
                        IP2=IP(2*L0-3,2)
                        IP(2*L0-3,1)=IP(IPQ(L0),1)
                        IP(2*L0-3,2)=IP(IPQ(L0),2)
                        IP(IPQ(L0),1)=IP1
                        IP(IPQ(L0),2)=IP2
                        IF(IP2.GT.0) THEN
                                IPQ(IP2)=IPQ(L0)
                        ELSE IF(IP2.LT.0) THEN
                                IPB(-IP2)=IPQ(L0)
                        ENDIF
                        IPQ(L0)=2*L0-3
C
                        IP1=IP(2*L0-2,1)
                        IP2=IP(2*L0-2,2)
                        IP(2*L0-2,1)=IP(IPB(L0),1)
                        IP(2*L0-2,2)=IP(IPB(L0),2)
                        IP(IPB(L0),1)=IP1
                        IP(IPB(L0),2)=IP2
                        IF(IP2.GT.0) THEN
                                IPQ(IP2)=IPB(L0)
                        ELSE IF(IP2.LT.0) THEN
                                IPB(-IP2)=IPB(L0)
                        ENDIF
                        IPB(L0)=2*L0-2
240                CONTINUE
C                ********move all the qqbar pair to the front of 
C                                the list, except the first pair
                IP1=IP(2*LPQ-1,1)
                IP2=IP(2*LPQ-1,2)
                IP(2*LPQ-1,1)=IP(IPQ(1),1)
                IP(2*LPQ-1,2)=IP(IPQ(1),2)
                IP(IPQ(1),1)=IP1
                IP(IPQ(1),2)=IP2
                IF(IP2.GT.0) THEN
                        IPQ(IP2)=IPQ(1)
                ELSE IF(IP2.LT.0) THEN
                        IPB(-IP2)=IPQ(1)
                ENDIF
                IPQ(1)=2*LPQ-1
C                ********move the first quark to the beginning of
C                                the last string system
                IP1=IP(JPP,1)
                IP2=IP(JPP,2)
                IP(JPP,1)=IP(IPB(1),1)
                IP(JPP,2)=IP(IPB(1),2)
                IP(IPB(1),1)=IP1
                IP(IPB(1),2)=IP2
                IF(IP2.GT.0) THEN
                        IPQ(IP2)=IPB(1)
                ELSE IF(IP2.LT.0) THEN
                        IPB(-IP2)=IPB(1)
                ENDIF
                IPB(1)=JPP
C                ********move the first anti-quark to the end of the 
C                        last string system
        ENDIF
        IF(NSG.GE.MXSG) THEN
           JFLG=0
           WRITE(6,*) 'number of jets forming single strings exceeds'
           WRITE(6,*) 'the common block size'
           RETURN
        ENDIF
        IF(JPP.GT.MXSJ) THEN
           JFLG=0
           WRITE(6,*) 'number of partons per single jet system'
           WRITE(6,*) 'exceeds the common block size'
           RETURN
        ENDIF
C                ********check the bounds of common block size
        NSG=NSG+1
        NJSG(NSG)=JPP
        IASG(NSG,1)=JP
        IASG(NSG,2)=JT
        IASG(NSG,3)=0
        DO 300 I=1,JPP
                K1SG(NSG,I)=2
                K2SG(NSG,I)=K(IP(I,1),2)
                IF(K2SG(NSG,I).LT.0) K1SG(NSG,I)=1
                PXSG(NSG,I)=P(IP(I,1),1)
                PYSG(NSG,I)=P(IP(I,1),2)
                PZSG(NSG,I)=P(IP(I,1),3)
                PESG(NSG,I)=P(IP(I,1),4)
                PMSG(NSG,I)=P(IP(I,1),5)
300        CONTINUE
        K1SG(NSG,1)=2
        K1SG(NSG,JPP)=1
C******* reset the energy-momentum of incoming particles ********
900        PP(JP,1)=PXP
        PP(JP,2)=PYP
        PP(JP,3)=PZP
        PP(JP,4)=PEP
        PP(JP,5)=0.0
        PT(JT,1)=PXT
        PT(JT,2)=PYT
        PT(JT,3)=PZT
        PT(JT,4)=PET
        PT(JT,5)=0.0

        NFP(JP,6)=NFP(JP,6)+1
        NFT(JT,6)=NFT(JT,6)+1
        RETURN
C
1000        JFLG=-1
        IF(IHPR2(10).EQ.0) RETURN
        WRITE(6,*) 'Fatal HIJHRD error'
        WRITE(6,*) JP, ' proj E+,E-',EPP,EPM,' status',NFP(JP,5)
        WRITE(6,*) JT, ' targ E+,E_',ETP,ETM,' status',NFT(JT,5)
        RETURN
        END
C
C
C
C
C
        SUBROUTINE JETINI(JP,JT,itrig)
C*******Initialize PYTHIA for jet production**********************
C        itrig=0: for normal processes
C        itrig=1: for triggered processes
C       JP: sequence number of the projectile
C       JT: sequence number of the target
C     For A+A collisions, one has to initilize pythia
C     separately for each type of collisions, pp, pn,np and nn,
C     or hp and hn for hA collisions. In this subroutine we use the following
C     catalogue for different type of collisions:
C     h+h: h+h (itype=1)
C     h+A: h+p (itype=1), h+n (itype=2)
C     A+h: p+h (itype=1), n+h (itype=2)
C     A+A: p+p (itype=1), p+n (itype=2), n+p (itype=3), n+n (itype=4)
C*****************************************************************
        CHARACTER BEAM*16,TARG*16
        DIMENSION XSEC0(8,0:200),COEF0(8,200,20),INI(8),
     &                MINT44(8),MINT45(8)
        COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/HSTRNG/NFP(300,15),PP(300,15),NFT(300,15),PT(300,15)
cc      SAVE /HSTRNG/
        COMMON/HPINT/MINT4,MINT5,ATCO(200,20),ATXS(0:200)
cc      SAVE /HPINT/
C
        COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
cc      SAVE /LUDAT1/
        COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
cc      SAVE /LUDAT3/
        COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200)
cc      SAVE /PYSUBS/
        COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200)
cc      SAVE /PYPARS/
        COMMON/PYINT1/MINT(400),VINT(400)
cc      SAVE /PYINT1/
        COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2)
cc      SAVE /PYINT2/
        COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3)
cc      SAVE /PYINT5/
        SAVE
clin        DATA INI/8*0/ilast/-1/
        DATA INI/8*0/,ilast/-1/
C
        IHNT2(11)=JP
        IHNT2(12)=JT
        IF(IHNT2(5).NE.0 .AND. IHNT2(6).NE.0) THEN
           itype=1
        ELSE IF(IHNT2(5).NE.0 .AND. IHNT2(6).EQ.0) THEN
           itype=1
           IF(NFT(JT,4).EQ.2112) itype=2
        ELSE IF(IHNT2(5).EQ.0 .AND. IHNT2(6).NE.0) THEN
           itype=1
           IF(NFP(JP,4).EQ.2112) itype=2
        ELSE
           IF(NFP(JP,4).EQ.2212 .AND. NFT(JT,4).EQ.2212) THEN
              itype=1
           ELSE IF(NFP(JP,4).EQ.2212 .AND. NFT(JT,4).EQ.2112) THEN
              itype=2
           ELSE IF(NFP(JP,4).EQ.2112 .AND. NFT(JT,4).EQ.2212) THEN
              itype=3
           ELSE
              itype=4
           ENDIF
        ENDIF

clin-12/2012 correct NN differential cross section in HIJING:
c        write(94,*) 'In JETINI: ',jp,jt,NFP(JP,4),NFT(JT,4),itype

c
        IF(itrig.NE.0) GO TO 160
        IF(itrig.EQ.ilast) GO TO 150
        MSTP(2)=2
c                        ********second order running alpha_strong
        MSTP(33)=1
        PARP(31)=HIPR1(17)
C                        ********inclusion of K factor
        MSTP(51)=3
C                        ********Duke-Owens set 1 structure functions
        MSTP(61)=1
C                        ********INITIAL STATE RADIATION
        MSTP(71)=1
C                        ********FINAL STATE RADIATION
        IF(IHPR2(2).EQ.0.OR.IHPR2(2).EQ.2) MSTP(61)=0
        IF(IHPR2(2).EQ.0.OR.IHPR2(2).EQ.1) MSTP(71)=0
c
        MSTP(81)=0
C                        ******** NO MULTIPLE INTERACTION
        MSTP(82)=1
C                        *******STRUCTURE OF MUTLIPLE INTERACTION
        MSTP(111)=0
C                ********frag off(have to be done by local call)
        IF(IHPR2(10).EQ.0) MSTP(122)=0
C                ********No printout of initialization information
        PARP(81)=HIPR1(8)
        CKIN(5)=HIPR1(8)
        CKIN(3)=HIPR1(8)
        CKIN(4)=HIPR1(9)
        IF(HIPR1(9).LE.HIPR1(8)) CKIN(4)=-1.0
        CKIN(9)=-10.0
        CKIN(10)=10.0
        MSEL=0
        DO 100 ISUB=1,200
           MSUB(ISUB)=0
 100    CONTINUE
        MSUB(11)=1
        MSUB(12)=1
        MSUB(13)=1
        MSUB(28)=1
        MSUB(53)=1
        MSUB(68)=1
        MSUB(81)=1
        MSUB(82)=1
        DO 110 J=1,MIN(8,MDCY(21,3))
 110    MDME(MDCY(21,2)+J-1,1)=0
        ISEL=4
        IF(HINT1(1).GE.20.0 .and. IHPR2(18).EQ.1) ISEL=5
        MDME(MDCY(21,2)+ISEL-1,1)=1
C                        ********QCD subprocesses
        MSUB(14)=1
        MSUB(18)=1
        MSUB(29)=1
C                       ******* direct photon production
 150    IF(INI(itype).NE.0) GO TO 800
        GO TO 400
C
C        *****triggered subprocesses, jet, photon, heavy quark and DY
C
 160    itype=4+itype
        IF(itrig.EQ.ilast) GO TO 260
        PARP(81)=ABS(HIPR1(10))-0.25
        CKIN(5)=ABS(HIPR1(10))-0.25
        CKIN(3)=ABS(HIPR1(10))-0.25
        CKIN(4)=ABS(HIPR1(10))+0.25
        IF(HIPR1(10).LT.HIPR1(8)) CKIN(4)=-1.0
c
        MSEL=0
        DO 101 ISUB=1,200
           MSUB(ISUB)=0
 101    CONTINUE
        IF(IHPR2(3).EQ.1) THEN
           MSUB(11)=1
           MSUB(12)=1
           MSUB(13)=1
           MSUB(28)=1
           MSUB(53)=1
           MSUB(68)=1
           MSUB(81)=1
           MSUB(82)=1
           MSUB(14)=1
           MSUB(18)=1
           MSUB(29)=1
           DO 102 J=1,MIN(8,MDCY(21,3))
 102           MDME(MDCY(21,2)+J-1,1)=0
           ISEL=4
           IF(HINT1(1).GE.20.0 .and. IHPR2(18).EQ.1) ISEL=5
           MDME(MDCY(21,2)+ISEL-1,1)=1
C                        ********QCD subprocesses
        ELSE IF(IHPR2(3).EQ.2) THEN
           MSUB(14)=1
           MSUB(18)=1
           MSUB(29)=1
C                ********Direct photon production
c                q+qbar->g+gamma,q+qbar->gamma+gamma, q+g->q+gamma
        ELSE IF(IHPR2(3).EQ.3) THEN
           CKIN(3)=MAX(0.0,HIPR1(10))
           CKIN(5)=HIPR1(8)
           PARP(81)=HIPR1(8)
           MSUB(81)=1
           MSUB(82)=1
           DO 105 J=1,MIN(8,MDCY(21,3))
 105           MDME(MDCY(21,2)+J-1,1)=0
           ISEL=4
           IF(HINT1(1).GE.20.0 .and. IHPR2(18).EQ.1) ISEL=5
           MDME(MDCY(21,2)+ISEL-1,1)=1
C             **********Heavy quark production
        ENDIF
260        IF(INI(itype).NE.0) GO TO 800
C
C
400        INI(itype)=1
        IF(IHPR2(10).EQ.0) MSTP(122)=0
        IF(NFP(JP,4).EQ.2212) THEN
                BEAM='P'
        ELSE IF(NFP(JP,4).EQ.-2212) THEN
                BEAM='P~'
        ELSE IF(NFP(JP,4).EQ.2112) THEN
                BEAM='N'
        ELSE IF(NFP(JP,4).EQ.-2112) THEN
                BEAM='N~'
        ELSE IF(NFP(JP,4).EQ.211) THEN
                BEAM='PI+'
        ELSE IF(NFP(JP,4).EQ.-211) THEN
                BEAM='PI-'
        ELSE IF(NFP(JP,4).EQ.321) THEN
                BEAM='PI+'
        ELSE IF(NFP(JP,4).EQ.-321) THEN
                BEAM='PI-'
        ELSE
                WRITE(6,*) 'unavailable beam type', NFP(JP,4)
        ENDIF
        IF(NFT(JT,4).EQ.2212) THEN
                TARG='P'
        ELSE IF(NFT(JT,4).EQ.-2212) THEN
                TARG='P~'
        ELSE IF(NFT(JT,4).EQ.2112) THEN
                TARG='N'
        ELSE IF(NFT(JT,4).EQ.-2112) THEN
                TARG='N~'
        ELSE IF(NFT(JT,4).EQ.211) THEN
                TARG='PI+'
        ELSE IF(NFT(JT,4).EQ.-211) THEN
                TARG='PI-'
        ELSE IF(NFT(JT,4).EQ.321) THEN
                TARG='PI+'
        ELSE IF(NFT(JT,4).EQ.-321) THEN
                TARG='PI-'
        ELSE
                WRITE(6,*) 'unavailable target type', NFT(JT,4)
        ENDIF
C
        IHNT2(16)=1
C       ******************indicate for initialization use when
C                         structure functions are called in PYTHIA
C
        CALL PYINIT('CMS',BEAM,TARG,HINT1(1))
        MINT4=MINT(44)
        MINT5=MINT(45)
        MINT44(itype)=MINT(44)
        MINT45(itype)=MINT(45)
        ATXS(0)=XSEC(0,1)
        XSEC0(itype,0)=XSEC(0,1)
        DO 500 I=1,200
                ATXS(I)=XSEC(I,1)
                XSEC0(itype,I)=XSEC(I,1)
                DO 500 J=1,20
                        ATCO(I,J)=COEF(I,J)
                        COEF0(itype,I,J)=COEF(I,J)
500        CONTINUE
C
        IHNT2(16)=0
C
        RETURN
C                ********Store the initialization information for
C                                late use
C
C
800        MINT(44)=MINT44(itype)
        MINT(45)=MINT45(itype)
        MINT4=MINT(44)
        MINT5=MINT(45)
        XSEC(0,1)=XSEC0(itype,0)
        ATXS(0)=XSEC(0,1)
        DO 900 I=1,200
                XSEC(I,1)=XSEC0(itype,I)
                ATXS(I)=XSEC(I,1)
        DO 900 J=1,20
                COEF(I,J)=COEF0(itype,I,J)
                ATCO(I,J)=COEF(I,J)
900        CONTINUE
        ilast=itrig
        MINT(11)=NFP(JP,4)
        MINT(12)=NFT(JT,4)
        RETURN
        END
C            
C
C
        SUBROUTINE HIJINI
        PARAMETER (MAXSTR=150001)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/HSTRNG/NFP(300,15),PP(300,15),NFT(300,15),PT(300,15)
cc      SAVE /HSTRNG/
        COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &                PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &                PJPM(300,500),NTJ(300),KFTJ(300,500),
     &                PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &                PJTE(300,500),PJTM(300,500)
cc      SAVE /HJJET1/
        COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &       K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &       PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
c        COMMON/HJJET4/NDR,IADR(900,2),KFDR(900),PDR(900,5)
        COMMON/HJJET4/NDR,IADR(MAXSTR,2),KFDR(MAXSTR),PDR(MAXSTR,5)
cc      SAVE /HJJET4/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   
C****************Reset the momentum of initial particles************
C             and assign flavors to the proj and targ string       *
C*******************************************************************
        NSG=0
        NDR=0
        IPP=2212
        IPT=2212
        IF(IHNT2(5).NE.0) IPP=IHNT2(5)
        IF(IHNT2(6).NE.0) IPT=IHNT2(6)
C                ********in case the proj or targ is a hadron.
C
        DO 100 I=1,IHNT2(1)
        PP(I,1)=0.0
        PP(I,2)=0.0
        PP(I,3)=SQRT(HINT1(1)**2/4.0-HINT1(8)**2)
        PP(I,4)=HINT1(1)/2
        PP(I,5)=HINT1(8)
        PP(I,6)=0.0
        PP(I,7)=0.0
        PP(I,8)=0.0
        PP(I,9)=0.0
        PP(I,10)=0.0
cbzdbg2/22/99
ctest OFF
        PP(I, 11) = 0.0
        PP(I, 12) = 0.0
cbzdbg2/22/99end
        NFP(I,3)=IPP
        NFP(I,4)=IPP
        NFP(I,5)=0
        NFP(I,6)=0
        NFP(I,7)=0
        NFP(I,8)=0
        NFP(I,9)=0
        NFP(I,10)=0
        NFP(I,11)=0
        NPJ(I)=0
        IF(I.GT.ABS(IHNT2(2))) NFP(I,3)=2112

clin-12/2012 correct NN differential cross section in HIJING:
        IF(I.GT.ABS(IHNT2(2))) NFP(I,4)=2112

        CALL ATTFLV(NFP(I,3),IDQ,IDQQ)
        NFP(I,1)=IDQ
        NFP(I,2)=IDQQ
        NFP(I,15)=-1
        IF(ABS(IDQ).GT.1000.OR.(ABS(IDQ*IDQQ).LT.100.AND.
     &                RANART(NSEED).LT.0.5)) NFP(I,15)=1
        PP(I,14)=ULMASS(IDQ)
        PP(I,15)=ULMASS(IDQQ)
100        CONTINUE
C
        DO 200 I=1,IHNT2(3)
        PT(I,1)=0.0
        PT(I,2)=0.0
        PT(I,3)=-SQRT(HINT1(1)**2/4.0-HINT1(9)**2)
        PT(I,4)=HINT1(1)/2.0
        PT(I,5)=HINT1(9)
        PT(I,6)=0.0
        PT(I,7)=0.0
        PT(I,8)=0.0
        PT(I,9)=0.0
        PT(I,10)=0.0
ctest OFF
cbzdbg2/22/99
        PT(I, 11) = 0.0
        PT(I, 12) = 0.0
cbzdbg2/22/99end
        NFT(I,3)=IPT
        NFT(I,4)=IPT
        NFT(I,5)=0
        NFT(I,6)=0
        NFT(I,7)=0
        NFT(I,8)=0
        NFT(I,9)=0
        NFT(I,10)=0
        NFT(I,11)=0
        NTJ(I)=0
        IF(I.GT.ABS(IHNT2(4))) NFT(I,3)=2112

clin-12/2012 correct NN differential cross section in HIJING:
        IF(I.GT.ABS(IHNT2(4))) NFT(I,4)=2112

        CALL ATTFLV(NFT(I,3),IDQ,IDQQ)
        NFT(I,1)=IDQ
        NFT(I,2)=IDQQ
        NFT(I,15)=1
        IF(ABS(IDQ).GT.1000.OR.(ABS(IDQ*IDQQ).LT.100.AND.
     &       RANART(NSEED).LT.0.5)) NFT(I,15)=-1
        PT(I,14)=ULMASS(IDQ)
        PT(I,15)=ULMASS(IDQQ)
200        CONTINUE
        RETURN
        END
C
C
C
        SUBROUTINE ATTFLV(ID,IDQ,IDQQ)
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   
C
        IF(ABS(ID).LT.100) THEN
                NSIGN=1
                IDQ=ID/100
                IDQQ=-ID/10+IDQ*10
                IF(ABS(IDQ).EQ.3) NSIGN=-1
                IDQ=NSIGN*IDQ
                IDQQ=NSIGN*IDQQ
                IF(IDQ.LT.0) THEN
                        ID0=IDQ
                        IDQ=IDQQ
                        IDQQ=ID0
                ENDIF
                RETURN
        ENDIF
C                ********return ID of quark(IDQ) and anti-quark(IDQQ)
C                        for pions and kaons
c
C        Return LU ID for quarks and diquarks for proton(ID=2212) 
C        anti-proton(ID=-2212) and nuetron(ID=2112)
C        LU ID for d=1,u=2, (ud)0=2101, (ud)1=2103, 
C       (dd)1=1103,(uu)1=2203.
C        Use SU(6)  weight  proton=1/3d(uu)1 + 1/6u(ud)1 + 1/2u(ud)0
C                          nurtron=1/3u(dd)1 + 1/6d(ud)1 + 1/2d(ud)0
C 
        IDQ=2
        IF(ABS(ID).EQ.2112) IDQ=1
        IDQQ=2101
        X=RANART(NSEED)
        IF(X.LE.0.5) GO TO 30
        IF(X.GT.0.666667) GO TO 10
        IDQQ=2103
        GO TO 30
10        IDQ=1
        IDQQ=2203
        IF(ABS(ID).EQ.2112) THEN
                IDQ=2
                IDQQ=1103
        ENDIF
30        IF(ID.LT.0) THEN
                ID00=IDQQ
                IDQQ=-IDQ
                IDQ=-ID00
        ENDIF
        RETURN
        END        
C
C*******************************************************************
C        This subroutine performs elastic scatterings and possible 
C        elastic cascading within their own nuclei
c*******************************************************************
        SUBROUTINE HIJCSC(JP,JT)
        DIMENSION PSC1(5),PSC2(5)
        COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        COMMON/HSTRNG/NFP(300,15),PP(300,15),NFT(300,15),PT(300,15)
cc      SAVE /HSTRNG/
        SAVE   
        IF(JP.EQ.0 .OR. JT.EQ.0) GO TO 25
        DO 10 I=1,5
        PSC1(I)=PP(JP,I)
        PSC2(I)=PT(JT,I)
10        CONTINUE
        CALL HIJELS(PSC1,PSC2)
        DPP1=PSC1(1)-PP(JP,1)
        DPP2=PSC1(2)-PP(JP,2)
        DPT1=PSC2(1)-PT(JT,1)
        DPT2=PSC2(2)-PT(JT,2)
        PP(JP,6)=PP(JP,6)+DPP1/2.0
        PP(JP,7)=PP(JP,7)+DPP2/2.0
        PP(JP,8)=PP(JP,8)+DPP1/2.0
        PP(JP,9)=PP(JP,9)+DPP2/2.0
        PT(JT,6)=PT(JT,6)+DPT1/2.0
        PT(JT,7)=PT(JT,7)+DPT2/2.0
        PT(JT,8)=PT(JT,8)+DPT1/2.0
        PT(JT,9)=PT(JT,9)+DPT2/2.0
        DO 20 I=1,4
        PP(JP,I)=PSC1(I)
        PT(JT,I)=PSC2(I)
20        CONTINUE
        NFP(JP,5)=MAX(1,NFP(JP,5))
        NFT(JT,5)=MAX(1,NFT(JT,5))
C                ********Perform elastic scattering between JP and JT
        RETURN
C                ********The following is for possible elastic cascade
c
25        IF(JP.EQ.0) GO TO 45
        PABS=SQRT(PP(JP,1)**2+PP(JP,2)**2+PP(JP,3)**2)
        BX=PP(JP,1)/PABS
        BY=PP(JP,2)/PABS
        BZ=PP(JP,3)/PABS
        DO 40 I=1,IHNT2(1)
                IF(I.EQ.JP) GO TO 40
                DX=YP(1,I)-YP(1,JP)
                DY=YP(2,I)-YP(2,JP)
                DZ=YP(3,I)-YP(3,JP)
                DIS=DX*BX+DY*BY+DZ*BZ
                IF(DIS.LE.0) GO TO 40
                BB=DX**2+DY**2+DZ**2-DIS**2
                R2=BB*HIPR1(40)/HIPR1(31)/0.1
C                ********mb=0.1*fm, YP is in fm,HIPR1(31) is in mb
                GS=1.0-EXP(-(HIPR1(30)+HINT1(11))/HIPR1(31)/2.0
     &                        *ROMG(R2))**2
                GS0=1.0-EXP(-(HIPR1(30)+HINT1(11))/HIPR1(31)/2.0
     &                        *ROMG(0.0))**2
                IF(RANART(NSEED).GT.GS/GS0) GO TO 40
                DO 30 K=1,5
                        PSC1(K)=PP(JP,K)
                        PSC2(K)=PP(I,K)
30                CONTINUE
                CALL HIJELS(PSC1,PSC2)
                DPP1=PSC1(1)-PP(JP,1)
                DPP2=PSC1(2)-PP(JP,2)
                DPT1=PSC2(1)-PP(I,1)
                DPT2=PSC2(2)-PP(I,2)
                PP(JP,6)=PP(JP,6)+DPP1/2.0
                PP(JP,7)=PP(JP,7)+DPP2/2.0
                PP(JP,8)=PP(JP,8)+DPP1/2.0
                PP(JP,9)=PP(JP,9)+DPP2/2.0
                PP(I,6)=PP(I,6)+DPT1/2.0
                PP(I,7)=PP(I,7)+DPT2/2.0
                PP(I,8)=PP(I,8)+DPT1/2.0
                PP(I,9)=PP(I,9)+DPT2/2.0
                DO 35 K=1,5
                        PP(JP,K)=PSC1(K)
                        PP(I,K)=PSC2(K)
35                CONTINUE
                NFP(I,5)=MAX(1,NFP(I,5))
                GO TO 45
40        CONTINUE
45        IF(JT.EQ.0) GO TO 80
clin 50        PABS=SQRT(PT(JT,1)**2+PT(JT,2)**2+PT(JT,3)**2)
        PABS=SQRT(PT(JT,1)**2+PT(JT,2)**2+PT(JT,3)**2)
        BX=PT(JT,1)/PABS
        BY=PT(JT,2)/PABS
        BZ=PT(JT,3)/PABS
        DO 70 I=1,IHNT2(3)
                IF(I.EQ.JT) GO TO 70
                DX=YT(1,I)-YT(1,JT)
                DY=YT(2,I)-YT(2,JT)
                DZ=YT(3,I)-YT(3,JT)
                DIS=DX*BX+DY*BY+DZ*BZ
                IF(DIS.LE.0) GO TO 70
                BB=DX**2+DY**2+DZ**2-DIS**2
                R2=BB*HIPR1(40)/HIPR1(31)/0.1
C                ********mb=0.1*fm, YP is in fm,HIPR1(31) is in mb
                GS=(1.0-EXP(-(HIPR1(30)+HINT1(11))/HIPR1(31)/2.0
     &                        *ROMG(R2)))**2
                GS0=(1.0-EXP(-(HIPR1(30)+HINT1(11))/HIPR1(31)/2.0
     &                        *ROMG(0.0)))**2
                IF(RANART(NSEED).GT.GS/GS0) GO TO 70
                DO 60 K=1,5
                        PSC1(K)=PT(JT,K)
                        PSC2(K)=PT(I,K)
60                CONTINUE
                CALL HIJELS(PSC1,PSC2)
                DPP1=PSC1(1)-PT(JT,1)
                DPP2=PSC1(2)-PT(JT,2)
                DPT1=PSC2(1)-PT(I,1)
                DPT2=PSC2(2)-PT(I,2)
                PT(JT,6)=PT(JT,6)+DPP1/2.0
                PT(JT,7)=PT(JT,7)+DPP2/2.0
                PT(JT,8)=PT(JT,8)+DPP1/2.0
                PT(JT,9)=PT(JT,9)+DPP2/2.0
                PT(I,6)=PT(I,6)+DPT1/2.0
                PT(I,7)=PT(I,7)+DPT2/2.0
                PT(I,8)=PT(I,8)+DPT1/2.0
                PT(I,9)=PT(I,9)+DPT2/2.0
                DO 65 K=1,5
                        PT(JT,K)=PSC1(K)
                        PT(I,K)=PSC2(K)
65                CONTINUE
                NFT(I,5)=MAX(1,NFT(I,5))
                GO TO 80
70        CONTINUE
80        RETURN
        END
C
C
C*******************************************************************
CThis subroutine performs elastic scattering between two nucleons
C
C*******************************************************************
        SUBROUTINE HIJELS(PSC1,PSC2)
        IMPLICIT DOUBLE PRECISION(D)
        DIMENSION PSC1(5),PSC2(5)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   
C
        CC=1.0-HINT1(12)/HINT1(13)
        RR=(1.0-CC)*HINT1(13)/HINT1(12)/(1.0-HIPR1(33))-1.0
        BB=0.5*(3.0+RR+SQRT(9.0+10.0*RR+RR**2))
        EP=SQRT((PSC1(1)-PSC2(1))**2+(PSC1(2)-PSC2(2))**2
     &                +(PSC1(3)-PSC2(3))**2)
        IF(EP.LE.0.1) RETURN
        ELS0=98.0/EP+52.0*(1.0+RR)**2
        PCM1=PSC1(1)+PSC2(1)
        PCM2=PSC1(2)+PSC2(2)
        PCM3=PSC1(3)+PSC2(3)
        ECM=PSC1(4)+PSC2(4)
        AM1=PSC1(5)**2
        AM2=PSC2(5)**2
        AMM=ECM**2-PCM1**2-PCM2**2-PCM3**2
        IF(AMM.LE.PSC1(5)+PSC2(5)) RETURN
C                ********elastic scattering only when approaching
C                                to each other
        PMAX=(AMM**2+AM1**2+AM2**2-2.0*AMM*AM1-2.0*AMM*AM2
     &                        -2.0*AM1*AM2)/4.0/AMM
        PMAX=ABS(PMAX)
20        TT=RANART(NSEED)*MIN(PMAX,1.5)
        ELS=98.0*EXP(-2.8*TT)/EP
     &         +52.0*EXP(-9.2*TT)*(1.0+RR*EXP(-4.6*(BB-1.0)*TT))**2
        IF(RANART(NSEED).GT.ELS/ELS0) GO TO 20
        PHI=2.0*HIPR1(40)*RANART(NSEED)
C
        DBX=dble(PCM1/ECM)
        DBY=dble(PCM2/ECM)
        DBZ=dble(PCM3/ECM)
        DB=dSQRT(DBX**2+DBY**2+DBZ**2)
        IF(DB.GT.0.99999999D0) THEN 
          DBX=DBX*(0.99999999D0/DB) 
          DBY=DBY*(0.99999999D0/DB) 
          DBZ=DBZ*(0.99999999D0/DB) 
          DB=0.99999999D0   
          WRITE(6,*) ' (HIJELS) boost vector too large' 
C                ********Rescale boost vector if too close to unity. 
        ENDIF   
        DGA=1D0/SQRT(1D0-DB**2)      
C
        DP1=dble(SQRT(TT)*SIN(PHI))
        DP2=dble(SQRT(TT)*COS(PHI))
        DP3=dble(SQRT(PMAX-TT))
        DP4=dble(SQRT(PMAX+AM1))
        DBP=DBX*DP1+DBY*DP2+DBZ*DP3   
        DGABP=DGA*(DGA*DBP/(1D0+DGA)+DP4) 
        PSC1(1)=sngl(DP1+DGABP*DBX)
        PSC1(2)=sngl(DP2+DGABP*DBY) 
        PSC1(3)=sngl(DP3+DGABP*DBZ) 
        PSC1(4)=sngl(DGA*(DP4+DBP))
C        
        DP1=-dble(SQRT(TT)*SIN(PHI))
        DP2=-dble(SQRT(TT)*COS(PHI))
        DP3=-dble(SQRT(PMAX-TT))
        DP4=dble(SQRT(PMAX+AM2))
        DBP=DBX*DP1+DBY*DP2+DBZ*DP3   
        DGABP=DGA*(DGA*DBP/(1D0+DGA)+DP4) 
        PSC2(1)=sngl(DP1+DGABP*DBX)
        PSC2(2)=sngl(DP2+DGABP*DBY)
        PSC2(3)=sngl(DP3+DGABP*DBZ)
        PSC2(4)=sngl(DGA*(DP4+DBP))
        RETURN
        END
C
C        
C*******************************************************************
C                                                                      *
C                Subroutine HIJSFT                                   *
C                                                                   *
C  Scatter two excited strings, JP from proj and JT from target    *
C*******************************************************************
        SUBROUTINE HIJSFT(JP,JT,JOUT,IERROR)
        PARAMETER (MAXSTR=150001)
        COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/HIJDAT/HIDAT0(10,10),HIDAT(10)
cc      SAVE /HIJDAT/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &               PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &               PJPM(300,500),NTJ(300),KFTJ(300,500),
     &               PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &               PJTE(300,500),PJTM(300,500)
cc      SAVE /HJJET1/
clin-4/25/01
c        COMMON/HJJET2/NSG,NJSG(900),IASG(900,3),K1SG(900,100),
c     &                K2SG(900,100),PXSG(900,100),PYSG(900,100),
c     &                PZSG(900,100),PESG(900,100),PMSG(900,100)
cc      SAVE /HJJET2/
        COMMON/HSTRNG/NFP(300,15),PP(300,15),NFT(300,15),PT(300,15)
cc      SAVE /HSTRNG/
        COMMON/DPMCM1/JJP,JJT,AMP,AMT,APX0,ATX0,AMPN,AMTN,AMP0,AMT0,
     &       NFDP,NFDT,WP,WM,SW,XREMP,XREMT,DPKC1,DPKC2,PP11,PP12,
     &       PT11,PT12,PTP2,PTT2
cc      SAVE /DPMCM1/
        COMMON/DPMCM2/NDPM,KDPM(20,2),PDPM1(20,5),PDPM2(20,5)
cc      SAVE /DPMCM2/
        SAVE   
C*******************************************************************
C        JOUT-> the number
C        of hard scatterings preceding this soft collision. 
C       IHNT2(13)-> 1=
C        double diffrac 2=single diffrac, 3=non-single diffrac.
C*******************************************************************
        IERROR=0
        JJP=JP
        JJT=JT
        NDPM=0
c        IOPMAIN=0
        IF(JP.GT.IHNT2(1) .OR. JT.GT.IHNT2(3)) RETURN

        EPP=PP(JP,4)+PP(JP,3)
        EPM=PP(JP,4)-PP(JP,3)
        ETP=PT(JT,4)+PT(JT,3)
        ETM=PT(JT,4)-PT(JT,3)

        WP=EPP+ETP
        WM=EPM+ETM
        SW=WP*WM
C                ********total W+,W- and center-of-mass energy

        IF(WP.LT.0.0 .OR. WM.LT.0.0) GO TO 1000

        IF(JOUT.EQ.0) THEN
                IF(EPP.LT.0.0) GO TO 1000
                IF(EPM.LT.0.0) GO TO 1000
                IF(ETP.LT.0.0) GO TO 1000
                IF(ETM.LT.0.0) GO TO 1000    
                IF(EPP/(EPM+0.01).LE.ETP/(ETM+0.01)) RETURN
        ENDIF
C                ********For strings which does not follow a jet-prod,
C                        scatter only if Ycm(JP)>Ycm(JT). When jets
C                        are produced just before this collision
C                        this requirement has already be enforced
C                        (see SUBROUTINE HIJHRD)
        IHNT2(11)=JP
        IHNT2(12)=JT
C
C
C
        MISS=0
        PKC1=0.0
        PKC2=0.0
        PKC11=0.0
        PKC12=0.0
        PKC21=0.0
        PKC22=0.0
        DPKC11=0.0
        DPKC12=0.0
        DPKC21=0.0
        DPKC22=0.0
        IF(NFP(JP,10).EQ.1.OR.NFT(JT,10).EQ.1) THEN
           IF(NFP(JP,10).EQ.1) THEN
              PHI1=ULANGL(PP(JP,10),PP(JP,11))
              PPJET=SQRT(PP(JP,10)**2+PP(JP,11)**2)
              PKC1=PPJET
              PKC11=PP(JP,10)
              PKC12=PP(JP,11)
           ENDIF
           IF(NFT(JT,10).EQ.1) THEN
              PHI2=ULANGL(PT(JT,10),PT(JT,11))
              PTJET=SQRT(PT(JT,10)**2+PT(JT,11)**2)
              PKC2=PTJET
              PKC21=PT(JT,10)
              PKC22=PT(JT,11)
           ENDIF
           IF(IHPR2(4).GT.0.AND.IHNT2(1).GT.1.AND.IHNT2(3).GT.1) THEN
              IF(NFP(JP,10).EQ.0) THEN
                 PHI=-PHI2
              ELSE IF(NFT(JT,10).EQ.0) THEN
                 PHI=PHI1
              ELSE
                 PHI=(PHI1+PHI2-HIPR1(40))/2.0
              ENDIF
              BX=HINT1(19)*COS(HINT1(20))
              BY=HINT1(19)*SIN(HINT1(20))
              XP0=YP(1,JP)
              YP0=YP(2,JP)
              XT0=YT(1,JT)+BX
              YT0=YT(2,JT)+BY
              R1=MAX(1.2*IHNT2(1)**0.3333333,
     &               SQRT(XP0**2+YP0**2))
              R2=MAX(1.2*IHNT2(3)**0.3333333,
     &               SQRT((XT0-BX)**2+(YT0-BY)**2))
              IF(ABS(COS(PHI)).LT.1.0E-5) THEN
                 DD1=R1
                 DD2=R1
                 DD3=ABS(BY+SQRT(R2**2-(XP0-BX)**2)-YP0)
                 DD4=ABS(BY-SQRT(R2**2-(XP0-BX)**2)-YP0)
                 GO TO 5
              ENDIF
              BB=2.0*SIN(PHI)*(COS(PHI)*YP0-SIN(PHI)*XP0)
              CC=(YP0**2-R1**2)*COS(PHI)**2+XP0*SIN(PHI)*(
     &                                XP0*SIN(PHI)-2.0*YP0*COS(PHI))
              DD=BB**2-4.0*CC
              IF(DD.LT.0.0) GO TO 10
              XX1=(-BB+SQRT(DD))/2.0
              XX2=(-BB-SQRT(DD))/2.0
              DD1=ABS((XX1-XP0)/COS(PHI))
              DD2=ABS((XX2-XP0)/COS(PHI))
C                        
              BB=2.0*SIN(PHI)*(COS(PHI)*(YT0-BY)-SIN(PHI)*XT0)-2.0*BX
              CC=(BX**2+(YT0-BY)**2-R2**2)*COS(PHI)**2+XT0*SIN(PHI)
     &           *(XT0*SIN(PHI)-2.0*COS(PHI)*(YT0-BY))
     &                 -2.0*BX*SIN(PHI)*(COS(PHI)*(YT0-BY)-SIN(PHI)*XT0)
              DD=BB**2-4.0*CC
              IF(DD.LT.0.0) GO TO 10
              XX1=(-BB+SQRT(DD))/2.0
              XX2=(-BB-SQRT(DD))/2.0
              DD3=ABS((XX1-XT0)/COS(PHI))
              DD4=ABS((XX2-XT0)/COS(PHI))
C
 5              DD1=MIN(DD1,DD3)
              DD2=MIN(DD2,DD4)
              IF(DD1.LT.HIPR1(13)) DD1=0.0
              IF(DD2.LT.HIPR1(13)) DD2=0.0
              IF(NFP(JP,10).EQ.1.AND.PPJET.GT.HIPR1(11)) THEN
                 DP1=DD1*HIPR1(14)/2.0
                 DP1=MIN(DP1,PPJET-HIPR1(11))
                 PKC1=PPJET-DP1
                 DPX1=COS(PHI1)*DP1
                 DPY1=SIN(PHI1)*DP1
                 PKC11=PP(JP,10)-DPX1
                 PKC12=PP(JP,11)-DPY1
                 IF(DP1.GT.0.0) THEN
                    CTHEP=PP(JP,12)/SQRT(PP(JP,12)**2+PPJET**2)
                    DPZ1=DP1*CTHEP/SQRT(1.0-CTHEP**2)
                    DPE1=SQRT(DPX1**2+DPY1**2+DPZ1**2)
                    EPPPRM=PP(JP,4)+PP(JP,3)-DPE1-DPZ1
                    EPMPRM=PP(JP,4)-PP(JP,3)-DPE1+DPZ1
                    IF(EPPPRM.LE.0.0.OR.EPMPRM.LE.0.0) GO TO 15
                    EPP=EPPPRM
                    EPM=EPMPRM
                    PP(JP,10)=PKC11
                    PP(JP,11)=PKC12
                    NPJ(JP)=NPJ(JP)+1
                    KFPJ(JP,NPJ(JP))=21
                    PJPX(JP,NPJ(JP))=DPX1
                    PJPY(JP,NPJ(JP))=DPY1
                    PJPZ(JP,NPJ(JP))=DPZ1
                    PJPE(JP,NPJ(JP))=DPE1
                    PJPM(JP,NPJ(JP))=0.0
                    PP(JP,3)=PP(JP,3)-DPZ1
                    PP(JP,4)=PP(JP,4)-DPE1
                 ENDIF
              ENDIF
 15              IF(NFT(JT,10).EQ.1.AND.PTJET.GT.HIPR1(11)) THEN
                 DP2=DD2*HIPR1(14)/2.0
                 DP2=MIN(DP2,PTJET-HIPR1(11))
                 PKC2=PTJET-DP2
                 DPX2=COS(PHI2)*DP2
                 DPY2=SIN(PHI2)*DP2
                 PKC21=PT(JT,10)-DPX2
                 PKC22=PT(JT,11)-DPY2
                 IF(DP2.GT.0.0) THEN
                    CTHET=PT(JT,12)/SQRT(PT(JT,12)**2+PTJET**2)
                    DPZ2=DP2*CTHET/SQRT(1.0-CTHET**2)
                    DPE2=SQRT(DPX2**2+DPY2**2+DPZ2**2)
                    ETPPRM=PT(JT,4)+PT(JT,3)-DPE2-DPZ2
                    ETMPRM=PT(JT,4)-PT(JT,3)-DPE2+DPZ2
                    IF(ETPPRM.LE.0.0.OR.ETMPRM.LE.0.0) GO TO 16
                    ETP=ETPPRM
                    ETM=ETMPRM
                    PT(JT,10)=PKC21
                    PT(JT,11)=PKC22
                    NTJ(JT)=NTJ(JT)+1
                    KFTJ(JT,NTJ(JT))=21
                    PJTX(JT,NTJ(JT))=DPX2
                    PJTY(JT,NTJ(JT))=DPY2
                    PJTZ(JT,NTJ(JT))=DPZ2
                    PJTE(JT,NTJ(JT))=DPE2
                    PJTM(JT,NTJ(JT))=0.0
                    PT(JT,3)=PT(JT,3)-DPZ2
                    PT(JT,4)=PT(JT,4)-DPE2
                 ENDIF
              ENDIF
 16              DPKC11=-(PP(JP,10)-PKC11)/2.0
              DPKC12=-(PP(JP,11)-PKC12)/2.0
              DPKC21=-(PT(JT,10)-PKC21)/2.0
              DPKC22=-(PT(JT,11)-PKC22)/2.0
              WP=EPP+ETP
              WM=EPM+ETM
              SW=WP*WM
           ENDIF
        ENDIF
C                ********If jet is quenched the pt from valence quark
C                        hard scattering has to reduced by d*kapa
C
C   
10        PTP02=PP(JP,1)**2+PP(JP,2)**2
        PTT02=PT(JT,1)**2+PT(JT,2)**2
C        
        AMQ=MAX(PP(JP,14)+PP(JP,15),PT(JT,14)+PT(JT,15))
        AMX=HIPR1(1)+AMQ
C                ********consider mass cut-off for strings which
C                        must also include quark's mass
        AMP0=AMX
        DPM0=AMX
        NFDP=0
        IF(NFP(JP,5).LE.2.AND.NFP(JP,3).NE.0) THEN
                AMP0=ULMASS(NFP(JP,3))
                NFDP=NFP(JP,3)+2*NFP(JP,3)/ABS(NFP(JP,3))
                DPM0=ULMASS(NFDP)
                IF(DPM0.LE.0.0) THEN
                        NFDP=NFDP-2*NFDP/ABS(NFDP)
                        DPM0=ULMASS(NFDP)
                ENDIF
        ENDIF
        AMT0=AMX
        DTM0=AMX
        NFDT=0
        IF(NFT(JT,5).LE.2.AND.NFT(JT,3).NE.0) THEN
                AMT0=ULMASS(NFT(JT,3))
                NFDT=NFT(JT,3)+2*NFT(JT,3)/ABS(NFT(JT,3))
                DTM0=ULMASS(NFDT)
                IF(DTM0.LE.0.0) THEN
                        NFDT=NFDT-2*NFDT/ABS(NFDT)
                        DTM0=ULMASS(NFDT)
                ENDIF
        ENDIF
C        
        AMPN=SQRT(AMP0**2+PTP02)
        AMTN=SQRT(AMT0**2+PTT02)
        SNN=(AMPN+AMTN)**2+0.001
C
        IF(SW.LT.SNN+0.001) GO TO 4000
C                ********Scatter only if SW>SNN
C*****give some PT kick to the two exited strings******************
clin 20        SWPTN=4.0*(MAX(AMP0,AMT0)**2+MAX(PTP02,PTT02))
        SWPTN=4.0*(MAX(AMP0,AMT0)**2+MAX(PTP02,PTT02))
        SWPTD=4.0*(MAX(DPM0,DTM0)**2+MAX(PTP02,PTT02))
        SWPTX=4.0*(AMX**2+MAX(PTP02,PTT02))
        IF(SW.LE.SWPTN) THEN
                PKCMX=0.0
        ELSE IF(SW.GT.SWPTN .AND. SW.LE.SWPTD
     &                .AND.NPJ(JP).EQ.0.AND.NTJ(JT).EQ.0) THEN
           PKCMX=SQRT(SW/4.0-MAX(AMP0,AMT0)**2)
     &           -SQRT(MAX(PTP02,PTT02))
        ELSE IF(SW.GT.SWPTD .AND. SW.LE.SWPTX
     &                .AND.NPJ(JP).EQ.0.AND.NTJ(JT).EQ.0) THEN
           PKCMX=SQRT(SW/4.0-MAX(DPM0,DTM0)**2)
     &           -SQRT(MAX(PTP02,PTT02))
        ELSE IF(SW.GT.SWPTX) THEN
           PKCMX=SQRT(SW/4.0-AMX**2)-SQRT(MAX(PTP02,PTT02))
        ENDIF
C                ********maximun PT kick
C*********************************************************
C
        IF(NFP(JP,10).EQ.1.OR.NFT(JT,10).EQ.1) THEN
                IF(PKC1.GT.PKCMX) THEN
                        PKC1=PKCMX
                        PKC11=PKC1*COS(PHI1)
                        PKC12=PKC1*SIN(PHI1)
                        DPKC11=-(PP(JP,10)-PKC11)/2.0
                        DPKC12=-(PP(JP,11)-PKC12)/2.0
                ENDIF
                IF(PKC2.GT.PKCMX) THEN
                        PKC2=PKCMX
                        PKC21=PKC2*COS(PHI2)
                        PKC22=PKC2*SIN(PHI2)
                        DPKC21=-(PT(JT,10)-PKC21)/2.0
                        DPKC22=-(PT(JT,11)-PKC22)/2.0
                ENDIF
                DPKC1=DPKC11+DPKC21
                DPKC2=DPKC12+DPKC22
                NFP(JP,10)=-NFP(JP,10)
                NFT(JT,10)=-NFT(JT,10)
                GO TO 40
        ENDIF
C                ********If the valence quarks had a hard-collision
C                        the pt kick is the pt from hard-collision.
        isng=0
        IF(IHPR2(13).NE.0 .AND. RANART(NSEED).LE.HIDAT(4)) isng=1
        IF((NFP(JP,5).EQ.3 .OR.NFT(JT,5).EQ.3).OR.
     &                (NPJ(JP).NE.0.OR.NFP(JP,10).NE.0).OR.
     &                (NTJ(JT).NE.0.OR.NFT(JT,10).NE.0)) isng=0
C
C               ********decite whether to have single-diffractive
        IF(IHPR2(5).EQ.0) THEN
                PKC=HIPR1(2)*SQRT(-ALOG(1.0-RANART(NSEED)
     &                        *(1.0-EXP(-PKCMX**2/HIPR1(2)**2))))
                GO TO 30
        ENDIF

clin-10/28/02 get rid of argument usage mismatch in HIRND2():
c        PKC=HIRND2(3,0.0,PKCMX**2)
        xminhi=0.0
        xmaxhi=PKCMX**2
        PKC=HIRND2(3,xminhi,xmaxhi)

        PKC=SQRT(PKC)
        IF(PKC.GT.HIPR1(20)) 
     &           PKC=HIPR1(2)*SQRT(-ALOG(EXP(-HIPR1(20)**2/HIPR1(2)**2)
     &               -RANART(NSEED)*(EXP(-HIPR1(20)**2/HIPR1(2)**2)-
     &               EXP(-PKCMX**2/HIPR1(2)**2))))
C
        IF(isng.EQ.1) PKC=0.65*SQRT(
     &       -ALOG(1.0-RANART(NSEED)*(1.0-EXP(-PKCMX**2/0.65**2))))
C                        ********select PT kick
30        PHI0=2.0*HIPR1(40)*RANART(NSEED)
        PKC11=PKC*SIN(PHI0)
        PKC12=PKC*COS(PHI0)
        PKC21=-PKC11
        PKC22=-PKC12
        DPKC1=0.0
        DPKC2=0.0
40        PP11=PP(JP,1)+PKC11-DPKC1
        PP12=PP(JP,2)+PKC12-DPKC2
        PT11=PT(JT,1)+PKC21-DPKC1
        PT12=PT(JT,2)+PKC22-DPKC2
        PTP2=PP11**2+PP12**2
        PTT2=PT11**2+PT12**2
C
        AMPN=SQRT(AMP0**2+PTP2)
        AMTN=SQRT(AMT0**2+PTT2)
        SNN=(AMPN+AMTN)**2+0.001
C***************************************
        WP=EPP+ETP
        WM=EPM+ETM
        SW=WP*WM
C****************************************
        IF(SW.LT.SNN) THEN
           MISS=MISS+1
           IF(MISS.LE.100) then
              PKC=0.0
              GO TO 30
           ENDIF
           IF(IHPR2(10).NE.0) 
     &          WRITE(6,*) 'Error occured in Pt kick section of HIJSFT'
           GO TO 4000
        ENDIF
C******************************************************************
        AMPD=SQRT(DPM0**2+PTP2)
        AMTD=SQRT(DTM0**2+PTT2)

        AMPX=SQRT(AMX**2+PTP2)
        AMTX=SQRT(AMX**2+PTT2)

        DPN=AMPN**2/SW
        DTN=AMTN**2/SW
        DPD=AMPD**2/SW
        DTD=AMTD**2/SW
        DPX=AMPX**2/SW
        DTX=AMTX**2/SW
C
        SPNTD=(AMPN+AMTD)**2
        SPNTX=(AMPN+AMTX)**2
C                        ********CM energy if proj=N,targ=N*
        SPDTN=(AMPD+AMTN)**2
        SPXTN=(AMPX+AMTN)**2
C                        ********CM energy if proj=N*,targ=N
        SPDTX=(AMPD+AMTX)**2
        SPXTD=(AMPX+AMTD)**2
        SDD=(AMPD+AMTD)**2
        SXX=(AMPX+AMTX)**2

C
C        
C                ********CM energy if proj=delta, targ=delta
C****************There are many different cases**********
c        IF(IHPR2(15).EQ.1) GO TO 500
C
C                ********to have DPM type soft interactions
C
clin 45        CONTINUE
        IF(SW.GT.SXX+0.001) THEN
           IF(isng.EQ.0) THEN
               D1=DPX
              D2=DTX
              NFP3=0
              NFT3=0
              GO TO 400
           ELSE
c**** 5/30/1998 this is identical to the above statement. Added to
c**** avoid questional branching to block.
              IF((NFP(JP,5).EQ.3 .AND.NFT(JT,5).EQ.3).OR.
     &                 (NPJ(JP).NE.0.OR.NFP(JP,10).NE.0).OR.
     &                 (NTJ(JT).NE.0.OR.NFT(JT,10).NE.0)) THEN
                 D1=DPX
                 D2=DTX
                 NFP3=0
                 NFT3=0
                 GO TO 400
              ENDIF
C                ********do not allow excited strings to have 
C                        single-diffr 
              IF(RANART(NSEED).GT.0.5.OR.(NFT(JT,5).GT.2.OR.
     &                      NTJ(JT).NE.0.OR.NFT(JT,10).NE.0)) THEN
                 D1=DPN
                 D2=DTX
                 NFP3=NFP(JP,3)
                 NFT3=0
                 GO TO 220
              ELSE
                 D1=DPX
                 D2=DTN
                 NFP3=0
                 NFT3=NFT(JT,3)
                 GO TO 240
              ENDIF
C                ********have single diffractive collision
           ENDIF
        ELSE IF(SW.GT.MAX(SPDTX,SPXTD)+0.001 .AND.
     &                                SW.LE.SXX+0.001) THEN
           IF(((NPJ(JP).EQ.0.AND.NTJ(JT).EQ.0.AND.
     &         RANART(NSEED).GT.0.5).OR.(NPJ(JP).EQ.0
     &         .AND.NTJ(JT).NE.0)).AND.NFP(JP,5).LE.2) THEN
              D1=DPD
              D2=DTX
              NFP3=NFDP
              NFT3=0
              GO TO 220
           ELSE IF(NTJ(JT).EQ.0.AND.NFT(JT,5).LE.2) THEN
              D1=DPX
              D2=DTD
              NFP3=0
              NFT3=NFDT
              GO TO 240
           ENDIF
           GO TO 4000
        ELSE IF(SW.GT.MIN(SPDTX,SPXTD)+0.001.AND.
     &                        SW.LE.MAX(SPDTX,SPXTD)+0.001) THEN
           IF(SPDTX.LE.SPXTD.AND.NPJ(JP).EQ.0
     &                       .AND.NFP(JP,5).LE.2) THEN
              D1=DPD
              D2=DTX
              NFP3=NFDP
              NFT3=0
              GO TO 220
           ELSE IF(SPDTX.GT.SPXTD.AND.NTJ(JT).EQ.0
     &                       .AND.NFT(JT,5).LE.2) THEN
              D1=DPX
              D2=DTD
              NFP3=0
              NFT3=NFDT
              GO TO 240
           ENDIF
c*** 5/30/1998 added to avoid questional branching to another block
c*** this is identical to the statement following the next ELSE IF
           IF(((NPJ(JP).EQ.0.AND.NTJ(JT).EQ.0
     &       .AND.RANART(NSEED).GT.0.5).OR.(NPJ(JP).EQ.0
     &        .AND.NTJ(JT).NE.0)).AND.NFP(JP,5).LE.2) THEN
              D1=DPN
              D2=DTX
              NFP3=NFP(JP,3)
              NFT3=0
              GO TO 220
           ELSE IF(NTJ(JT).EQ.0.AND.NFT(JT,5).LE.2) THEN
              D1=DPX
              D2=DTN
              NFP3=0
              NFT3=NFT(JT,3)
              GO TO 240
           ENDIF
           GO TO 4000
        ELSE IF(SW.GT.MAX(SPNTX,SPXTN)+0.001 .AND.
     &                        SW.LE.MIN(SPDTX,SPXTD)+0.001) THEN
           IF(((NPJ(JP).EQ.0.AND.NTJ(JT).EQ.0
     &       .AND.RANART(NSEED).GT.0.5).OR.(NPJ(JP).EQ.0
     &        .AND.NTJ(JT).NE.0)).AND.NFP(JP,5).LE.2) THEN
              D1=DPN
              D2=DTX
              NFP3=NFP(JP,3)
              NFT3=0
              GO TO 220
           ELSE IF(NTJ(JT).EQ.0.AND.NFT(JT,5).LE.2) THEN
              D1=DPX
              D2=DTN
              NFP3=0
              NFT3=NFT(JT,3)
              GO TO 240
           ENDIF
           GO TO 4000
        ELSE IF(SW.GT.MIN(SPNTX,SPXTN)+0.001 .AND.
     &                        SW.LE.MAX(SPNTX,SPXTN)+0.001) THEN
           IF(SPNTX.LE.SPXTN.AND.NPJ(JP).EQ.0
     &                           .AND.NFP(JP,5).LE.2) THEN
              D1=DPN
              D2=DTX
              NFP3=NFP(JP,3)
              NFT3=0
              GO TO 220
           ELSEIF(SPNTX.GT.SPXTN.AND.NTJ(JT).EQ.0
     &                           .AND.NFT(JT,5).LE.2) THEN
              D1=DPX
              D2=DTN
              NFP3=0
              NFT3=NFT(JT,3)
              GO TO 240
           ENDIF
           GO TO 4000
        ELSE IF(SW.LE.MIN(SPNTX,SPXTN)+0.001 .AND.
     &                        (NPJ(JP).NE.0 .OR.NTJ(JT).NE.0)) THEN
           GO TO 4000
        ELSE IF(SW.LE.MIN(SPNTX,SPXTN)+0.001 .AND.
     &                NFP(JP,5).GT.2.AND.NFT(JT,5).GT.2) THEN
           GO TO 4000
        ELSE IF(SW.GT.SDD+0.001.AND.SW.LE.
     &                     MIN(SPNTX,SPXTN)+0.001) THEN
           D1=DPD
           D2=DTD
           NFP3=NFDP
           NFT3=NFDT
           GO TO 100
        ELSE IF(SW.GT.MAX(SPNTD,SPDTN)+0.001 
     &                      .AND. SW.LE.SDD+0.001) THEN
           IF(RANART(NSEED).GT.0.5) THEN
              D1=DPD
              D2=DTN
              NFP3=NFDP
              NFT3=NFT(JT,3)
              GO TO 100
           ELSE
              D1=DPN
              D2=DTD
              NFP3=NFP(JP,3)
              NFT3=NFDT
              GO TO 100
           ENDIF
        ELSE IF(SW.GT.MIN(SPNTD,SPDTN)+0.001
     &                .AND. SW.LE.MAX(SPNTD,SPDTN)+0.001) THEN
           IF(SPNTD.GT.SPDTN) THEN
              D1=DPD
              D2=DTN
              NFP3=NFDP
              NFT3=NFT(JT,3)
              GO TO 100
           ELSE
              D1=DPN
              D2=DTD
              NFP3=NFP(JP,3)
              NFT3=NFDT
              GO TO 100
           ENDIF
        ELSE IF(SW.LE.MIN(SPNTD,SPDTN)+0.001) THEN
           D1=DPN
           D2=DTN
           NFP3=NFP(JP,3)
           NFT3=NFT(JT,3)
           GO TO 100
        ENDIF
        WRITE(6,*) ' Error in HIJSFT: There is no path to here'
        RETURN
C
C***************  elastic scattering ***************
C        this is like elastic, both proj and targ mass
C        must be fixed
C***************************************************
100        NFP5=MAX(2,NFP(JP,5))
        NFT5=MAX(2,NFT(JT,5))
        BB1=1.0+D1-D2
        BB2=1.0+D2-D1
        IF(BB1**2.LT.4.0*D1 .OR. BB2**2.LT.4.0*D2) THEN
                MISS=MISS+1
                IF(MISS.GT.100.OR.PKC.EQ.0.0) GO TO 3000
                PKC=PKC*0.5
                GO TO 30
        ENDIF
        IF(RANART(NSEED).LT.0.5) THEN
                X1=(BB1-SQRT(BB1**2-4.0*D1))/2.0
                X2=(BB2-SQRT(BB2**2-4.0*D2))/2.0
        ELSE
                X1=(BB1+SQRT(BB1**2-4.0*D1))/2.0
                X2=(BB2+SQRT(BB2**2-4.0*D2))/2.0
        ENDIF
        IHNT2(13)=2
        GO TO 600
C
C********** Single diffractive ***********************
C either proj or targ's mass is fixed
C*****************************************************
220        NFP5=MAX(2,NFP(JP,5))
        NFT5=3
        IF(NFP3.EQ.0) NFP5=3
        BB2=1.0+D2-D1
        IF(BB2**2.LT.4.0*D2) THEN
                MISS=MISS+1
                IF(MISS.GT.100.OR.PKC.EQ.0.0) GO TO 3000
                PKC=PKC*0.5
                GO TO 30
        ENDIF
        XMIN=(BB2-SQRT(BB2**2-4.0*D2))/2.0
        XMAX=(BB2+SQRT(BB2**2-4.0*D2))/2.0
        MISS4=0
222        X2=HIRND2(6,XMIN,XMAX)
        X1=D1/(1.0-X2)
        IF(X2*(1.0-X1).LT.(D2+1.E-4/SW)) THEN
                MISS4=MISS4+1
                IF(MISS4.LE.1000) GO TO 222
                GO TO 5000
        ENDIF
        IHNT2(13)=2
        GO TO 600
C                        ********Fix proj mass*********
240        NFP5=3
        NFT5=MAX(2,NFT(JT,5))
        IF(NFT3.EQ.0) NFT5=3
        BB1=1.0+D1-D2
        IF(BB1**2.LT.4.0*D1) THEN
                MISS=MISS+1
                IF(MISS.GT.100.OR.PKC.EQ.0.0) GO TO 3000
                PKC=PKC*0.5
                GO TO 30
        ENDIF
        XMIN=(BB1-SQRT(BB1**2-4.0*D1))/2.0
        XMAX=(BB1+SQRT(BB1**2-4.0*D1))/2.0
        MISS4=0
242        X1=HIRND2(6,XMIN,XMAX)
        X2=D2/(1.0-X1)
        IF(X1*(1.0-X2).LT.(D1+1.E-4/SW)) THEN
                MISS4=MISS4+1
                IF(MISS4.LE.1000) GO TO 242
                GO TO 5000
        ENDIF
        IHNT2(13)=2
        GO TO 600
C                        ********Fix targ mass*********
C
C*************non-single diffractive**********************
C        both proj and targ may not be fixed in mass 
C*********************************************************
C
400        NFP5=3
        NFT5=3
        BB1=1.0+D1-D2
        BB2=1.0+D2-D1
        IF(BB1**2.LT.4.0*D1 .OR. BB2**2.LT.4.0*D2) THEN
                MISS=MISS+1
                IF(MISS.GT.100.OR.PKC.EQ.0.0) GO TO 3000
                PKC=PKC*0.5
                GO TO 30
        ENDIF
        XMIN1=(BB1-SQRT(BB1**2-4.0*D1))/2.0
        XMAX1=(BB1+SQRT(BB1**2-4.0*D1))/2.0
        XMIN2=(BB2-SQRT(BB2**2-4.0*D2))/2.0
        XMAX2=(BB2+SQRT(BB2**2-4.0*D2))/2.0
        MISS4=0        
410        X1=HIRND2(4,XMIN1,XMAX1)
        X2=HIRND2(4,XMIN2,XMAX2)
        IF(NFP(JP,5).EQ.3.OR.NFT(JT,5).EQ.3) THEN
                X1=HIRND2(6,XMIN1,XMAX1)
                X2=HIRND2(6,XMIN2,XMAX2)
        ENDIF
C                        ********
        IF(ABS(NFP(JP,1)*NFP(JP,2)).GT.1000000.OR.
     &                        ABS(NFP(JP,1)*NFP(JP,2)).LT.100) THEN
                X1=HIRND2(5,XMIN1,XMAX1)
        ENDIF
        IF(ABS(NFT(JT,1)*NFT(JT,2)).GT.1000000.OR.
     &                        ABS(NFT(JT,1)*NFT(JT,2)).LT.100) THEN
                X2=HIRND2(5,XMIN2,XMAX2)
        ENDIF
c        IF(IOPMAIN.EQ.3) X1=HIRND2(6,XMIN1,XMAX1)
c        IF(IOPMAIN.EQ.2) X2=HIRND2(6,XMIN2,XMAX2) 
C        ********For q-qbar or (qq)-(qq)bar system use symetric
C                distribution, for q-(qq) or qbar-(qq)bar use
C                unsymetrical distribution
C
        IF(ABS(NFP(JP,1)*NFP(JP,2)).GT.1000000) X1=1.0-X1
        XXP=X1*(1.0-X2)
        XXT=X2*(1.0-X1)
        IF(XXP.LT.(D1+1.E-4/SW) .OR. XXT.LT.(D2+1.E-4/SW)) THEN
                MISS4=MISS4+1
                IF(MISS4.LE.1000) GO TO 410
                GO TO 5000
        ENDIF
        IHNT2(13)=3
C***************************************************
C***************************************************
600        CONTINUE
        IF(X1*(1.0-X2).LT.(AMPN**2-1.E-4)/SW.OR.
     &                        X2*(1.0-X1).LT.(AMTN**2-1.E-4)/SW) THEN
                MISS=MISS+1
                IF(MISS.GT.100.OR.PKC.EQ.0.0) GO TO 2000
                PKC=0.0
                GO TO 30
        ENDIF
C
        EPP=(1.0-X2)*WP
        EPM=X1*WM
        ETP=X2*WP
        ETM=(1.0-X1)*WM
        PP(JP,3)=(EPP-EPM)/2.0
        PP(JP,4)=(EPP+EPM)/2.0
        IF(EPP*EPM-PTP2.LT.0.0) GO TO 6000
        PP(JP,5)=SQRT(EPP*EPM-PTP2)
        NFP(JP,3)=NFP3
        NFP(JP,5)=NFP5

        PT(JT,3)=(ETP-ETM)/2.0
        PT(JT,4)=(ETP+ETM)/2.0
        IF(ETP*ETM-PTT2.LT.0.0) GO TO 6000
        PT(JT,5)=SQRT(ETP*ETM-PTT2)
        NFT(JT,3)=NFT3
        NFT(JT,5)=NFT5
C*****recoil PT from hard-inter is shared by two end-partons 
C       so that pt=p1+p2
        PP(JP,1)=PP11-PKC11
        PP(JP,2)=PP12-PKC12

        KCDIP=1
        KCDIT=1
        IF(ABS(NFP(JP,1)*NFP(JP,2)).GT.1000000.OR.
     &                        ABS(NFP(JP,1)*NFP(JP,2)).LT.100) THEN
                KCDIP=0
        ENDIF
        IF(ABS(NFT(JT,1)*NFT(JT,2)).GT.1000000.OR.
     &                        ABS(NFT(JT,1)*NFT(JT,2)).LT.100) THEN
                KCDIT=0
        ENDIF
        IF((KCDIP.EQ.0.AND.RANART(NSEED).LT.0.5)
     &     .OR.(KCDIP.NE.0.AND.RANART(NSEED)
     &     .LT.0.5/(1.0+(PKC11**2+PKC12**2)/HIPR1(22)**2))) THEN
           PP(JP,6)=(PP(JP,1)-PP(JP,6)-PP(JP,8)-DPKC1)/2.0+PP(JP,6)
           PP(JP,7)=(PP(JP,2)-PP(JP,7)-PP(JP,9)-DPKC2)/2.0+PP(JP,7)
           PP(JP,8)=(PP(JP,1)-PP(JP,6)-PP(JP,8)-DPKC1)/2.0
     &              +PP(JP,8)+PKC11
           PP(JP,9)=(PP(JP,2)-PP(JP,7)-PP(JP,9)-DPKC2)/2.0
     &              +PP(JP,9)+PKC12
        ELSE
           PP(JP,8)=(PP(JP,1)-PP(JP,6)-PP(JP,8)-DPKC1)/2.0+PP(JP,8)
           PP(JP,9)=(PP(JP,2)-PP(JP,7)-PP(JP,9)-DPKC2)/2.0+PP(JP,9)
           PP(JP,6)=(PP(JP,1)-PP(JP,6)-PP(JP,8)-DPKC1)/2.0
     &              +PP(JP,6)+PKC11
           PP(JP,7)=(PP(JP,2)-PP(JP,7)-PP(JP,9)-DPKC2)/2.0
     &              +PP(JP,7)+PKC12
        ENDIF
        PP(JP,1)=PP(JP,6)+PP(JP,8)
        PP(JP,2)=PP(JP,7)+PP(JP,9)
C                                ********pt kick for proj
        PT(JT,1)=PT11-PKC21
        PT(JT,2)=PT12-PKC22
        IF((KCDIT.EQ.0.AND.RANART(NSEED).LT.0.5)
     &     .OR.(KCDIT.NE.0.AND.RANART(NSEED)
     &     .LT.0.5/(1.0+(PKC21**2+PKC22**2)/HIPR1(22)**2))) THEN
           PT(JT,6)=(PT(JT,1)-PT(JT,6)-PT(JT,8)-DPKC1)/2.0+PT(JT,6)
           PT(JT,7)=(PT(JT,2)-PT(JT,7)-PT(JT,9)-DPKC2)/2.0+PT(JT,7)
           PT(JT,8)=(PT(JT,1)-PT(JT,6)-PT(JT,8)-DPKC1)/2.0
     &              +PT(JT,8)+PKC21
           PT(JT,9)=(PT(JT,2)-PT(JT,7)-PT(JT,9)-DPKC2)/2.0
     &              +PT(JT,9)+PKC22
        ELSE
           PT(JT,8)=(PT(JT,1)-PT(JT,6)-PT(JT,8)-DPKC1)/2.0+PT(JT,8)
           PT(JT,9)=(PT(JT,2)-PT(JT,7)-PT(JT,9)-DPKC2)/2.0+PT(JT,9)
           PT(JT,6)=(PT(JT,1)-PT(JT,6)-PT(JT,8)-DPKC1)/2.0
     &              +PT(JT,6)+PKC21
           PT(JT,7)=(PT(JT,2)-PT(JT,7)-PT(JT,9)-DPKC2)/2.0
     &              +PT(JT,7)+PKC22
        ENDIF
        PT(JT,1)=PT(JT,6)+PT(JT,8)
        PT(JT,2)=PT(JT,7)+PT(JT,9)
C                        ********pt kick for targ

        IF(NPJ(JP).NE.0) NFP(JP,5)=3
        IF(NTJ(JT).NE.0) NFT(JT,5)=3
C                        ********jets must be connected to string
        IF(EPP/(EPM+0.0001).LT.ETP/(ETM+0.0001).AND.
     &                        ABS(NFP(JP,1)*NFP(JP,2)).LT.1000000)THEN
                DO 620 JSB=1,15
                PSB=PP(JP,JSB)
                PP(JP,JSB)=PT(JT,JSB)
                PT(JT,JSB)=PSB
                NSB=NFP(JP,JSB)
                NFP(JP,JSB)=NFT(JT,JSB)
                NFT(JT,JSB)=NSB
620                CONTINUE
C                ********when Ycm(JP)<Ycm(JT) after the collision
C                        exchange the positions of the two   
        ENDIF
C
        RETURN
C**************************************************
C**************************************************
1000        IERROR=1
        IF(IHPR2(10).EQ.0) RETURN
        WRITE(6,*) '     Fatal HIJSFT start error,abandon this event'
        WRITE(6,*) '     PROJ E+,E-,W+',EPP,EPM,WP
        WRITE(6,*) '     TARG E+,E-,W-',ETP,ETM,WM
        WRITE(6,*) '     W+*W-, (APN+ATN)^2',SW,SNN
        RETURN
2000        IERROR=0
        IF(IHPR2(10).EQ.0) RETURN
        WRITE(6,*) '     (2)energy partition fail,'
        WRITE(6,*) '     HIJSFT not performed, but continue'
        WRITE(6,*) '     MP1,MPN',X1*(1.0-X2)*SW,AMPN**2
        WRITE(6,*) '     MT2,MTN',X2*(1.0-X1)*SW,AMTN**2
        RETURN
3000        IERROR=0
        IF(IHPR2(10).EQ.0) RETURN
        WRITE(6,*) '     (3)something is wrong with the pt kick, '
        WRITE(6,*) '     HIJSFT not performed, but continue'
        WRITE(6,*) '     D1=',D1,' D2=',D2,' SW=',SW
        WRITE(6,*) '     HISTORY NFP5=',NFP(JP,5),' NFT5=',NFT(JT,5)
        WRITE(6,*) '     THIS COLLISON NFP5=',NFP5, ' NFT5=',NFT5
        WRITE(6,*) '     # OF JET IN PROJ',NPJ(JP),' IN TARG',NTJ(JT)
        RETURN
4000        IERROR=0
        IF(IHPR2(10).EQ.0) RETURN
        WRITE(6,*) '     (4)unable to choose process, but not harmful'
        WRITE(6,*) '     HIJSFT not performed, but continue'
        WRITE(6,*) '     PTP=',SQRT(PTP2),' PTT=',SQRT(PTT2),' SW=',SW
        WRITE(6,*) '     AMCUT=',AMX,' JP=',JP,' JT=',JT
        WRITE(6,*) '     HISTORY NFP5=',NFP(JP,5),' NFT5=',NFT(JT,5)
        RETURN
5000        IERROR=0
        IF(IHPR2(10).EQ.0) RETURN
        WRITE(6,*) '     energy partition failed(5),for limited try'
        WRITE(6,*) '     HIJSFT not performed, but continue'
        WRITE(6,*) '     NFP5=',NFP5,' NFT5=',NFT5
        WRITE(6,*) '     D1',D1,' X1(1-X2)',X1*(1.0-X2)
        WRITE(6,*) '     D2',D2,' X2(1-X1)',X2*(1.0-X1)
        RETURN
6000        PKC=0.0
        MISS=MISS+1
        IF(MISS.LT.100) GO TO 30
        IERROR=1
        IF(IHPR2(10).EQ.0) RETURN
        WRITE(6,*) ' ERROR OCCURED, HIJSFT NOT PERFORMED'
        WRITE(6,*) ' Abort this event'
        WRITE(6,*) 'MTP,PTP2',EPP*EPM,PTP2,'  MTT,PTT2',ETP*ETM,PTT2 
        RETURN
        END
C
C
C
C ********************************************************
C ************************              WOOD-SAX
        SUBROUTINE HIJWDS(IA,IDH,XHIGH)
C     SETS UP HISTOGRAM IDH WITH RADII FOR
C     NUCLEUS IA DISTRIBUTED ACCORDING TO THREE PARAM WOOD SAXON
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/WOOD/R,D,FNORM,W
cc      SAVE /WOOD/
c        DIMENSION IAA(20),RR(20),DD(20),WW(20),RMS(20)
        DIMENSION IAA(20),RR(20),DD(20),WW(20)
        EXTERNAL RWDSAX,WDSAX
        SAVE   
C
C   PARAMETERS OF SPECIAL NUCLEI FROM ATOMIC DATA AND NUC DATA TABLES
C     VOL 14, 5-6 1974
        DATA IAA/2,4,12,16,27,32,40,56,63,93,184,197,208,7*0./
        DATA RR/0.01,.964,2.355,2.608,2.84,3.458,3.766,3.971,4.214,
     1        4.87,6.51,6.38,6.624,7*0./
        DATA DD/0.5882,.322,.522,.513,.569,.61,.586,.5935,.586,.573,
     1        .535,.535,.549,7*0./
        DATA WW/0.0,.517,-0.149,-0.051,0.,-0.208,-0.161,13*0./
c        DATA RMS/2.11,1.71,2.46,2.73,3.05,3.247,3.482,3.737,3.925,4.31,
c     1        5.42,5.33,5.521,7*0./
C
              A=IA
C
C                 ********SET WOOD-SAX PARAMS FIRST  AS IN DATE ET AL
              D=0.54
C                        ********D IS WOOD SAX DIFFUSE PARAM IN FM
        R=1.19*A**(1./3.) - 1.61*A**(-1./3.)
C                         ********R IS RADIUS PARAM
        W=0.
C                 ********W IS The third of three WOOD-SAX PARAM
C
C                      ********CHECK TABLE FOR SPECIAL CASES
        DO 10 I=1,13
                IF (IA.EQ.IAA(I)) THEN
                        R=RR(I)
                             D=DD(I)
                              W=WW(I)
clin RS not used                              RS=RMS(I)
                      END IF
10            CONTINUE
C                             ********FNORM is the normalize factor
              FNORM=1.0
              XLOW=0.
              XHIGH=R+ 12.*D
              IF (W.LT.-0.01)  THEN
                      IF (XHIGH.GT.R/SQRT(ABS(W))) XHIGH=R/SQRT(ABS(W))
              END IF
              FGAUS=GAUSS1(RWDSAX,XLOW,XHIGH,0.001)
              FNORM=1./FGAUS
C
        IF (IDH.EQ.1) THEN
           HINT1(72)=R
           HINT1(73)=D
           HINT1(74)=W
           HINT1(75)=FNORM/4.0/HIPR1(40)
        ELSE IF (IDH.EQ.2) THEN
           HINT1(76)=R
           HINT1(77)=D
           HINT1(78)=W
           HINT1(79)=FNORM/4.0/HIPR1(40)
        ENDIF
C
C             NOW SET UP HBOOK FUNCTIONS IDH FOR  R**2*RHO(R)
C             THESE HISTOGRAMS ARE USED TO GENERATE RANDOM RADII
              CALL HIFUN(IDH,XLOW,XHIGH,RWDSAX)
              RETURN
              END
C
C
        FUNCTION WDSAX(X)
C                             ********THREE PARAMETER WOOD SAXON
              COMMON/WOOD/R,D,FNORM,W
cc      SAVE /WOOD/
        SAVE   
              WDSAX=FNORM*(1.+W*(X/R)**2)/(1+EXP((X-R)/D))
               IF (W.LT.0.) THEN
                       IF (X.GE.R/SQRT(ABS(W))) WDSAX=0.
               ENDIF
              RETURN
              END
C
C
        FUNCTION RWDSAX(X)
        SAVE   
              RWDSAX=X*X*WDSAX(X)
              RETURN
              END
C
C
C
C
C The next three subroutines are for Monte Carlo generation 
C according to a given function FHB. One calls first HIFUN 
C with assigned channel number I, low and up limits. Then to 
C generate the distribution one can call HIRND(I) which gives 
C you a random number generated according to the given function.
C 
        SUBROUTINE HIFUN(I,XMIN,XMAX,FHB)
        COMMON/HIJHB/RR(10,201),XX(10,201)
cc      SAVE /HIJHB/
        EXTERNAL FHB
        SAVE   
        FNORM=GAUSS1(FHB,XMIN,XMAX,0.001)
        DO 100 J=1,201
                XX(I,J)=XMIN+(XMAX-XMIN)*(J-1)/200.0
                XDD=XX(I,J)
                RR(I,J)=GAUSS1(FHB,XMIN,XDD,0.001)/FNORM
100        CONTINUE
        RETURN
        END
C
C
C
        FUNCTION HIRND(I)
        COMMON/HIJHB/RR(10,201),XX(10,201)
cc      SAVE /HIJHB/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   
        RX=RANART(NSEED)
        JL=0
        JU=202
10        IF(JU-JL.GT.1) THEN
           JM=(JU+JL)/2
           IF((RR(I,201).GT.RR(I,1)).EQV.(RX.GT.RR(I,JM))) THEN
              JL=JM
           ELSE
              JU=JM
           ENDIF
        GO TO 10
        ENDIF
        J=JL
        IF(J.LT.1) J=1
        IF(J.GE.201) J=200
        HIRND=(XX(I,J)+XX(I,J+1))/2.0
        RETURN
        END        
C
C
C
C
C        This generate random number between XMIN and XMAX
        FUNCTION HIRND2(I,XMIN,XMAX)
        COMMON/HIJHB/RR(10,201),XX(10,201)
cc      SAVE /HIJHB/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   
        IF(XMIN.LT.XX(I,1)) XMIN=XX(I,1)
        IF(XMAX.GT.XX(I,201)) XMAX=XX(I,201)
        JMIN=1+int(200*(XMIN-XX(I,1))/(XX(I,201)-XX(I,1)))
        JMAX=1+int(200*(XMAX-XX(I,1))/(XX(I,201)-XX(I,1)))
        RX=RR(I,JMIN)+(RR(I,JMAX)-RR(I,JMIN))*RANART(NSEED)
        JL=0
        JU=202
10        IF(JU-JL.GT.1) THEN
           JM=(JU+JL)/2
           IF((RR(I,201).GT.RR(I,1)).EQV.(RX.GT.RR(I,JM))) THEN
              JL=JM
           ELSE
              JU=JM
           ENDIF
        GO TO 10
        ENDIF
        J=JL
        IF(J.LT.1) J=1
        IF(J.GE.201) J=200
        HIRND2=(XX(I,J)+XX(I,J+1))/2.0
        RETURN
        END        
C
C
C
C
        SUBROUTINE HIJCRS
C        THIS IS TO CALCULATE THE CROSS SECTIONS OF JET PRODUCTION AND
C        THE TOTAL INELASTIC CROSS SECTIONS.
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/NJET/N,ipcrs
cc      SAVE /NJET/
        EXTERNAL FHIN,FTOT,FNJET,FTOTJT,FTOTRG
        SAVE   
        IF(HINT1(1).GE.10.0) CALL CRSJET
C                        ********calculate jet cross section(in mb)
C
clin-7/2009 these are related to nuclear shadowing:
        APHX1=HIPR1(6)*(IHNT2(1)**0.3333333-1.0)
        APHX2=HIPR1(6)*(IHNT2(3)**0.3333333-1.0)
        HINT1(11)=HINT1(14)-APHX1*HINT1(15)
     &                        -APHX2*HINT1(16)+APHX1*APHX2*HINT1(17)
        HINT1(10)=GAUSS1(FTOTJT,0.0,20.0,0.01)
        HINT1(12)=GAUSS1(FHIN,0.0,20.0,0.01)
        HINT1(13)=GAUSS1(FTOT,0.0,20.0,0.01)
        HINT1(60)=HINT1(61)-APHX1*HINT1(62)
     &                        -APHX2*HINT1(63)+APHX1*APHX2*HINT1(64)
        HINT1(59)=GAUSS1(FTOTRG,0.0,20.0,0.01)
        IF(HINT1(59).EQ.0.0) HINT1(59)=HINT1(60)
        IF(HINT1(1).GE.10.0) Then
           DO 20 I=0,20
              N=I
              HINT1(80+I)=GAUSS1(FNJET,0.0,20.0,0.01)/HINT1(12)
 20           CONTINUE
        ENDIF
        HINT1(10)=HINT1(10)*HIPR1(31)
        HINT1(12)=HINT1(12)*HIPR1(31)
        HINT1(13)=HINT1(13)*HIPR1(31)
        HINT1(59)=HINT1(59)*HIPR1(31)
C                ********Total and Inel cross section are calculated
C                        by Gaussian integration.
        IF(IHPR2(13).NE.0) THEN
        HIPR1(33)=1.36*(1.0+36.0/HINT1(1)**2)
     &             *ALOG(0.6+0.1*HINT1(1)**2)
        HIPR1(33)=HIPR1(33)/HINT1(12)
        ENDIF
C                ********Parametrized cross section for single
C                        diffractive reaction(Goulianos)
        RETURN
        END
C
C
C
C
        FUNCTION FTOT(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        SAVE   
        OMG=OMG0(X)*(HIPR1(30)+HINT1(11))/HIPR1(31)/2.0
        FTOT=2.0*(1.0-EXP(-OMG))
        RETURN
        END
C
C
C
        FUNCTION FHIN(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        SAVE   
        OMG=OMG0(X)*(HIPR1(30)+HINT1(11))/HIPR1(31)/2.0
        FHIN=1.0-EXP(-2.0*OMG)
        RETURN
        END
C
C
C
        FUNCTION FTOTJT(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        SAVE   
        OMG=OMG0(X)*HINT1(11)/HIPR1(31)/2.0
        FTOTJT=1.0-EXP(-2.0*OMG)
        RETURN
        END
C
C
C
        FUNCTION FTOTRG(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        SAVE   
        OMG=OMG0(X)*HINT1(60)/HIPR1(31)/2.0
        FTOTRG=1.0-EXP(-2.0*OMG)
        RETURN
        END
C
C
C
C
        FUNCTION FNJET(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/NJET/N,ipcrs
cc      SAVE /NJET/
        SAVE   
        OMG1=OMG0(X)*HINT1(11)/HIPR1(31)
clin-8/2015 could cause IEEE_UNDERFLOW, does not seem to affect results:
        C0=EXP(N*ALOG(OMG1)-SGMIN(N+1))
        IF(N.EQ.0) C0=1.0-EXP(-2.0*OMG0(X)*HIPR1(30)/HIPR1(31)/2.0)
        FNJET=C0*EXP(-OMG1)
        RETURN
        END
C
C
C
C
C
        FUNCTION SGMIN(N)
        SAVE   
        GA=0.
        IF(N.LE.2) GO TO 20
        DO 10 I=1,N-1
        Z=I
        GA=GA+ALOG(Z)
10      CONTINUE
20      SGMIN=GA
        RETURN
        END
C
C
C
        FUNCTION OMG0(X)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON /BESEL/X4
cc      SAVE /BESEL/
        EXTERNAL BK
        SAVE   
        X4=HIPR1(32)*SQRT(X)
        OMG0=HIPR1(32)**2*GAUSS2(BK,X4,X4+20.0,0.01)/96.0
        RETURN
        END
C
C
C
        FUNCTION ROMG(X)
C                ********This gives the eikonal function from a table
C                        calculated in the first call
        DIMENSION FR(0:1000)
clin-10/29/02 unsaved FR causes wrong values for ROMG with f77 compiler:
cc        SAVE FR
        SAVE   
        DATA I0/0/

        IF(I0.NE.0) GO TO 100
        DO 50 I=1,1001
        XR=(I-1)*0.01
        FR(I-1)=OMG0(XR)
50        CONTINUE
100        I0=1
        IF(X.GE.10.0) THEN
                ROMG=0.0
                RETURN
        ENDIF
        IX=INT(X*100)
        ROMG=(FR(IX)*((IX+1)*0.01-X)+FR(IX+1)*(X-IX*0.01))/0.01
        RETURN
        END
C
C
C
        FUNCTION BK(X)
        COMMON /BESEL/X4
cc      SAVE /BESEL/
        SAVE   
        BK=EXP(-X)*(X**2-X4**2)**2.50/15.0
        RETURN
        END
C
C
C        THIS PROGRAM IS TO CALCULATE THE JET CROSS SECTION
C        THE INTEGRATION IS DONE BY USING VEGAS
C
        SUBROUTINE CRSJET
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        REAL HIPR1(100),HINT1(100)
        COMMON/HPARNT/HIPR1,IHPR2(50),HINT1,IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/NJET/N,ipcrs
cc      SAVE /NJET/
        COMMON/BVEG1/XL(10),XU(10),ACC,NDIM,NCALL,ITMX,NPRN
cc      SAVE /BVEG1/
        COMMON/BVEG2/XI(50,10),SI,SI2,SWGT,SCHI,NDO,IT
cc      SAVE /BVEG2/
        COMMON/BVEG3/F,TI,TSI
cc      SAVE /BVEG3/
        COMMON/SEDVAX/NUM1
cc      SAVE /SEDVAX/
        EXTERNAL FJET,FJETRG
        SAVE   
C
c************************
c        NCALL give the number of inner-iteration, ITMX 
C       gives the limit of out-iteration. Nprn is an option
C       ( 1: print the integration process. 0: do not print)
C
        NDIM=3
        ipcrs=0
        CALL VEGAS(FJET,AVGI,SD,CHI2A)
        HINT1(14)=sngl(AVGI)/2.5682
        IF(IHPR2(6).EQ.1 .AND. IHNT2(1).GT.1) THEN
                ipcrs=1
                CALL VEGAS(FJET,AVGI,SD,CHI2A)
                HINT1(15)=sngl(AVGI)/2.5682
        ENDIF
        IF(IHPR2(6).EQ.1 .AND. IHNT2(3).GT.1) THEN
                ipcrs=2
                CALL VEGAS(FJET,AVGI,SD,CHI2A)
                HINT1(16)=sngl(AVGI)/2.5682
        ENDIF
        IF(IHPR2(6).EQ.1.AND.IHNT2(1).GT.1.AND.IHNT2(3).GT.1) THEN
                ipcrs=3
                CALL VEGAS(FJET,AVGI,SD,CHI2A)
                HINT1(17)=sngl(AVGI)/2.5682
        ENDIF
C                ********Total inclusive jet cross section(Pt>P0) 
C
        IF(IHPR2(3).NE.0) THEN
           ipcrs=0
           CALL VEGAS(FJETRG,AVGI,SD,CHI2A)
           HINT1(61)=sngl(AVGI)/2.5682
           IF(IHPR2(6).EQ.1 .AND. IHNT2(1).GT.1) THEN
              ipcrs=1
              CALL VEGAS(FJETRG,AVGI,SD,CHI2A)
              HINT1(62)=sngl(AVGI)/2.5682
           ENDIF
           IF(IHPR2(6).EQ.1 .AND. IHNT2(3).GT.1) THEN
              ipcrs=2
              CALL VEGAS(FJETRG,AVGI,SD,CHI2A)
              HINT1(63)=sngl(AVGI)/2.5682
           ENDIF
           IF(IHPR2(6).EQ.1.AND.IHNT2(1).GT.1.AND.IHNT2(3).GT.1) THEN
              ipcrs=3
              CALL VEGAS(FJETRG,AVGI,SD,CHI2A)
              HINT1(64)=sngl(AVGI)/2.5682
           ENDIF
        ENDIF
C                        ********cross section of trigger jet
C
        RETURN
        END
C
C
C
        FUNCTION FJET(X,WGT)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        REAL HIPR1(100),HINT1(100)
        COMMON/HPARNT/HIPR1,IHPR2(50),HINT1,IHNT2(50)
cc      SAVE /HPARNT/
        DIMENSION X(10)
        SAVE   
        PT2=dble(HINT1(1)**2/4.0-HIPR1(8)**2)*X(1)+dble(HIPR1(8))**2
        XT=2.0d0*DSQRT(PT2)/dble(HINT1(1))
        YMX1=DLOG(1.0d0/XT+DSQRT(1.0d0/XT**2-1.0d0))
        Y1=2.0d0*YMX1*X(2)-YMX1
        YMX2=DLOG(2.0d0/XT-DEXP(Y1))
        YMN2=DLOG(2.0d0/XT-DEXP(-Y1))
        Y2=(YMX2+YMN2)*X(3)-YMN2
        FJET=2.0d0*YMX1*(YMX2+YMN2)*dble(HINT1(1)**2/4.0-HIPR1(8)**2)
     &                *G(Y1,Y2,PT2)/2.0d0
        RETURN
        END
C
C
C
        FUNCTION FJETRG(X,WGT)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        REAL HIPR1(100),HINT1(100),PTMAX,PTMIN
        COMMON/HPARNT/HIPR1,IHPR2(50),HINT1,IHNT2(50)
cc      SAVE /HPARNT/
        DIMENSION X(10)
        SAVE   
        PTMIN=ABS(HIPR1(10))-0.25
        PTMIN=MAX(PTMIN,HIPR1(8))
        AM2=0.D0
        IF(IHPR2(3).EQ.3) THEN
           AM2=dble(HIPR1(7)**2)
           PTMIN=MAX(0.0,HIPR1(10))
        ENDIF
        PTMAX=ABS(HIPR1(10))+0.25
        IF(HIPR1(10).LE.0.0) PTMAX=HINT1(1)/2.0-sngl(AM2)
        IF(PTMAX.LE.PTMIN) PTMAX=PTMIN+0.25
        PT2=dble(PTMAX**2-PTMIN**2)*X(1)+dble(PTMIN)**2
        AMT2=PT2+AM2
        XT=2.0d0*DSQRT(AMT2)/dble(HINT1(1))
        YMX1=DLOG(1.0d0/XT+DSQRT(1.0d0/XT**2-1.0d0))
        Y1=2.0d0*YMX1*X(2)-YMX1
        YMX2=DLOG(2.0d0/XT-DEXP(Y1))
        YMN2=DLOG(2.0d0/XT-DEXP(-Y1))
        Y2=(YMX2+YMN2)*X(3)-YMN2
        IF(IHPR2(3).EQ.3) THEN
           GTRIG=2.0d0*GHVQ(Y1,Y2,AMT2)
        ELSE IF(IHPR2(3).EQ.2) THEN
           GTRIG=2.0d0*GPHOTN(Y1,Y2,PT2)
        ELSE
           GTRIG=G(Y1,Y2,PT2)
        ENDIF
        FJETRG=2.0d0*YMX1*(YMX2+YMN2)*dble(PTMAX**2-PTMIN**2)
     &                *GTRIG/2.0d0
        RETURN
        END
C
C
C
        FUNCTION GHVQ(Y1,Y2,AMT2)
        IMPLICIT DOUBLE PRECISION  (A-H,O-Z)
        REAL HIPR1(100),HINT1(100)
        COMMON/HPARNT/HIPR1,IHPR2(50),HINT1,IHNT2(50)
cc      SAVE /HPARNT/
        DIMENSION F(2,7)
        SAVE   
        XT=2.0d0*DSQRT(AMT2)/dble(HINT1(1))
        X1=0.5d0*XT*(DEXP(Y1)+DEXP(Y2))
        X2=0.5d0*XT*(DEXP(-Y1)+DEXP(-Y2))
        SS=X1*X2*dble(HINT1(1))**2
        AF=4.0d0
        IF(IHPR2(18).NE.0) AF=5.0d0
        DLAM=dble(HIPR1(15))
        APH=12.0d0*3.1415926d0/(33.d0-2.d0*AF)/DLOG(AMT2/DLAM**2)
C
        CALL PARTON(F,X1,X2,AMT2)
C
        Gqq=4.d0*(DCOSH(Y1-Y2)+dble(HIPR1(7))**2/AMT2)
     &       /(1.D0+DCOSH(Y1-Y2))
     &       /9.d0*(F(1,1)*F(2,2)+F(1,2)*F(2,1)+F(1,3)*F(2,4)
     &       +F(1,4)*F(2,3)+F(1,5)*F(2,6)+F(1,6)*F(2,5))
        Ggg=(8.D0*DCOSH(Y1-Y2)-1.D0)
     &       *(DCOSH(Y1-Y2)+2.d0*dble(HIPR1(7))**2
     &       /AMT2-2.d0*dble(HIPR1(7))**4/AMT2**2)/(1.d0+DCOSH(Y1-Y2))
     &       /24.d0*F(1,7)*F(2,7)
C
        GHVQ=(Gqq+Ggg)*dble(HIPR1(23))*3.14159d0*APH**2/SS**2
        RETURN
        END
C
C
C
        FUNCTION GPHOTN(Y1,Y2,PT2)
        IMPLICIT DOUBLE PRECISION  (A-H,O-Z)
        REAL HIPR1(100),HINT1(100)
        COMMON/HPARNT/HIPR1,IHPR2(50),HINT1,IHNT2(50)
cc      SAVE /HPARNT/
        DIMENSION F(2,7)
        SAVE   
        XT=2.d0*DSQRT(PT2)/dble(HINT1(1))
        X1=0.5d0*XT*(DEXP(Y1)+DEXP(Y2))
        X2=0.5d0*XT*(DEXP(-Y1)+DEXP(-Y2))
        Z=DSQRT(1.D0-XT**2/X1/X2)
        SS=X1*X2*dble(HINT1(1))**2
        T=-(1.d0-Z)/2.d0
        U=-(1.d0+Z)/2.d0
        AF=3.d0
        DLAM=dble(HIPR1(15))
        APH=12.d0*3.1415926d0/(33.d0-2.d0*AF)/DLOG(PT2/DLAM**2)
        APHEM=1.d0/137.d0
C
        CALL PARTON(F,X1,X2,PT2)
C
        G11=-(U**2+1.d0)/U/3.d0*F(1,7)*(4.d0*F(2,1)+4.d0*F(2,2)
     &      +F(2,3)+F(2,4)+F(2,5)+F(2,6))/9.d0
        G12=-(T**2+1.d0)/T/3.d0*F(2,7)*(4.d0*F(1,1)+4.d0*F(1,2)
     &      +F(1,3)+F(1,4)+F(1,5)+F(1,6))/9.d0
        G2=8.d0*(U**2+T**2)/U/T/9.d0*(4.d0*F(1,1)*F(2,2)
     &     +4.d0*F(1,2)*F(2,1)+F(1,3)*F(2,4)+F(1,4)*F(2,3)
     &     +F(1,5)*F(2,6)+F(1,6)*F(2,5))/9.d0
C
        GPHOTN=(G11+G12+G2)*dble(HIPR1(23))*3.14159d0*APH*APHEM/SS**2
        RETURN
        END
C
C
C
C
        FUNCTION G(Y1,Y2,PT2)
        IMPLICIT DOUBLE PRECISION  (A-H,O-Z)
        REAL HIPR1(100),HINT1(100)
        COMMON/HPARNT/HIPR1,IHPR2(50),HINT1,IHNT2(50)
cc      SAVE /HPARNT/
        DIMENSION F(2,7)
        SAVE   
        XT=2.d0*DSQRT(PT2)/dble(HINT1(1))
        X1=0.5d0*XT*(DEXP(Y1)+DEXP(Y2))
        X2=0.5d0*XT*(DEXP(-Y1)+DEXP(-Y2))
        Z=DSQRT(1.D0-XT**2/X1/X2)
        SS=X1*X2*dble(HINT1(1))**2
        T=-(1.d0-Z)/2.d0
        U=-(1.d0+Z)/2.d0
        AF=3.d0
        DLAM=dble(HIPR1(15))
        APH=12.d0*3.1415926d0/(33.d0-2.d0*AF)/DLOG(PT2/DLAM**2)
C
        CALL PARTON(F,X1,X2,PT2)
C
        G11=( (F(1,1)+F(1,2))*(F(2,3)+F(2,4)+F(2,5)+F(2,6))
     &      +(F(1,3)+F(1,4))*(F(2,5)+F(2,6)) )*SUBCR1(T,U)
C
        G12=( (F(2,1)+F(2,2))*(F(1,3)+F(1,4)+F(1,5)+F(1,6))
     &      +(F(2,3)+F(2,4))*(F(1,5)+F(1,6)) )*SUBCR1(U,T)
C
        G13=(F(1,1)*F(2,1)+F(1,2)*F(2,2)+F(1,3)*F(2,3)+F(1,4)*F(2,4)
     &      +F(1,5)*F(2,5)+F(1,6)*F(2,6))*(SUBCR1(U,T)
     &      +SUBCR1(T,U)-8.D0/T/U/27.D0)
C
        G2=(AF-1)*(F(1,1)*F(2,2)+F(2,1)*F(1,2)+F(1,3)*F(2,4)
     &     +F(2,3)*F(1,4)+F(1,5)*F(2,6)+F(2,5)*F(1,6))*SUBCR2(T,U)
C
        G31=(F(1,1)*F(2,2)+F(1,3)*F(2,4)+F(1,5)*F(2,6))*SUBCR3(T,U)
        G32=(F(2,1)*F(1,2)+F(2,3)*F(1,4)+F(2,5)*F(1,6))*SUBCR3(U,T)
C
        G4=(F(1,1)*F(2,2)+F(2,1)*F(1,2)+F(1,3)*F(2,4)+F(2,3)*F(1,4)+
     1        F(1,5)*F(2,6)+F(2,5)*F(1,6))*SUBCR4(T,U)
C
        G5=AF*F(1,7)*F(2,7)*SUBCR5(T,U)
C
        G61=F(1,7)*(F(2,1)+F(2,2)+F(2,3)+F(2,4)+F(2,5)
     &      +F(2,6))*SUBCR6(T,U)
        G62=F(2,7)*(F(1,1)+F(1,2)+F(1,3)+F(1,4)+F(1,5)
     &      +F(1,6))*SUBCR6(U,T)
C
        G7=F(1,7)*F(2,7)*SUBCR7(T,U)
C
        G=(G11+G12+G13+G2+G31+G32+G4+G5+G61+G62+G7)*dble(HIPR1(17))*
     1        3.14159D0*APH**2/SS**2
        RETURN
        END
C
C
C
        FUNCTION SUBCR1(T,U)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        SUBCR1=4.D0/9.D0*(1.D0+U**2)/T**2
        RETURN
        END
C
C
        FUNCTION SUBCR2(T,U)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        SUBCR2=4.D0/9.D0*(T**2+U**2)
        RETURN
        END
C
C
        FUNCTION SUBCR3(T,U)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        SUBCR3=4.D0/9.D0*(T**2+U**2+(1.D0+U**2)/T**2
     1        -2.D0*U**2/3.D0/T)
        RETURN
        END
C
C
        FUNCTION SUBCR4(T,U)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        SUBCR4=8.D0/3.D0*(T**2+U**2)*(4.D0/9.D0/T/U-1.D0)
        RETURN
        END
C
C
C
        FUNCTION SUBCR5(T,U)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        SUBCR5=3.D0/8.D0*(T**2+U**2)*(4.D0/9.D0/T/U-1.D0)
        RETURN
        END
C
C
        FUNCTION SUBCR6(T,U)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        SUBCR6=(1.D0+U**2)*(1.D0/T**2-4.D0/U/9.D0)
        RETURN
        END
C
C
        FUNCTION SUBCR7(T,U)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        SUBCR7=9.D0/2.D0*(3.D0-T*U-U/T**2-T/U**2)
        RETURN
        END
C
C
C
        SUBROUTINE PARTON(F,X1,X2,QQ)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        REAL HIPR1(100),HINT1(100)
        COMMON/HPARNT/HIPR1,IHPR2(50),HINT1,IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/NJET/N,ipcrs
cc      SAVE /NJET/
clin-7/2009:
        common/cmsflag/dshadow,ishadow
        DIMENSION F(2,7) 
        SAVE   
        DLAM=dble(HIPR1(15))
        Q0=dble(HIPR1(16))
        S=DLOG(DLOG(QQ/DLAM**2)/DLOG(Q0**2/DLAM**2))
        IF(IHPR2(7).EQ.2) GO TO 200
C*******************************************************
        AT1=0.419d0+0.004d0*S-0.007d0*S**2
        AT2=3.460d0+0.724d0*S-0.066d0*S**2
        GMUD=4.40d0-4.86d0*S+1.33d0*S**2
        AT3=0.763d0-0.237d0*S+0.026d0*S**2
        AT4=4.00d0+0.627d0*S-0.019d0*S**2
        GMD=-0.421d0*S+0.033d0*S**2
C*******************************************************
        CAS=1.265d0-1.132d0*S+0.293d0*S**2
        AS=-0.372d0*S-0.029d0*S**2
        BS=8.05d0+1.59d0*S-0.153d0*S**2
        APHS=6.31d0*S-0.273d0*S**2
        BTAS=-10.5d0*S-3.17d0*S**2
        GMS=14.7d0*S+9.80d0*S**2
C********************************************************
C        CAC=0.135*S-0.075*S**2
C        AC=-0.036-0.222*S-0.058*S**2
C        BC=6.35+3.26*S-0.909*S**2
C        APHC=-3.03*S+1.50*S**2
C        BTAC=17.4*S-11.3*S**2
C        GMC=-17.9*S+15.6*S**2
C***********************************************************
        CAG=1.56d0-1.71d0*S+0.638d0*S**2
        AG=-0.949d0*S+0.325d0*S**2
        BG=6.0d0+1.44d0*S-1.05d0*S**2
        APHG=9.0d0-7.19d0*S+0.255d0*S**2
        BTAG=-16.5d0*S+10.9d0*S**2
        GMG=15.3d0*S-10.1d0*S**2
        GO TO 300
C********************************************************
200        AT1=0.374d0+0.014d0*S
        AT2=3.33d0+0.753d0*S-0.076d0*S**2
        GMUD=6.03d0-6.22d0*S+1.56d0*S**2
        AT3=0.761d0-0.232d0*S+0.023d0*S**2
        AT4=3.83d0+0.627d0*S-0.019d0*S**2
        GMD=-0.418d0*S+0.036d0*S**2
C************************************
        CAS=1.67d0-1.92d0*S+0.582d0*S**2
        AS=-0.273d0*S-0.164d0*S**2
        BS=9.15d0+0.530d0*S-0.763d0*S**2
        APHS=15.7d0*S-2.83d0*S**2
        BTAS=-101.0d0*S+44.7d0*S**2
        GMS=223.0d0*S-117.0d0*S**2
C*********************************
C        CAC=0.067*S-0.031*S**2
C        AC=-0.120-0.233*S-0.023*S**2
C        BC=3.51+3.66*S-0.453*S**2
C        APHC=-0.474*S+0.358*S**2
C        BTAC=9.50*S-5.43*S**2
C        GMC=-16.6*S+15.5*S**2
C**********************************
        CAG=0.879d0-0.971d0*S+0.434d0*S**2
        AG=-1.16d0*S+0.476d0*S**2
        BG=4.0d0+1.23d0*S-0.254d0*S**2
        APHG=9.0d0-5.64d0*S-0.817d0*S**2
        BTAG=-7.54d0*S+5.50d0*S**2
        GMG=-0.596d0*S+1.26d0*S**2
C*********************************
300        B12=DEXP(GMRE(AT1)+GMRE(AT2+1.D0)-GMRE(AT1+AT2+1.D0))
        B34=DEXP(GMRE(AT3)+GMRE(AT4+1.D0)-GMRE(AT3+AT4+1.D0))
        CNUD=3.D0/B12/(1.D0+GMUD*AT1/(AT1+AT2+1.D0))
        CND=1.D0/B34/(1.D0+GMD*AT3/(AT3+AT4+1.D0))
C********************************************************
C        FUD=X*(U+D)
C        FS=X*2(UBAR+DBAR+SBAR)  AND UBAR=DBAR=SBAR
C*******************************************************
        FUD1=CNUD*X1**AT1*(1.D0-X1)**AT2*(1.D0+GMUD*X1)
        FS1=CAS*X1**AS*(1.D0-X1)**BS*(1.D0+APHS*X1
     &      +BTAS*X1**2+GMS*X1**3)
        F(1,3)=CND*X1**AT3*(1.D0-X1)**AT4*(1.D0+GMD*X1)+FS1/6.D0
        F(1,1)=FUD1-F(1,3)+FS1/3.D0
        F(1,2)=FS1/6.D0
        F(1,4)=FS1/6.D0
        F(1,5)=FS1/6.D0
        F(1,6)=FS1/6.D0
        F(1,7)=CAG*X1**AG*(1.D0-X1)**BG*(1.D0+APHG*X1
     &         +BTAG*X1**2+GMG*X1**3)
C
        FUD2=CNUD*X2**AT1*(1.D0-X2)**AT2*(1.D0+GMUD*X2)
        FS2=CAS*X2**AS*(1.D0-X2)**BS*(1.D0+APHS*X2
     &      +BTAS*X2**2+GMS*X2**3)
        F(2,3)=CND*X2**AT3*(1.D0-X2)**AT4*(1.D0+GMD*X2)+FS2/6.D0
        F(2,1)=FUD2-F(2,3)+FS2/3.D0
        F(2,2)=FS2/6.D0
        F(2,4)=FS2/6.D0
        F(2,5)=FS2/6.D0
        F(2,6)=FS2/6.D0
        F(2,7)=CAG*X2**AG*(1.D0-X2)**BG*(1.D0+APHG*X2
     &         +BTAG*X2**2+GMG*X2**3)
C***********Nuclear effect on the structure function****************
C
        IF(IHPR2(6).EQ.1 .AND. IHNT2(1).GT.1) THEN
           AAX=1.193d0*dble(ALOG(FLOAT(IHNT2(1)))**0.16666666)
           RRX=AAX*(X1**3-1.2d0*X1**2+0.21d0*X1)+1.d0
     &               +dble(1.079*(FLOAT(IHNT2(1))**0.33333333-1.0))
     &          /dble(ALOG(float(IHNT2(1))+1.0))*DSQRT(X1)
     &          *DEXP(-X1**2/0.01d0)
clin-8/2015 DEXP() above may cause IEEE_UNDERFLOW, 
c     does not seem to affect results.
c     &          /DLOG(IHNT2(1)+1.0D0)*(DSQRT(X1)*DEXP(-X1**2/0.01)
clin-7/2009 enable users to modify nuclear shadowing:
           if(ishadow.eq.1) RRX=1.d0+dshadow*(RRX-1.d0)
           IF(ipcrs.EQ.1 .OR.ipcrs.EQ.3) RRX=DEXP(-X1**2/0.01d0)
clin-7/2009:
           if((ipcrs.EQ.1.OR.ipcrs.EQ.3).and.ishadow.eq.1) 
     1          RRX=DEXP(-X1**2/0.01d0)*dshadow
           DO 400 I=1,7
              F(1,I)=RRX*F(1,I)
 400           CONTINUE
        ENDIF
        IF(IHPR2(6).EQ.1 .AND. IHNT2(3).GT.1) THEN
           AAX=1.193d0*dble(ALOG(FLOAT(IHNT2(3)))**0.16666666)
           RRX=AAX*(X2**3-1.2d0*X2**2+0.21d0*X2)+1.d0
     &               +dble(1.079*(FLOAT(IHNT2(3))**0.33333-1.0))
     &          /dble(ALOG(float(IHNT2(3))+1.0))*DSQRT(X2)
     &          *DEXP(-X2**2/0.01d0)
c     &         /DLOG(IHNT2(3)+1.0D0)*DSQRT(X2)*DEXP(-X2**2/0.01)
clin-7/2009:
           if(ishadow.eq.1) RRX=1.d0+dshadow*(RRX-1.d0)
           IF(ipcrs.EQ.2 .OR. ipcrs.EQ.3) RRX=DEXP(-X2**2/0.01d0)
clin-7/2009:
           if((ipcrs.EQ.2.OR.ipcrs.EQ.3).and.ishadow.eq.1) 
     1          RRX=DEXP(-X2**2/0.01d0)*dshadow
           DO 500 I=1,7
              F(2,I)=RRX*F(2,I)
 500           CONTINUE
        ENDIF
c
        RETURN
        END
C
C
C
        FUNCTION GMRE(X)
        IMPLICIT DOUBLE PRECISION (A-H,O-Z)
        SAVE   
        Z=X
        IF(X.GT.3.0D0) GO TO 10
        Z=X+3.D0
10      GMRE=0.5D0*DLOG(2.D0*3.14159265D0/Z)+Z*DLOG(Z)-Z+DLOG(1.D0
     1        +1.D0/12.D0/Z+1.D0/288.D0/Z**2-139.D0/51840.D0/Z**3
     1        -571.D0/2488320.D0/Z**4)
        IF(Z.EQ.X) GO TO 20
        GMRE=GMRE-DLOG(Z-1.D0)-DLOG(Z-2.D0)-DLOG(Z-3.D0)
20      CONTINUE
        RETURN
        END
c
C
C
C***************************************************************

        BLOCK DATA HIDATA
        PARAMETER (MAXSTR=150001)
        DOUBLE PRECISION  XL(10),XU(10),ACC
        COMMON/BVEG1/XL,XU,ACC,NDIM,NCALL,ITMX,NPRN
cc      SAVE /BVEG1/
        COMMON/SEDVAX/NUM1
cc      SAVE /SEDVAX/
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        COMMON/HMAIN1/EATT,JATT,NATT,NT,NP,N0,N01,N10,N11
cc      SAVE /HMAIN1/
        COMMON/HMAIN2/KATT(MAXSTR,4),PATT(MAXSTR,4)
cc      SAVE /HMAIN2/
        COMMON/HSTRNG/NFP(300,15),PP(300,15),NFT(300,15),PT(300,15)
cc      SAVE /HSTRNG/
        COMMON/hjcrdn/YP(3,300),YT(3,300)
cc      SAVE /hjcrdn/
        COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &               PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &               PJPM(300,500),NTJ(300),KFTJ(300,500),
     &               PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &               PJTE(300,500),PJTM(300,500)
cc      SAVE /HJJET1/
        COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &       K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &       PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
        COMMON/HIJDAT/HIDAT0(10,10),HIDAT(10)
cc      SAVE /HIJDAT/
        COMMON/HPINT/MINT4,MINT5,ATCO(200,20),ATXS(0:200)
cc      SAVE /HPINT/
        SAVE   
        DATA NUM1/30123984/,XL/10*0.D0/,XU/10*1.D0/
        DATA NCALL/1000/,ITMX/100/,ACC/0.01/,NPRN/0/
C...give all the switchs and parameters the default values
clin-4/2008 input.ampt provides NSEED for AMPT:
c        DATA NSEED/74769375/
        DATA HIPR1/
     &       1.5,  0.35, 0.5,  0.9,  2.0,  0.1,  1.5,  2.0, -1.0, -2.25,
     &       2.0,  0.5,  1.0,  2.0,  0.2,  2.0,  2.5,  0.3,  0.1,  1.4,
     &       1.6,  1.0,  2.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.4,  57.0,
     &       28.5, 3.9,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  
     &       3.14159,
     &       0.0,  0.4,  0.1,  1.5,  0.1, 0.25, 0.0,  0.5,  0.0,  0.0,
     &       50*0.0/

        DATA IHPR2/
     &       1,    3,    0,    1,    1,    1,    1,    10,    0,    0,
     &       1,    1,    1,    1,    0,    0,    1,     0,    0,    1,
     &        30*0/

        DATA HINT1/100*0/
        DATA IHNT2/50*0/

C...initialize all the data common blocks
        DATA NATT/0/,EATT/0.0/,JATT/0/,NT/0/,NP/0/,
     1 N0/0/,N01/0/,N10/0/,N11/0/
clin-4/26/01
c        DATA KATT/520000*0/PATT/520000*0.0/
        DATA KATT/600004*0/,PATT/600004*0.0/

        DATA NFP/4500*0/,PP/4500*0.0/,NFT/4500*0/,PT/4500*0.0/

        DATA YP/900*0.0/,YT/900*0.0/

        DATA NPJ/300*0/,KFPJ/150000*0/,PJPX/150000*0.0/,PJPY/150000*0.0/
     &        ,PJPZ/150000*0.0/,PJPE/150000*0.0/,PJPM/150000*0.0/
        DATA NTJ/300*0/,KFTJ/150000*0/,PJTX/150000*0.0/,PJTY/150000*0.0/
     &        ,PJTZ/150000*0.0/,PJTE/150000*0.0/,PJTM/150000*0.0/

clin-4/2008
c        DATA NSG/0/,NJSG/900*0/,IASG/2700*0/,K1SG/90000*0/,K2SG/90000*0/
c     &       ,PXSG/90000*0.0/,PYSG/90000*0.0/,PZSG/90000*0.0/
c     &       ,PESG/90000*0.0/,PMSG/90000*0.0/
        DATA NSG/0/,NJSG/150001*0/,IASG/450003*0/,
     &       K1SG/15000100*0/,K2SG/15000100*0/,
     &       PXSG/15000100*0.0/,PYSG/15000100*0.0/,PZSG/15000100*0.0/,
     &       PESG/15000100*0.0/,PMSG/15000100*0.0/
        DATA MINT4/0/,MINT5/0/,ATCO/4000*0.0/,ATXS/201*0.0/
        DATA (HIDAT0(1,I),I=1,10)/0.0,0.0,0.0,0.0,0.0,0.0,2.25,
     &          2.5,4.0,4.1/
        DATA (HIDAT0(2,I),I=1,10)/2.0,3.0,5.0,6.0,7.0,8.0,8.0,10.0,
     &                10.0,10.0/
        DATA (HIDAT0(3,I),I=1,10)/1.0,0.8,0.8,0.7,0.45,0.215,
     &          0.21,0.19,0.19,0.19/
        DATA (HIDAT0(4,I),I=1,10)/0.35,0.35,0.3,0.3,0.3,0.3,
     &          0.5,0.6,0.6,0.6/
        DATA (HIDAT0(5,I),I=1,10)/23.8,24.0,26.0,26.2,27.0,28.5,28.5,
     &                28.5,28.5,28.5/
        DATA ((HIDAT0(J,I),I=1,10),J=6,9)/40*0.0/
        DATA (HIDAT0(10,I),I=1,10)/5.0,20.0,53.0,62.0,100.0,200.0,
     &          546.0,900.0,1800.0,4000.0/
        DATA HIDAT/10*0.0/
        END
C*******************************************************************
C
C
C
C
C*******************************************************************
C   SUBROUTINE PERFORMS N-DIMENSIONAL MONTE CARLO INTEG'N
C      - BY G.P. LEPAGE   SEPT 1976/(REV)APR 1978
C*******************************************************************
C
      SUBROUTINE VEGAS(FXN,AVGI,SD,CHI2A)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON/BVEG1/XL(10),XU(10),ACC,NDIM,NCALL,ITMX,NPRN
cc      SAVE /BVEG1/
      COMMON/BVEG2/XI(50,10),SI,SI2,SWGT,SCHI,NDO,IT
cc      SAVE /BVEG2/
      COMMON/BVEG3/F,TI,TSI   
cc      SAVE /BVEG3/
      EXTERNAL FXN
      DIMENSION D(50,10),DI(50,10),XIN(50),R(50),DX(10),DT(10),X(10)
     1   ,KG(10),IA(10)
c      REAL*4 QRAN(10)
      REAL QRAN(10)
      SAVE   
      DATA NDMX/50/,ALPH/1.5D0/,ONE/1.D0/,MDS/-1/
C
      NDO=1
      DO 1 J=1,NDIM
1     XI(1,J)=ONE
C
      ENTRY VEGAS1(FXN,AVGI,SD,CHI2A)
C         - INITIALIZES CUMMULATIVE VARIABLES, BUT NOT GRID
      IT=0
      SI=0.d0
      SI2=SI
      SWGT=SI
      SCHI=SI
C
      ENTRY VEGAS2(FXN,AVGI,SD,CHI2A)
C         - NO INITIALIZATION
      ND=NDMX
      NG=1
      IF(MDS.EQ.0) GO TO 2
      NG=int((real(NCALL)/2.)**(1./real(NDIM)))
      MDS=1
      IF((2*NG-NDMX).LT.0) GO TO 2
      MDS=-1
      NPG=NG/NDMX+1
      ND=NG/NPG
      NG=NPG*ND
2     K=NG**NDIM
      NPG=NCALL/K
      IF(NPG.LT.2) NPG=2
      CALLS=NPG*K
      DXG=ONE/NG
      DV2G=(CALLS*DXG**NDIM)**2/NPG/NPG/(NPG-ONE)
      XND=ND
      NDM=ND-1
      DXG=DXG*XND
      XJAC=ONE/CALLS
      DO 3 J=1,NDIM
c***this is the line 50
      DX(J)=XU(J)-XL(J)
3     XJAC=XJAC*DX(J)
C
C   REBIN PRESERVING BIN DENSITY
C
      IF(ND.EQ.NDO) GO TO 8
      RC=NDO/XND
      DO 7 J=1,NDIM
      K=0
      XN=0.d0
      DR=XN
      I=K
4     K=K+1
      DR=DR+ONE
      XO=XN
      XN=XI(K,J)
5     IF(RC.GT.DR) GO TO 4
      I=I+1
      DR=DR-RC
      XIN(I)=XN-(XN-XO)*DR
      IF(I.LT.NDM) GO TO 5
      DO 6 I=1,NDM
6     XI(I,J)=XIN(I)
7     XI(ND,J)=ONE
      NDO=ND
C
8     CONTINUE
c      IF(NPRN.NE.0) WRITE(16,200) NDIM,CALLS,IT,ITMX,ACC,MDS,ND
c     1                           ,(XL(J),XU(J),J=1,NDIM)
C
      ENTRY VEGAS3(FXN,AVGI,SD,CHI2A)
C         - MAIN INTEGRATION LOOP
9     IT=IT+1
      TI=0.d0
      TSI=TI
      DO 10 J=1,NDIM
      KG(J)=1
      DO 10 I=1,ND
      D(I,J)=TI
10    DI(I,J)=TI
C
11    FB=0.d0
      F2B=FB
      K=0
12    K=K+1
      CALL ARAN9(QRAN,NDIM)
      WGT=XJAC
      DO 15 J=1,NDIM
      XN=dble(float(KG(J))-QRAN(J))*DXG+ONE
c*****this is the line 100
      IA(J)=int(XN)
      IF(IA(J).GT.1) GO TO 13
      XO=XI(IA(J),J)
      RC=(XN-IA(J))*XO
      GO TO 14
13    XO=XI(IA(J),J)-XI(IA(J)-1,J)
      RC=XI(IA(J)-1,J)+(XN-IA(J))*XO
14    X(J)=XL(J)+RC*DX(J)
      WGT=WGT*XO*XND
15    CONTINUE
C
      F=WGT
      F=F*FXN(X,WGT)
      F2=F*F
      FB=FB+F
      F2B=F2B+F2
      DO 16 J=1,NDIM
      DI(IA(J),J)=DI(IA(J),J)+F
16    IF(MDS.GE.0) D(IA(J),J)=D(IA(J),J)+F2
      IF(K.LT.NPG) GO TO 12
C
      F2B=DSQRT(F2B*NPG)
      F2B=(F2B-FB)*(F2B+FB)
      TI=TI+FB
      TSI=TSI+F2B
      IF(MDS.GE.0) GO TO 18
      DO 17 J=1,NDIM
17    D(IA(J),J)=D(IA(J),J)+F2B
18    K=NDIM
19    KG(K)=MOD(KG(K),NG)+1
      IF(KG(K).NE.1) GO TO 11
      K=K-1
      IF(K.GT.0) GO TO 19
C
C   FINAL RESULTS FOR THIS ITERATION
C
      TSI=TSI*DV2G
      TI2=TI*TI
      WGT=TI2/(TSI+1.0d-37)
      SI=SI+TI*WGT
      SI2=SI2+TI2
      SWGT=SWGT+WGT
      SWGT=SWGT+1.0D-37
      SI2=SI2+1.0D-37
      SCHI=SCHI+TI2*WGT
      AVGI=SI/SWGT
      SD=SWGT*IT/SI2
      CHI2A=SD*(SCHI/SWGT-AVGI*AVGI)/dble(float(IT)-.999)
      SD=DSQRT(ONE/SD)
C****this is the line 150
      IF(NPRN.EQ.0) GO TO 21
      TSI=DSQRT(TSI)
c      WRITE(16,201) IT,TI,TSI,AVGI,SD,CHI2A
c      IF(NPRN.GE.0) GO TO 21
c      DO 20 J=1,NDIM
c20    WRITE(16,202) J,(XI(I,J),DI(I,J),D(I,J),I=1,ND)
C
C   REFINE GRID
C
21    DO 23 J=1,NDIM
      XO=D(1,J)
      XN=D(2,J)
      D(1,J)=(XO+XN)/2.d0
      DT(J)=D(1,J)
      DO 22 I=2,NDM
      D(I,J)=XO+XN
      XO=XN
      XN=D(I+1,J)
      D(I,J)=(D(I,J)+XN)/3.d0
22    DT(J)=DT(J)+D(I,J)
      D(ND,J)=(XN+XO)/2.d0
23    DT(J)=DT(J)+D(ND,J)
C
      DO 28 J=1,NDIM
      RC=0.d0
      DO 24 I=1,ND
      R(I)=0.d0
      IF (DT(J).GE.1.0D18) THEN
       WRITE(6,*) '************** A SINGULARITY >1.0D18'
C      WRITE(5,1111)
C1111  FORMAT(1X,'**************IMPORTANT NOTICE***************')
C      WRITE(5,1112)
C1112  FORMAT(1X,'THE INTEGRAND GIVES RISE A SINGULARITY >1.0D18')
C      WRITE(5,1113)
C1113  FORMAT(1X,'PLEASE CHECK THE INTEGRAND AND THE LIMITS')
C      WRITE(5,1114)
C1114  FORMAT(1X,'**************END NOTICE*************')
      END IF    
      IF(D(I,J).LE.1.0D-18) GO TO 24
      XO=DT(J)/D(I,J)
      R(I)=((XO-ONE)/XO/DLOG(XO))**ALPH
24    RC=RC+R(I)
      RC=RC/XND
      K=0
      XN=0.d0
      DR=XN
      I=K
25    K=K+1
      DR=DR+R(K)
      XO=XN
c****this is the line 200
      XN=XI(K,J)
26    IF(RC.GT.DR) GO TO 25
      I=I+1
      DR=DR-RC
      XIN(I)=XN-(XN-XO)*DR/(R(K)+1.0d-30)
      IF(I.LT.NDM) GO TO 26
      DO 27 I=1,NDM
27    XI(I,J)=XIN(I)
28    XI(ND,J)=ONE
C
      IF(IT.LT.ITMX.AND.ACC*DABS(AVGI).LT.SD) GO TO 9
c200   FORMAT('0INPUT PARAMETERS FOR VEGAS:  NDIM=',I3,'  NCALL=',F8.0
c     1    /28X,'  IT=',I5,'  ITMX=',I5/28X,'  ACC=',G9.3
c     2    /28X,'  MDS=',I3,'   ND=',I4/28X,'  (XL,XU)=',
c     3    (T40,'( ',G12.6,' , ',G12.6,' )'))
c201   FORMAT(///' INTEGRATION BY VEGAS' / '0ITERATION NO.',I3,
c     1    ':   INTEGRAL =',G14.8/21X,'STD DEV  =',G10.4 /
c     2    ' ACCUMULATED RESULTS:   INTEGRAL =',G14.8 /
c     3    24X,'STD DEV  =',G10.4 / 24X,'CHI**2 PER IT''N =',G10.4)
c202   FORMAT('0DATA FOR AXIS',I2 / ' ',6X,'X',7X,'  DELT I  ',
c     1    2X,' CONV''CE  ',11X,'X',7X,'  DELT I  ',2X,' CONV''CE  '
c     2   ,11X,'X',7X,'  DELT I  ',2X,' CONV''CE  ' /
c     2    (' ',3G12.4,5X,3G12.4,5X,3G12.4))
      RETURN
      END
C
C
      SUBROUTINE ARAN9(QRAN,NDIM)
      DIMENSION QRAN(10)
      COMMON/SEDVAX/NUM1
      SAVE   
      DO 1 I=1,NDIM
    1 QRAN(I)=RANART(NUM1)
      RETURN
      END

C
C
C*********GAUSSIAN ONE-DIMENSIONAL INTEGRATION PROGRAM*************
C
        FUNCTION GAUSS1(F,A,B,EPS)
        EXTERNAL F
        DIMENSION W(12),X(12)
        SAVE   
        DATA CONST/1.0E-12/
        DATA W/0.1012285,.2223810,.3137067,.3623838,.0271525,
     &         .0622535,0.0951585,.1246290,.1495960,.1691565,
     &         .1826034,.1894506/
        DATA X/0.9602899,.7966665,.5255324,.1834346,.9894009,
     &         .9445750,0.8656312,.7554044,.6178762,.4580168,
     &         .2816036,.0950125/

        DELTA=CONST*ABS(A-B)
        GAUSS1=0.0
        AA=A
5        Y=B-AA
        IF(ABS(Y).LE.DELTA) RETURN
2        BB=AA+Y
        C1=0.5*(AA+BB)
        C2=C1-AA
        S8=0.0
        S16=0.0
        DO 1 I=1,4
        U=X(I)*C2
1        S8=S8+W(I)*(F(C1+U)+F(C1-U))
        DO 3 I=5,12
        U=X(I)*C2
3        S16=S16+W(I)*(F(C1+U)+F(C1-U))
        S8=S8*C2
        S16=S16*C2
        IF(ABS(S16-S8).GT.EPS*(1.+ABS(S16))) GOTO 4
        GAUSS1=GAUSS1+S16
        AA=BB
        GOTO 5
4        Y=0.5*Y
        IF(ABS(Y).GT.DELTA) GOTO 2
        WRITE(6,7)
        GAUSS1=0.0
        RETURN
7        FORMAT(1X,'GAUSS1....TOO HIGH ACURACY REQUIRED')
        END
C
C
C
        FUNCTION GAUSS2(F,A,B,EPS)
        EXTERNAL F
        DIMENSION W(12),X(12)
        SAVE   
        DATA CONST/1.0E-12/
        DATA W/0.1012285,.2223810,.3137067,.3623838,.0271525,
     &         .0622535,0.0951585,.1246290,.1495960,.1691565,
     &         .1826034,.1894506/
        DATA X/0.9602899,.7966665,.5255324,.1834346,.9894009,
     &         .9445750,0.8656312,.7554044,.6178762,.4580168,
     &         .2816036,.0950125/

        DELTA=CONST*ABS(A-B)
        GAUSS2=0.0
        AA=A
5        Y=B-AA
        IF(ABS(Y).LE.DELTA) RETURN
2        BB=AA+Y
        C1=0.5*(AA+BB)
        C2=C1-AA
        S8=0.0
        S16=0.0
        DO 1 I=1,4
        U=X(I)*C2
1        S8=S8+W(I)*(F(C1+U)+F(C1-U))
        DO 3 I=5,12
        U=X(I)*C2
3        S16=S16+W(I)*(F(C1+U)+F(C1-U))
        S8=S8*C2
        S16=S16*C2
        IF(ABS(S16-S8).GT.EPS*(1.+ABS(S16))) GOTO 4
        GAUSS2=GAUSS2+S16
        AA=BB
        GOTO 5
4        Y=0.5*Y
        IF(ABS(Y).GT.DELTA) GOTO 2
        WRITE(6,7)
        GAUSS2=0.0
        RETURN
7        FORMAT(1X,'GAUSS2....TOO HIGH ACURACY REQUIRED')
        END
C
C
C
C
C
        SUBROUTINE TITLE

      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        SAVE   

        WRITE(6,200)
clin-8/15/02 f77:
c200        FORMAT(//10X,
c     &        '**************************************************'/10X,
c     &  '*     |      \       _______      /  ------/     *'/10X,
c     &        '*   ----- ------     |_____|     /_/     /       *'/10X,
c     &        '*    ||\    /        |_____|      /    / \       *'/10X,
c     &        '*    /| \  /_/       /_______    /_  /    \_     *'/10X,
c     &        '*   / |     / /     /  /  / |        -------     *'/10X,
c     &        '*     |    / /\       /  /  |     /     |        *'/10X,
c     &        '*     |   / /  \     /  / \_|    /   -------     *'/10X,
200        FORMAT(//10X,
     &        '**************************************************'/10X,
     &  '*     |      |       _______      /  ------/     *'/10X,
     &        '*   ----- ------     |_____|     /_/     /       *'/10X,
     &        '*    |||    /        |_____|      /    / |       *'/10X,
     &        '*    /| |  /_/       /_______    /_  /    |      *'/10X,
     &        '*   / |     / /     /  /  / |        -------     *'/10X,
     &        '*     |    / /|       /  /  |     /     |        *'/10X,
     &        '*     |   / /  |     /  /  _|    /   -------     *'/10X,
     &        '*                                                *'/10X,
     &        '**************************************************'/10X,
     &        '                      HIJING                      '/10X,
     &        '       Heavy Ion Jet INteraction Generator        '/10X,
     &        '                        by                        '/10X,
     &  '            X. N. Wang  and  M. Gyulassy           '/10X,
     &  '             Lawrence Berkeley Laboratory           '//)        
        RETURN
        END

c.................... hipyset1.35.f
C
C
C
C     Modified for HIJING program
c
c    modification July 22, 1997  In pyremnn put an upper limit
c     on the total pt kick the parton can accumulate via multiple
C     scattering. Set the upper limit to be the sqrt(s)/2,
c     this is fix cronin bug for Pb+Pb events at SPS energy.
c
C
C Last modification Oct. 1993 to comply with non-vax
C machines' compiler 
C
C*********************************************************************  
    
      SUBROUTINE LU2ENT(IP,KF1,KF2,PECM)    
    
C...Purpose: to store two partons/particles in their CM frame,  
C...with the first along the +z axis.   
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
    
C...Standard checks.    
      MSTU(28)=0    
      IF(MSTU(12).GE.1) CALL LULIST(0)  
      IPA=MAX(1,IABS(IP))   
      IF(IPA.GT.MSTU(4)-1) CALL LUERRM(21,  
     &'(LU2ENT:) writing outside LUJETS memory')    
      KC1=LUCOMP(KF1)   
      KC2=LUCOMP(KF2)   
      IF(KC1.EQ.0.OR.KC2.EQ.0) CALL LUERRM(12,  
     &'(LU2ENT:) unknown flavour code') 
    
C...Find masses. Reset K, P and V vectors.  
      PM1=0.    
      IF(MSTU(10).EQ.1) PM1=P(IPA,5)    
      IF(MSTU(10).GE.2) PM1=ULMASS(KF1) 
      PM2=0.    
      IF(MSTU(10).EQ.1) PM2=P(IPA+1,5)  
      IF(MSTU(10).GE.2) PM2=ULMASS(KF2) 
      DO 100 I=IPA,IPA+1    
      DO 100 J=1,5  
      K(I,J)=0  
      P(I,J)=0. 
  100 V(I,J)=0. 
    
C...Check flavours. 
      KQ1=KCHG(KC1,2)*ISIGN(1,KF1)  
      KQ2=KCHG(KC2,2)*ISIGN(1,KF2)  
      IF(KQ1+KQ2.NE.0.AND.KQ1+KQ2.NE.4) CALL LUERRM(2,  
     &'(LU2ENT:) unphysical flavour combination')   
      K(IPA,2)=KF1  
      K(IPA+1,2)=KF2    
    
C...Store partons/particles in K vectors for normal case.   
      IF(IP.GE.0) THEN  
        K(IPA,1)=1  
        IF(KQ1.NE.0.AND.KQ2.NE.0) K(IPA,1)=2    
        K(IPA+1,1)=1    
    
C...Store partons in K vectors for parton shower evolution. 
      ELSE  
        IF(KQ1.EQ.0.OR.KQ2.EQ.0) CALL LUERRM(2, 
     &  '(LU2ENT:) requested flavours can not develop parton shower')   
        K(IPA,1)=3  
        K(IPA+1,1)=3    
        K(IPA,4)=MSTU(5)*(IPA+1)    
        K(IPA,5)=K(IPA,4)   
        K(IPA+1,4)=MSTU(5)*IPA  
        K(IPA+1,5)=K(IPA+1,4)   
      ENDIF 
    
C...Check kinematics and store partons/particles in P vectors.  
      IF(PECM.LE.PM1+PM2) CALL LUERRM(13,   
     &'(LU2ENT:) energy smaller than sum of masses')    
      PA=SQRT(MAX(0.,(PECM**2-PM1**2-PM2**2)**2-(2.*PM1*PM2)**2))/  
     &(2.*PECM) 
      P(IPA,3)=PA   
      P(IPA,4)=SQRT(PM1**2+PA**2)   
      P(IPA,5)=PM1  
      P(IPA+1,3)=-PA    
      P(IPA+1,4)=SQRT(PM2**2+PA**2) 
      P(IPA+1,5)=PM2    
    
C...Set N. Optionally fragment/decay.   
      N=IPA+1   
      IF(IP.EQ.0) CALL LUEXEC   
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUGIVE(CHIN)   
    
C...Purpose: to set values of commonblock variables.    
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      COMMON/LUDAT4/CHAF(500)   
      CHARACTER CHAF*8  
      SAVE /LUDAT4/ 
      CHARACTER CHIN*(*),CHFIX*104,CHBIT*104,CHOLD*8,CHNEW*8,   
     &CHNAM*4,CHVAR(17)*4,CHALP(2)*26,CHIND*8,CHINI*10,CHINR*16 
      DATA CHVAR/'N','K','P','V','MSTU','PARU','MSTJ','PARJ','KCHG',    
     &'PMAS','PARF','VCKM','MDCY','MDME','BRAT','KFDP','CHAF'/  
      DATA CHALP/'abcdefghijklmnopqrstuvwxyz',  
     &'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/ 
    
C...Length of character variable. Subdivide it into instructions.   
      IF(MSTU(12).GE.1) CALL LULIST(0)  
      CHBIT=CHIN//' '   
      LBIT=101  
  100 LBIT=LBIT-1   
      IF(CHBIT(LBIT:LBIT).EQ.' ') GOTO 100  
      LTOT=0    
      DO 110 LCOM=1,LBIT    
      IF(CHBIT(LCOM:LCOM).EQ.' ') GOTO 110  
      LTOT=LTOT+1   
      CHFIX(LTOT:LTOT)=CHBIT(LCOM:LCOM) 
  110 CONTINUE  
      LLOW=0    
  120 LHIG=LLOW+1   
  130 LHIG=LHIG+1   
      IF(LHIG.LE.LTOT.AND.CHFIX(LHIG:LHIG).NE.';') GOTO 130 
      LBIT=LHIG-LLOW-1  
      CHBIT(1:LBIT)=CHFIX(LLOW+1:LHIG-1)    
    
C...Identify commonblock variable.  
      LNAM=1    
  140 LNAM=LNAM+1   
      IF(CHBIT(LNAM:LNAM).NE.'('.AND.CHBIT(LNAM:LNAM).NE.'='.AND.   
     &LNAM.LE.4) GOTO 140   
      CHNAM=CHBIT(1:LNAM-1)//' '    
      DO 150 LCOM=1,LNAM-1  
      DO 150 LALP=1,26  
  150 IF(CHNAM(LCOM:LCOM).EQ.CHALP(1)(LALP:LALP)) CHNAM(LCOM:LCOM)= 
     &CHALP(2)(LALP:LALP)   
      IVAR=0    
      DO 160 IV=1,17    
  160 IF(CHNAM.EQ.CHVAR(IV)) IVAR=IV    
      IF(IVAR.EQ.0) THEN    
        CALL LUERRM(18,'(LUGIVE:) do not recognize variable '//CHNAM)   
        LLOW=LHIG   
        IF(LLOW.LT.LTOT) GOTO 120   
        RETURN  
      ENDIF 
    
C...Identify any indices.   
      I=0   
      J=0   
      IF(CHBIT(LNAM:LNAM).EQ.'(') THEN  
        LIND=LNAM   
  170   LIND=LIND+1 
        IF(CHBIT(LIND:LIND).NE.')'.AND.CHBIT(LIND:LIND).NE.',') GOTO 170    
        CHIND=' '   
        IF((CHBIT(LNAM+1:LNAM+1).EQ.'C'.OR.CHBIT(LNAM+1:LNAM+1).EQ.'c').    
     &  AND.(IVAR.EQ.9.OR.IVAR.EQ.10.OR.IVAR.EQ.13.OR.IVAR.EQ.17)) THEN 
          CHIND(LNAM-LIND+11:8)=CHBIT(LNAM+2:LIND-1)    
          READ(CHIND,'(I8)') I1 
          I=LUCOMP(I1)  
        ELSE    
          CHIND(LNAM-LIND+10:8)=CHBIT(LNAM+1:LIND-1)    
          READ(CHIND,'(I8)') I  
        ENDIF   
        LNAM=LIND   
        IF(CHBIT(LNAM:LNAM).EQ.')') LNAM=LNAM+1 
      ENDIF 
      IF(CHBIT(LNAM:LNAM).EQ.',') THEN  
        LIND=LNAM   
  180   LIND=LIND+1 
        IF(CHBIT(LIND:LIND).NE.')'.AND.CHBIT(LIND:LIND).NE.',') GOTO 180    
        CHIND=' '   
        CHIND(LNAM-LIND+10:8)=CHBIT(LNAM+1:LIND-1)  
        READ(CHIND,'(I8)') J    
        LNAM=LIND+1 
      ENDIF 
    
C...Check that indices allowed and save old value.  
      IERR=1    
      IF(CHBIT(LNAM:LNAM).NE.'=') GOTO 190  
      IF(IVAR.EQ.1) THEN    
        IF(I.NE.0.OR.J.NE.0) GOTO 190   
        IOLD=N  
      ELSEIF(IVAR.EQ.2) THEN    
        IF(I.LT.1.OR.I.GT.MSTU(4).OR.J.LT.1.OR.J.GT.5) GOTO 190 
        IOLD=K(I,J) 
      ELSEIF(IVAR.EQ.3) THEN    
        IF(I.LT.1.OR.I.GT.MSTU(4).OR.J.LT.1.OR.J.GT.5) GOTO 190 
        ROLD=P(I,J) 
      ELSEIF(IVAR.EQ.4) THEN    
        IF(I.LT.1.OR.I.GT.MSTU(4).OR.J.LT.1.OR.J.GT.5) GOTO 190 
        ROLD=V(I,J) 
      ELSEIF(IVAR.EQ.5) THEN    
        IF(I.LT.1.OR.I.GT.200.OR.J.NE.0) GOTO 190   
        IOLD=MSTU(I)    
      ELSEIF(IVAR.EQ.6) THEN    
        IF(I.LT.1.OR.I.GT.200.OR.J.NE.0) GOTO 190   
        ROLD=PARU(I)    
      ELSEIF(IVAR.EQ.7) THEN    
        IF(I.LT.1.OR.I.GT.200.OR.J.NE.0) GOTO 190   
        IOLD=MSTJ(I)    
      ELSEIF(IVAR.EQ.8) THEN    
        IF(I.LT.1.OR.I.GT.200.OR.J.NE.0) GOTO 190   
        ROLD=PARJ(I)    
      ELSEIF(IVAR.EQ.9) THEN    
        IF(I.LT.1.OR.I.GT.MSTU(6).OR.J.LT.1.OR.J.GT.3) GOTO 190 
        IOLD=KCHG(I,J)  
      ELSEIF(IVAR.EQ.10) THEN   
        IF(I.LT.1.OR.I.GT.MSTU(6).OR.J.LT.1.OR.J.GT.4) GOTO 190 
        ROLD=PMAS(I,J)  
      ELSEIF(IVAR.EQ.11) THEN   
        IF(I.LT.1.OR.I.GT.2000.OR.J.NE.0) GOTO 190  
        ROLD=PARF(I)    
      ELSEIF(IVAR.EQ.12) THEN   
        IF(I.LT.1.OR.I.GT.4.OR.J.LT.1.OR.J.GT.4) GOTO 190   
        ROLD=VCKM(I,J)  
      ELSEIF(IVAR.EQ.13) THEN   
        IF(I.LT.1.OR.I.GT.MSTU(6).OR.J.LT.1.OR.J.GT.3) GOTO 190 
        IOLD=MDCY(I,J)  
      ELSEIF(IVAR.EQ.14) THEN   
        IF(I.LT.1.OR.I.GT.MSTU(7).OR.J.LT.1.OR.J.GT.2) GOTO 190 
        IOLD=MDME(I,J)  
      ELSEIF(IVAR.EQ.15) THEN   
        IF(I.LT.1.OR.I.GT.MSTU(7).OR.J.NE.0) GOTO 190   
        ROLD=BRAT(I)    
      ELSEIF(IVAR.EQ.16) THEN   
        IF(I.LT.1.OR.I.GT.MSTU(7).OR.J.LT.1.OR.J.GT.5) GOTO 190 
        IOLD=KFDP(I,J)  
      ELSEIF(IVAR.EQ.17) THEN   
        IF(I.LT.1.OR.I.GT.MSTU(6).OR.J.NE.0) GOTO 190   
        CHOLD=CHAF(I)   
      ENDIF 
      IERR=0    
  190 IF(IERR.EQ.1) THEN    
        CALL LUERRM(18,'(LUGIVE:) unallowed indices for '// 
     &  CHBIT(1:LNAM-1))    
        LLOW=LHIG   
        IF(LLOW.LT.LTOT) GOTO 120   
        RETURN  
      ENDIF 
    
C...Print current value of variable. Loop back. 
      IF(LNAM.GE.LBIT) THEN 
        CHBIT(LNAM:14)=' '  
        CHBIT(15:60)=' has the value                                '   
        IF(IVAR.EQ.1.OR.IVAR.EQ.2.OR.IVAR.EQ.5.OR.IVAR.EQ.7.OR. 
     &  IVAR.EQ.9.OR.IVAR.EQ.13.OR.IVAR.EQ.14.OR.IVAR.EQ.16) THEN   
          WRITE(CHBIT(51:60),'(I10)') IOLD  
        ELSEIF(IVAR.NE.17) THEN 
          WRITE(CHBIT(47:60),'(F14.5)') ROLD    
        ELSE    
          CHBIT(53:60)=CHOLD    
        ENDIF   
        IF(MSTU(13).GE.1) WRITE(MSTU(11),1000) CHBIT(1:60)  
        LLOW=LHIG   
        IF(LLOW.LT.LTOT) GOTO 120   
        RETURN  
      ENDIF 
    
C...Read in new variable value. 
      IF(IVAR.EQ.1.OR.IVAR.EQ.2.OR.IVAR.EQ.5.OR.IVAR.EQ.7.OR.   
     &IVAR.EQ.9.OR.IVAR.EQ.13.OR.IVAR.EQ.14.OR.IVAR.EQ.16) THEN 
        CHINI=' '   
        CHINI(LNAM-LBIT+11:10)=CHBIT(LNAM+1:LBIT)   
        READ(CHINI,'(I10)') INEW    
      ELSEIF(IVAR.NE.17) THEN   
        CHINR=' '   
        CHINR(LNAM-LBIT+17:16)=CHBIT(LNAM+1:LBIT)   
        READ(CHINR,'(F16.2)') RNEW  
      ELSE  
        CHNEW=CHBIT(LNAM+1:LBIT)//' '   
      ENDIF 
    
C...Store new variable value.   
      IF(IVAR.EQ.1) THEN    
        N=INEW  
      ELSEIF(IVAR.EQ.2) THEN    
        K(I,J)=INEW 
      ELSEIF(IVAR.EQ.3) THEN    
        P(I,J)=RNEW 
      ELSEIF(IVAR.EQ.4) THEN    
        V(I,J)=RNEW 
      ELSEIF(IVAR.EQ.5) THEN    
        MSTU(I)=INEW    
      ELSEIF(IVAR.EQ.6) THEN    
        PARU(I)=RNEW    
      ELSEIF(IVAR.EQ.7) THEN    
        MSTJ(I)=INEW    
      ELSEIF(IVAR.EQ.8) THEN    
        PARJ(I)=RNEW    
      ELSEIF(IVAR.EQ.9) THEN    
        KCHG(I,J)=INEW  
      ELSEIF(IVAR.EQ.10) THEN   
        PMAS(I,J)=RNEW  
      ELSEIF(IVAR.EQ.11) THEN   
        PARF(I)=RNEW    
      ELSEIF(IVAR.EQ.12) THEN   
        VCKM(I,J)=RNEW  
      ELSEIF(IVAR.EQ.13) THEN   
        MDCY(I,J)=INEW  
      ELSEIF(IVAR.EQ.14) THEN   
        MDME(I,J)=INEW  
      ELSEIF(IVAR.EQ.15) THEN   
        BRAT(I)=RNEW    
      ELSEIF(IVAR.EQ.16) THEN   
        KFDP(I,J)=INEW  
      ELSEIF(IVAR.EQ.17) THEN   
        CHAF(I)=CHNEW   
      ENDIF 
    
C...Write old and new value. Loop back. 
      CHBIT(LNAM:14)=' '    
      CHBIT(15:60)=' changed from                to               ' 
      IF(IVAR.EQ.1.OR.IVAR.EQ.2.OR.IVAR.EQ.5.OR.IVAR.EQ.7.OR.   
     &IVAR.EQ.9.OR.IVAR.EQ.13.OR.IVAR.EQ.14.OR.IVAR.EQ.16) THEN 
        WRITE(CHBIT(33:42),'(I10)') IOLD    
        WRITE(CHBIT(51:60),'(I10)') INEW    
      ELSEIF(IVAR.NE.17) THEN   
        WRITE(CHBIT(29:42),'(F14.5)') ROLD  
        WRITE(CHBIT(47:60),'(F14.5)') RNEW  
      ELSE  
        CHBIT(35:42)=CHOLD  
        CHBIT(53:60)=CHNEW  
      ENDIF 
      IF(MSTU(13).GE.1) WRITE(MSTU(11),1000) CHBIT(1:60)    
      LLOW=LHIG 
      IF(LLOW.LT.LTOT) GOTO 120 
    
C...Format statement for output on unit MSTU(11) (by default 6).    
 1000 FORMAT(5X,A60)    
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUEXEC 
    
C...Purpose: to administrate the fragmentation and decay chain. 
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      DIMENSION PS(2,6) 
    
C...Initialize and reset.   
      MSTU(24)=0    
      IF(MSTU(12).GE.1) CALL LULIST(0)  
      MSTU(31)=MSTU(31)+1   
      MSTU(1)=0 
      MSTU(2)=0 
      MSTU(3)=0 
      MCONS=1   
    
C...Sum up momentum, energy and charge for starting entries.    
      NSAV=N    
      DO 100 I=1,2  
      DO 100 J=1,6  
  100 PS(I,J)=0.    
      DO 120 I=1,N  
      IF(K(I,1).LE.0.OR.K(I,1).GT.10) GOTO 120  
      DO 110 J=1,4  
  110 PS(1,J)=PS(1,J)+P(I,J)    
      PS(1,6)=PS(1,6)+LUCHGE(K(I,2))    
  120 CONTINUE  
      PARU(21)=PS(1,4)  
    
C...Prepare system for subsequent fragmentation/decay.  
      CALL LUPREP(0)    
    
C...Loop through jet fragmentation and particle decays. 
      MBE=0 
  130 MBE=MBE+1 
      IP=0  
  140 IP=IP+1   
      KC=0  
      IF(K(IP,1).GT.0.AND.K(IP,1).LE.10) KC=LUCOMP(K(IP,2)) 
      IF(KC.EQ.0) THEN  
    
C...Particle decay if unstable and allowed. Save long-lived particle    
C...decays until second pass after Bose-Einstein effects.   
      ELSEIF(KCHG(KC,2).EQ.0) THEN  
clin-4/2008 break up compound IF statements:
c        IF(MSTJ(21).GE.1.AND.MDCY(KC,1).GE.1.AND.(MSTJ(51).LE.0.OR.MBE. 
c     &  EQ.2.OR.PMAS(KC,2).GE.PARJ(91).OR.IABS(K(IP,2)).EQ.311))    
c     &  CALL LUDECY(IP) 
         if(MSTJ(21).GE.1.AND.MDCY(KC,1).GE.1) then
            if(MSTJ(51).LE.0.OR.MBE.EQ.2.OR.PMAS(KC,2).GE.PARJ(91)
     &           .OR.IABS(K(IP,2)).EQ.311)
     &           CALL LUDECY(IP) 
         endif
c    
C...Decay products may develop a shower.    
        IF(MSTJ(92).GT.0) THEN  
          IP1=MSTJ(92)  
          QMAX=SQRT(MAX(0.,(P(IP1,4)+P(IP1+1,4))**2-(P(IP1,1)+P(IP1+1,  
     &    1))**2-(P(IP1,2)+P(IP1+1,2))**2-(P(IP1,3)+P(IP1+1,3))**2))    
          CALL LUSHOW(IP1,IP1+1,QMAX)   
          CALL LUPREP(IP1)  
          MSTJ(92)=0    
        ELSEIF(MSTJ(92).LT.0) THEN  
          IP1=-MSTJ(92) 
clin-8/19/02 avoid actual argument in common blocks of LUSHOW:
c          CALL LUSHOW(IP1,-3,P(IP,5))   
          pip5=P(IP,5)
          CALL LUSHOW(IP1,-3,pip5)   
          CALL LUPREP(IP1)  
          MSTJ(92)=0    
        ENDIF   
    
C...Jet fragmentation: string or independent fragmentation. 
      ELSEIF(K(IP,1).EQ.1.OR.K(IP,1).EQ.2) THEN 
        MFRAG=MSTJ(1)   
        IF(MFRAG.GE.1.AND.K(IP,1).EQ.1) MFRAG=2 
        IF(MSTJ(21).GE.2.AND.K(IP,1).EQ.2.AND.N.GT.IP) THEN 
          IF(K(IP+1,1).EQ.1.AND.K(IP+1,3).EQ.K(IP,3).AND.   
     &    K(IP,3).GT.0.AND.K(IP,3).LT.IP) THEN  
            IF(KCHG(LUCOMP(K(K(IP,3),2)),2).EQ.0) MFRAG=MIN(1,MFRAG)    
          ENDIF 
        ENDIF   
        IF(MFRAG.EQ.1) then
           CALL LUSTRF(IP)  
        endif
        IF(MFRAG.EQ.2) CALL LUINDF(IP)  
        IF(MFRAG.EQ.2.AND.K(IP,1).EQ.1) MCONS=0 
        IF(MFRAG.EQ.2.AND.(MSTJ(3).LE.0.OR.MOD(MSTJ(3),5).EQ.0)) MCONS=0    
      ENDIF 
    
C...Loop back if enough space left in LUJETS and no error abort.    
      IF(MSTU(24).NE.0.AND.MSTU(21).GE.2) THEN  
      ELSEIF(IP.LT.N.AND.N.LT.MSTU(4)-20-MSTU(32)) THEN 
        GOTO 140    
      ELSEIF(IP.LT.N) THEN  
        CALL LUERRM(11,'(LUEXEC:) no more memory left in LUJETS')   
      ENDIF 
    
C...Include simple Bose-Einstein effect parametrization if desired. 
      IF(MBE.EQ.1.AND.MSTJ(51).GE.1) THEN   
        CALL LUBOEI(NSAV)   
        GOTO 130    
      ENDIF 
    
C...Check that momentum, energy and charge were conserved.  
      DO 160 I=1,N  
      IF(K(I,1).LE.0.OR.K(I,1).GT.10) GOTO 160  
      DO 150 J=1,4  
  150 PS(2,J)=PS(2,J)+P(I,J)    
      PS(2,6)=PS(2,6)+LUCHGE(K(I,2))    
  160 CONTINUE  
      PDEV=(ABS(PS(2,1)-PS(1,1))+ABS(PS(2,2)-PS(1,2))+ABS(PS(2,3)-  
     &PS(1,3))+ABS(PS(2,4)-PS(1,4)))/(1.+ABS(PS(2,4))+ABS(PS(1,4))) 
      IF(MCONS.EQ.1.AND.PDEV.GT.PARU(11)) CALL LUERRM(15,   
     &'(LUEXEC:) four-momentum was not conserved')  
c      IF(MCONS.EQ.1.AND.PDEV.GT.PARU(11)) then
c         CALL LUERRM(15,   
c     &'(LUEXEC:) four-momentum was not conserved')  
c         write(6,*) 'PS1,2=',PS(1,1),PS(1,2),PS(1,3),PS(1,4),
c     1        '*',PS(2,1),PS(2,2),PS(2,3),PS(2,4)
c      endif

      IF(MCONS.EQ.1.AND.ABS(PS(2,6)-PS(1,6)).GT.0.1) CALL LUERRM(15,    
     &'(LUEXEC:) charge was not conserved') 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUPREP(IP) 
    
C...Purpose: to rearrange partons along strings, to allow small systems 
C...to collapse into one or two particles and to check flavours.    
      IMPLICIT DOUBLE PRECISION(D)  
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      DIMENSION DPS(5),DPC(5),UE(3) 
    
C...Rearrange parton shower product listing along strings: begin loop.  
      I1=N  
      DO 130 MQGST=1,2  
      DO 120 I=MAX(1,IP),N  
      IF(K(I,1).NE.3) GOTO 120  
      KC=LUCOMP(K(I,2)) 
      IF(KC.EQ.0) GOTO 120  
      KQ=KCHG(KC,2) 
      IF(KQ.EQ.0.OR.(MQGST.EQ.1.AND.KQ.EQ.2)) GOTO 120  
    
C...Pick up loose string end.   
      KCS=4 
      IF(KQ*ISIGN(1,K(I,2)).LT.0) KCS=5 
      IA=I  
      NSTP=0    
  100 NSTP=NSTP+1   
      IF(NSTP.GT.4*N) THEN  
        CALL LUERRM(14,'(LUPREP:) caught in infinite loop') 
        RETURN  
      ENDIF 
    
C...Copy undecayed parton.  
      IF(K(IA,1).EQ.3) THEN 
        IF(I1.GE.MSTU(4)-MSTU(32)-5) THEN   
          CALL LUERRM(11,'(LUPREP:) no more memory left in LUJETS') 
          RETURN    
        ENDIF   
        I1=I1+1 
        K(I1,1)=2   
        IF(NSTP.GE.2.AND.IABS(K(IA,2)).NE.21) K(I1,1)=1 
        K(I1,2)=K(IA,2) 
        K(I1,3)=IA  
        K(I1,4)=0   
        K(I1,5)=0   
        DO 110 J=1,5    
        P(I1,J)=P(IA,J) 
  110   V(I1,J)=V(IA,J) 
        K(IA,1)=K(IA,1)+10  
        IF(K(I1,1).EQ.1) GOTO 120   
      ENDIF 
    
C...Go to next parton in colour space.  
      IB=IA 
      IF(MOD(K(IB,KCS)/MSTU(5)**2,2).EQ.0.AND.MOD(K(IB,KCS),MSTU(5)).   
     &NE.0) THEN    
        IA=MOD(K(IB,KCS),MSTU(5))   
        K(IB,KCS)=K(IB,KCS)+MSTU(5)**2  
        MREV=0  
      ELSE  
        IF(K(IB,KCS).GE.2*MSTU(5)**2.OR.MOD(K(IB,KCS)/MSTU(5),MSTU(5)). 
     &  EQ.0) KCS=9-KCS 
        IA=MOD(K(IB,KCS)/MSTU(5),MSTU(5))   
        K(IB,KCS)=K(IB,KCS)+2*MSTU(5)**2    
        MREV=1  
      ENDIF 
      IF(IA.LE.0.OR.IA.GT.N) THEN   
        CALL LUERRM(12,'(LUPREP:) colour rearrangement failed') 
        RETURN  
      ENDIF 
      IF(MOD(K(IA,4)/MSTU(5),MSTU(5)).EQ.IB.OR.MOD(K(IA,5)/MSTU(5), 
     &MSTU(5)).EQ.IB) THEN  
        IF(MREV.EQ.1) KCS=9-KCS 
        IF(MOD(K(IA,KCS)/MSTU(5),MSTU(5)).NE.IB) KCS=9-KCS  
        K(IA,KCS)=K(IA,KCS)+2*MSTU(5)**2    
      ELSE  
        IF(MREV.EQ.0) KCS=9-KCS 
        IF(MOD(K(IA,KCS),MSTU(5)).NE.IB) KCS=9-KCS  
        K(IA,KCS)=K(IA,KCS)+MSTU(5)**2  
      ENDIF 
      IF(IA.NE.I) GOTO 100  
      K(I1,1)=1 
  120 CONTINUE  
  130 CONTINUE  
      N=I1  
    
C...Find lowest-mass colour singlet jet system, OK if above thresh.  
      IF(MSTJ(14).LE.0) GOTO 320    
      NS=N  
  140 NSIN=N-NS 
      PDM=1.+PARJ(32)   
      IC=0  
      DO 190 I=MAX(1,IP),NS 
      IF(K(I,1).NE.1.AND.K(I,1).NE.2) THEN  
      ELSEIF(K(I,1).EQ.2.AND.IC.EQ.0) THEN  
        NSIN=NSIN+1 
        IC=I    
        DO 150 J=1,4    
  150   DPS(J)=dble(P(I,J))
        MSTJ(93)=1  
        DPS(5)=dble(ULMASS(K(I,2)))
      ELSEIF(K(I,1).EQ.2) THEN  
        DO 160 J=1,4    
  160   DPS(J)=DPS(J)+dble(P(I,J))
      ELSEIF(IC.NE.0.AND.KCHG(LUCOMP(K(I,2)),2).NE.0) THEN  
        DO 170 J=1,4    
  170   DPS(J)=DPS(J)+dble(P(I,J))
        MSTJ(93)=1  
        DPS(5)=DPS(5)+dble(ULMASS(K(I,2)))
        PD=sngl(SQRT(MAX(0D0,DPS(4)**2
     1       -DPS(1)**2-DPS(2)**2-DPS(3)**2))-DPS(5))    
        IF(PD.LT.PDM) THEN  
          PDM=PD    
          DO 180 J=1,5  
  180     DPC(J)=DPS(J) 
          IC1=IC    
          IC2=I 
        ENDIF   
        IC=0    
      ELSE  
        NSIN=NSIN+1 
      ENDIF 
  190 CONTINUE  
      IF(PDM.GE.PARJ(32)) GOTO 320  
    
C...Fill small-mass system as cluster.  
      NSAV=N    
      PECM=sngl(SQRT(MAX(0D0,DPC(4)**2-DPC(1)**2-DPC(2)**2-DPC(3)**2)))
      K(N+1,1)=11   
      K(N+1,2)=91   
      K(N+1,3)=IC1  
      K(N+1,4)=N+2  
      K(N+1,5)=N+3  
      P(N+1,1)=sngl(DPC(1))
      P(N+1,2)=sngl(DPC(2))  
      P(N+1,3)=sngl(DPC(3))  
      P(N+1,4)=sngl(DPC(4))
      P(N+1,5)=PECM 
    
C...Form two particles from flavours of lowest-mass system, if feasible.    
      K(N+2,1)=1    
      K(N+3,1)=1    
      IF(MSTU(16).NE.2) THEN    
        K(N+2,3)=N+1    
        K(N+3,3)=N+1    
      ELSE  
        K(N+2,3)=IC1    
        K(N+3,3)=IC2    
      ENDIF 
      K(N+2,4)=0    
      K(N+3,4)=0    
      K(N+2,5)=0    
      K(N+3,5)=0    
      IF(IABS(K(IC1,2)).NE.21) THEN 
        KC1=LUCOMP(K(IC1,2))    
        KC2=LUCOMP(K(IC2,2))    
        IF(KC1.EQ.0.OR.KC2.EQ.0) GOTO 320   
        KQ1=KCHG(KC1,2)*ISIGN(1,K(IC1,2))   
        KQ2=KCHG(KC2,2)*ISIGN(1,K(IC2,2))   
        IF(KQ1+KQ2.NE.0) GOTO 320   
  200   CALL LUKFDI(K(IC1,2),0,KFLN,K(N+2,2))   
        CALL LUKFDI(K(IC2,2),-KFLN,KFLDMP,K(N+3,2)) 
        IF(K(N+2,2).EQ.0.OR.K(N+3,2).EQ.0) GOTO 200 
      ELSE  
        IF(IABS(K(IC2,2)).NE.21) GOTO 320   
  210   CALL LUKFDI(1+INT((2.+PARJ(2))*RLU(0)),0,KFLN,KFDMP)    
        CALL LUKFDI(KFLN,0,KFLM,K(N+2,2))   
        CALL LUKFDI(-KFLN,-KFLM,KFLDMP,K(N+3,2))    
        IF(K(N+2,2).EQ.0.OR.K(N+3,2).EQ.0) GOTO 210 
      ENDIF 
      P(N+2,5)=ULMASS(K(N+2,2)) 
      P(N+3,5)=ULMASS(K(N+3,2)) 
      IF(P(N+2,5)+P(N+3,5)+PARJ(64).GE.PECM.AND.NSIN.EQ.1) GOTO 320 
      IF(P(N+2,5)+P(N+3,5)+PARJ(64).GE.PECM) GOTO 260   
    
C...Perform two-particle decay of jet system, if possible.  
clin-5/2012:
c      IF(PECM.GE.0.02d0*DPC(4)) THEN  
      IF(dble(PECM).GE.0.02d0*DPC(4)) THEN  
        PA=SQRT((PECM**2-(P(N+2,5)+P(N+3,5))**2)*(PECM**2-  
     &  (P(N+2,5)-P(N+3,5))**2))/(2.*PECM)  
        UE(3)=2.*RLU(0)-1.  
        PHI=PARU(2)*RLU(0)  
        UE(1)=SQRT(1.-UE(3)**2)*COS(PHI)    
        UE(2)=SQRT(1.-UE(3)**2)*SIN(PHI)    
        DO 220 J=1,3    
        P(N+2,J)=PA*UE(J)   
  220   P(N+3,J)=-PA*UE(J)  
        P(N+2,4)=SQRT(PA**2+P(N+2,5)**2)    
        P(N+3,4)=SQRT(PA**2+P(N+3,5)**2)    
        CALL LUDBRB(N+2,N+3,0.,0.,DPC(1)/DPC(4),DPC(2)/DPC(4),  
     &  DPC(3)/DPC(4))  
      ELSE  
        NP=0    
        DO 230 I=IC1,IC2    
  230   IF(K(I,1).EQ.1.OR.K(I,1).EQ.2) NP=NP+1  
        HA=P(IC1,4)*P(IC2,4)-P(IC1,1)*P(IC2,1)-P(IC1,2)*P(IC2,2)-   
     &  P(IC1,3)*P(IC2,3)   
        IF(NP.GE.3.OR.HA.LE.1.25*P(IC1,5)*P(IC2,5)) GOTO 260    
        HD1=0.5*(P(N+2,5)**2-P(IC1,5)**2)   
        HD2=0.5*(P(N+3,5)**2-P(IC2,5)**2)   
        HR=SQRT(MAX(0.,((HA-HD1-HD2)**2-(P(N+2,5)*P(N+3,5))**2)/    
     &  (HA**2-(P(IC1,5)*P(IC2,5))**2)))-1. 
        HC=P(IC1,5)**2+2.*HA+P(IC2,5)**2    
        HK1=((P(IC2,5)**2+HA)*HR+HD1-HD2)/HC    
        HK2=((P(IC1,5)**2+HA)*HR+HD2-HD1)/HC    
        DO 240 J=1,4    
        P(N+2,J)=(1.+HK1)*P(IC1,J)-HK2*P(IC2,J) 
  240   P(N+3,J)=(1.+HK2)*P(IC2,J)-HK1*P(IC1,J) 
      ENDIF 
      DO 250 J=1,4  
      V(N+1,J)=V(IC1,J) 
      V(N+2,J)=V(IC1,J) 
  250 V(N+3,J)=V(IC2,J) 
      V(N+1,5)=0.   
      V(N+2,5)=0.   
      V(N+3,5)=0.   
      N=N+3 
      GOTO 300  
    
C...Else form one particle from the flavours available, if possible.    
  260 K(N+1,5)=N+2  
      IF(IABS(K(IC1,2)).GT.100.AND.IABS(K(IC2,2)).GT.100) THEN  
        GOTO 320    
      ELSEIF(IABS(K(IC1,2)).NE.21) THEN 
        CALL LUKFDI(K(IC1,2),K(IC2,2),KFLDMP,K(N+2,2))  
      ELSE  
        KFLN=1+INT((2.+PARJ(2))*RLU(0)) 
        CALL LUKFDI(KFLN,-KFLN,KFLDMP,K(N+2,2)) 
      ENDIF 
      IF(K(N+2,2).EQ.0) GOTO 260    
      P(N+2,5)=ULMASS(K(N+2,2)) 
    
C...Find parton/particle which combines to largest extra mass.  
      IR=0  
      HA=0. 
      DO 280 MCOMB=1,3  
      IF(IR.NE.0) GOTO 280  
      DO 270 I=MAX(1,IP),N  
      IF(K(I,1).LE.0.OR.K(I,1).GT.10.OR.(I.GE.IC1.AND.I.LE.IC2. 
     &AND.K(I,1).GE.1.AND.K(I,1).LE.2)) GOTO 270    
      IF(MCOMB.EQ.1) KCI=LUCOMP(K(I,2)) 
      IF(MCOMB.EQ.1.AND.KCI.EQ.0) GOTO 270  
      IF(MCOMB.EQ.1.AND.KCHG(KCI,2).EQ.0.AND.I.LE.NS) GOTO 270  
      IF(MCOMB.EQ.2.AND.IABS(K(I,2)).GT.10.AND.IABS(K(I,2)).LE.100) 
     &GOTO 270  
      HCR=sngl(DPC(4))*P(I,4)-sngl(DPC(1))*P(I,1)
     1     -sngl(DPC(2))*P(I,2)-sngl(DPC(3))*P(I,3)   
      IF(HCR.GT.HA) THEN    
        IR=I    
        HA=HCR  
      ENDIF 
  270 CONTINUE  
  280 CONTINUE  
    
C...Shuffle energy and momentum to put new particle on mass shell.  
      HB=PECM**2+HA 
      HC=P(N+2,5)**2+HA 
      HD=P(IR,5)**2+HA
C******************CHANGES BY HIJING************  
      HK2=0.0
      IF(HA**2-(PECM*P(IR,5))**2.EQ.0.0.OR.HB+HD.EQ.0.0) GO TO 285
C******************
      HK2=0.5*(HB*SQRT(((HB+HC)**2-4.*(HB+HD)*P(N+2,5)**2)/ 
     &(HA**2-(PECM*P(IR,5))**2))-(HB+HC))/(HB+HD)   
  285 HK1=(0.5*(P(N+2,5)**2-PECM**2)+HD*HK2)/HB 
      DO 290 J=1,4  
      P(N+2,J)=(1.+HK1)*sngl(DPC(J))-HK2*P(IR,J)  
      P(IR,J)=(1.+HK2)*P(IR,J)-HK1*sngl(DPC(J))
      V(N+1,J)=V(IC1,J) 
  290 V(N+2,J)=V(IC1,J) 
      V(N+1,5)=0.   
      V(N+2,5)=0.   
      N=N+2 
    
C...Mark collapsed system and store daughter pointers. Iterate. 
  300 DO 310 I=IC1,IC2  
      IF((K(I,1).EQ.1.OR.K(I,1).EQ.2).AND.KCHG(LUCOMP(K(I,2)),2).NE.0)  
     &THEN  
        K(I,1)=K(I,1)+10    
        IF(MSTU(16).NE.2) THEN  
          K(I,4)=NSAV+1 
          K(I,5)=NSAV+1 
        ELSE    
          K(I,4)=NSAV+2 
          K(I,5)=N  
        ENDIF   
      ENDIF 
  310 CONTINUE  
      IF(N.LT.MSTU(4)-MSTU(32)-5) GOTO 140  
    
C...Check flavours and invariant masses in parton systems.  
  320 NP=0  
      KFN=0 
      KQS=0 
      DO 330 J=1,5  
  330 DPS(J)=0d0
      DO 360 I=MAX(1,IP),N  
      IF(K(I,1).LE.0.OR.K(I,1).GT.10) GOTO 360  
      KC=LUCOMP(K(I,2)) 
      IF(KC.EQ.0) GOTO 360  
      KQ=KCHG(KC,2)*ISIGN(1,K(I,2)) 
      IF(KQ.EQ.0) GOTO 360  
      NP=NP+1   
      IF(KQ.NE.2) THEN  
        KFN=KFN+1   
        KQS=KQS+KQ  
        MSTJ(93)=1  
        DPS(5)=DPS(5)+dble(ULMASS(K(I,2)))
      ENDIF 
      DO 340 J=1,4  
  340 DPS(J)=DPS(J)+dble(P(I,J))

clin-4/12/01:
c     np: # of partons, KFN: number of quarks and diquarks, 
c     KC=0 for color singlet system, -1 for quarks and anti-diquarks, 
c     1 for quarks and anti-diquarks, and 2 for gluons:
      IF(K(I,1).EQ.1) THEN  
clin-4/12/01     end of color singlet system.
        IF(NP.NE.1.AND.(KFN.EQ.1.OR.KFN.GE.3.OR.KQS.NE.0)) CALL 
     &  LUERRM(2,'(LUPREP:) unphysical flavour combination')    

clin-4/16/01: 'jet system' should be defined as np.ne.2:
c        IF(NP.NE.1.AND.DPS(4)**2-DPS(1)**2-DPS(2)**2-DPS(3)**2.LT.  
c     &  (0.9*PARJ(32)+DPS(5))**2) CALL LUERRM(3,    
c     &  '(LUPREP:) too small mass in jet system')   
        IF(NP.NE.2.AND.DPS(4)**2-DPS(1)**2-DPS(2)**2-DPS(3)**2.LT.  
     &  (0.9d0*dble(PARJ(32))+DPS(5))**2) then 
           CALL LUERRM(3,    
     &  '(LUPREP:) too small mass in jet system')   
           write (6,*) 'DPS(1-5),KI1-5=',DPS(1),DPS(2),DPS(3),DPS(4),
     1 DPS(5),'*',K(I,1),K(I,2),K(I,3),K(I,4),K(I,5)
        endif

        NP=0    
        KFN=0   
        KQS=0   
        DO 350 J=1,5    
  350   DPS(J)=0d0
      ENDIF 
  360 CONTINUE  
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUSTRF(IP) 
C...Purpose: to handle the fragmentation of an arbitrary colour singlet 
C...jet system according to the Lund string fragmentation model.    
      IMPLICIT DOUBLE PRECISION(D)  
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      DIMENSION DPS(5),KFL(3),PMQ(3),PX(3),PY(3),GAM(3),IE(2),PR(2),    
     &IN(9),DHM(4),DHG(4),DP(5,5),IRANK(2),MJU(4),IJU(3),PJU(5,5),  
     &TJU(5),KFJH(2),NJS(2),KFJS(2),PJS(4,5)    
    
C...Function: four-product of two vectors.  
      FOUR(I,J)=P(I,4)*P(J,4)-P(I,1)*P(J,1)-P(I,2)*P(J,2)-P(I,3)*P(J,3) 
      DFOUR(I,J)=DP(I,4)*DP(J,4)-DP(I,1)*DP(J,1)-DP(I,2)*DP(J,2)-   
     &DP(I,3)*DP(J,3)   
    
C...Reset counters. Identify parton system. 
      MSTJ(91)=0    
      NSAV=N    
      NP=0  
      KQSUM=0   
      DO 100 J=1,5  
  100 DPS(J)=0d0 
      MJU(1)=0  
      MJU(2)=0  
      I=IP-1    
  110 I=I+1 
      IF(I.GT.MIN(N,MSTU(4)-MSTU(32))) THEN 
        CALL LUERRM(12,'(LUSTRF:) failed to reconstruct jet system')    
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      IF(K(I,1).NE.1.AND.K(I,1).NE.2.AND.K(I,1).NE.41) GOTO 110 
      KC=LUCOMP(K(I,2)) 
      IF(KC.EQ.0) GOTO 110  
      KQ=KCHG(KC,2)*ISIGN(1,K(I,2)) 
      IF(KQ.EQ.0) GOTO 110  
      IF(N+5*NP+11.GT.MSTU(4)-MSTU(32)-5) THEN  
        CALL LUERRM(11,'(LUSTRF:) no more memory left in LUJETS')   
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
    
C...Take copy of partons to be considered. Check flavour sum.   
      NP=NP+1   
      DO 120 J=1,5  
      K(N+NP,J)=K(I,J)  
      P(N+NP,J)=P(I,J)  
  120 DPS(J)=DPS(J)+dble(P(I,J))
      K(N+NP,3)=I   
      IF(P(N+NP,4)**2.LT.P(N+NP,1)**2+P(N+NP,2)**2+P(N+NP,3)**2) THEN   
        P(N+NP,4)=SQRT(P(N+NP,1)**2+P(N+NP,2)**2+P(N+NP,3)**2+  
     &  P(N+NP,5)**2)   
        DPS(4)=DPS(4)+dble(MAX(0.,P(N+NP,4)-P(I,4)))
      ENDIF 
      IF(KQ.NE.2) KQSUM=KQSUM+KQ    
      IF(K(I,1).EQ.41) THEN 
        KQSUM=KQSUM+2*KQ    
        IF(KQSUM.EQ.KQ) MJU(1)=N+NP 
        IF(KQSUM.NE.KQ) MJU(2)=N+NP 
      ENDIF 
      IF(K(I,1).EQ.2.OR.K(I,1).EQ.41) GOTO 110  
      IF(KQSUM.NE.0) THEN   
        CALL LUERRM(12,'(LUSTRF:) unphysical flavour combination')  
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 

C...Boost copied system to CM frame (for better numerical precision).   
      CALL LUDBRB(N+1,N+NP,0.,0.,-DPS(1)/DPS(4),-DPS(2)/DPS(4), 
     &-DPS(3)/DPS(4))   

C...Search for very nearby partons that may be recombined.  
      NTRYR=0   
      PARU12=PARU(12)   
      PARU13=PARU(13)   
      MJU(3)=MJU(1) 
      MJU(4)=MJU(2) 
      NR=NP 
  130 IF(NR.GE.3) THEN  
        PDRMIN=2.*PARU12    
        DO 140 I=N+1,N+NR   
        IF(I.EQ.N+NR.AND.IABS(K(N+1,2)).NE.21) GOTO 140 
        I1=I+1  
        IF(I.EQ.N+NR) I1=N+1    
        IF(K(I,1).EQ.41.OR.K(I1,1).EQ.41) GOTO 140  
        IF(MJU(1).NE.0.AND.I1.LT.MJU(1).AND.IABS(K(I1,2)).NE.21)    
     &  GOTO 140    
        IF(MJU(2).NE.0.AND.I.GT.MJU(2).AND.IABS(K(I,2)).NE.21) GOTO 140 
        PAP=SQRT((P(I,1)**2+P(I,2)**2+P(I,3)**2)*(P(I1,1)**2+   
     &  P(I1,2)**2+P(I1,3)**2)) 
        PVP=P(I,1)*P(I1,1)+P(I,2)*P(I1,2)+P(I,3)*P(I1,3)    
        PDR=4.*(PAP-PVP)**2/(PARU13**2*PAP+2.*(PAP-PVP))    
        IF(PDR.LT.PDRMIN) THEN  
          IR=I  
          PDRMIN=PDR    
        ENDIF   
  140   CONTINUE    
    
C...Recombine very nearby partons to avoid machine precision problems.  
        IF(PDRMIN.LT.PARU12.AND.IR.EQ.N+NR) THEN    
          DO 150 J=1,4  
  150     P(N+1,J)=P(N+1,J)+P(N+NR,J)   
          P(N+1,5)=SQRT(MAX(0.,P(N+1,4)**2-P(N+1,1)**2-P(N+1,2)**2- 
     &    P(N+1,3)**2)) 
          NR=NR-1   
          GOTO 130  
        ELSEIF(PDRMIN.LT.PARU12) THEN   
          DO 160 J=1,4  
  160     P(IR,J)=P(IR,J)+P(IR+1,J) 
          P(IR,5)=SQRT(MAX(0.,P(IR,4)**2-P(IR,1)**2-P(IR,2)**2- 
     &    P(IR,3)**2))  
          DO 170 I=IR+1,N+NR-1  
          K(I,2)=K(I+1,2)   
          DO 170 J=1,5  
  170     P(I,J)=P(I+1,J)   
          IF(IR.EQ.N+NR-1) K(IR,2)=K(N+NR,2)    
          NR=NR-1   
          IF(MJU(1).GT.IR) MJU(1)=MJU(1)-1  
          IF(MJU(2).GT.IR) MJU(2)=MJU(2)-1  
          GOTO 130  
        ENDIF   
      ENDIF 
      NTRYR=NTRYR+1 
    
C...Reset particle counter. Skip ahead if no junctions are present; 
C...this is usually the case!   
      NRS=MAX(5*NR+11,NP)   
      NTRY=0    
  180 NTRY=NTRY+1   
      IF(NTRY.GT.100.AND.NTRYR.LE.4) THEN   
        PARU12=4.*PARU12    
        PARU13=2.*PARU13    
        GOTO 130    
      ELSEIF(NTRY.GT.100) THEN  
        CALL LUERRM(14,'(LUSTRF:) caught in infinite loop') 
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      I=N+NRS   
      IF(MJU(1).EQ.0.AND.MJU(2).EQ.0) GOTO 500  
      DO 490 JT=1,2 
      NJS(JT)=0 
      IF(MJU(JT).EQ.0) GOTO 490 
      JS=3-2*JT 
    
C...Find and sum up momentum on three sides of junction. Check flavours.    
      DO 190 IU=1,3 
      IJU(IU)=0 
      DO 190 J=1,5  
  190 PJU(IU,J)=0.  
      IU=0  
      DO 200 I1=N+1+(JT-1)*(NR-1),N+NR+(JT-1)*(1-NR),JS 
      IF(K(I1,2).NE.21.AND.IU.LE.2) THEN    
        IU=IU+1 
        IJU(IU)=I1  
      ENDIF 
      DO 200 J=1,4  
  200 PJU(IU,J)=PJU(IU,J)+P(I1,J)   
      DO 210 IU=1,3 
  210 PJU(IU,5)=SQRT(PJU(IU,1)**2+PJU(IU,2)**2+PJU(IU,3)**2)    
      IF(K(IJU(3),2)/100.NE.10*K(IJU(1),2)+K(IJU(2),2).AND. 
     &K(IJU(3),2)/100.NE.10*K(IJU(2),2)+K(IJU(1),2)) THEN   
        CALL LUERRM(12,'(LUSTRF:) unphysical flavour combination')  
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
    
C...Calculate (approximate) boost to rest frame of junction.    
      T12=(PJU(1,1)*PJU(2,1)+PJU(1,2)*PJU(2,2)+PJU(1,3)*PJU(2,3))/  
     &(PJU(1,5)*PJU(2,5))   
      T13=(PJU(1,1)*PJU(3,1)+PJU(1,2)*PJU(3,2)+PJU(1,3)*PJU(3,3))/  
     &(PJU(1,5)*PJU(3,5))   
      T23=(PJU(2,1)*PJU(3,1)+PJU(2,2)*PJU(3,2)+PJU(2,3)*PJU(3,3))/  
     &(PJU(2,5)*PJU(3,5))   
      T11=SQRT((2./3.)*(1.-T12)*(1.-T13)/(1.-T23))  
      T22=SQRT((2./3.)*(1.-T12)*(1.-T23)/(1.-T13))  
      TSQ=SQRT((2.*T11*T22+T12-1.)*(1.+T12))    
      T1F=(TSQ-T22*(1.+T12))/(1.-T12**2)    
      T2F=(TSQ-T11*(1.+T12))/(1.-T12**2)    
      DO 220 J=1,3  
  220 TJU(J)=-(T1F*PJU(1,J)/PJU(1,5)+T2F*PJU(2,J)/PJU(2,5)) 
      TJU(4)=SQRT(1.+TJU(1)**2+TJU(2)**2+TJU(3)**2) 
      DO 230 IU=1,3 
  230 PJU(IU,5)=TJU(4)*PJU(IU,4)-TJU(1)*PJU(IU,1)-TJU(2)*PJU(IU,2)- 
     &TJU(3)*PJU(IU,3)  
    
C...Put junction at rest if motion could give inconsistencies.  
      IF(PJU(1,5)+PJU(2,5).GT.PJU(1,4)+PJU(2,4)) THEN   
        DO 240 J=1,3    
  240   TJU(J)=0.   
        TJU(4)=1.   
        PJU(1,5)=PJU(1,4)   
        PJU(2,5)=PJU(2,4)   
        PJU(3,5)=PJU(3,4)   
      ENDIF 
    
C...Start preparing for fragmentation of two strings from junction. 
      ISTA=I    
      DO 470 IU=1,2 
      NS=IJU(IU+1)-IJU(IU)  
    
C...Junction strings: find longitudinal string directions.  
      DO 260 IS=1,NS    
      IS1=IJU(IU)+IS-1  
      IS2=IJU(IU)+IS    
      DO 250 J=1,5  
      DP(1,J)=dble(0.5*P(IS1,J))
      IF(IS.EQ.1) DP(1,J)=dble(P(IS1,J))
      DP(2,J)=dble(0.5*P(IS2,J))
  250 IF(IS.EQ.NS) DP(2,J)=-dble(PJU(IU,J))
      IF(IS.EQ.NS) DP(2,4)=dble(
     1     SQRT(PJU(IU,1)**2+PJU(IU,2)**2+PJU(IU,3)**2))
      IF(IS.EQ.NS) DP(2,5)=0d0   
      DP(3,5)=DFOUR(1,1)    
      DP(4,5)=DFOUR(2,2)    
      DHKC=DFOUR(1,2)   
      IF(DP(3,5)+2d0*DHKC+DP(4,5).LE.0d0) THEN    
        DP(1,4)=SQRT(DP(1,1)**2+DP(1,2)**2+DP(1,3)**2)  
        DP(2,4)=SQRT(DP(2,1)**2+DP(2,2)**2+DP(2,3)**2)  
        DP(3,5)=0D0 
        DP(4,5)=0D0 
        DHKC=DFOUR(1,2) 
      ENDIF 
      DHKS=SQRT(DHKC**2-DP(3,5)*DP(4,5))    
      DHK1=0.5d0*((DP(4,5)+DHKC)/DHKS-1d0) 
      DHK2=0.5d0*((DP(3,5)+DHKC)/DHKS-1d0) 
      IN1=N+NR+4*IS-3   
      P(IN1,5)=sngl(SQRT(DP(3,5)+2d0*DHKC+DP(4,5)))
      DO 260 J=1,4  
      P(IN1,J)=sngl((1d0+DHK1)*DP(1,J)-DHK2*DP(2,J))
  260 P(IN1+1,J)=sngl((1d0+DHK2)*DP(2,J)-DHK1*DP(1,J))
    
C...Junction strings: initialize flavour, momentum and starting pos.    
      ISAV=I    
  270 NTRY=NTRY+1   
      IF(NTRY.GT.100.AND.NTRYR.LE.4) THEN   
        PARU12=4.*PARU12    
        PARU13=2.*PARU13    
        GOTO 130    
      ELSEIF(NTRY.GT.100) THEN  
        CALL LUERRM(14,'(LUSTRF:) caught in infinite loop') 
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      I=ISAV    
      IRANKJ=0  
      IE(1)=K(N+1+(JT/2)*(NP-1),3)  
      IN(4)=N+NR+1  
      IN(5)=IN(4)+1 
      IN(6)=N+NR+4*NS+1 
      DO 280 JQ=1,2 
      DO 280 IN1=N+NR+2+JQ,N+NR+4*NS-2+JQ,4 
      P(IN1,1)=2-JQ 
      P(IN1,2)=JQ-1 
  280 P(IN1,3)=1.   
      KFL(1)=K(IJU(IU),2)   
      PX(1)=0.  
      PY(1)=0.  
      GAM(1)=0. 
      DO 290 J=1,5  
  290 PJU(IU+3,J)=0.    
    
C...Junction strings: find initial transverse directions.   
      DO 300 J=1,4  
      DP(1,J)=dble(P(IN(4),J))
      DP(2,J)=dble(P(IN(4)+1,J))
      DP(3,J)=0d0    
  300 DP(4,J)=0d0    
      DP(1,4)=SQRT(DP(1,1)**2+DP(1,2)**2+DP(1,3)**2)    
      DP(2,4)=SQRT(DP(2,1)**2+DP(2,2)**2+DP(2,3)**2)    
      DP(5,1)=DP(1,1)/DP(1,4)-DP(2,1)/DP(2,4)   
      DP(5,2)=DP(1,2)/DP(1,4)-DP(2,2)/DP(2,4)   
      DP(5,3)=DP(1,3)/DP(1,4)-DP(2,3)/DP(2,4)   
      IF(DP(5,1)**2.LE.DP(5,2)**2+DP(5,3)**2) DP(3,1)=1d0    
      IF(DP(5,1)**2.GT.DP(5,2)**2+DP(5,3)**2) DP(3,3)=1d0    
      IF(DP(5,2)**2.LE.DP(5,1)**2+DP(5,3)**2) DP(4,2)=1d0    
      IF(DP(5,2)**2.GT.DP(5,1)**2+DP(5,3)**2) DP(4,3)=1d0    
      DHC12=DFOUR(1,2)  
      DHCX1=DFOUR(3,1)/DHC12    
      DHCX2=DFOUR(3,2)/DHC12    
      DHCXX=1D0/SQRT(1D0+2D0*DHCX1*DHCX2*DHC12) 
      DHCY1=DFOUR(4,1)/DHC12    
      DHCY2=DFOUR(4,2)/DHC12    
      DHCYX=DHCXX*(DHCX1*DHCY2+DHCX2*DHCY1)*DHC12   
      DHCYY=1D0/SQRT(1D0+2D0*DHCY1*DHCY2*DHC12-DHCYX**2)    
      DO 310 J=1,4  
      DP(3,J)=DHCXX*(DP(3,J)-DHCX2*DP(1,J)-DHCX1*DP(2,J))   
      P(IN(6),J)=sngl(DP(3,J))
  310 P(IN(6)+1,J)=sngl(DHCYY*(DP(4,J)-DHCY2*DP(1,J)-DHCY1*DP(2,J)-  
     &DHCYX*DP(3,J)))    
    
C...Junction strings: produce new particle, origin. 
  320 I=I+1 
      IF(2*I-NSAV.GE.MSTU(4)-MSTU(32)-5) THEN   
        CALL LUERRM(11,'(LUSTRF:) no more memory left in LUJETS')   
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      IRANKJ=IRANKJ+1   
      K(I,1)=1  
      K(I,3)=IE(1)  
      K(I,4)=0  
      K(I,5)=0  
    
C...Junction strings: generate flavour, hadron, pT, z and Gamma.    
  330 CALL LUKFDI(KFL(1),0,KFL(3),K(I,2))   
      IF(K(I,2).EQ.0) GOTO 270  
      IF(MSTJ(12).GE.3.AND.IRANKJ.EQ.1.AND.IABS(KFL(1)).LE.10.AND.  
     &IABS(KFL(3)).GT.10) THEN  
        IF(RLU(0).GT.PARJ(19)) GOTO 330 
      ENDIF 
      P(I,5)=ULMASS(K(I,2)) 
      CALL LUPTDI(KFL(1),PX(3),PY(3))   
      PR(1)=P(I,5)**2+(PX(1)+PX(3))**2+(PY(1)+PY(3))**2 
      CALL LUZDIS(KFL(1),KFL(3),PR(1),Z)    
      GAM(3)=(1.-Z)*(GAM(1)+PR(1)/Z)    
      DO 340 J=1,3  
  340 IN(J)=IN(3+J) 

C...Junction strings: stepping within or from 'low' string region easy. 
      IF(IN(1)+1.EQ.IN(2).AND.Z*P(IN(1)+2,3)*P(IN(2)+2,3)*  
     &P(IN(1),5)**2.GE.PR(1)) THEN  
        P(IN(1)+2,4)=Z*P(IN(1)+2,3) 
        P(IN(2)+2,4)=PR(1)/(P(IN(1)+2,4)*P(IN(1),5)**2) 
        DO 350 J=1,4    
  350   P(I,J)=(PX(1)+PX(3))*P(IN(3),J)+(PY(1)+PY(3))*P(IN(3)+1,J)  
        GOTO 420    
      ELSEIF(IN(1)+1.EQ.IN(2)) THEN 
        P(IN(2)+2,4)=P(IN(2)+2,3)   
        P(IN(2)+2,1)=1. 
        IN(2)=IN(2)+4   
        IF(IN(2).GT.N+NR+4*NS) GOTO 270 
        IF(FOUR(IN(1),IN(2)).LE.1E-2) THEN  
          P(IN(1)+2,4)=P(IN(1)+2,3) 
          P(IN(1)+2,1)=0.   
          IN(1)=IN(1)+4 
        ENDIF   
      ENDIF 
    
C...Junction strings: find new transverse directions.   
  360 IF(IN(1).GT.N+NR+4*NS.OR.IN(2).GT.N+NR+4*NS.OR.   
     &IN(1).GT.IN(2)) GOTO 270  
      IF(IN(1).NE.IN(4).OR.IN(2).NE.IN(5)) THEN 
        DO 370 J=1,4    
        DP(1,J)=dble(P(IN(1),J))
        DP(2,J)=dble(P(IN(2),J))
        DP(3,J)=0d0  
  370   DP(4,J)=0d0  
        DP(1,4)=SQRT(DP(1,1)**2+DP(1,2)**2+DP(1,3)**2)  
        DP(2,4)=SQRT(DP(2,1)**2+DP(2,2)**2+DP(2,3)**2)  
        DHC12=DFOUR(1,2)    
clin-5/2012:
c        IF(DHC12.LE.1E-2) THEN  
        IF(DHC12.LE.1D-2) THEN  
          P(IN(1)+2,4)=P(IN(1)+2,3) 
          P(IN(1)+2,1)=0.   
          IN(1)=IN(1)+4 
          GOTO 360  
        ENDIF   
        IN(3)=N+NR+4*NS+5   
        DP(5,1)=DP(1,1)/DP(1,4)-DP(2,1)/DP(2,4) 
        DP(5,2)=DP(1,2)/DP(1,4)-DP(2,2)/DP(2,4) 
        DP(5,3)=DP(1,3)/DP(1,4)-DP(2,3)/DP(2,4) 
        IF(DP(5,1)**2.LE.DP(5,2)**2+DP(5,3)**2) DP(3,1)=1d0  
        IF(DP(5,1)**2.GT.DP(5,2)**2+DP(5,3)**2) DP(3,3)=1d0  
        IF(DP(5,2)**2.LE.DP(5,1)**2+DP(5,3)**2) DP(4,2)=1d0  
        IF(DP(5,2)**2.GT.DP(5,1)**2+DP(5,3)**2) DP(4,3)=1d0  
        DHCX1=DFOUR(3,1)/DHC12  
        DHCX2=DFOUR(3,2)/DHC12  
        DHCXX=1D0/SQRT(1D0+2D0*DHCX1*DHCX2*DHC12)   
        DHCY1=DFOUR(4,1)/DHC12  
        DHCY2=DFOUR(4,2)/DHC12  
        DHCYX=DHCXX*(DHCX1*DHCY2+DHCX2*DHCY1)*DHC12 
        DHCYY=1D0/SQRT(1D0+2D0*DHCY1*DHCY2*DHC12-DHCYX**2)  
        DO 380 J=1,4    
        DP(3,J)=DHCXX*(DP(3,J)-DHCX2*DP(1,J)-DHCX1*DP(2,J)) 
        P(IN(3),J)=sngl(DP(3,J))
  380   P(IN(3)+1,J)=sngl(DHCYY*(DP(4,J)-DHCY2*DP(1,J)-DHCY1*DP(2,J)-    
     &  DHCYX*DP(3,J)))  
C...Express pT with respect to new axes, if sensible.   
        PXP=-(PX(3)*FOUR(IN(6),IN(3))+PY(3)*FOUR(IN(6)+1,IN(3)))    
        PYP=-(PX(3)*FOUR(IN(6),IN(3)+1)+PY(3)*FOUR(IN(6)+1,IN(3)+1))    
        IF(ABS(PXP**2+PYP**2-PX(3)**2-PY(3)**2).LT.0.01) THEN   
          PX(3)=PXP 
          PY(3)=PYP 
        ENDIF   
      ENDIF 
    
C...Junction strings: sum up known four-momentum, coefficients for m2.  
      DO 400 J=1,4  
      DHG(J)=0d0 
      P(I,J)=PX(1)*P(IN(6),J)+PY(1)*P(IN(6)+1,J)+PX(3)*P(IN(3),J)+  
     &PY(3)*P(IN(3)+1,J)    
      DO 390 IN1=IN(4),IN(1)-4,4    
  390 P(I,J)=P(I,J)+P(IN1+2,3)*P(IN1,J) 
      DO 400 IN2=IN(5),IN(2)-4,4    
  400 P(I,J)=P(I,J)+P(IN2+2,3)*P(IN2,J) 
      DHM(1)=dble(FOUR(I,I))
      DHM(2)=dble(2.*FOUR(I,IN(1)))   
      DHM(3)=dble(2.*FOUR(I,IN(2)))  
      DHM(4)=dble(2.*FOUR(IN(1),IN(2))) 
    
C...Junction strings: find coefficients for Gamma expression.   
      DO 410 IN2=IN(1)+1,IN(2),4    
      DO 410 IN1=IN(1),IN2-1,4  
      DHC=dble(2.*FOUR(IN1,IN2))
      DHG(1)=DHG(1)+dble(P(IN1+2,1)*P(IN2+2,1))*DHC   
      IF(IN1.EQ.IN(1)) DHG(2)=DHG(2)-dble(P(IN2+2,1))*DHC 
      IF(IN2.EQ.IN(2)) DHG(3)=DHG(3)+dble(P(IN1+2,1))*DHC 
  410 IF(IN1.EQ.IN(1).AND.IN2.EQ.IN(2)) DHG(4)=DHG(4)-DHC   
    
C...Junction strings: solve (m2, Gamma) equation system for energies.   
      DHS1=DHM(3)*DHG(4)-DHM(4)*DHG(3)  
clin-5/2012:
c      IF(ABS(DHS1).LT.1E-4) GOTO 270    
      IF(DABS(DHS1).LT.1D-4) GOTO 270    
      DHS2=DHM(4)*(dble(GAM(3))-DHG(1))-DHM(2)*DHG(3)-DHG(4)* 
     &(dble(P(I,5))**2-DHM(1))+DHG(2)*DHM(3)  
      DHS3=DHM(2)*(dble(GAM(3))-DHG(1))
     1     -DHG(2)*(dble(P(I,5))**2-DHM(1)) 
      P(IN(2)+2,4)=0.5*sngl(SQRT(MAX(0D0,DHS2**2-4d0*DHS1*DHS3))
     &     /ABS(DHS1)-DHS2/DHS1)
      IF(DHM(2)+DHM(4)*dble(P(IN(2)+2,4)).LE.0d0) GOTO 270 
      P(IN(1)+2,4)=(P(I,5)**2-sngl(DHM(1))-sngl(DHM(3))*P(IN(2)+2,4))/  
     &(sngl(DHM(2))+sngl(DHM(4))*P(IN(2)+2,4))  

C...Junction strings: step to new region if necessary.  
      IF(P(IN(2)+2,4).GT.P(IN(2)+2,3)) THEN 
        P(IN(2)+2,4)=P(IN(2)+2,3)   
        P(IN(2)+2,1)=1. 
        IN(2)=IN(2)+4   
        IF(IN(2).GT.N+NR+4*NS) GOTO 270 
        IF(FOUR(IN(1),IN(2)).LE.1E-2) THEN  
          P(IN(1)+2,4)=P(IN(1)+2,3) 
          P(IN(1)+2,1)=0.   
          IN(1)=IN(1)+4 
        ENDIF   
        GOTO 360    
      ELSEIF(P(IN(1)+2,4).GT.P(IN(1)+2,3)) THEN 
        P(IN(1)+2,4)=P(IN(1)+2,3)   
        P(IN(1)+2,1)=0. 
        IN(1)=IN(1)+JS  
        GOTO 710    
      ENDIF 
    
C...Junction strings: particle four-momentum, remainder, loop back. 
  420 DO 430 J=1,4  
      P(I,J)=P(I,J)+P(IN(1)+2,4)*P(IN(1),J)+P(IN(2)+2,4)*P(IN(2),J) 
  430 PJU(IU+3,J)=PJU(IU+3,J)+P(I,J)    
      IF(P(I,4).LE.0.) GOTO 270 
      PJU(IU+3,5)=TJU(4)*PJU(IU+3,4)-TJU(1)*PJU(IU+3,1)-    
     &TJU(2)*PJU(IU+3,2)-TJU(3)*PJU(IU+3,3) 
      IF(PJU(IU+3,5).LT.PJU(IU,5)) THEN 
        KFL(1)=-KFL(3)  
        PX(1)=-PX(3)    
        PY(1)=-PY(3)    
        GAM(1)=GAM(3)   
        IF(IN(3).NE.IN(6)) THEN 
          DO 440 J=1,4  
          P(IN(6),J)=P(IN(3),J) 
  440     P(IN(6)+1,J)=P(IN(3)+1,J) 
        ENDIF   
        DO 450 JQ=1,2   
        IN(3+JQ)=IN(JQ) 
        P(IN(JQ)+2,3)=P(IN(JQ)+2,3)-P(IN(JQ)+2,4)   
  450   P(IN(JQ)+2,1)=P(IN(JQ)+2,1)-(3-2*JQ)*P(IN(JQ)+2,4)  
        GOTO 320    
      ENDIF 
    
C...Junction strings: save quantities left after each string.   
      IF(IABS(KFL(1)).GT.10) GOTO 270   
      I=I-1 
      KFJH(IU)=KFL(1)   
      DO 460 J=1,4  
  460 PJU(IU+3,J)=PJU(IU+3,J)-P(I+1,J)  
  470 CONTINUE  
    
C...Junction strings: put together to new effective string endpoint.    
      NJS(JT)=I-ISTA    
      KFJS(JT)=K(K(MJU(JT+2),3),2)  
      KFLS=2*INT(RLU(0)+3.*PARJ(4)/(1.+3.*PARJ(4)))+1   
      IF(KFJH(1).EQ.KFJH(2)) KFLS=3 
      IF(ISTA.NE.I) KFJS(JT)=ISIGN(1000*MAX(IABS(KFJH(1)),  
     &IABS(KFJH(2)))+100*MIN(IABS(KFJH(1)),IABS(KFJH(2)))+  
     &KFLS,KFJH(1)) 
      DO 480 J=1,4  
      PJS(JT,J)=PJU(1,J)+PJU(2,J)+P(MJU(JT),J)  
  480 PJS(JT+2,J)=PJU(4,J)+PJU(5,J) 
      PJS(JT,5)=SQRT(MAX(0.,PJS(JT,4)**2-PJS(JT,1)**2-PJS(JT,2)**2- 
     &PJS(JT,3)**2))    
  490 CONTINUE  
    
C...Open versus closed strings. Choose breakup region for latter.   
  500 IF(MJU(1).NE.0.AND.MJU(2).NE.0) THEN  
        NS=MJU(2)-MJU(1)    
        NB=MJU(1)-N 
      ELSEIF(MJU(1).NE.0) THEN  
        NS=N+NR-MJU(1)  
        NB=MJU(1)-N 
      ELSEIF(MJU(2).NE.0) THEN  
        NS=MJU(2)-N 
        NB=1    
      ELSEIF(IABS(K(N+1,2)).NE.21) THEN 
        NS=NR-1 
        NB=1    
      ELSE  
        NS=NR+1 
        W2SUM=0.    
        DO 510 IS=1,NR  
        P(N+NR+IS,1)=0.5*FOUR(N+IS,N+IS+1-NR*(IS/NR))   
  510   W2SUM=W2SUM+P(N+NR+IS,1)    
        W2RAN=RLU(0)*W2SUM  
        NB=0    
  520   NB=NB+1 
        W2SUM=W2SUM-P(N+NR+NB,1)    
        IF(W2SUM.GT.W2RAN.AND.NB.LT.NR) GOTO 520    
      ENDIF 
    
C...Find longitudinal string directions (i.e. lightlike four-vectors).  
      DO 540 IS=1,NS    
      IS1=N+IS+NB-1-NR*((IS+NB-2)/NR)   
      IS2=N+IS+NB-NR*((IS+NB-1)/NR) 
      DO 530 J=1,5  
      DP(1,J)=dble(P(IS1,J))
      IF(IABS(K(IS1,2)).EQ.21) DP(1,J)=0.5d0*DP(1,J)  
      IF(IS1.EQ.MJU(1)) DP(1,J)=dble(PJS(1,J)-PJS(3,J))
      DP(2,J)=dble(P(IS2,J))
      IF(IABS(K(IS2,2)).EQ.21) DP(2,J)=0.5d0*DP(2,J)  
  530 IF(IS2.EQ.MJU(2)) DP(2,J)=dble(PJS(2,J)-PJS(4,J))
      DP(3,5)=DFOUR(1,1)    
      DP(4,5)=DFOUR(2,2)    
      DHKC=DFOUR(1,2)   
      IF(DP(3,5)+2.d0*DHKC+DP(4,5).LE.0.d0) THEN    
        DP(3,5)=DP(1,5)**2  
        DP(4,5)=DP(2,5)**2  
        DP(1,4)=SQRT(DP(1,1)**2+DP(1,2)**2+DP(1,3)**2+DP(1,5)**2)   
        DP(2,4)=SQRT(DP(2,1)**2+DP(2,2)**2+DP(2,3)**2+DP(2,5)**2)   
        DHKC=DFOUR(1,2) 
      ENDIF 
      DHKS=SQRT(DHKC**2-DP(3,5)*DP(4,5))    
      DHK1=0.5d0*((DP(4,5)+DHKC)/DHKS-1.d0) 
      DHK2=0.5d0*((DP(3,5)+DHKC)/DHKS-1.d0) 
      IN1=N+NR+4*IS-3   
      P(IN1,5)=SQRT(sngl(DP(3,5)+2.d0*DHKC+DP(4,5)))
      DO 540 J=1,4  
      P(IN1,J)=sngl((1.d0+DHK1)*DP(1,J)-DHK2*DP(2,J))
  540 P(IN1+1,J)=sngl((1.d0+DHK2)*DP(2,J)-DHK1*DP(1,J))
    
C...Begin initialization: sum up energy, set starting position. 
      ISAV=I    
  550 NTRY=NTRY+1   
      IF(NTRY.GT.100.AND.NTRYR.LE.4) THEN   
        PARU12=4.*PARU12    
        PARU13=2.*PARU13    
        GOTO 130    
      ELSEIF(NTRY.GT.100) THEN  
        CALL LUERRM(14,'(LUSTRF:) caught in infinite loop') 
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      I=ISAV    
      DO 560 J=1,4  
      P(N+NRS,J)=0. 
      DO 560 IS=1,NR    
  560 P(N+NRS,J)=P(N+NRS,J)+P(N+IS,J)   
      DO 570 JT=1,2 
      IRANK(JT)=0   
      IF(MJU(JT).NE.0) IRANK(JT)=NJS(JT)    
      IF(NS.GT.NR) IRANK(JT)=1  
      IE(JT)=K(N+1+(JT/2)*(NP-1),3) 
      IN(3*JT+1)=N+NR+1+4*(JT/2)*(NS-1) 
      IN(3*JT+2)=IN(3*JT+1)+1   
      IN(3*JT+3)=N+NR+4*NS+2*JT-1   
      DO 570 IN1=N+NR+2+JT,N+NR+4*NS-2+JT,4 
      P(IN1,1)=2-JT 
      P(IN1,2)=JT-1 
  570 P(IN1,3)=1.   
    
C...Initialize flavour and pT variables for open string.    
      IF(NS.LT.NR) THEN 
        PX(1)=0.    
        PY(1)=0.    
        IF(NS.EQ.1.AND.MJU(1)+MJU(2).EQ.0) CALL LUPTDI(0,PX(1),PY(1))   
        PX(2)=-PX(1)    
        PY(2)=-PY(1)    
        DO 580 JT=1,2   
        KFL(JT)=K(IE(JT),2) 
        IF(MJU(JT).NE.0) KFL(JT)=KFJS(JT)   
        MSTJ(93)=1  
        PMQ(JT)=ULMASS(KFL(JT)) 
  580   GAM(JT)=0.  
    
C...Closed string: random initial breakup flavour, pT and vertex.   
      ELSE  
        KFL(3)=INT(1.+(2.+PARJ(2))*RLU(0))*(-1)**INT(RLU(0)+0.5)    
        CALL LUKFDI(KFL(3),0,KFL(1),KDUMP)  
        KFL(2)=-KFL(1)  
        IF(IABS(KFL(1)).GT.10.AND.RLU(0).GT.0.5) THEN   
          KFL(2)=-(KFL(1)+ISIGN(10000,KFL(1)))  
        ELSEIF(IABS(KFL(1)).GT.10) THEN 
          KFL(1)=-(KFL(2)+ISIGN(10000,KFL(2)))  
        ENDIF   
        CALL LUPTDI(KFL(1),PX(1),PY(1)) 
        PX(2)=-PX(1)    
        PY(2)=-PY(1)    
        PR3=MIN(25.,0.1*P(N+NR+1,5)**2) 
  590   CALL LUZDIS(KFL(1),KFL(2),PR3,Z)    
        ZR=PR3/(Z*P(N+NR+1,5)**2)   
        IF(ZR.GE.1.) GOTO 590   

        DO 600 JT=1,2   
        MSTJ(93)=1  
        PMQ(JT)=ULMASS(KFL(JT)) 
        GAM(JT)=PR3*(1.-Z)/Z    
        IN1=N+NR+3+4*(JT/2)*(NS-1)  
        P(IN1,JT)=1.-Z  
        P(IN1,3-JT)=JT-1    
        P(IN1,3)=(2-JT)*(1.-Z)+(JT-1)*Z 
        P(IN1+1,JT)=ZR  
        P(IN1+1,3-JT)=2-JT  
  600   P(IN1+1,3)=(2-JT)*(1.-ZR)+(JT-1)*ZR 
      ENDIF 
    
C...Find initial transverse directions (i.e. spacelike four-vectors).   
      DO 640 JT=1,2 
      IF(JT.EQ.1.OR.NS.EQ.NR-1) THEN    
        IN1=IN(3*JT+1)  
        IN3=IN(3*JT+3)  
        DO 610 J=1,4    
        DP(1,J)=dble(P(IN1,J))
        DP(2,J)=dble(P(IN1+1,J))
        DP(3,J)=0.d0
  610   DP(4,J)=0.d0
        DP(1,4)=DSQRT(DP(1,1)**2+DP(1,2)**2+DP(1,3)**2)  
        DP(2,4)=DSQRT(DP(2,1)**2+DP(2,2)**2+DP(2,3)**2)  
        DP(5,1)=DP(1,1)/DP(1,4)-DP(2,1)/DP(2,4) 
        DP(5,2)=DP(1,2)/DP(1,4)-DP(2,2)/DP(2,4) 
        DP(5,3)=DP(1,3)/DP(1,4)-DP(2,3)/DP(2,4) 
        IF(DP(5,1)**2.LE.DP(5,2)**2+DP(5,3)**2) DP(3,1)=1.d0
        IF(DP(5,1)**2.GT.DP(5,2)**2+DP(5,3)**2) DP(3,3)=1.d0
        IF(DP(5,2)**2.LE.DP(5,1)**2+DP(5,3)**2) DP(4,2)=1.d0
        IF(DP(5,2)**2.GT.DP(5,1)**2+DP(5,3)**2) DP(4,3)=1.d0
        DHC12=DFOUR(1,2)    
        DHCX1=DFOUR(3,1)/DHC12  
        DHCX2=DFOUR(3,2)/DHC12  
        DHCXX=1D0/SQRT(1D0+2D0*DHCX1*DHCX2*DHC12)   
        DHCY1=DFOUR(4,1)/DHC12  
        DHCY2=DFOUR(4,2)/DHC12  
        DHCYX=DHCXX*(DHCX1*DHCY2+DHCX2*DHCY1)*DHC12 
        DHCYY=1D0/SQRT(1D0+2D0*DHCY1*DHCY2*DHC12-DHCYX**2)  
        DO 620 J=1,4    
        DP(3,J)=DHCXX*(DP(3,J)-DHCX2*DP(1,J)-DHCX1*DP(2,J)) 
        P(IN3,J)=sngl(DP(3,J))
  620   P(IN3+1,J)=sngl(DHCYY*(DP(4,J)-DHCY2*DP(1,J)-DHCY1*DP(2,J)-  
     &  DHCYX*DP(3,J)))
      ELSE  
        DO 630 J=1,4    
        P(IN3+2,J)=P(IN3,J) 
  630   P(IN3+3,J)=P(IN3+1,J)   
      ENDIF 
  640 CONTINUE  
    
C...Remove energy used up in junction string fragmentation. 
      IF(MJU(1)+MJU(2).GT.0) THEN   
        DO 660 JT=1,2   
        IF(NJS(JT).EQ.0) GOTO 660   
        DO 650 J=1,4    
  650   P(N+NRS,J)=P(N+NRS,J)-PJS(JT+2,J)   
  660   CONTINUE    
      ENDIF 
    
C...Produce new particle: side, origin. 
  670 I=I+1 
      IF(2*I-NSAV.GE.MSTU(4)-MSTU(32)-5) THEN   
        CALL LUERRM(11,'(LUSTRF:) no more memory left in LUJETS')   
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      JT=int(1.5+RLU(0))
      IF(IABS(KFL(3-JT)).GT.10) JT=3-JT 
      JR=3-JT   
      JS=3-2*JT 
      IRANK(JT)=IRANK(JT)+1 
      K(I,1)=1  
      K(I,3)=IE(JT) 
      K(I,4)=0  
      K(I,5)=0  
    
C...Generate flavour, hadron and pT.    
  680 CALL LUKFDI(KFL(JT),0,KFL(3),K(I,2))  
      IF(K(I,2).EQ.0) GOTO 550  
      IF(MSTJ(12).GE.3.AND.IRANK(JT).EQ.1.AND.IABS(KFL(JT)).LE.10.AND.  
     &IABS(KFL(3)).GT.10) THEN  
        IF(RLU(0).GT.PARJ(19)) GOTO 680 
      ENDIF 
      P(I,5)=ULMASS(K(I,2)) 
      CALL LUPTDI(KFL(JT),PX(3),PY(3))  
      PR(JT)=P(I,5)**2+(PX(JT)+PX(3))**2+(PY(JT)+PY(3))**2  
    
C...Final hadrons for small invariant mass. 
      MSTJ(93)=1    
      PMQ(3)=ULMASS(KFL(3)) 
      WMIN=PARJ(32+MSTJ(11))+PMQ(1)+PMQ(2)+PARJ(36)*PMQ(3)  
      IF(IABS(KFL(JT)).GT.10.AND.IABS(KFL(3)).GT.10) WMIN=  
     &WMIN-0.5*PARJ(36)*PMQ(3)  
      WREM2=FOUR(N+NRS,N+NRS)   
      IF(WREM2.LT.0.10) GOTO 550    
      IF(WREM2.LT.MAX(WMIN*(1.+(2.*RLU(0)-1.)*PARJ(37)),    
     &PARJ(32)+PMQ(1)+PMQ(2))**2) GOTO 810  
    
C...Choose z, which gives Gamma. Shift z for heavy flavours.    
      CALL LUZDIS(KFL(JT),KFL(3),PR(JT),Z)  

      KFL1A=IABS(KFL(1))    
      KFL2A=IABS(KFL(2))    
      IF(MAX(MOD(KFL1A,10),MOD(KFL1A/1000,10),MOD(KFL2A,10),    
     &MOD(KFL2A/1000,10)).GE.4) THEN    
        PR(JR)=(PMQ(JR)+PMQ(3))**2+(PX(JR)-PX(3))**2+(PY(JR)-PY(3))**2  
        PW12=SQRT(MAX(0.,(WREM2-PR(1)-PR(2))**2-4.*PR(1)*PR(2)))    
        Z=(WREM2+PR(JT)-PR(JR)+PW12*(2.*Z-1.))/(2.*WREM2)   
        PR(JR)=(PMQ(JR)+PARJ(32+MSTJ(11)))**2+(PX(JR)-PX(3))**2+    
     &  (PY(JR)-PY(3))**2   
        IF((1.-Z)*(WREM2-PR(JT)/Z).LT.PR(JR)) GOTO 810  
      ENDIF 
      GAM(3)=(1.-Z)*(GAM(JT)+PR(JT)/Z)  
      DO 690 J=1,3  
  690 IN(J)=IN(3*JT+J)  
    
C...Stepping within or from 'low' string region easy.   
      IF(IN(1)+1.EQ.IN(2).AND.Z*P(IN(1)+2,3)*P(IN(2)+2,3)*  
     &P(IN(1),5)**2.GE.PR(JT)) THEN 
        P(IN(JT)+2,4)=Z*P(IN(JT)+2,3)   
        P(IN(JR)+2,4)=PR(JT)/(P(IN(JT)+2,4)*P(IN(1),5)**2)  
        DO 700 J=1,4    
  700   P(I,J)=(PX(JT)+PX(3))*P(IN(3),J)+(PY(JT)+PY(3))*P(IN(3)+1,J)    
        GOTO 770    
      ELSEIF(IN(1)+1.EQ.IN(2)) THEN 
        P(IN(JR)+2,4)=P(IN(JR)+2,3) 
        P(IN(JR)+2,JT)=1.   
        IN(JR)=IN(JR)+4*JS  
        IF(JS*IN(JR).GT.JS*IN(4*JR)) GOTO 550   
        IF(FOUR(IN(1),IN(2)).LE.1E-2) THEN  
          P(IN(JT)+2,4)=P(IN(JT)+2,3)   
          P(IN(JT)+2,JT)=0. 
          IN(JT)=IN(JT)+4*JS    
        ENDIF   
      ENDIF 
    
C...Find new transverse directions (i.e. spacelike string vectors). 
  710 IF(JS*IN(1).GT.JS*IN(3*JR+1).OR.JS*IN(2).GT.JS*IN(3*JR+2).OR. 
     &IN(1).GT.IN(2)) GOTO 550  
      IF(IN(1).NE.IN(3*JT+1).OR.IN(2).NE.IN(3*JT+2)) THEN   
        DO 720 J=1,4    
        DP(1,J)=dble(P(IN(1),J))
        DP(2,J)=dble(P(IN(2),J))
        DP(3,J)=0.d0
  720   DP(4,J)=0.d0
        DP(1,4)=DSQRT(DP(1,1)**2+DP(1,2)**2+DP(1,3)**2)  
        DP(2,4)=DSQRT(DP(2,1)**2+DP(2,2)**2+DP(2,3)**2)  
        DHC12=DFOUR(1,2)    
clin-5/2012:
c        IF(DHC12.LE.1E-2) THEN  
        IF(DHC12.LE.1D-2) THEN  
          P(IN(JT)+2,4)=P(IN(JT)+2,3)   
          P(IN(JT)+2,JT)=0. 
          IN(JT)=IN(JT)+4*JS    
          GOTO 710  
        ENDIF   
        IN(3)=N+NR+4*NS+5   
        DP(5,1)=DP(1,1)/DP(1,4)-DP(2,1)/DP(2,4) 
        DP(5,2)=DP(1,2)/DP(1,4)-DP(2,2)/DP(2,4) 
        DP(5,3)=DP(1,3)/DP(1,4)-DP(2,3)/DP(2,4) 
        IF(DP(5,1)**2.LE.DP(5,2)**2+DP(5,3)**2) DP(3,1)=1.d0
        IF(DP(5,1)**2.GT.DP(5,2)**2+DP(5,3)**2) DP(3,3)=1.d0
        IF(DP(5,2)**2.LE.DP(5,1)**2+DP(5,3)**2) DP(4,2)=1.d0
        IF(DP(5,2)**2.GT.DP(5,1)**2+DP(5,3)**2) DP(4,3)=1.d0
        DHCX1=DFOUR(3,1)/DHC12  
        DHCX2=DFOUR(3,2)/DHC12  
        DHCXX=1D0/SQRT(1D0+2D0*DHCX1*DHCX2*DHC12)   
        DHCY1=DFOUR(4,1)/DHC12  
        DHCY2=DFOUR(4,2)/DHC12  
        DHCYX=DHCXX*(DHCX1*DHCY2+DHCX2*DHCY1)*DHC12 
        DHCYY=1D0/SQRT(1D0+2D0*DHCY1*DHCY2*DHC12-DHCYX**2)  
        DO 730 J=1,4    
        DP(3,J)=DHCXX*(DP(3,J)-DHCX2*DP(1,J)-DHCX1*DP(2,J)) 
        P(IN(3),J)=sngl(DP(3,J))
  730   P(IN(3)+1,J)=sngl(DHCYY*(DP(4,J)-DHCY2*DP(1,J)-DHCY1*DP(2,J)-    
     &  DHCYX*DP(3,J))) 
C...Express pT with respect to new axes, if sensible.   
        PXP=-(PX(3)*FOUR(IN(3*JT+3),IN(3))+PY(3)*   
     &  FOUR(IN(3*JT+3)+1,IN(3)))   
        PYP=-(PX(3)*FOUR(IN(3*JT+3),IN(3)+1)+PY(3)* 
     &  FOUR(IN(3*JT+3)+1,IN(3)+1)) 
        IF(ABS(PXP**2+PYP**2-PX(3)**2-PY(3)**2).LT.0.01) THEN   
          PX(3)=PXP 
          PY(3)=PYP 
        ENDIF   
      ENDIF 
    
C...Sum up known four-momentum. Gives coefficients for m2 expression.   
      DO 750 J=1,4  
      DHG(J)=0.d0
      P(I,J)=PX(JT)*P(IN(3*JT+3),J)+PY(JT)*P(IN(3*JT+3)+1,J)+   
     &PX(3)*P(IN(3),J)+PY(3)*P(IN(3)+1,J)   
      DO 740 IN1=IN(3*JT+1),IN(1)-4*JS,4*JS 
  740 P(I,J)=P(I,J)+P(IN1+2,3)*P(IN1,J) 
      DO 750 IN2=IN(3*JT+2),IN(2)-4*JS,4*JS 
  750 P(I,J)=P(I,J)+P(IN2+2,3)*P(IN2,J) 
      DHM(1)=dble(FOUR(I,I))
      DHM(2)=dble(2.*FOUR(I,IN(1)))  
      DHM(3)=dble(2.*FOUR(I,IN(2)))
      DHM(4)=dble(2.*FOUR(IN(1),IN(2)))
    
C...Find coefficients for Gamma expression. 
      DO 760 IN2=IN(1)+1,IN(2),4    
      DO 760 IN1=IN(1),IN2-1,4  
      DHC=dble(2.*FOUR(IN1,IN2))
      DHG(1)=DHG(1)+dble(P(IN1+2,JT)*P(IN2+2,JT))*DHC 
      IF(IN1.EQ.IN(1)) DHG(2)=DHG(2)-dble(float(JS)*P(IN2+2,JT))*DHC 
      IF(IN2.EQ.IN(2)) DHG(3)=DHG(3)+dble(float(JS)*P(IN1+2,JT))*DHC 
  760 IF(IN1.EQ.IN(1).AND.IN2.EQ.IN(2)) DHG(4)=DHG(4)-DHC   
    
C...Solve (m2, Gamma) equation system for energies taken.   
      DHS1=DHM(JR+1)*DHG(4)-DHM(4)*DHG(JR+1)    
clin-5/2012:
c      IF(ABS(DHS1).LT.1E-4) GOTO 550    
      IF(DABS(DHS1).LT.1D-4) GOTO 550    
      DHS2=DHM(4)*(dble(GAM(3))-DHG(1))-DHM(JT+1)*DHG(JR+1)-DHG(4)*   
     &(dble(P(I,5))**2-DHM(1))+DHG(JT+1)*DHM(JR+1)    
      DHS3=DHM(JT+1)*(dble(GAM(3))-DHG(1))-DHG(JT+1)
     &     *(dble(P(I,5))**2-DHM(1))   
      P(IN(JR)+2,4)=0.5*sngl((SQRT(MAX(0D0,DHS2**2-4.d0*DHS1*DHS3)))
     &/ABS(DHS1)-DHS2/DHS1)
      IF(DHM(JT+1)+DHM(4)*dble(P(IN(JR)+2,4)).LE.0.d0) GOTO 550 
      P(IN(JT)+2,4)=(P(I,5)**2-sngl(DHM(1))-sngl(DHM(JR+1))
     &     *P(IN(JR)+2,4))/(sngl(DHM(JT+1))+sngl(DHM(4))*P(IN(JR)+2,4))
    
C...Step to new region if necessary.    
      IF(P(IN(JR)+2,4).GT.P(IN(JR)+2,3)) THEN   
        P(IN(JR)+2,4)=P(IN(JR)+2,3) 
        P(IN(JR)+2,JT)=1.   
        IN(JR)=IN(JR)+4*JS  
        IF(JS*IN(JR).GT.JS*IN(4*JR)) GOTO 550   
        IF(FOUR(IN(1),IN(2)).LE.1E-2) THEN  
          P(IN(JT)+2,4)=P(IN(JT)+2,3)   
          P(IN(JT)+2,JT)=0. 
          IN(JT)=IN(JT)+4*JS    
        ENDIF   
        GOTO 710    
      ELSEIF(P(IN(JT)+2,4).GT.P(IN(JT)+2,3)) THEN   
        P(IN(JT)+2,4)=P(IN(JT)+2,3) 
        P(IN(JT)+2,JT)=0.   
        IN(JT)=IN(JT)+4*JS  
        GOTO 710    
      ENDIF 
    
C...Four-momentum of particle. Remaining quantities. Loop back. 
  770 DO 780 J=1,4  
      P(I,J)=P(I,J)+P(IN(1)+2,4)*P(IN(1),J)+P(IN(2)+2,4)*P(IN(2),J) 
  780 P(N+NRS,J)=P(N+NRS,J)-P(I,J)  
      IF(P(I,4).LE.0.) GOTO 550 
      KFL(JT)=-KFL(3)   
      PMQ(JT)=PMQ(3)    
      PX(JT)=-PX(3) 
      PY(JT)=-PY(3) 
      GAM(JT)=GAM(3)    
      IF(IN(3).NE.IN(3*JT+3)) THEN  
        DO 790 J=1,4    
        P(IN(3*JT+3),J)=P(IN(3),J)  
  790   P(IN(3*JT+3)+1,J)=P(IN(3)+1,J)  
      ENDIF 
      DO 800 JQ=1,2 
      IN(3*JT+JQ)=IN(JQ)    
      P(IN(JQ)+2,3)=P(IN(JQ)+2,3)-P(IN(JQ)+2,4) 
  800 P(IN(JQ)+2,JT)=P(IN(JQ)+2,JT)-JS*(3-2*JQ)*P(IN(JQ)+2,4)   
      GOTO 670  
    
C...Final hadron: side, flavour, hadron, mass.  
  810 I=I+1 
      K(I,1)=1  
      K(I,3)=IE(JR) 
      K(I,4)=0  
      K(I,5)=0  
      CALL LUKFDI(KFL(JR),-KFL(3),KFLDMP,K(I,2))    
      IF(K(I,2).EQ.0) GOTO 550  
      P(I,5)=ULMASS(K(I,2)) 
      PR(JR)=P(I,5)**2+(PX(JR)-PX(3))**2+(PY(JR)-PY(3))**2  

C...Final two hadrons: find common setup of four-vectors.   
      JQ=1  
      IF(P(IN(4)+2,3)*P(IN(5)+2,3)*FOUR(IN(4),IN(5)).LT.P(IN(7),3)* 
     &P(IN(8),3)*FOUR(IN(7),IN(8))) JQ=2    
      DHC12=dble(FOUR(IN(3*JQ+1),IN(3*JQ+2)))
      DHR1=dble(FOUR(N+NRS,IN(3*JQ+2)))/DHC12
      DHR2=dble(FOUR(N+NRS,IN(3*JQ+1)))/DHC12
      IF(IN(4).NE.IN(7).OR.IN(5).NE.IN(8)) THEN 
        PX(3-JQ)=-FOUR(N+NRS,IN(3*JQ+3))-PX(JQ) 
        PY(3-JQ)=-FOUR(N+NRS,IN(3*JQ+3)+1)-PY(JQ)   
        PR(3-JQ)=P(I+(JT+JQ-3)**2-1,5)**2+(PX(3-JQ)+(2*JQ-3)*JS*    
     &  PX(3))**2+(PY(3-JQ)+(2*JQ-3)*JS*PY(3))**2   
      ENDIF 
    
C...Solve kinematics for final two hadrons, if possible.    
      WREM2=WREM2+(PX(1)+PX(2))**2+(PY(1)+PY(2))**2 
      FD=(SQRT(PR(1))+SQRT(PR(2)))/SQRT(WREM2)  
      IF(MJU(1)+MJU(2).NE.0.AND.I.EQ.ISAV+2.AND.FD.GE.1.) GOTO 180  
      IF(FD.GE.1.) GOTO 550 
      FA=WREM2+PR(JT)-PR(JR)    
      IF(MSTJ(11).EQ.2) PREV=0.5*FD**PARJ(37+MSTJ(11))  
      IF(MSTJ(11).NE.2) PREV=0.5*EXP(MAX(-100.,LOG(FD)* 
     &PARJ(37+MSTJ(11))*(PR(1)+PR(2))**2))  
      FB=SIGN(SQRT(MAX(0.,FA**2-4.*WREM2*PR(JT))),JS*(RLU(0)-PREV)) 
      KFL1A=IABS(KFL(1))    
      KFL2A=IABS(KFL(2))    
      IF(MAX(MOD(KFL1A,10),MOD(KFL1A/1000,10),MOD(KFL2A,10),    
     &MOD(KFL2A/1000,10)).GE.6) FB=SIGN(SQRT(MAX(0.,FA**2-  
     &4.*WREM2*PR(JT))),FLOAT(JS))  
      DO 820 J=1,4  
      P(I-1,J)=(PX(JT)+PX(3))*P(IN(3*JQ+3),J)+(PY(JT)+PY(3))*   
     &P(IN(3*JQ+3)+1,J)+0.5*(sngl(DHR1)*(FA+FB)*P(IN(3*JQ+1),J)+  
     &sngl(DHR2)*(FA-FB)*P(IN(3*JQ+2),J))/WREM2   
  820 P(I,J)=P(N+NRS,J)-P(I-1,J)    

C...Mark jets as fragmented and give daughter pointers. 
      N=I-NRS+1 
      DO 830 I=NSAV+1,NSAV+NP   
      IM=K(I,3) 
      K(IM,1)=K(IM,1)+10    
      IF(MSTU(16).NE.2) THEN    
        K(IM,4)=NSAV+1  
        K(IM,5)=NSAV+1  
      ELSE  
        K(IM,4)=NSAV+2  
        K(IM,5)=N   
      ENDIF 
  830 CONTINUE  
    
C...Document string system. Move up particles.  
      NSAV=NSAV+1   
      K(NSAV,1)=11  
      K(NSAV,2)=92  
      K(NSAV,3)=IP  
      K(NSAV,4)=NSAV+1  
      K(NSAV,5)=N   
      DO 840 J=1,4  
      P(NSAV,J)=sngl(DPS(J))
  840 V(NSAV,J)=V(IP,J) 
      P(NSAV,5)=SQRT(sngl(MAX(0D0,DPS(4)**2-DPS(1)**2-DPS(2)**2
     &     -DPS(3)**2)))
      V(NSAV,5)=0.
      DO 850 I=NSAV+1,N 

      DO 850 J=1,5  
      K(I,J)=K(I+NRS-1,J)   
      P(I,J)=P(I+NRS-1,J)   
  850 V(I,J)=0. 
    
C...Order particles in rank along the chain. Update mother pointer. 
      DO 860 I=NSAV+1,N 
      DO 860 J=1,5  
      K(I-NSAV+N,J)=K(I,J)  
  860 P(I-NSAV+N,J)=P(I,J)  
      I1=NSAV   
      DO 880 I=N+1,2*N-NSAV 
      IF(K(I,3).NE.IE(1)) GOTO 880  
      I1=I1+1   
      DO 870 J=1,5  
      K(I1,J)=K(I,J)    
  870 P(I1,J)=P(I,J)    
      IF(MSTU(16).NE.2) K(I1,3)=NSAV    
  880 CONTINUE  
      DO 900 I=2*N-NSAV,N+1,-1  
      IF(K(I,3).EQ.IE(1)) GOTO 900  
      I1=I1+1   
      DO 890 J=1,5  
      K(I1,J)=K(I,J)    
  890 P(I1,J)=P(I,J)    
      IF(MSTU(16).NE.2) K(I1,3)=NSAV    
  900 CONTINUE  
    
C...Boost back particle system. Set production vertices.    
      CALL LUDBRB(NSAV+1,N,0.,0.,DPS(1)/DPS(4),DPS(2)/DPS(4),   
     &DPS(3)/DPS(4))    
      DO 910 I=NSAV+1,N 

      DO 910 J=1,4  
  910 V(I,J)=V(IP,J)    
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUINDF(IP) 
    
C...Purpose: to handle the fragmentation of a jet system (or a single   
C...jet) according to independent fragmentation models. 
      IMPLICIT DOUBLE PRECISION(D)  
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      DIMENSION DPS(5),PSI(4),NFI(3),NFL(3),IFET(3),KFLF(3),    
     &KFLO(2),PXO(2),PYO(2),WO(2)   

C...Reset counters. Identify parton system and take copy. Check flavour.    
      NSAV=N    
      NJET=0    
      KQSUM=0   
      DO 100 J=1,5  
  100 DPS(J)=0.d0
      I=IP-1    
  110 I=I+1 
      IF(I.GT.MIN(N,MSTU(4)-MSTU(32))) THEN 
        CALL LUERRM(12,'(LUINDF:) failed to reconstruct jet system')    
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      IF(K(I,1).NE.1.AND.K(I,1).NE.2) GOTO 110  
      KC=LUCOMP(K(I,2)) 
      IF(KC.EQ.0) GOTO 110  
      KQ=KCHG(KC,2)*ISIGN(1,K(I,2)) 
      IF(KQ.EQ.0) GOTO 110  
      NJET=NJET+1   
      IF(KQ.NE.2) KQSUM=KQSUM+KQ    
      DO 120 J=1,5  
      K(NSAV+NJET,J)=K(I,J) 
      P(NSAV+NJET,J)=P(I,J) 
  120 DPS(J)=DPS(J)+dble(P(I,J))
      K(NSAV+NJET,3)=I  
      IF(K(I,1).EQ.2.OR.(MSTJ(3).LE.5.AND.N.GT.I.AND.   
     &K(I+1,1).EQ.2)) GOTO 110  
      IF(NJET.NE.1.AND.KQSUM.NE.0) THEN 
        CALL LUERRM(12,'(LUINDF:) unphysical flavour combination')  
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
    
C...Boost copied system to CM frame. Find CM energy and sum flavours.   
      IF(NJET.NE.1) CALL LUDBRB(NSAV+1,NSAV+NJET,0.,0.,-DPS(1)/DPS(4),  
     &-DPS(2)/DPS(4),-DPS(3)/DPS(4))    
      PECM=0.   
      DO 130 J=1,3  
  130 NFI(J)=0  
      DO 140 I=NSAV+1,NSAV+NJET 
      PECM=PECM+P(I,4)  
      KFA=IABS(K(I,2))  
      IF(KFA.LE.3) THEN 
        NFI(KFA)=NFI(KFA)+ISIGN(1,K(I,2))   
      ELSEIF(KFA.GT.1000) THEN  
        KFLA=MOD(KFA/1000,10)   
        KFLB=MOD(KFA/100,10)    
        IF(KFLA.LE.3) NFI(KFLA)=NFI(KFLA)+ISIGN(1,K(I,2))   
        IF(KFLB.LE.3) NFI(KFLB)=NFI(KFLB)+ISIGN(1,K(I,2))   
      ENDIF 
  140 CONTINUE  
    
C...Loop over attempts made. Reset counters.    
      NTRY=0    
  150 NTRY=NTRY+1   
      N=NSAV+NJET   
      IF(NTRY.GT.200) THEN  
        CALL LUERRM(14,'(LUINDF:) caught in infinite loop') 
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      DO 160 J=1,3  
      NFL(J)=NFI(J) 
      IFET(J)=0 
  160 KFLF(J)=0 
    
C...Loop over jets to be fragmented.    
      DO 230 IP1=NSAV+1,NSAV+NJET   
      MSTJ(91)=0    
      NSAV1=N   
    
C...Initial flavour and momentum values. Jet along +z axis. 
      KFLH=IABS(K(IP1,2))   
      IF(KFLH.GT.10) KFLH=MOD(KFLH/1000,10) 
      KFLO(2)=0 
      WF=P(IP1,4)+SQRT(P(IP1,1)**2+P(IP1,2)**2+P(IP1,3)**2) 
    
C...Initial values for quark or diquark jet.    
  170 IF(IABS(K(IP1,2)).NE.21) THEN 
        NSTR=1  
        KFLO(1)=K(IP1,2)    
        CALL LUPTDI(0,PXO(1),PYO(1))    
        WO(1)=WF    
    
C...Initial values for gluon treated like random quark jet. 
      ELSEIF(MSTJ(2).LE.2) THEN 
        NSTR=1  
        IF(MSTJ(2).EQ.2) MSTJ(91)=1 
        KFLO(1)=INT(1.+(2.+PARJ(2))*RLU(0))*(-1)**INT(RLU(0)+0.5)   
        CALL LUPTDI(0,PXO(1),PYO(1))    
        WO(1)=WF    
    
C...Initial values for gluon treated like quark-antiquark jet pair, 
C...sharing energy according to Altarelli-Parisi splitting function.    
      ELSE  
        NSTR=2  
        IF(MSTJ(2).EQ.4) MSTJ(91)=1 
        KFLO(1)=INT(1.+(2.+PARJ(2))*RLU(0))*(-1)**INT(RLU(0)+0.5)   
        KFLO(2)=-KFLO(1)    
        CALL LUPTDI(0,PXO(1),PYO(1))    
        PXO(2)=-PXO(1)  
        PYO(2)=-PYO(1)  
        WO(1)=WF*RLU(0)**(1./3.)    
        WO(2)=WF-WO(1)  
      ENDIF 
    
C...Initial values for rank, flavour, pT and W+.    
      DO 220 ISTR=1,NSTR    
  180 I=N   
      IRANK=0   
      KFL1=KFLO(ISTR)   
      PX1=PXO(ISTR) 
      PY1=PYO(ISTR) 
      W=WO(ISTR)    
    
C...New hadron. Generate flavour and hadron species.    
  190 I=I+1 
      IF(I.GE.MSTU(4)-MSTU(32)-NJET-5) THEN 
        CALL LUERRM(11,'(LUINDF:) no more memory left in LUJETS')   
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      IRANK=IRANK+1 
      K(I,1)=1  
      K(I,3)=IP1    
      K(I,4)=0  
      K(I,5)=0  
  200 CALL LUKFDI(KFL1,0,KFL2,K(I,2))   
      IF(K(I,2).EQ.0) GOTO 180  
      IF(MSTJ(12).GE.3.AND.IRANK.EQ.1.AND.IABS(KFL1).LE.10.AND. 
     &IABS(KFL2).GT.10) THEN    
        IF(RLU(0).GT.PARJ(19)) GOTO 200 
      ENDIF 
    
C...Find hadron mass. Generate four-momentum.   
      P(I,5)=ULMASS(K(I,2)) 
      CALL LUPTDI(KFL1,PX2,PY2) 
      P(I,1)=PX1+PX2    
      P(I,2)=PY1+PY2    
      PR=P(I,5)**2+P(I,1)**2+P(I,2)**2  
      CALL LUZDIS(KFL1,KFL2,PR,Z)   
      P(I,3)=0.5*(Z*W-PR/(Z*W)) 
      P(I,4)=0.5*(Z*W+PR/(Z*W)) 
      IF(MSTJ(3).GE.1.AND.IRANK.EQ.1.AND.KFLH.GE.4.AND. 
     &P(I,3).LE.0.001) THEN 
        IF(W.GE.P(I,5)+0.5*PARJ(32)) GOTO 180   
        P(I,3)=0.0001   
        P(I,4)=SQRT(PR) 
        Z=P(I,4)/W  
      ENDIF 
    
C...Remaining flavour and momentum. 
      KFL1=-KFL2    
      PX1=-PX2  
      PY1=-PY2  
      W=(1.-Z)*W    
      DO 210 J=1,5  
  210 V(I,J)=0. 
    
C...Check if pL acceptable. Go back for new hadron if enough energy.    
      IF(MSTJ(3).GE.0.AND.P(I,3).LT.0.) I=I-1   
      IF(W.GT.PARJ(31)) GOTO 190    
  220 N=I   
      IF(MOD(MSTJ(3),5).EQ.4.AND.N.EQ.NSAV1) WF=WF+0.1*PARJ(32) 
      IF(MOD(MSTJ(3),5).EQ.4.AND.N.EQ.NSAV1) GOTO 170   
    
C...Rotate jet to new direction.    
      THE=ULANGL(P(IP1,3),SQRT(P(IP1,1)**2+P(IP1,2)**2))    
      PHI=ULANGL(P(IP1,1),P(IP1,2)) 
      CALL LUDBRB(NSAV1+1,N,THE,PHI,0D0,0D0,0D0)    
      K(K(IP1,3),4)=NSAV1+1 
      K(K(IP1,3),5)=N   
    
C...End of jet generation loop. Skip conservation in some cases.    
  230 CONTINUE  
      IF(NJET.EQ.1.OR.MSTJ(3).LE.0) GOTO 470    
      IF(MOD(MSTJ(3),5).NE.0.AND.N-NSAV-NJET.LT.2) GOTO 150 
    
C...Subtract off produced hadron flavours, finished if zero.    
      DO 240 I=NSAV+NJET+1,N    
      KFA=IABS(K(I,2))  
      KFLA=MOD(KFA/1000,10) 
      KFLB=MOD(KFA/100,10)  
      KFLC=MOD(KFA/10,10)   
      IF(KFLA.EQ.0) THEN    
        IF(KFLB.LE.3) NFL(KFLB)=NFL(KFLB)-ISIGN(1,K(I,2))*(-1)**KFLB    
        IF(KFLC.LE.3) NFL(KFLC)=NFL(KFLC)+ISIGN(1,K(I,2))*(-1)**KFLB    
      ELSE  
        IF(KFLA.LE.3) NFL(KFLA)=NFL(KFLA)-ISIGN(1,K(I,2))   
        IF(KFLB.LE.3) NFL(KFLB)=NFL(KFLB)-ISIGN(1,K(I,2))   
        IF(KFLC.LE.3) NFL(KFLC)=NFL(KFLC)-ISIGN(1,K(I,2))   
      ENDIF 
  240 CONTINUE  
      NREQ=(IABS(NFL(1))+IABS(NFL(2))+IABS(NFL(3))-IABS(NFL(1)+ 
     &NFL(2)+NFL(3)))/2+IABS(NFL(1)+NFL(2)+NFL(3))/3    
      IF(NREQ.EQ.0) GOTO 320    
    
C...Take away flavour of low-momentum particles until enough freedom.   
      NREM=0    
  250 IREM=0    
      P2MIN=PECM**2 
      DO 260 I=NSAV+NJET+1,N    
      P2=P(I,1)**2+P(I,2)**2+P(I,3)**2  
      IF(K(I,1).EQ.1.AND.P2.LT.P2MIN) IREM=I    
  260 IF(K(I,1).EQ.1.AND.P2.LT.P2MIN) P2MIN=P2  
      IF(IREM.EQ.0) GOTO 150    
      K(IREM,1)=7   
      KFA=IABS(K(IREM,2))   
      KFLA=MOD(KFA/1000,10) 
      KFLB=MOD(KFA/100,10)  
      KFLC=MOD(KFA/10,10)   
      IF(KFLA.GE.4.OR.KFLB.GE.4) K(IREM,1)=8    
      IF(K(IREM,1).EQ.8) GOTO 250   
      IF(KFLA.EQ.0) THEN    
        ISGN=ISIGN(1,K(IREM,2))*(-1)**KFLB  
        IF(KFLB.LE.3) NFL(KFLB)=NFL(KFLB)+ISGN  
        IF(KFLC.LE.3) NFL(KFLC)=NFL(KFLC)-ISGN  
      ELSE  
        IF(KFLA.LE.3) NFL(KFLA)=NFL(KFLA)+ISIGN(1,K(IREM,2))    
        IF(KFLB.LE.3) NFL(KFLB)=NFL(KFLB)+ISIGN(1,K(IREM,2))    
        IF(KFLC.LE.3) NFL(KFLC)=NFL(KFLC)+ISIGN(1,K(IREM,2))    
      ENDIF 
      NREM=NREM+1   
      NREQ=(IABS(NFL(1))+IABS(NFL(2))+IABS(NFL(3))-IABS(NFL(1)+ 
     &NFL(2)+NFL(3)))/2+IABS(NFL(1)+NFL(2)+NFL(3))/3    
      IF(NREQ.GT.NREM) GOTO 250 
      DO 270 I=NSAV+NJET+1,N    
  270 IF(K(I,1).EQ.8) K(I,1)=1  
    
C...Find combination of existing and new flavours for hadron.   
  280 NFET=2    
      IF(NFL(1)+NFL(2)+NFL(3).NE.0) NFET=3  
      IF(NREQ.LT.NREM) NFET=1   
      IF(IABS(NFL(1))+IABS(NFL(2))+IABS(NFL(3)).EQ.0) NFET=0    
      DO 290 J=1,NFET   
      IFET(J)=1+int((IABS(NFL(1))+IABS(NFL(2))+IABS(NFL(3)))*RLU(0))
      KFLF(J)=ISIGN(1,NFL(1))   
      IF(IFET(J).GT.IABS(NFL(1))) KFLF(J)=ISIGN(2,NFL(2))   
  290 IF(IFET(J).GT.IABS(NFL(1))+IABS(NFL(2))) KFLF(J)=ISIGN(3,NFL(3))  
      IF(NFET.EQ.2.AND.(IFET(1).EQ.IFET(2).OR.KFLF(1)*KFLF(2).GT.0))    
     &GOTO 280  
      IF(NFET.EQ.3.AND.(IFET(1).EQ.IFET(2).OR.IFET(1).EQ.IFET(3).OR.    
     &IFET(2).EQ.IFET(3).OR.KFLF(1)*KFLF(2).LT.0.OR.KFLF(1)*KFLF(3).    
     &LT.0.OR.KFLF(1)*(NFL(1)+NFL(2)+NFL(3)).LT.0)) GOTO 280    
      IF(NFET.EQ.0) KFLF(1)=1+INT((2.+PARJ(2))*RLU(0))  
      IF(NFET.EQ.0) KFLF(2)=-KFLF(1)    
      IF(NFET.EQ.1) KFLF(2)=ISIGN(1+INT((2.+PARJ(2))*RLU(0)),-KFLF(1))  
      IF(NFET.LE.2) KFLF(3)=0   
      IF(KFLF(3).NE.0) THEN 
        KFLFC=ISIGN(1000*MAX(IABS(KFLF(1)),IABS(KFLF(3)))+  
     &  100*MIN(IABS(KFLF(1)),IABS(KFLF(3)))+1,KFLF(1)) 
        IF(KFLF(1).EQ.KFLF(3).OR.(1.+3.*PARJ(4))*RLU(0).GT.1.)  
     &  KFLFC=KFLFC+ISIGN(2,KFLFC)  
      ELSE  
        KFLFC=KFLF(1)   
      ENDIF 
      CALL LUKFDI(KFLFC,KFLF(2),KFLDMP,KF)  
      IF(KF.EQ.0) GOTO 280  
      DO 300 J=1,MAX(2,NFET)    
  300 NFL(IABS(KFLF(J)))=NFL(IABS(KFLF(J)))-ISIGN(1,KFLF(J))    
    
C...Store hadron at random among free positions.    
      NPOS=MIN(1+INT(RLU(0)*NREM),NREM) 
      DO 310 I=NSAV+NJET+1,N    
      IF(K(I,1).EQ.7) NPOS=NPOS-1   
      IF(K(I,1).EQ.1.OR.NPOS.NE.0) GOTO 310 
      K(I,1)=1  
      K(I,2)=KF 
      P(I,5)=ULMASS(K(I,2)) 
      P(I,4)=SQRT(P(I,1)**2+P(I,2)**2+P(I,3)**2+P(I,5)**2)  
  310 CONTINUE  
      NREM=NREM-1   
      NREQ=(IABS(NFL(1))+IABS(NFL(2))+IABS(NFL(3))-IABS(NFL(1)+ 
     &NFL(2)+NFL(3)))/2+IABS(NFL(1)+NFL(2)+NFL(3))/3    
      IF(NREM.GT.0) GOTO 280    
    
C...Compensate for missing momentum in global scheme (3 options).   
  320 IF(MOD(MSTJ(3),5).NE.0.AND.MOD(MSTJ(3),5).NE.4) THEN  
        DO 330 J=1,3    
        PSI(J)=0.   
        DO 330 I=NSAV+NJET+1,N  
  330   PSI(J)=PSI(J)+P(I,J)    
        PSI(4)=PSI(1)**2+PSI(2)**2+PSI(3)**2    
        PWS=0.  
        DO 340 I=NSAV+NJET+1,N  
        IF(MOD(MSTJ(3),5).EQ.1) PWS=PWS+P(I,4)  
        IF(MOD(MSTJ(3),5).EQ.2) PWS=PWS+SQRT(P(I,5)**2+(PSI(1)*P(I,1)+  
     &  PSI(2)*P(I,2)+PSI(3)*P(I,3))**2/PSI(4)) 
  340   IF(MOD(MSTJ(3),5).EQ.3) PWS=PWS+1.  
        DO 360 I=NSAV+NJET+1,N  
        IF(MOD(MSTJ(3),5).EQ.1) PW=P(I,4)   
        IF(MOD(MSTJ(3),5).EQ.2) PW=SQRT(P(I,5)**2+(PSI(1)*P(I,1)+   
     &  PSI(2)*P(I,2)+PSI(3)*P(I,3))**2/PSI(4)) 
        IF(MOD(MSTJ(3),5).EQ.3) PW=1.   
        DO 350 J=1,3    
  350   P(I,J)=P(I,J)-PSI(J)*PW/PWS 
  360   P(I,4)=SQRT(P(I,1)**2+P(I,2)**2+P(I,3)**2+P(I,5)**2)    
    
C...Compensate for missing momentum withing each jet separately.    
      ELSEIF(MOD(MSTJ(3),5).EQ.4) THEN  
        DO 370 I=N+1,N+NJET 
        K(I,1)=0    
        DO 370 J=1,5    
  370   P(I,J)=0.   
        DO 390 I=NSAV+NJET+1,N  
        IR1=K(I,3)  
        IR2=N+IR1-NSAV  
        K(IR2,1)=K(IR2,1)+1 
        PLS=(P(I,1)*P(IR1,1)+P(I,2)*P(IR1,2)+P(I,3)*P(IR1,3))/  
     &  (P(IR1,1)**2+P(IR1,2)**2+P(IR1,3)**2)   
        DO 380 J=1,3    
  380   P(IR2,J)=P(IR2,J)+P(I,J)-PLS*P(IR1,J)   
        P(IR2,4)=P(IR2,4)+P(I,4)    
  390   P(IR2,5)=P(IR2,5)+PLS   
        PSS=0.  
        DO 400 I=N+1,N+NJET 
  400   IF(K(I,1).NE.0) PSS=PSS+P(I,4)/(PECM*(0.8*P(I,5)+0.2))  
        DO 420 I=NSAV+NJET+1,N  
        IR1=K(I,3)  
        IR2=N+IR1-NSAV  
        PLS=(P(I,1)*P(IR1,1)+P(I,2)*P(IR1,2)+P(I,3)*P(IR1,3))/  
     &  (P(IR1,1)**2+P(IR1,2)**2+P(IR1,3)**2)   
        DO 410 J=1,3    
  410   P(I,J)=P(I,J)-P(IR2,J)/K(IR2,1)+(1./(P(IR2,5)*PSS)-1.)*PLS* 
     &  P(IR1,J)    
  420   P(I,4)=SQRT(P(I,1)**2+P(I,2)**2+P(I,3)**2+P(I,5)**2)    
      ENDIF 
    
C...Scale momenta for energy conservation.  
      IF(MOD(MSTJ(3),5).NE.0) THEN  
        PMS=0.  
        PES=0.  
        PQS=0.  
        DO 430 I=NSAV+NJET+1,N  
        PMS=PMS+P(I,5)  
        PES=PES+P(I,4)  
  430   PQS=PQS+P(I,5)**2/P(I,4)    
        IF(PMS.GE.PECM) GOTO 150    
        NECO=0  
  440   NECO=NECO+1 
        PFAC=(PECM-PQS)/(PES-PQS)   
        PES=0.  
        PQS=0.  
        DO 460 I=NSAV+NJET+1,N  
        DO 450 J=1,3    
  450   P(I,J)=PFAC*P(I,J)  
        P(I,4)=SQRT(P(I,1)**2+P(I,2)**2+P(I,3)**2+P(I,5)**2)    
        PES=PES+P(I,4)  
  460   PQS=PQS+P(I,5)**2/P(I,4)    
        IF(NECO.LT.10.AND.ABS(PECM-PES).GT.2E-6*PECM) GOTO 440  
      ENDIF 
    
C...Origin of produced particles and parton daughter pointers.  
  470 DO 480 I=NSAV+NJET+1,N    
      IF(MSTU(16).NE.2) K(I,3)=NSAV+1   
  480 IF(MSTU(16).EQ.2) K(I,3)=K(K(I,3),3)  
      DO 490 I=NSAV+1,NSAV+NJET 
      I1=K(I,3) 
      K(I1,1)=K(I1,1)+10    
      IF(MSTU(16).NE.2) THEN    
        K(I1,4)=NSAV+1  
        K(I1,5)=NSAV+1  
      ELSE  
        K(I1,4)=K(I1,4)-NJET+1  
        K(I1,5)=K(I1,5)-NJET+1  
        IF(K(I1,5).LT.K(I1,4)) THEN 
          K(I1,4)=0 
          K(I1,5)=0 
        ENDIF   
      ENDIF 
  490 CONTINUE  
    
C...Document independent fragmentation system. Remove copy of jets. 
      NSAV=NSAV+1   
      K(NSAV,1)=11  
      K(NSAV,2)=93  
      K(NSAV,3)=IP  
      K(NSAV,4)=NSAV+1  
      K(NSAV,5)=N-NJET+1    
      DO 500 J=1,4  
      P(NSAV,J)=sngl(DPS(J))
  500 V(NSAV,J)=V(IP,J) 
      P(NSAV,5)=SQRT(sngl(MAX(0D0,DPS(4)**2-DPS(1)**2-DPS(2)**2
     &     -DPS(3)**2)))
      V(NSAV,5)=0.  
      DO 510 I=NSAV+NJET,N  
      DO 510 J=1,5  
      K(I-NJET+1,J)=K(I,J)  
      P(I-NJET+1,J)=P(I,J)  
  510 V(I-NJET+1,J)=V(I,J)  
      N=N-NJET+1    
    
C...Boost back particle system. Set production vertices.    
      IF(NJET.NE.1) CALL LUDBRB(NSAV+1,N,0.,0.,DPS(1)/DPS(4),   
     &DPS(2)/DPS(4),DPS(3)/DPS(4))  
      DO 520 I=NSAV+1,N 
      DO 520 J=1,4  
  520 V(I,J)=V(IP,J)    
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUDECY(IP) 
    
C...Purpose: to handle the decay of unstable particles. 
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      DIMENSION VDCY(4),KFLO(4),KFL1(4),PV(10,5),RORD(10),UE(3),BE(3),  
     &WTCOR(10) 
clin-2/18/03 for resonance decay in hadron cascade:
      common/resdcy/NSAV,iksdcy
      SAVE /resdcy/
      DATA WTCOR/2.,5.,15.,60.,250.,1500.,1.2E4,1.2E5,150.,16./ 
    
C...Functions: momentum in two-particle decays, four-product and    
C...matrix element times phase space in weak decays.    
      PAWT(A,B,C)=SQRT((A**2-(B+C)**2)*(A**2-(B-C)**2))/(2.*A)  
      FOUR(I,J)=P(I,4)*P(J,4)-P(I,1)*P(J,1)-P(I,2)*P(J,2)-P(I,3)*P(J,3) 
      HMEPS(HA)=((1.-HRQ-HA)**2+3.*HA*(1.+HRQ-HA))* 
     &SQRT((1.-HRQ-HA)**2-4.*HRQ*HA)    
    
C...Initial values. 
      NTRY=0    
      NSAV=N    
      KFA=IABS(K(IP,2)) 
      KFS=ISIGN(1,K(IP,2))  
      KC=LUCOMP(KFA)    
      MSTJ(92)=0    
    
C...Choose lifetime and determine decay vertex. 
      IF(K(IP,1).EQ.5) THEN 
        V(IP,5)=0.  
      ELSEIF(K(IP,1).NE.4) THEN 
        V(IP,5)=-PMAS(KC,4)*LOG(RLU(0)) 
      ENDIF 
      DO 100 J=1,4  
  100 VDCY(J)=V(IP,J)+V(IP,5)*P(IP,J)/P(IP,5)   
    
C...Determine whether decay allowed or not. 
      MOUT=0    
      IF(MSTJ(22).EQ.2) THEN    
        IF(PMAS(KC,4).GT.PARJ(71)) MOUT=1   
      ELSEIF(MSTJ(22).EQ.3) THEN    
        IF(VDCY(1)**2+VDCY(2)**2+VDCY(3)**2.GT.PARJ(72)**2) MOUT=1  
      ELSEIF(MSTJ(22).EQ.4) THEN    
        IF(VDCY(1)**2+VDCY(2)**2.GT.PARJ(73)**2) MOUT=1 
        IF(ABS(VDCY(3)).GT.PARJ(74)) MOUT=1 
      ENDIF 
      IF(MOUT.EQ.1.AND.K(IP,1).NE.5) THEN   
        K(IP,1)=4   
        RETURN  
      ENDIF 
    
C...Check existence of decay channels. Particle/antiparticle rules. 
      KCA=KC    
      IF(MDCY(KC,2).GT.0) THEN  
        MDMDCY=MDME(MDCY(KC,2),2)   
        IF(MDMDCY.GT.80.AND.MDMDCY.LE.90) KCA=MDMDCY    
      ENDIF 
      IF(MDCY(KCA,2).LE.0.OR.MDCY(KCA,3).LE.0) THEN 
        CALL LUERRM(9,'(LUDECY:) no decay channel defined') 
        RETURN  
      ENDIF 
      IF(MOD(KFA/1000,10).EQ.0.AND.(KCA.EQ.85.OR.KCA.EQ.87)) KFS=-KFS   
      IF(KCHG(KC,3).EQ.0) THEN  
        KFSP=1  
        KFSN=0  
        IF(RLU(0).GT.0.5) KFS=-KFS  
      ELSEIF(KFS.GT.0) THEN 
        KFSP=1  
        KFSN=0  
      ELSE  
        KFSP=0  
        KFSN=1  
      ENDIF 
    
C...Sum branching ratios of allowed decay channels. 
clin  110 NOPE=0    
      NOPE=0    
      BRSU=0.   
      DO 120 IDL=MDCY(KCA,2),MDCY(KCA,2)+MDCY(KCA,3)-1  
      IF(MDME(IDL,1).NE.1.AND.KFSP*MDME(IDL,1).NE.2.AND.    
     &KFSN*MDME(IDL,1).NE.3) GOTO 120   
      IF(MDME(IDL,2).GT.100) GOTO 120   
      NOPE=NOPE+1   
      BRSU=BRSU+BRAT(IDL)   
  120 CONTINUE  
      IF(NOPE.EQ.0) THEN    
        CALL LUERRM(2,'(LUDECY:) all decay channels closed by user')    
        RETURN  
      ENDIF 
    
C...Select decay channel among allowed ones.    
  130 RBR=BRSU*RLU(0)   
      IDL=MDCY(KCA,2)-1 
  140 IDL=IDL+1 
      IF(MDME(IDL,1).NE.1.AND.KFSP*MDME(IDL,1).NE.2.AND.    
     &KFSN*MDME(IDL,1).NE.3) THEN   
        IF(IDL.LT.MDCY(KCA,2)+MDCY(KCA,3)-1) GOTO 140   
      ELSEIF(MDME(IDL,2).GT.100) THEN   
        IF(IDL.LT.MDCY(KCA,2)+MDCY(KCA,3)-1) GOTO 140   
      ELSE  
        IDC=IDL 
        RBR=RBR-BRAT(IDL)   
        IF(IDL.LT.MDCY(KCA,2)+MDCY(KCA,3)-1.AND.RBR.GT.0.) GOTO 140 
      ENDIF 
    
C...Start readout of decay channel: matrix element, reset counters. 
      MMAT=MDME(IDC,2)  
  150 NTRY=NTRY+1   
      IF(NTRY.GT.1000) THEN 
        CALL LUERRM(14,'(LUDECY:) caught in infinite loop') 
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      I=N   
      NP=0  
      NQ=0  
      MBST=0    
      IF(MMAT.GE.11.AND.MMAT.NE.46.AND.P(IP,4).GT.20.*P(IP,5)) MBST=1   
      DO 160 J=1,4  
      PV(1,J)=0.    
  160 IF(MBST.EQ.0) PV(1,J)=P(IP,J) 
      IF(MBST.EQ.1) PV(1,4)=P(IP,5) 
      PV(1,5)=P(IP,5)   
      PS=0. 
      PSQ=0.    
      MREM=0    
    
C...Read out decay products. Convert to standard flavour code.  
      JTMAX=5   
      IF(MDME(IDC+1,2).EQ.101) JTMAX=10 
      DO 170 JT=1,JTMAX 
      IF(JT.LE.5) KP=KFDP(IDC,JT)   
      IF(JT.GE.6) KP=KFDP(IDC+1,JT-5)   
      IF(KP.EQ.0) GOTO 170  
      KPA=IABS(KP)  
      KCP=LUCOMP(KPA)   
      IF(KCHG(KCP,3).EQ.0.AND.KPA.NE.81.AND.KPA.NE.82) THEN 
        KFP=KP  
      ELSEIF(KPA.NE.81.AND.KPA.NE.82) THEN  
        KFP=KFS*KP  
      ELSEIF(KPA.EQ.81.AND.MOD(KFA/1000,10).EQ.0) THEN  
        KFP=-KFS*MOD(KFA/10,10) 
      ELSEIF(KPA.EQ.81.AND.MOD(KFA/100,10).GE.MOD(KFA/10,10)) THEN  
        KFP=KFS*(100*MOD(KFA/10,100)+3) 
      ELSEIF(KPA.EQ.81) THEN    
        KFP=KFS*(1000*MOD(KFA/10,10)+100*MOD(KFA/100,10)+1) 
      ELSEIF(KP.EQ.82) THEN 
        CALL LUKFDI(-KFS*INT(1.+(2.+PARJ(2))*RLU(0)),0,KFP,KDUMP)   
        IF(KFP.EQ.0) GOTO 150   
        MSTJ(93)=1  
        IF(PV(1,5).LT.PARJ(32)+2.*ULMASS(KFP)) GOTO 150 
      ELSEIF(KP.EQ.-82) THEN    
        KFP=-KFP    
        IF(IABS(KFP).GT.10) KFP=KFP+ISIGN(10000,KFP)    
      ENDIF 
      IF(KPA.EQ.81.OR.KPA.EQ.82) KCP=LUCOMP(KFP)    
    
C...Add decay product to event record or to quark flavour list. 
      KFPA=IABS(KFP)    
      KQP=KCHG(KCP,2)   
      IF(MMAT.GE.11.AND.MMAT.LE.30.AND.KQP.NE.0) THEN   
        NQ=NQ+1 
        KFLO(NQ)=KFP    
        MSTJ(93)=2  
        PSQ=PSQ+ULMASS(KFLO(NQ))    
      ELSEIF(MMAT.GE.42.AND.MMAT.LE.43.AND.NP.EQ.3.AND.MOD(NQ,2).EQ.1)  
     &THEN  
        NQ=NQ-1 
        PS=PS-P(I,5)    
        K(I,1)=1    
        KFI=K(I,2)  
        CALL LUKFDI(KFP,KFI,KFLDMP,K(I,2))  
        IF(K(I,2).EQ.0) GOTO 150    
        MSTJ(93)=1  
        P(I,5)=ULMASS(K(I,2))   
        PS=PS+P(I,5)    
      ELSE  
        I=I+1   
        NP=NP+1 
        IF(MMAT.NE.33.AND.KQP.NE.0) NQ=NQ+1 
        IF(MMAT.EQ.33.AND.KQP.NE.0.AND.KQP.NE.2) NQ=NQ+1    
        K(I,1)=1+MOD(NQ,2)  
        IF(MMAT.EQ.4.AND.JT.LE.2.AND.KFP.EQ.21) K(I,1)=2    
        IF(MMAT.EQ.4.AND.JT.EQ.3) K(I,1)=1  
        K(I,2)=KFP  
        K(I,3)=IP   
        K(I,4)=0    
        K(I,5)=0    
        P(I,5)=ULMASS(KFP)  
        IF(MMAT.EQ.45.AND.KFPA.EQ.89) P(I,5)=PARJ(32)   
        PS=PS+P(I,5)    
      ENDIF 
  170 CONTINUE  
    
C...Choose decay multiplicity in phase space model. 
  180 IF(MMAT.GE.11.AND.MMAT.LE.30) THEN    
        PSP=PS  
        CNDE=PARJ(61)*LOG(MAX((PV(1,5)-PS-PSQ)/PARJ(62),1.1))   
        IF(MMAT.EQ.12) CNDE=CNDE+PARJ(63)   
  190   NTRY=NTRY+1 
        IF(NTRY.GT.1000) THEN   
          CALL LUERRM(14,'(LUDECY:) caught in infinite loop')   
          IF(MSTU(21).GE.1) RETURN  
        ENDIF   
        IF(MMAT.LE.20) THEN 
          GAUSS=SQRT(-2.*CNDE*LOG(MAX(1E-10,RLU(0))))*  
     &    SIN(PARU(2)*RLU(0))   
          ND=int(0.5+0.5*NP+0.25*NQ+CNDE+GAUSS)
          IF(ND.LT.NP+NQ/2.OR.ND.LT.2.OR.ND.GT.10) GOTO 190 
          IF(MMAT.EQ.13.AND.ND.EQ.2) GOTO 190   
          IF(MMAT.EQ.14.AND.ND.LE.3) GOTO 190   
          IF(MMAT.EQ.15.AND.ND.LE.4) GOTO 190   
        ELSE    
          ND=MMAT-20    
        ENDIF   
    
C...Form hadrons from flavour content.  
        DO 200 JT=1,4   
  200   KFL1(JT)=KFLO(JT)   
        IF(ND.EQ.NP+NQ/2) GOTO 220  
        DO 210 I=N+NP+1,N+ND-NQ/2   
        JT=1+INT((NQ-1)*RLU(0)) 
        CALL LUKFDI(KFL1(JT),0,KFL2,K(I,2)) 
        IF(K(I,2).EQ.0) GOTO 190    
  210   KFL1(JT)=-KFL2  
  220   JT=2    
        JT2=3   
        JT3=4   
        IF(NQ.EQ.4.AND.RLU(0).LT.PARJ(66)) JT=4 
        IF(JT.EQ.4.AND.ISIGN(1,KFL1(1)*(10-IABS(KFL1(1))))* 
     &  ISIGN(1,KFL1(JT)*(10-IABS(KFL1(JT)))).GT.0) JT=3    
        IF(JT.EQ.3) JT2=2   
        IF(JT.EQ.4) JT3=2   
        CALL LUKFDI(KFL1(1),KFL1(JT),KFLDMP,K(N+ND-NQ/2+1,2))   
        IF(K(N+ND-NQ/2+1,2).EQ.0) GOTO 190  
        IF(NQ.EQ.4) CALL LUKFDI(KFL1(JT2),KFL1(JT3),KFLDMP,K(N+ND,2))   
        IF(NQ.EQ.4.AND.K(N+ND,2).EQ.0) GOTO 190 
    
C...Check that sum of decay product masses not too large.   
        PS=PSP  
        DO 230 I=N+NP+1,N+ND    
        K(I,1)=1    
        K(I,3)=IP   
        K(I,4)=0    
        K(I,5)=0    
        P(I,5)=ULMASS(K(I,2))   
  230   PS=PS+P(I,5)    
        IF(PS+PARJ(64).GT.PV(1,5)) GOTO 190 
    
C...Rescale energy to subtract off spectator quark mass.    
      ELSEIF((MMAT.EQ.31.OR.MMAT.EQ.33.OR.MMAT.EQ.44.OR.MMAT.EQ.45).    
     &AND.NP.GE.3) THEN 
        PS=PS-P(N+NP,5) 
        PQT=(P(N+NP,5)+PARJ(65))/PV(1,5)    
        DO 240 J=1,5    
        P(N+NP,J)=PQT*PV(1,J)   
  240   PV(1,J)=(1.-PQT)*PV(1,J)    
        IF(PS+PARJ(64).GT.PV(1,5)) GOTO 150 
        ND=NP-1 
        MREM=1  
    
C...Phase space factors imposed in W decay. 
      ELSEIF(MMAT.EQ.46) THEN   
        MSTJ(93)=1  
        PSMC=ULMASS(K(N+1,2))   
        MSTJ(93)=1  
        PSMC=PSMC+ULMASS(K(N+2,2))  
        IF(MAX(PS,PSMC)+PARJ(32).GT.PV(1,5)) GOTO 130   
        HR1=(P(N+1,5)/PV(1,5))**2   
        HR2=(P(N+2,5)/PV(1,5))**2   
        IF((1.-HR1-HR2)*(2.+HR1+HR2)*SQRT((1.-HR1-HR2)**2-4.*HR1*HR2).  
     &  LT.2.*RLU(0)) GOTO 130  
        ND=NP   
    
C...Fully specified final state: check mass broadening effects. 
      ELSE  
        IF(NP.GE.2.AND.PS+PARJ(64).GT.PV(1,5)) GOTO 150 
        ND=NP   
      ENDIF 
    
C...Select W mass in decay Q -> W + q, without W propagator.    
      IF(MMAT.EQ.45.AND.MSTJ(25).LE.0) THEN 
        HLQ=(PARJ(32)/PV(1,5))**2   
        HUQ=(1.-(P(N+2,5)+PARJ(64))/PV(1,5))**2 
        HRQ=(P(N+2,5)/PV(1,5))**2   
  250   HW=HLQ+RLU(0)*(HUQ-HLQ) 
        IF(HMEPS(HW).LT.RLU(0)) GOTO 250    
        P(N+1,5)=PV(1,5)*SQRT(HW)   
    
C...Ditto, including W propagator. Divide mass range into three regions.    
      ELSEIF(MMAT.EQ.45) THEN   
        HQW=(PV(1,5)/PMAS(24,1))**2 
        HLW=(PARJ(32)/PMAS(24,1))**2    
        HUW=((PV(1,5)-P(N+2,5)-PARJ(64))/PMAS(24,1))**2 
        HRQ=(P(N+2,5)/PV(1,5))**2   
        HG=PMAS(24,2)/PMAS(24,1)    
        HATL=ATAN((HLW-1.)/HG)  
        HM=MIN(1.,HUW-0.001)    
        HMV1=HMEPS(HM/HQW)/((HM-1.)**2+HG**2)   
  260   HM=HM-HG    
        HMV2=HMEPS(HM/HQW)/((HM-1.)**2+HG**2)   
        HSAV1=HMEPS(HM/HQW) 
        HSAV2=1./((HM-1.)**2+HG**2) 
        IF(HMV2.GT.HMV1.AND.HM-HG.GT.HLW) THEN  
          HMV1=HMV2 
          GOTO 260  
        ENDIF   
        HMV=MIN(2.*HMV1,HMEPS(HM/HQW)/HG**2)    
        HM1=1.-SQRT(1./HMV-HG**2)   
        IF(HM1.GT.HLW.AND.HM1.LT.HM) THEN   
          HM=HM1    
        ELSEIF(HMV2.LE.HMV1) THEN   
          HM=MAX(HLW,HM-MIN(0.1,1.-HM)) 
        ENDIF   
        HATM=ATAN((HM-1.)/HG)   
        HWT1=(HATM-HATL)/HG 
        HWT2=HMV*(MIN(1.,HUW)-HM)   
        HWT3=0. 
        IF(HUW.GT.1.) THEN  
          HATU=ATAN((HUW-1.)/HG)    
          HMP1=HMEPS(1./HQW)    
          HWT3=HMP1*HATU/HG 
        ENDIF   
    
C...Select mass region and W mass there. Accept according to weight.    
  270   HREG=RLU(0)*(HWT1+HWT2+HWT3)    
        IF(HREG.LE.HWT1) THEN   
          HW=1.+HG*TAN(HATL+RLU(0)*(HATM-HATL)) 
          HACC=HMEPS(HW/HQW)    
        ELSEIF(HREG.LE.HWT1+HWT2) THEN  
          HW=HM+RLU(0)*(MIN(1.,HUW)-HM) 
          HACC=HMEPS(HW/HQW)/((HW-1.)**2+HG**2)/HMV 
        ELSE    
          HW=1.+HG*TAN(RLU(0)*HATU) 
          HACC=HMEPS(HW/HQW)/HMP1   
        ENDIF   
        IF(HACC.LT.RLU(0)) GOTO 270 
        P(N+1,5)=PMAS(24,1)*SQRT(HW)    
      ENDIF 
    
C...Determine position of grandmother, number of sisters, Q -> W sign.  
      NM=0  
      MSGN=0    
      IF(MMAT.EQ.3.OR.MMAT.EQ.46) THEN  
        IM=K(IP,3)  
        IF(IM.LT.0.OR.IM.GE.IP) IM=0    
        IF(IM.NE.0) KFAM=IABS(K(IM,2))  
        IF(IM.NE.0.AND.MMAT.EQ.3) THEN  
          DO 280 IL=MAX(IP-2,IM+1),MIN(IP+2,N)  
  280     IF(K(IL,3).EQ.IM) NM=NM+1 
          IF(NM.NE.2.OR.KFAM.LE.100.OR.MOD(KFAM,10).NE.1.OR.    
     &    MOD(KFAM/1000,10).NE.0) NM=0  
        ELSEIF(IM.NE.0.AND.MMAT.EQ.46) THEN 
          MSGN=ISIGN(1,K(IM,2)*K(IP,2)) 
          IF(KFAM.GT.100.AND.MOD(KFAM/1000,10).EQ.0) MSGN=  
     &    MSGN*(-1)**MOD(KFAM/100,10)   
        ENDIF   
      ENDIF 
    
C...Kinematics of one-particle decays.  
      IF(ND.EQ.1) THEN  
        DO 290 J=1,4    
  290   P(N+1,J)=P(IP,J)    
        GOTO 510    
      ENDIF 
    
C...Calculate maximum weight ND-particle decay. 
      PV(ND,5)=P(N+ND,5)    
      IF(ND.GE.3) THEN  
        WTMAX=1./WTCOR(ND-2)    
        PMAX=PV(1,5)-PS+P(N+ND,5)   
        PMIN=0. 
        DO 300 IL=ND-1,1,-1 
        PMAX=PMAX+P(N+IL,5) 
        PMIN=PMIN+P(N+IL+1,5)   
  300   WTMAX=WTMAX*PAWT(PMAX,PMIN,P(N+IL,5))   
      ENDIF 
    
C...Find virtual gamma mass in Dalitz decay.    
  310 IF(ND.EQ.2) THEN  
      ELSEIF(MMAT.EQ.2) THEN    
        PMES=4.*PMAS(11,1)**2   
        PMRHO2=PMAS(131,1)**2   
        PGRHO2=PMAS(131,2)**2   
  320   PMST=PMES*(P(IP,5)**2/PMES)**RLU(0) 
        WT=(1+0.5*PMES/PMST)*SQRT(MAX(0.,1.-PMES/PMST))*    
     &  (1.-PMST/P(IP,5)**2)**3*(1.+PGRHO2/PMRHO2)/ 
     &  ((1.-PMST/PMRHO2)**2+PGRHO2/PMRHO2) 
        IF(WT.LT.RLU(0)) GOTO 320   
        PV(2,5)=MAX(2.00001*PMAS(11,1),SQRT(PMST))  
    
C...M-generator gives weight. If rejected, try again.   
      ELSE  
  330   RORD(1)=1.  
        DO 350 IL1=2,ND-1   
        RSAV=RLU(0) 
        DO 340 IL2=IL1-1,1,-1   
        IF(RSAV.LE.RORD(IL2)) GOTO 350  
  340   RORD(IL2+1)=RORD(IL2)   
  350   RORD(IL2+1)=RSAV    
        RORD(ND)=0. 
        WT=1.   
        DO 360 IL=ND-1,1,-1 
        PV(IL,5)=PV(IL+1,5)+P(N+IL,5)+(RORD(IL)-RORD(IL+1))*(PV(1,5)-PS)    
  360   WT=WT*PAWT(PV(IL,5),PV(IL+1,5),P(N+IL,5))   
        IF(WT.LT.RLU(0)*WTMAX) GOTO 330 
      ENDIF 
    
C...Perform two-particle decays in respective CM frame. 
  370 DO 390 IL=1,ND-1  
      PA=PAWT(PV(IL,5),PV(IL+1,5),P(N+IL,5))    
      UE(3)=2.*RLU(0)-1.    
      PHI=PARU(2)*RLU(0)    
      UE(1)=SQRT(1.-UE(3)**2)*COS(PHI)  
      UE(2)=SQRT(1.-UE(3)**2)*SIN(PHI)  
      DO 380 J=1,3  
      P(N+IL,J)=PA*UE(J)    
  380 PV(IL+1,J)=-PA*UE(J)  
      P(N+IL,4)=SQRT(PA**2+P(N+IL,5)**2)    
  390 PV(IL+1,4)=SQRT(PA**2+PV(IL+1,5)**2)  
    
C...Lorentz transform decay products to lab frame.  
      DO 400 J=1,4  
  400 P(N+ND,J)=PV(ND,J)    
      DO 430 IL=ND-1,1,-1   
      DO 410 J=1,3  
  410 BE(J)=PV(IL,J)/PV(IL,4)   
      GA=PV(IL,4)/PV(IL,5)  
      DO 430 I=N+IL,N+ND    
      BEP=BE(1)*P(I,1)+BE(2)*P(I,2)+BE(3)*P(I,3)    
      DO 420 J=1,3  
  420 P(I,J)=P(I,J)+GA*(GA*BEP/(1.+GA)+P(I,4))*BE(J)    
  430 P(I,4)=GA*(P(I,4)+BEP)    
    
C...Matrix elements for omega and phi decays.   
      IF(MMAT.EQ.1) THEN    
        WT=(P(N+1,5)*P(N+2,5)*P(N+3,5))**2-(P(N+1,5)*FOUR(N+2,N+3))**2  
     &  -(P(N+2,5)*FOUR(N+1,N+3))**2-(P(N+3,5)*FOUR(N+1,N+2))**2    
     &  +2.*FOUR(N+1,N+2)*FOUR(N+1,N+3)*FOUR(N+2,N+3)   
        IF(MAX(WT*WTCOR(9)/P(IP,5)**6,0.001).LT.RLU(0)) GOTO 310    
    
C...Matrix elements for pi0 or eta Dalitz decay to gamma e+ e-. 
      ELSEIF(MMAT.EQ.2) THEN    
        FOUR12=FOUR(N+1,N+2)    
        FOUR13=FOUR(N+1,N+3)    
        FOUR23=0.5*PMST-0.25*PMES   
        WT=(PMST-0.5*PMES)*(FOUR12**2+FOUR13**2)+   
     &  PMES*(FOUR12*FOUR13+FOUR12**2+FOUR13**2)    
        IF(WT.LT.RLU(0)*0.25*PMST*(P(IP,5)**2-PMST)**2) GOTO 370    
    
C...Matrix element for S0 -> S1 + V1 -> S1 + S2 + S3 (S scalar, 
C...V vector), of form cos**2(theta02) in V1 rest frame.    
      ELSEIF(MMAT.EQ.3.AND.NM.EQ.2) THEN    
        IF((P(IP,5)**2*FOUR(IM,N+1)-FOUR(IP,IM)*FOUR(IP,N+1))**2.LE.    
     &  RLU(0)*(FOUR(IP,IM)**2-(P(IP,5)*P(IM,5))**2)*(FOUR(IP,N+1)**2-  
     &  (P(IP,5)*P(N+1,5))**2)) GOTO 370    
    
C...Matrix element for "onium" -> g + g + g or gamma + g + g.   
      ELSEIF(MMAT.EQ.4) THEN    
        HX1=2.*FOUR(IP,N+1)/P(IP,5)**2  
        HX2=2.*FOUR(IP,N+2)/P(IP,5)**2  
        HX3=2.*FOUR(IP,N+3)/P(IP,5)**2  
        WT=((1.-HX1)/(HX2*HX3))**2+((1.-HX2)/(HX1*HX3))**2+ 
     &  ((1.-HX3)/(HX1*HX2))**2 
        IF(WT.LT.2.*RLU(0)) GOTO 310    
        IF(K(IP+1,2).EQ.22.AND.(1.-HX1)*P(IP,5)**2.LT.4.*PARJ(32)**2)   
     &  GOTO 310    
    
C...Effective matrix element for nu spectrum in tau -> nu + hadrons.    
      ELSEIF(MMAT.EQ.41) THEN   
        HX1=2.*FOUR(IP,N+1)/P(IP,5)**2  
        IF(8.*HX1*(3.-2.*HX1)/9..LT.RLU(0)) GOTO 310    
    
C...Matrix elements for weak decays (only semileptonic for c and b) 
      ELSEIF(MMAT.GE.42.AND.MMAT.LE.44.AND.ND.EQ.3) THEN    
        IF(MBST.EQ.0) WT=FOUR(IP,N+1)*FOUR(N+2,N+3) 
        IF(MBST.EQ.1) WT=P(IP,5)*P(N+1,4)*FOUR(N+2,N+3) 
        IF(WT.LT.RLU(0)*P(IP,5)*PV(1,5)**3/WTCOR(10)) GOTO 310  
      ELSEIF(MMAT.GE.42.AND.MMAT.LE.44) THEN    
        DO 440 J=1,4    
        P(N+NP+1,J)=0.  
        DO 440 IS=N+3,N+NP  
  440   P(N+NP+1,J)=P(N+NP+1,J)+P(IS,J) 
        IF(MBST.EQ.0) WT=FOUR(IP,N+1)*FOUR(N+2,N+NP+1)  
        IF(MBST.EQ.1) WT=P(IP,5)*P(N+1,4)*FOUR(N+2,N+NP+1)  
        IF(WT.LT.RLU(0)*P(IP,5)*PV(1,5)**3/WTCOR(10)) GOTO 310  
    
C...Angular distribution in W decay.    
      ELSEIF(MMAT.EQ.46.AND.MSGN.NE.0) THEN 
        IF(MSGN.GT.0) WT=FOUR(IM,N+1)*FOUR(N+2,IP+1)    
        IF(MSGN.LT.0) WT=FOUR(IM,N+2)*FOUR(N+1,IP+1)    
        IF(WT.LT.RLU(0)*P(IM,5)**4/WTCOR(10)) GOTO 370  
      ENDIF 
    
C...Scale back energy and reattach spectator.   
      IF(MREM.EQ.1) THEN    
        DO 450 J=1,5    
  450   PV(1,J)=PV(1,J)/(1.-PQT)    
        ND=ND+1 
        MREM=0  
      ENDIF 
    
C...Low invariant mass for system with spectator quark gives particle,  
C...not two jets. Readjust momenta accordingly. 
      IF((MMAT.EQ.31.OR.MMAT.EQ.45).AND.ND.EQ.3) THEN   
        MSTJ(93)=1  
        PM2=ULMASS(K(N+2,2))    
        MSTJ(93)=1  
        PM3=ULMASS(K(N+3,2))    
        IF(P(N+2,5)**2+P(N+3,5)**2+2.*FOUR(N+2,N+3).GE. 
     &  (PARJ(32)+PM2+PM3)**2) GOTO 510 
        K(N+2,1)=1  
        KFTEMP=K(N+2,2) 
        CALL LUKFDI(KFTEMP,K(N+3,2),KFLDMP,K(N+2,2))    
        IF(K(N+2,2).EQ.0) GOTO 150  
        P(N+2,5)=ULMASS(K(N+2,2))   
        PS=P(N+1,5)+P(N+2,5)    
        PV(2,5)=P(N+2,5)    
        MMAT=0  
        ND=2    
        GOTO 370    
      ELSEIF(MMAT.EQ.44) THEN   
        MSTJ(93)=1  
        PM3=ULMASS(K(N+3,2))    
        MSTJ(93)=1  
        PM4=ULMASS(K(N+4,2))    
        IF(P(N+3,5)**2+P(N+4,5)**2+2.*FOUR(N+3,N+4).GE. 
     &  (PARJ(32)+PM3+PM4)**2) GOTO 480 
        K(N+3,1)=1  
        KFTEMP=K(N+3,2) 
        CALL LUKFDI(KFTEMP,K(N+4,2),KFLDMP,K(N+3,2))    
        IF(K(N+3,2).EQ.0) GOTO 150  
        P(N+3,5)=ULMASS(K(N+3,2))   
        DO 460 J=1,3    
  460   P(N+3,J)=P(N+3,J)+P(N+4,J)  
        P(N+3,4)=SQRT(P(N+3,1)**2+P(N+3,2)**2+P(N+3,3)**2+P(N+3,5)**2)  
        HA=P(N+1,4)**2-P(N+2,4)**2  
        HB=HA-(P(N+1,5)**2-P(N+2,5)**2) 
        HC=(P(N+1,1)-P(N+2,1))**2+(P(N+1,2)-P(N+2,2))**2+   
     &  (P(N+1,3)-P(N+2,3))**2  
        HD=(PV(1,4)-P(N+3,4))**2    
        HE=HA**2-2.*HD*(P(N+1,4)**2+P(N+2,4)**2)+HD**2  
        HF=HD*HC-HB**2  
        HG=HD*HC-HA*HB  
        HH=(SQRT(HG**2+HE*HF)-HG)/(2.*HF)   
        DO 470 J=1,3    
        PCOR=HH*(P(N+1,J)-P(N+2,J)) 
        P(N+1,J)=P(N+1,J)+PCOR  
  470   P(N+2,J)=P(N+2,J)-PCOR  
        P(N+1,4)=SQRT(P(N+1,1)**2+P(N+1,2)**2+P(N+1,3)**2+P(N+1,5)**2)  
        P(N+2,4)=SQRT(P(N+2,1)**2+P(N+2,2)**2+P(N+2,3)**2+P(N+2,5)**2)  
        ND=ND-1 
      ENDIF 
    
C...Check invariant mass of W jets. May give one particle or start over.    
  480 IF(MMAT.GE.42.AND.MMAT.LE.44.AND.IABS(K(N+1,2)).LT.10) THEN   
        PMR=SQRT(MAX(0.,P(N+1,5)**2+P(N+2,5)**2+2.*FOUR(N+1,N+2)))  
        MSTJ(93)=1  
        PM1=ULMASS(K(N+1,2))    
        MSTJ(93)=1  
        PM2=ULMASS(K(N+2,2))    
        IF(PMR.GT.PARJ(32)+PM1+PM2) GOTO 490    
        KFLDUM=INT(1.5+RLU(0))  
        CALL LUKFDI(K(N+1,2),-ISIGN(KFLDUM,K(N+1,2)),KFLDMP,KF1)    
        CALL LUKFDI(K(N+2,2),-ISIGN(KFLDUM,K(N+2,2)),KFLDMP,KF2)    
        IF(KF1.EQ.0.OR.KF2.EQ.0) GOTO 150   
        PSM=ULMASS(KF1)+ULMASS(KF2) 
        IF(MMAT.EQ.42.AND.PMR.GT.PARJ(64)+PSM) GOTO 490 
        IF(MMAT.GE.43.AND.PMR.GT.0.2*PARJ(32)+PSM) GOTO 490 
        IF(ND.EQ.4.OR.KFA.EQ.15) GOTO 150   
        K(N+1,1)=1  
        KFTEMP=K(N+1,2) 
        CALL LUKFDI(KFTEMP,K(N+2,2),KFLDMP,K(N+1,2))    
        IF(K(N+1,2).EQ.0) GOTO 150  
        P(N+1,5)=ULMASS(K(N+1,2))   
        K(N+2,2)=K(N+3,2)   
        P(N+2,5)=P(N+3,5)   
        PS=P(N+1,5)+P(N+2,5)    
        PV(2,5)=P(N+3,5)    
        MMAT=0  
        ND=2    
        GOTO 370    
      ENDIF 
    
C...Phase space decay of partons from W decay.  
  490 IF(MMAT.EQ.42.AND.IABS(K(N+1,2)).LT.10) THEN  
        KFLO(1)=K(N+1,2)    
        KFLO(2)=K(N+2,2)    
        K(N+1,1)=K(N+3,1)   
        K(N+1,2)=K(N+3,2)   
        DO 500 J=1,5    
        PV(1,J)=P(N+1,J)+P(N+2,J)   
  500   P(N+1,J)=P(N+3,J)   
        PV(1,5)=PMR 
        N=N+1   
        NP=0    
        NQ=2    
        PS=0.   
        MSTJ(93)=2  
        PSQ=ULMASS(KFLO(1)) 
        MSTJ(93)=2  
        PSQ=PSQ+ULMASS(KFLO(2)) 
        MMAT=11 
        GOTO 180    
      ENDIF 
    
C...Boost back for rapidly moving particle. 
  510 N=N+ND    
      IF(MBST.EQ.1) THEN    
        DO 520 J=1,3    
  520   BE(J)=P(IP,J)/P(IP,4)   
        GA=P(IP,4)/P(IP,5)  
        DO 540 I=NSAV+1,N   
        BEP=BE(1)*P(I,1)+BE(2)*P(I,2)+BE(3)*P(I,3)  
        DO 530 J=1,3    
  530   P(I,J)=P(I,J)+GA*(GA*BEP/(1.+GA)+P(I,4))*BE(J)  
  540   P(I,4)=GA*(P(I,4)+BEP)  
      ENDIF 
    
C...Fill in position of decay vertex.   
      DO 560 I=NSAV+1,N 
      DO 550 J=1,4  
  550 V(I,J)=VDCY(J)    
  560 V(I,5)=0. 
    
C...Set up for parton shower evolution from jets.   
      IF(MSTJ(23).GE.1.AND.MMAT.EQ.4.AND.K(NSAV+1,2).EQ.21) THEN    
        K(NSAV+1,1)=3   
        K(NSAV+2,1)=3   
        K(NSAV+3,1)=3   
        K(NSAV+1,4)=MSTU(5)*(NSAV+2)    
        K(NSAV+1,5)=MSTU(5)*(NSAV+3)    
        K(NSAV+2,4)=MSTU(5)*(NSAV+3)    
        K(NSAV+2,5)=MSTU(5)*(NSAV+1)    
        K(NSAV+3,4)=MSTU(5)*(NSAV+1)    
        K(NSAV+3,5)=MSTU(5)*(NSAV+2)    
        MSTJ(92)=-(NSAV+1)  
      ELSEIF(MSTJ(23).GE.1.AND.MMAT.EQ.4) THEN  
        K(NSAV+2,1)=3   
        K(NSAV+3,1)=3   
        K(NSAV+2,4)=MSTU(5)*(NSAV+3)    
        K(NSAV+2,5)=MSTU(5)*(NSAV+3)    
        K(NSAV+3,4)=MSTU(5)*(NSAV+2)    
        K(NSAV+3,5)=MSTU(5)*(NSAV+2)    
        MSTJ(92)=NSAV+2 
      ELSEIF(MSTJ(23).GE.1.AND.(MMAT.EQ.32.OR.MMAT.EQ.44.OR.MMAT.EQ.46).    
     &AND.IABS(K(NSAV+1,2)).LE.10.AND.IABS(K(NSAV+2,2)).LE.10) THEN 
        K(NSAV+1,1)=3   
        K(NSAV+2,1)=3   
        K(NSAV+1,4)=MSTU(5)*(NSAV+2)    
        K(NSAV+1,5)=MSTU(5)*(NSAV+2)    
        K(NSAV+2,4)=MSTU(5)*(NSAV+1)    
        K(NSAV+2,5)=MSTU(5)*(NSAV+1)    
        MSTJ(92)=NSAV+1 
      ELSEIF(MSTJ(23).GE.1.AND.MMAT.EQ.33.AND.IABS(K(NSAV+2,2)).EQ.21)  
     &THEN  
        K(NSAV+1,1)=3   
        K(NSAV+2,1)=3   
        K(NSAV+3,1)=3   
        KCP=LUCOMP(K(NSAV+1,2)) 
        KQP=KCHG(KCP,2)*ISIGN(1,K(NSAV+1,2))    
        JCON=4  
        IF(KQP.LT.0) JCON=5 
        K(NSAV+1,JCON)=MSTU(5)*(NSAV+2) 
        K(NSAV+2,9-JCON)=MSTU(5)*(NSAV+1)   
        K(NSAV+2,JCON)=MSTU(5)*(NSAV+3) 
        K(NSAV+3,9-JCON)=MSTU(5)*(NSAV+2)   
        MSTJ(92)=NSAV+1 
      ELSEIF(MSTJ(23).GE.1.AND.MMAT.EQ.33) THEN 
        K(NSAV+1,1)=3   
        K(NSAV+3,1)=3   
        K(NSAV+1,4)=MSTU(5)*(NSAV+3)    
        K(NSAV+1,5)=MSTU(5)*(NSAV+3)    
        K(NSAV+3,4)=MSTU(5)*(NSAV+1)    
        K(NSAV+3,5)=MSTU(5)*(NSAV+1)    
        MSTJ(92)=NSAV+1 
      ENDIF 
    
C...Mark decayed particle.  
      IF(K(IP,1).EQ.5) K(IP,1)=15   
      IF(K(IP,1).LE.10) K(IP,1)=11  
      K(IP,4)=NSAV+1    
      K(IP,5)=N 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUKFDI(KFL1,KFL2,KFL3,KF)  
    
C...Purpose: to generate a new flavour pair and combine off a hadron.   
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
    
C...Default flavour values. Input consistency checks.   
      KF1A=IABS(KFL1)   
      KF2A=IABS(KFL2)   
      KFL3=0    
      KF=0  
      IF(KF1A.EQ.0) RETURN  
      IF(KF2A.NE.0) THEN    
        IF(KF1A.LE.10.AND.KF2A.LE.10.AND.KFL1*KFL2.GT.0) RETURN 
        IF(KF1A.GT.10.AND.KF2A.GT.10) RETURN    
        IF((KF1A.GT.10.OR.KF2A.GT.10).AND.KFL1*KFL2.LT.0) RETURN    
      ENDIF 
    
C...Check if tabulated flavour probabilities are to be used.    
      IF(MSTJ(15).EQ.1) THEN    
        KTAB1=-1    
        IF(KF1A.GE.1.AND.KF1A.LE.6) KTAB1=KF1A  
        KFL1A=MOD(KF1A/1000,10) 
        KFL1B=MOD(KF1A/100,10)  
        KFL1S=MOD(KF1A,10)  
        IF(KFL1A.GE.1.AND.KFL1A.LE.4.AND.KFL1B.GE.1.AND.KFL1B.LE.4) 
     &  KTAB1=6+KFL1A*(KFL1A-2)+2*KFL1B+(KFL1S-1)/2 
        IF(KFL1A.GE.1.AND.KFL1A.LE.4.AND.KFL1A.EQ.KFL1B) KTAB1=KTAB1-1  
        IF(KF1A.GE.1.AND.KF1A.LE.6) KFL1A=KF1A  
        KTAB2=0 
        IF(KF2A.NE.0) THEN  
          KTAB2=-1  
          IF(KF2A.GE.1.AND.KF2A.LE.6) KTAB2=KF2A    
          KFL2A=MOD(KF2A/1000,10)   
          KFL2B=MOD(KF2A/100,10)    
          KFL2S=MOD(KF2A,10)    
          IF(KFL2A.GE.1.AND.KFL2A.LE.4.AND.KFL2B.GE.1.AND.KFL2B.LE.4)   
     &    KTAB2=6+KFL2A*(KFL2A-2)+2*KFL2B+(KFL2S-1)/2   
          IF(KFL2A.GE.1.AND.KFL2A.LE.4.AND.KFL2A.EQ.KFL2B) KTAB2=KTAB2-1    
        ENDIF   
        IF(KTAB1.GE.0.AND.KTAB2.GE.0) GOTO 140  
      ENDIF 
    
C...Parameters and breaking diquark parameter combinations. 
  100 PAR2=PARJ(2)  
      PAR3=PARJ(3)  
      PAR4=3.*PARJ(4)   
      IF(MSTJ(12).GE.2) THEN    
        PAR3M=SQRT(PARJ(3)) 
        PAR4M=1./(3.*SQRT(PARJ(4))) 
        PARDM=PARJ(7)/(PARJ(7)+PAR3M*PARJ(6))   
        PARS0=PARJ(5)*(2.+(1.+PAR2*PAR3M*PARJ(7))*(1.+PAR4M))   
        PARS1=PARJ(7)*PARS0/(2.*PAR3M)+PARJ(5)*(PARJ(6)*(1.+PAR4M)+ 
     &  PAR2*PAR3M*PARJ(6)*PARJ(7)) 
        PARS2=PARJ(5)*2.*PARJ(6)*PARJ(7)*(PAR2*PARJ(7)+(1.+PAR4M)/PAR3M)    
        PARSM=MAX(PARS0,PARS1,PARS2)    
        PAR4=PAR4*(1.+PARSM)/(1.+PARSM/(3.*PAR4M))  
      ENDIF 
    
C...Choice of whether to generate meson or baryon.  
      MBARY=0   
      KFDA=0    
      IF(KF1A.LE.10) THEN   
        IF(KF2A.EQ.0.AND.MSTJ(12).GE.1.AND.(1.+PARJ(1))*RLU(0).GT.1.)   
     &  MBARY=1 
        IF(KF2A.GT.10) MBARY=2  
        IF(KF2A.GT.10.AND.KF2A.LE.10000) KFDA=KF2A  
      ELSE  
        MBARY=2 
        IF(KF1A.LE.10000) KFDA=KF1A 
      ENDIF 
    
C...Possibility of process diquark -> meson + new diquark.  
      IF(KFDA.NE.0.AND.MSTJ(12).GE.2) THEN  
        KFLDA=MOD(KFDA/1000,10) 
        KFLDB=MOD(KFDA/100,10)  
        KFLDS=MOD(KFDA,10)  
        WTDQ=PARS0  
        IF(MAX(KFLDA,KFLDB).EQ.3) WTDQ=PARS1    
        IF(MIN(KFLDA,KFLDB).EQ.3) WTDQ=PARS2    
        IF(KFLDS.EQ.1) WTDQ=WTDQ/(3.*PAR4M) 
        IF((1.+WTDQ)*RLU(0).GT.1.) MBARY=-1 
        IF(MBARY.EQ.-1.AND.KF2A.NE.0) RETURN    
      ENDIF 
    
C...Flavour for meson, possibly with new flavour.   
      IF(MBARY.LE.0) THEN   
        KFS=ISIGN(1,KFL1)   
        IF(MBARY.EQ.0) THEN 
          IF(KF2A.EQ.0) KFL3=ISIGN(1+INT((2.+PAR2)*RLU(0)),-KFL1)   
          KFLA=MAX(KF1A,KF2A+IABS(KFL3))    
          KFLB=MIN(KF1A,KF2A+IABS(KFL3))    
          IF(KFLA.NE.KF1A) KFS=-KFS 
    
C...Splitting of diquark into meson plus new diquark.   
        ELSE    
          KFL1A=MOD(KF1A/1000,10)   
          KFL1B=MOD(KF1A/100,10)    
  110     KFL1D=KFL1A+INT(RLU(0)+0.5)*(KFL1B-KFL1A) 
          KFL1E=KFL1A+KFL1B-KFL1D   
          IF((KFL1D.EQ.3.AND.RLU(0).GT.PARDM).OR.(KFL1E.EQ.3.AND.   
     &    RLU(0).LT.PARDM)) THEN    
            KFL1D=KFL1A+KFL1B-KFL1D 
            KFL1E=KFL1A+KFL1B-KFL1E 
          ENDIF 
          KFL3A=1+INT((2.+PAR2*PAR3M*PARJ(7))*RLU(0))   
          IF((KFL1E.NE.KFL3A.AND.RLU(0).GT.(1.+PAR4M)/MAX(2.,1.+PAR4M)).    
     &    OR.(KFL1E.EQ.KFL3A.AND.RLU(0).GT.2./MAX(2.,1.+PAR4M)))    
     &    GOTO 110  
          KFLDS=3   
          IF(KFL1E.NE.KFL3A) KFLDS=2*INT(RLU(0)+1./(1.+PAR4M))+1    
          KFL3=ISIGN(10000+1000*MAX(KFL1E,KFL3A)+100*MIN(KFL1E,KFL3A)+  
     &    KFLDS,-KFL1)  
          KFLA=MAX(KFL1D,KFL3A) 
          KFLB=MIN(KFL1D,KFL3A) 
          IF(KFLA.NE.KFL1D) KFS=-KFS    
        ENDIF   
    
C...Form meson, with spin and flavour mixing for diagonal states.   
        IF(KFLA.LE.2) KMUL=INT(PARJ(11)+RLU(0)) 
        IF(KFLA.EQ.3) KMUL=INT(PARJ(12)+RLU(0)) 
        IF(KFLA.GE.4) KMUL=INT(PARJ(13)+RLU(0)) 
        IF(KMUL.EQ.0.AND.PARJ(14).GT.0.) THEN   
          IF(RLU(0).LT.PARJ(14)) KMUL=2 
        ELSEIF(KMUL.EQ.1.AND.PARJ(15)+PARJ(16)+PARJ(17).GT.0.) THEN 
          RMUL=RLU(0)   
          IF(RMUL.LT.PARJ(15)) KMUL=3   
          IF(KMUL.EQ.1.AND.RMUL.LT.PARJ(15)+PARJ(16)) KMUL=4    
          IF(KMUL.EQ.1.AND.RMUL.LT.PARJ(15)+PARJ(16)+PARJ(17)) KMUL=5   
        ENDIF   
        KFLS=3  
        IF(KMUL.EQ.0.OR.KMUL.EQ.3) KFLS=1   
        IF(KMUL.EQ.5) KFLS=5    
        IF(KFLA.NE.KFLB) THEN   
          KF=(100*KFLA+10*KFLB+KFLS)*KFS*(-1)**KFLA 
        ELSE    
          RMIX=RLU(0)   
          IMIX=2*KFLA+10*KMUL   
          IF(KFLA.LE.3) KF=110*(1+INT(RMIX+PARF(IMIX-1))+   
     &    INT(RMIX+PARF(IMIX)))+KFLS    
          IF(KFLA.GE.4) KF=110*KFLA+KFLS    
        ENDIF   
        IF(KMUL.EQ.2.OR.KMUL.EQ.3) KF=KF+ISIGN(10000,KF)    
        IF(KMUL.EQ.4) KF=KF+ISIGN(20000,KF) 
    
C...Generate diquark flavour.   
      ELSE  
  120   IF(KF1A.LE.10.AND.KF2A.EQ.0) THEN   
          KFLA=KF1A 
  130     KFLB=1+INT((2.+PAR2*PAR3)*RLU(0)) 
          KFLC=1+INT((2.+PAR2*PAR3)*RLU(0)) 
          KFLDS=1   
          IF(KFLB.GE.KFLC) KFLDS=3  
          IF(KFLDS.EQ.1.AND.PAR4*RLU(0).GT.1.) GOTO 130 
          IF(KFLDS.EQ.3.AND.PAR4.LT.RLU(0)) GOTO 130    
          KFL3=ISIGN(1000*MAX(KFLB,KFLC)+100*MIN(KFLB,KFLC)+KFLDS,KFL1) 
    
C...Take diquark flavour from input.    
        ELSEIF(KF1A.LE.10) THEN 
          KFLA=KF1A 
          KFLB=MOD(KF2A/1000,10)    
          KFLC=MOD(KF2A/100,10) 
          KFLDS=MOD(KF2A,10)    
    
C...Generate (or take from input) quark to go with diquark. 
        ELSE    
          IF(KF2A.EQ.0) KFL3=ISIGN(1+INT((2.+PAR2)*RLU(0)),KFL1)    
          KFLA=KF2A+IABS(KFL3)  
          KFLB=MOD(KF1A/1000,10)    
          KFLC=MOD(KF1A/100,10) 
          KFLDS=MOD(KF1A,10)    
        ENDIF   
    
C...SU(6) factors for formation of baryon. Try again if fails.  
        KBARY=KFLDS 
        IF(KFLDS.EQ.3.AND.KFLB.NE.KFLC) KBARY=5 
        IF(KFLA.NE.KFLB.AND.KFLA.NE.KFLC) KBARY=KBARY+1 
        WT=PARF(60+KBARY)+PARJ(18)*PARF(70+KBARY)   
        IF(MBARY.EQ.1.AND.MSTJ(12).GE.2) THEN   
          WTDQ=PARS0    
          IF(MAX(KFLB,KFLC).EQ.3) WTDQ=PARS1    
          IF(MIN(KFLB,KFLC).EQ.3) WTDQ=PARS2    
          IF(KFLDS.EQ.1) WTDQ=WTDQ/(3.*PAR4M)   
          IF(KFLDS.EQ.1) WT=WT*(1.+WTDQ)/(1.+PARSM/(3.*PAR4M))  
          IF(KFLDS.EQ.3) WT=WT*(1.+WTDQ)/(1.+PARSM) 
        ENDIF   
        IF(KF2A.EQ.0.AND.WT.LT.RLU(0)) GOTO 120 
    
C...Form baryon. Distinguish Lambda- and Sigmalike baryons. 
        KFLD=MAX(KFLA,KFLB,KFLC)    
        KFLF=MIN(KFLA,KFLB,KFLC)    
        KFLE=KFLA+KFLB+KFLC-KFLD-KFLF   
        KFLS=2  
        IF((PARF(60+KBARY)+PARJ(18)*PARF(70+KBARY))*RLU(0).GT.  
     &  PARF(60+KBARY)) KFLS=4  
        KFLL=0  
        IF(KFLS.EQ.2.AND.KFLD.GT.KFLE.AND.KFLE.GT.KFLF) THEN    
          IF(KFLDS.EQ.1.AND.KFLA.EQ.KFLD) KFLL=1    
          IF(KFLDS.EQ.1.AND.KFLA.NE.KFLD) KFLL=INT(0.25+RLU(0)) 
          IF(KFLDS.EQ.3.AND.KFLA.NE.KFLD) KFLL=INT(0.75+RLU(0)) 
        ENDIF   
        IF(KFLL.EQ.0) KF=ISIGN(1000*KFLD+100*KFLE+10*KFLF+KFLS,KFL1)    
        IF(KFLL.EQ.1) KF=ISIGN(1000*KFLD+100*KFLF+10*KFLE+KFLS,KFL1)    
      ENDIF 
      RETURN    
    
C...Use tabulated probabilities to select new flavour and hadron.   
  140 IF(KTAB2.EQ.0.AND.MSTJ(12).LE.0) THEN 
        KT3L=1  
        KT3U=6  
      ELSEIF(KTAB2.EQ.0.AND.KTAB1.GE.7.AND.MSTJ(12).LE.1) THEN  
        KT3L=1  
        KT3U=6  
      ELSEIF(KTAB2.EQ.0) THEN   
        KT3L=1  
        KT3U=22 
      ELSE  
        KT3L=KTAB2  
        KT3U=KTAB2  
      ENDIF 
      RFL=0.    
      DO 150 KTS=0,2    
      DO 150 KT3=KT3L,KT3U  
      RFL=RFL+PARF(120+80*KTAB1+25*KTS+KT3) 
  150 CONTINUE  
      RFL=RLU(0)*RFL    
      DO 160 KTS=0,2    
      KTABS=KTS 
      DO 160 KT3=KT3L,KT3U  
      KTAB3=KT3 
      RFL=RFL-PARF(120+80*KTAB1+25*KTS+KT3) 
  160 IF(RFL.LE.0.) GOTO 170    
  170 CONTINUE  
    
C...Reconstruct flavour of produced quark/diquark.  
      IF(KTAB3.LE.6) THEN   
        KFL3A=KTAB3 
        KFL3B=0 
        KFL3=ISIGN(KFL3A,KFL1*(2*KTAB1-13)) 
      ELSE  
        KFL3A=1 
        IF(KTAB3.GE.8) KFL3A=2  
        IF(KTAB3.GE.11) KFL3A=3 
        IF(KTAB3.GE.16) KFL3A=4 
        KFL3B=(KTAB3-6-KFL3A*(KFL3A-2))/2   
        KFL3=1000*KFL3A+100*KFL3B+1 
        IF(KFL3A.EQ.KFL3B.OR.KTAB3.NE.6+KFL3A*(KFL3A-2)+2*KFL3B) KFL3=  
     &  KFL3+2  
        KFL3=ISIGN(KFL3,KFL1*(13-2*KTAB1))  
      ENDIF 
    
C...Reconstruct meson code. 
      IF(KFL3A.EQ.KFL1A.AND.KFL3B.EQ.KFL1B.AND.(KFL3A.LE.3.OR.  
     &KFL3B.NE.0)) THEN 
        RFL=RLU(0)*(PARF(143+80*KTAB1+25*KTABS)+PARF(144+80*KTAB1+  
     &  25*KTABS)+PARF(145+80*KTAB1+25*KTABS))  
        KF=110+2*KTABS+1    
        IF(RFL.GT.PARF(143+80*KTAB1+25*KTABS)) KF=220+2*KTABS+1 
        IF(RFL.GT.PARF(143+80*KTAB1+25*KTABS)+PARF(144+80*KTAB1+    
     &  25*KTABS)) KF=330+2*KTABS+1 
      ELSEIF(KTAB1.LE.6.AND.KTAB3.LE.6) THEN    
        KFLA=MAX(KTAB1,KTAB3)   
        KFLB=MIN(KTAB1,KTAB3)   
        KFS=ISIGN(1,KFL1)   
        IF(KFLA.NE.KF1A) KFS=-KFS   
        KF=(100*KFLA+10*KFLB+2*KTABS+1)*KFS*(-1)**KFLA  
      ELSEIF(KTAB1.GE.7.AND.KTAB3.GE.7) THEN    
        KFS=ISIGN(1,KFL1)   
        IF(KFL1A.EQ.KFL3A) THEN 
          KFLA=MAX(KFL1B,KFL3B) 
          KFLB=MIN(KFL1B,KFL3B) 
          IF(KFLA.NE.KFL1B) KFS=-KFS    
        ELSEIF(KFL1A.EQ.KFL3B) THEN 
          KFLA=KFL3A    
          KFLB=KFL1B    
          KFS=-KFS  
        ELSEIF(KFL1B.EQ.KFL3A) THEN 
          KFLA=KFL1A    
          KFLB=KFL3B    
        ELSEIF(KFL1B.EQ.KFL3B) THEN 
          KFLA=MAX(KFL1A,KFL3A) 
          KFLB=MIN(KFL1A,KFL3A) 
          IF(KFLA.NE.KFL1A) KFS=-KFS    
        ELSE    
          CALL LUERRM(2,'(LUKFDI:) no matching flavours for qq -> qq')  
          GOTO 100  
        ENDIF   
        KF=(100*KFLA+10*KFLB+2*KTABS+1)*KFS*(-1)**KFLA  
    
C...Reconstruct baryon code.    
      ELSE  
        IF(KTAB1.GE.7) THEN 
          KFLA=KFL3A    
          KFLB=KFL1A    
          KFLC=KFL1B    
        ELSE    
          KFLA=KFL1A    
          KFLB=KFL3A    
          KFLC=KFL3B    
        ENDIF   
        KFLD=MAX(KFLA,KFLB,KFLC)    
        KFLF=MIN(KFLA,KFLB,KFLC)    
        KFLE=KFLA+KFLB+KFLC-KFLD-KFLF   
        IF(KTABS.EQ.0) KF=ISIGN(1000*KFLD+100*KFLF+10*KFLE+2,KFL1)  
        IF(KTABS.GE.1) KF=ISIGN(1000*KFLD+100*KFLE+10*KFLF+2*KTABS,KFL1)    
      ENDIF 
    
C...Check that constructed flavour code is an allowed one.  
      IF(KFL2.NE.0) KFL3=0  
      KC=LUCOMP(KF) 
      IF(KC.EQ.0) THEN  
        CALL LUERRM(2,'(LUKFDI:) user-defined flavour probabilities '// 
     &  'failed')   
        GOTO 100    
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUPTDI(KFL,PX,PY)  
    
C...Purpose: to generate transverse momentum according to a Gaussian.   
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
    
C...Generate p_T and azimuthal angle, gives p_x and p_y.    
      KFLA=IABS(KFL)    
      PT=PARJ(21)*SQRT(-LOG(MAX(1E-10,RLU(0)))) 
      IF(MSTJ(91).EQ.1) PT=PARJ(22)*PT  
      IF(KFLA.EQ.0.AND.MSTJ(13).LE.0) PT=0. 
      PHI=PARU(2)*RLU(0)    
      PX=PT*COS(PHI)    
      PY=PT*SIN(PHI)    
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUZDIS(KFL1,KFL2,PR,Z) 
    
C...Purpose: to generate the longitudinal splitting variable z. 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
    
C...Check if heavy flavour fragmentation.   
      KFLA=IABS(KFL1)   
      KFLB=IABS(KFL2)   
      KFLH=KFLA 
      IF(KFLA.GE.10) KFLH=MOD(KFLA/1000,10) 
    
C...Lund symmetric scaling function: determine parameters of shape. 
      IF(MSTJ(11).EQ.1.OR.(MSTJ(11).EQ.3.AND.KFLH.LE.3)) THEN   
        FA=PARJ(41) 
        IF(MSTJ(91).EQ.1) FA=PARJ(43)   
        IF(KFLB.GE.10) FA=FA+PARJ(45)   
        FB=PARJ(42)*PR  
        IF(MSTJ(91).EQ.1) FB=PARJ(44)*PR    
        FC=1.   
        IF(KFLA.GE.10) FC=FC-PARJ(45)   
        IF(KFLB.GE.10) FC=FC+PARJ(45)   
        MC=1    
        IF(ABS(FC-1.).GT.0.01) MC=2 
    
C...Determine position of maximum. Special cases for a = 0 or a = c.    
        IF(FA.LT.0.02) THEN 
          MA=1  
          ZMAX=1.   
          IF(FC.GT.FB) ZMAX=FB/FC   
        ELSEIF(ABS(FC-FA).LT.0.01) THEN 
          MA=2  
          ZMAX=FB/(FB+FC)   
        ELSE    
          MA=3  
          ZMAX=0.5*(FB+FC-SQRT((FB-FC)**2+4.*FA*FB))/(FC-FA)    
          IF(ZMAX.GT.0.99.AND.FB.GT.100.) ZMAX=1.-FA/FB 
        ENDIF   
    
C...Subdivide z range if distribution very peaked near endpoint.    
        MMAX=2  
        IF(ZMAX.LT.0.1) THEN    
          MMAX=1    
          ZDIV=2.75*ZMAX    
          IF(MC.EQ.1) THEN  
            FINT=1.-LOG(ZDIV)   
          ELSE  
            ZDIVC=ZDIV**(1.-FC) 
            FINT=1.+(1.-1./ZDIVC)/(FC-1.)   
          ENDIF 
        ELSEIF(ZMAX.GT.0.85.AND.FB.GT.1.) THEN  
          MMAX=3    
          FSCB=SQRT(4.+(FC/FB)**2)  
          ZDIV=FSCB-1./ZMAX-(FC/FB)*LOG(ZMAX*0.5*(FSCB+FC/FB))  
          IF(MA.GE.2) ZDIV=ZDIV+(FA/FB)*LOG(1.-ZMAX)    
          ZDIV=MIN(ZMAX,MAX(0.,ZDIV))   
          FINT=1.+FB*(1.-ZDIV)  
        ENDIF   
    
C...Choice of z, preweighted for peaks at low or high z.    
  100   Z=RLU(0)    
        FPRE=1. 
        IF(MMAX.EQ.1) THEN  
          IF(FINT*RLU(0).LE.1.) THEN    
            Z=ZDIV*Z    
          ELSEIF(MC.EQ.1) THEN  
            Z=ZDIV**Z   
            FPRE=ZDIV/Z 
          ELSE  
            Z=1./(ZDIVC+Z*(1.-ZDIVC))**(1./(1.-FC)) 
            FPRE=(ZDIV/Z)**FC   
          ENDIF 
        ELSEIF(MMAX.EQ.3) THEN  
          IF(FINT*RLU(0).LE.1.) THEN    
            Z=ZDIV+LOG(Z)/FB    
            FPRE=EXP(FB*(Z-ZDIV))   
          ELSE  
            Z=ZDIV+Z*(1.-ZDIV)  
          ENDIF 
        ENDIF   
    
C...Weighting according to correct formula. 
        IF(Z.LE.FB/(50.+FB).OR.Z.GE.1.) GOTO 100    
        FVAL=(ZMAX/Z)**FC*EXP(FB*(1./ZMAX-1./Z))    
        IF(MA.GE.2) FVAL=((1.-Z)/(1.-ZMAX))**FA*FVAL    
        IF(FVAL.LT.RLU(0)*FPRE) GOTO 100    
    
C...Generate z according to Field-Feynman, SLAC, (1-z)**c OR z**c.  
      ELSE  
        FC=PARJ(50+MAX(1,KFLH)) 
        IF(MSTJ(91).EQ.1) FC=PARJ(59)   
  110   Z=RLU(0)    
        IF(FC.GE.0..AND.FC.LE.1.) THEN  
          IF(FC.GT.RLU(0)) Z=1.-Z**(1./3.)  
        ELSEIF(FC.GT.-1.) THEN  
          IF(-4.*FC*Z*(1.-Z)**2.LT.RLU(0)*((1.-Z)**2-FC*Z)**2) GOTO 110 
        ELSE    
          IF(FC.GT.0.) Z=1.-Z**(1./FC)  
          IF(FC.LT.0.) Z=Z**(-1./FC)    
        ENDIF   
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUSHOW(IP1,IP2,QMAX)   
    
C...Purpose: to generate timelike parton showers from given partons.    
      IMPLICIT DOUBLE PRECISION(D)  
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      DIMENSION PMTH(5,40),PS(5),PMA(4),PMSD(4),IEP(4),IPA(4),  
     &KFLA(4),KFLD(4),KFL(4),ITRY(4),ISI(4),ISL(4),DP(4),DPT(5,4)   
    
C...Initialization of cutoff masses etc.    
      IF(MSTJ(41).LE.0.OR.(MSTJ(41).EQ.1.AND.QMAX.LE.PARJ(82)).OR.  
     &QMAX.LE.MIN(PARJ(82),PARJ(83)).OR.MSTJ(41).GE.3) RETURN   
      PMTH(1,21)=ULMASS(21) 
      PMTH(2,21)=SQRT(PMTH(1,21)**2+0.25*PARJ(82)**2)   
      PMTH(3,21)=2.*PMTH(2,21)  
      PMTH(4,21)=PMTH(3,21) 
      PMTH(5,21)=PMTH(3,21) 
      PMTH(1,22)=ULMASS(22) 
      PMTH(2,22)=SQRT(PMTH(1,22)**2+0.25*PARJ(83)**2)   
      PMTH(3,22)=2.*PMTH(2,22)  
      PMTH(4,22)=PMTH(3,22) 
      PMTH(5,22)=PMTH(3,22) 
      PMQTH1=PARJ(82)   
      IF(MSTJ(41).EQ.2) PMQTH1=MIN(PARJ(82),PARJ(83))   
      PMQTH2=PMTH(2,21) 
      IF(MSTJ(41).EQ.2) PMQTH2=MIN(PMTH(2,21),PMTH(2,22))   
      DO 100 IF=1,8 
      PMTH(1,IF)=ULMASS(IF) 
      PMTH(2,IF)=SQRT(PMTH(1,IF)**2+0.25*PMQTH1**2) 
      PMTH(3,IF)=PMTH(2,IF)+PMQTH2  
      PMTH(4,IF)=SQRT(PMTH(1,IF)**2+0.25*PARJ(82)**2)+PMTH(2,21)    
  100 PMTH(5,IF)=SQRT(PMTH(1,IF)**2+0.25*PARJ(83)**2)+PMTH(2,22)    
      PT2MIN=MAX(0.5*PARJ(82),1.1*PARJ(81))**2  
      ALAMS=PARJ(81)**2 
      ALFM=LOG(PT2MIN/ALAMS)    
    
C...Store positions of shower initiating partons.   
      M3JC=0    
      IF(IP1.GT.0.AND.IP1.LE.MIN(N,MSTU(4)-MSTU(32)).AND.IP2.EQ.0) THEN 
        NPA=1   
        IPA(1)=IP1  
      ELSEIF(MIN(IP1,IP2).GT.0.AND.MAX(IP1,IP2).LE.MIN(N,MSTU(4)-   
     &MSTU(32))) THEN   
        NPA=2   
        IPA(1)=IP1  
        IPA(2)=IP2  
      ELSEIF(IP1.GT.0.AND.IP1.LE.MIN(N,MSTU(4)-MSTU(32)).AND.IP2.LT.0.  
     &AND.IP2.GE.-3) THEN   
        NPA=IABS(IP2)   
        DO 110 I=1,NPA  
  110   IPA(I)=IP1+I-1  
      ELSE  
        CALL LUERRM(12, 
     &  '(LUSHOW:) failed to reconstruct showering system') 
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
    
C...Check on phase space available for emission.    
      IREJ=0    
      DO 120 J=1,5  
  120 PS(J)=0.  
      PM=0. 
      DO 130 I=1,NPA    
      KFLA(I)=IABS(K(IPA(I),2)) 
      PMA(I)=P(IPA(I),5)    
      IF(KFLA(I).NE.0.AND.(KFLA(I).LE.8.OR.KFLA(I).EQ.21))  
     &PMA(I)=PMTH(3,KFLA(I))    
      PM=PM+PMA(I)  
      IF(KFLA(I).EQ.0.OR.(KFLA(I).GT.8.AND.KFLA(I).NE.21).OR.   
     &PMA(I).GT.QMAX) IREJ=IREJ+1   
      DO 130 J=1,4  
  130 PS(J)=PS(J)+P(IPA(I),J)   
      IF(IREJ.EQ.NPA) RETURN    
      PS(5)=SQRT(MAX(0.,PS(4)**2-PS(1)**2-PS(2)**2-PS(3)**2))   
      IF(NPA.EQ.1) PS(5)=PS(4)  
      IF(PS(5).LE.PM+PMQTH1) RETURN 
      IF(NPA.EQ.2.AND.MSTJ(47).GE.1) THEN   
        IF(KFLA(1).GE.1.AND.KFLA(1).LE.8.AND.KFLA(2).GE.1.AND.  
     &  KFLA(2).LE.8) M3JC=1    
        IF(MSTJ(47).GE.2) M3JC=1    
      ENDIF 
    
C...Define imagined single initiator of shower for parton system.   
      NS=N  
      IF(N.GT.MSTU(4)-MSTU(32)-5) THEN  
        CALL LUERRM(11,'(LUSHOW:) no more memory left in LUJETS')   
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      IF(NPA.GE.2) THEN 
        K(N+1,1)=11 
        K(N+1,2)=21 
        K(N+1,3)=0  
        K(N+1,4)=0  
        K(N+1,5)=0  
        P(N+1,1)=0. 
        P(N+1,2)=0. 
        P(N+1,3)=0. 
        P(N+1,4)=PS(5)  
        P(N+1,5)=PS(5)  
        V(N+1,5)=PS(5)**2   
        N=N+1   
      ENDIF 
    
C...Loop over partons that may branch.  
      NEP=NPA   
      IM=NS 
      IF(NPA.EQ.1) IM=NS-1  
  140 IM=IM+1   
      IF(N.GT.NS) THEN  
        IF(IM.GT.N) GOTO 380    
        KFLM=IABS(K(IM,2))  
        IF(KFLM.EQ.0.OR.(KFLM.GT.8.AND.KFLM.NE.21)) GOTO 140    
        IF(P(IM,5).LT.PMTH(2,KFLM)) GOTO 140    
        IGM=K(IM,3) 
      ELSE  
        IGM=-1  
      ENDIF 
      IF(N+NEP.GT.MSTU(4)-MSTU(32)-5) THEN  
        CALL LUERRM(11,'(LUSHOW:) no more memory left in LUJETS')   
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
    
C...Position of aunt (sister to branching parton).  
C...Origin and flavour of daughters.    
      IAU=0 
      IF(IGM.GT.0) THEN 
        IF(K(IM-1,3).EQ.IGM) IAU=IM-1   
        IF(N.GE.IM+1.AND.K(IM+1,3).EQ.IGM) IAU=IM+1 
      ENDIF 
      IF(IGM.GE.0) THEN 
        K(IM,4)=N+1 
        DO 150 I=1,NEP  
  150   K(N+I,3)=IM 
      ELSE  
        K(N+1,3)=IPA(1) 
      ENDIF 
      IF(IGM.LE.0) THEN 
        DO 160 I=1,NEP  
  160   K(N+I,2)=K(IPA(I),2)    
      ELSEIF(KFLM.NE.21) THEN   
        K(N+1,2)=K(IM,2)    
        K(N+2,2)=K(IM,5)    
      ELSEIF(K(IM,5).EQ.21) THEN    
        K(N+1,2)=21 
        K(N+2,2)=21 
      ELSE  
        K(N+1,2)=K(IM,5)    
        K(N+2,2)=-K(IM,5)   
      ENDIF 
    
C...Reset flags on daughers and tries made. 
      DO 170 IP=1,NEP   
      K(N+IP,1)=3   
      K(N+IP,4)=0   
      K(N+IP,5)=0   
      KFLD(IP)=IABS(K(N+IP,2))  
      ITRY(IP)=0    
      ISL(IP)=0 
      ISI(IP)=0 
  170 IF(KFLD(IP).GT.0.AND.(KFLD(IP).LE.8.OR.KFLD(IP).EQ.21)) ISI(IP)=1 
      ISLM=0    
    
C...Maximum virtuality of daughters.    
      IF(IGM.LE.0) THEN 
        DO 180 I=1,NPA  
        IF(NPA.GE.3) P(N+I,4)=(PS(4)*P(IPA(I),4)-PS(1)*P(IPA(I),1)- 
     &  PS(2)*P(IPA(I),2)-PS(3)*P(IPA(I),3))/PS(5)  
        P(N+I,5)=MIN(QMAX,PS(5))    
        IF(NPA.GE.3) P(N+I,5)=MIN(P(N+I,5),P(N+I,4))    
  180   IF(ISI(I).EQ.0) P(N+I,5)=P(IPA(I),5)    
      ELSE  
        IF(MSTJ(43).LE.2) PEM=V(IM,2)   
        IF(MSTJ(43).GE.3) PEM=P(IM,4)   
        P(N+1,5)=MIN(P(IM,5),V(IM,1)*PEM)   
        P(N+2,5)=MIN(P(IM,5),(1.-V(IM,1))*PEM)  
        IF(K(N+2,2).EQ.22) P(N+2,5)=PMTH(1,22)  
      ENDIF 
      DO 190 I=1,NEP    
      PMSD(I)=P(N+I,5)  
      IF(ISI(I).EQ.1) THEN  
        IF(P(N+I,5).LE.PMTH(3,KFLD(I))) P(N+I,5)=PMTH(1,KFLD(I))    
      ENDIF 
  190 V(N+I,5)=P(N+I,5)**2  
    
C...Choose one of the daughters for evolution.  
  200 INUM=0    
      IF(NEP.EQ.1) INUM=1   
      DO 210 I=1,NEP    
  210 IF(INUM.EQ.0.AND.ISL(I).EQ.1) INUM=I  
      DO 220 I=1,NEP    
      IF(INUM.EQ.0.AND.ITRY(I).EQ.0.AND.ISI(I).EQ.1) THEN   
        IF(P(N+I,5).GE.PMTH(2,KFLD(I))) INUM=I  
      ENDIF 
  220 CONTINUE  
      IF(INUM.EQ.0) THEN    
        RMAX=0. 
        DO 230 I=1,NEP  
        IF(ISI(I).EQ.1.AND.PMSD(I).GE.PMQTH2) THEN  
          RPM=P(N+I,5)/PMSD(I)  
          IF(RPM.GT.RMAX.AND.P(N+I,5).GE.PMTH(2,KFLD(I))) THEN  
            RMAX=RPM    
            INUM=I  
          ENDIF 
        ENDIF   
  230   CONTINUE    
      ENDIF 
    
C...Store information on choice of evolving daughter.   
      INUM=MAX(1,INUM)  
      IEP(1)=N+INUM 
      DO 240 I=2,NEP    
      IEP(I)=IEP(I-1)+1 
  240 IF(IEP(I).GT.N+NEP) IEP(I)=N+1    
      DO 250 I=1,NEP    
  250 KFL(I)=IABS(K(IEP(I),2))  
      ITRY(INUM)=ITRY(INUM)+1   
      IF(ITRY(INUM).GT.200) THEN    
        CALL LUERRM(14,'(LUSHOW:) caught in infinite loop') 
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      Z=0.5 
      IF(KFL(1).EQ.0.OR.(KFL(1).GT.8.AND.KFL(1).NE.21)) GOTO 300    
      IF(P(IEP(1),5).LT.PMTH(2,KFL(1))) GOTO 300    
    
C...Calculate allowed z range.  
      IF(NEP.EQ.1) THEN 
        PMED=PS(4)  
      ELSEIF(IGM.EQ.0.OR.MSTJ(43).LE.2) THEN    
        PMED=P(IM,5)    
      ELSE  
        IF(INUM.EQ.1) PMED=V(IM,1)*PEM  
        IF(INUM.EQ.2) PMED=(1.-V(IM,1))*PEM 
      ENDIF 
      IF(MOD(MSTJ(43),2).EQ.1) THEN 
        ZC=PMTH(2,21)/PMED  
        ZCE=PMTH(2,22)/PMED 
      ELSE  
        ZC=0.5*(1.-SQRT(MAX(0.,1.-(2.*PMTH(2,21)/PMED)**2)))    
        IF(ZC.LT.1E-4) ZC=(PMTH(2,21)/PMED)**2  
        ZCE=0.5*(1.-SQRT(MAX(0.,1.-(2.*PMTH(2,22)/PMED)**2)))   
        IF(ZCE.LT.1E-4) ZCE=(PMTH(2,22)/PMED)**2    
      ENDIF 
      ZC=MIN(ZC,0.491)  
      ZCE=MIN(ZCE,0.491)    
      IF((MSTJ(41).EQ.1.AND.ZC.GT.0.49).OR.(MSTJ(41).EQ.2.AND.  
     &MIN(ZC,ZCE).GT.0.49)) THEN    
        P(IEP(1),5)=PMTH(1,KFL(1))  
        V(IEP(1),5)=P(IEP(1),5)**2  
        GOTO 300    
      ENDIF 
    
C...Integral of Altarelli-Parisi z kernel for QCD.  
      IF(MSTJ(49).EQ.0.AND.KFL(1).EQ.21) THEN   
        FBR=6.*LOG((1.-ZC)/ZC)+MSTJ(45)*(0.5-ZC)    
      ELSEIF(MSTJ(49).EQ.0) THEN    
        FBR=(8./3.)*LOG((1.-ZC)/ZC) 
    
C...Integral of Altarelli-Parisi z kernel for scalar gluon. 
      ELSEIF(MSTJ(49).EQ.1.AND.KFL(1).EQ.21) THEN   
        FBR=(PARJ(87)+MSTJ(45)*PARJ(88))*(1.-2.*ZC) 
      ELSEIF(MSTJ(49).EQ.1) THEN    
        FBR=(1.-2.*ZC)/3.   
        IF(IGM.EQ.0.AND.M3JC.EQ.1) FBR=4.*FBR   
    
C...Integral of Altarelli-Parisi z kernel for Abelian vector gluon. 
      ELSEIF(KFL(1).EQ.21) THEN 
        FBR=6.*MSTJ(45)*(0.5-ZC)    
      ELSE  
        FBR=2.*LOG((1.-ZC)/ZC)  
      ENDIF 
    
C...Integral of Altarelli-Parisi kernel for photon emission.    
      IF(MSTJ(41).EQ.2.AND.KFL(1).GE.1.AND.KFL(1).LE.8) 
     &FBRE=(KCHG(KFL(1),1)/3.)**2*2.*LOG((1.-ZCE)/ZCE)  
    
C...Inner veto algorithm starts. Find maximum mass for evolution.   
  260 PMS=V(IEP(1),5)   
      IF(IGM.GE.0) THEN 
        PM2=0.  
        DO 270 I=2,NEP  
        PM=P(IEP(I),5)  
        IF(KFL(I).GT.0.AND.(KFL(I).LE.8.OR.KFL(I).EQ.21)) PM=   
     &  PMTH(2,KFL(I))  
  270   PM2=PM2+PM  
        PMS=MIN(PMS,(P(IM,5)-PM2)**2)   
      ENDIF 
    
C...Select mass for daughter in QCD evolution.  
      B0=27./6. 
      DO 280 IF=4,MSTJ(45)  
  280 IF(PMS.GT.4.*PMTH(2,IF)**2) B0=(33.-2.*IF)/6. 
      IF(MSTJ(44).LE.0) THEN    
        PMSQCD=PMS*EXP(MAX(-100.,LOG(RLU(0))*PARU(2)/(PARU(111)*FBR)))  
      ELSEIF(MSTJ(44).EQ.1) THEN    
        PMSQCD=4.*ALAMS*(0.25*PMS/ALAMS)**(RLU(0)**(B0/FBR))    
      ELSE  
        PMSQCD=PMS*RLU(0)**(ALFM*B0/FBR)    
      ENDIF 
      IF(ZC.GT.0.49.OR.PMSQCD.LE.PMTH(4,KFL(1))**2) PMSQCD= 
     &PMTH(2,KFL(1))**2 
      V(IEP(1),5)=PMSQCD    
      MCE=1 
    
C...Select mass for daughter in QED evolution.  
      IF(MSTJ(41).EQ.2.AND.KFL(1).GE.1.AND.KFL(1).LE.8) THEN    
        PMSQED=PMS*EXP(MAX(-100.,LOG(RLU(0))*PARU(2)/(PARU(101)*FBRE))) 
        IF(ZCE.GT.0.49.OR.PMSQED.LE.PMTH(5,KFL(1))**2) PMSQED=  
     &  PMTH(2,KFL(1))**2   
        IF(PMSQED.GT.PMSQCD) THEN   
          V(IEP(1),5)=PMSQED    
          MCE=2 
        ENDIF   
      ENDIF 
    
C...Check whether daughter mass below cutoff.   
      P(IEP(1),5)=SQRT(V(IEP(1),5)) 
      IF(P(IEP(1),5).LE.PMTH(3,KFL(1))) THEN    
        P(IEP(1),5)=PMTH(1,KFL(1))  
        V(IEP(1),5)=P(IEP(1),5)**2  
        GOTO 300    
      ENDIF 
    
C...Select z value of branching: q -> qgamma.   
      IF(MCE.EQ.2) THEN 
        Z=1.-(1.-ZCE)*(ZCE/(1.-ZCE))**RLU(0)    
        IF(1.+Z**2.LT.2.*RLU(0)) GOTO 260   
        K(IEP(1),5)=22  
    
C...Select z value of branching: q -> qg, g -> gg, g -> qqbar.  
      ELSEIF(MSTJ(49).NE.1.AND.KFL(1).NE.21) THEN   
        Z=1.-(1.-ZC)*(ZC/(1.-ZC))**RLU(0)   
        IF(1.+Z**2.LT.2.*RLU(0)) GOTO 260   
        K(IEP(1),5)=21  
      ELSEIF(MSTJ(49).EQ.0.AND.MSTJ(45)*(0.5-ZC).LT.RLU(0)*FBR) THEN    
        Z=(1.-ZC)*(ZC/(1.-ZC))**RLU(0)  
        IF(RLU(0).GT.0.5) Z=1.-Z    
        IF((1.-Z*(1.-Z))**2.LT.RLU(0)) GOTO 260 
        K(IEP(1),5)=21  
      ELSEIF(MSTJ(49).NE.1) THEN    
        Z=ZC+(1.-2.*ZC)*RLU(0)  
        IF(Z**2+(1.-Z)**2.LT.RLU(0)) GOTO 260   
        KFLB=1+INT(MSTJ(45)*RLU(0)) 
        PMQ=4.*PMTH(2,KFLB)**2/V(IEP(1),5)  
        IF(PMQ.GE.1.) GOTO 260  
        PMQ0=4.*PMTH(2,21)**2/V(IEP(1),5)   
        IF(MOD(MSTJ(43),2).EQ.0.AND.(1.+0.5*PMQ)*SQRT(1.-PMQ).LT.   
     &  RLU(0)*(1.+0.5*PMQ0)*SQRT(1.-PMQ0)) GOTO 260    
        K(IEP(1),5)=KFLB    
    
C...Ditto for scalar gluon model.   
      ELSEIF(KFL(1).NE.21) THEN 
        Z=1.-SQRT(ZC**2+RLU(0)*(1.-2.*ZC))  
        K(IEP(1),5)=21  
      ELSEIF(RLU(0)*(PARJ(87)+MSTJ(45)*PARJ(88)).LE.PARJ(87)) THEN  
        Z=ZC+(1.-2.*ZC)*RLU(0)  
        K(IEP(1),5)=21  
      ELSE  
        Z=ZC+(1.-2.*ZC)*RLU(0)  
        KFLB=1+INT(MSTJ(45)*RLU(0)) 
        PMQ=4.*PMTH(2,KFLB)**2/V(IEP(1),5)  
        IF(PMQ.GE.1.) GOTO 260  
        K(IEP(1),5)=KFLB    
      ENDIF 
      IF(MCE.EQ.1.AND.MSTJ(44).GE.2) THEN   
        IF(Z*(1.-Z)*V(IEP(1),5).LT.PT2MIN) GOTO 260 
        IF(ALFM/LOG(V(IEP(1),5)*Z*(1.-Z)/ALAMS).LT.RLU(0)) GOTO 260 
      ENDIF 
    
C...Check if z consistent with chosen m.    
      IF(KFL(1).EQ.21) THEN 
        KFLGD1=IABS(K(IEP(1),5))    
        KFLGD2=KFLGD1   
      ELSE  
        KFLGD1=KFL(1)   
        KFLGD2=IABS(K(IEP(1),5))    
      ENDIF 
      IF(NEP.EQ.1) THEN 
        PED=PS(4)   
      ELSEIF(NEP.GE.3) THEN 
        PED=P(IEP(1),4) 
      ELSEIF(IGM.EQ.0.OR.MSTJ(43).LE.2) THEN    
        PED=0.5*(V(IM,5)+V(IEP(1),5)-PM2**2)/P(IM,5)    
      ELSE  
        IF(IEP(1).EQ.N+1) PED=V(IM,1)*PEM   
        IF(IEP(1).EQ.N+2) PED=(1.-V(IM,1))*PEM  
      ENDIF 
      IF(MOD(MSTJ(43),2).EQ.1) THEN 
        PMQTH3=0.5*PARJ(82) 
        IF(KFLGD2.EQ.22) PMQTH3=0.5*PARJ(83)    
        PMQ1=(PMTH(1,KFLGD1)**2+PMQTH3**2)/V(IEP(1),5)  
        PMQ2=(PMTH(1,KFLGD2)**2+PMQTH3**2)/V(IEP(1),5)  
        ZD=SQRT(MAX(0.,(1.-V(IEP(1),5)/PED**2)*((1.-PMQ1-PMQ2)**2-  
     &  4.*PMQ1*PMQ2))) 
        ZH=1.+PMQ1-PMQ2 
      ELSE  
        ZD=SQRT(MAX(0.,1.-V(IEP(1),5)/PED**2))  
        ZH=1.   
      ENDIF 
      ZL=0.5*(ZH-ZD)    
      ZU=0.5*(ZH+ZD)    
      IF(Z.LT.ZL.OR.Z.GT.ZU) GOTO 260   
      IF(KFL(1).EQ.21) V(IEP(1),3)=LOG(ZU*(1.-ZL)/MAX(1E-20,ZL* 
     &(1.-ZU))) 
      IF(KFL(1).NE.21) V(IEP(1),3)=LOG((1.-ZL)/MAX(1E-10,1.-ZU))    
    
C...Three-jet matrix element correction.    
      IF(IGM.EQ.0.AND.M3JC.EQ.1) THEN   
        X1=Z*(1.+V(IEP(1),5)/V(NS+1,5)) 
        X2=1.-V(IEP(1),5)/V(NS+1,5) 
        X3=(1.-X1)+(1.-X2)  
        IF(MCE.EQ.2) THEN   
          KI1=K(IPA(INUM),2)    
          KI2=K(IPA(3-INUM),2)  
          QF1=KCHG(IABS(KI1),1)*ISIGN(1,KI1)/3. 
          QF2=KCHG(IABS(KI2),1)*ISIGN(1,KI2)/3. 
          WSHOW=QF1**2*(1.-X1)/X3*(1.+(X1/(2.-X2))**2)+ 
     &    QF2**2*(1.-X2)/X3*(1.+(X2/(2.-X1))**2)    
          WME=(QF1*(1.-X1)/X3-QF2*(1.-X2)/X3)**2*(X1**2+X2**2)  
        ELSEIF(MSTJ(49).NE.1) THEN  
          WSHOW=1.+(1.-X1)/X3*(X1/(2.-X2))**2+  
     &    (1.-X2)/X3*(X2/(2.-X1))**2    
          WME=X1**2+X2**2   
        ELSE    
          WSHOW=4.*X3*((1.-X1)/(2.-X2)**2+(1.-X2)/(2.-X1)**2)   
          WME=X3**2 
        ENDIF   
        IF(WME.LT.RLU(0)*WSHOW) GOTO 260    
    
C...Impose angular ordering by rejection of nonordered emission.    
      ELSEIF(MCE.EQ.1.AND.IGM.GT.0.AND.MSTJ(42).GE.2) THEN  
        MAOM=1  
        ZM=V(IM,1)  
        IF(IEP(1).EQ.N+2) ZM=1.-V(IM,1) 
        THE2ID=Z*(1.-Z)*(ZM*P(IM,4))**2/V(IEP(1),5) 
        IAOM=IM 
  290   IF(K(IAOM,5).EQ.22) THEN    
          IAOM=K(IAOM,3)    
          IF(K(IAOM,3).LE.NS) MAOM=0    
          IF(MAOM.EQ.1) GOTO 290    
        ENDIF   
        IF(MAOM.EQ.1) THEN  
          THE2IM=V(IAOM,1)*(1.-V(IAOM,1))*P(IAOM,4)**2/V(IAOM,5)    
          IF(THE2ID.LT.THE2IM) GOTO 260 
        ENDIF   
      ENDIF 
    
C...Impose user-defined maximum angle at first branching.   
      IF(MSTJ(48).EQ.1) THEN    
        IF(NEP.EQ.1.AND.IM.EQ.NS) THEN  
          THE2ID=Z*(1.-Z)*PS(4)**2/V(IEP(1),5)  
          IF(THE2ID.LT.1./PARJ(85)**2) GOTO 260 
        ELSEIF(NEP.EQ.2.AND.IEP(1).EQ.NS+2) THEN    
          THE2ID=Z*(1.-Z)*(0.5*P(IM,4))**2/V(IEP(1),5)  
          IF(THE2ID.LT.1./PARJ(85)**2) GOTO 260 
        ELSEIF(NEP.EQ.2.AND.IEP(1).EQ.NS+3) THEN    
          THE2ID=Z*(1.-Z)*(0.5*P(IM,4))**2/V(IEP(1),5)  
          IF(THE2ID.LT.1./PARJ(86)**2) GOTO 260 
        ENDIF   
      ENDIF 
    
C...End of inner veto algorithm. Check if only one leg evolved so far.  
  300 V(IEP(1),1)=Z 
      ISL(1)=0  
      ISL(2)=0  
      IF(NEP.EQ.1) GOTO 330 
      IF(NEP.EQ.2.AND.P(IEP(1),5)+P(IEP(2),5).GE.P(IM,5)) GOTO 200  
      DO 310 I=1,NEP    
      IF(ITRY(I).EQ.0.AND.KFLD(I).GT.0.AND.(KFLD(I).LE.8.OR.KFLD(I).EQ. 
     &21)) THEN 
        IF(P(N+I,5).GE.PMTH(2,KFLD(I))) GOTO 200    
      ENDIF 
  310 CONTINUE  
    
C...Check if chosen multiplet m1,m2,z1,z2 is physical.  
      IF(NEP.EQ.3) THEN 
        PA1S=(P(N+1,4)+P(N+1,5))*(P(N+1,4)-P(N+1,5))    
        PA2S=(P(N+2,4)+P(N+2,5))*(P(N+2,4)-P(N+2,5))    
        PA3S=(P(N+3,4)+P(N+3,5))*(P(N+3,4)-P(N+3,5))    
        PTS=0.25*(2.*PA1S*PA2S+2.*PA1S*PA3S+2.*PA2S*PA3S-   
     &  PA1S**2-PA2S**2-PA3S**2)/PA1S   
        IF(PTS.LE.0.) GOTO 200  
      ELSEIF(IGM.EQ.0.OR.MSTJ(43).LE.2.OR.MOD(MSTJ(43),2).EQ.0) THEN    
        DO 320 I1=N+1,N+2   
        KFLDA=IABS(K(I1,2)) 
        IF(KFLDA.EQ.0.OR.(KFLDA.GT.8.AND.KFLDA.NE.21)) GOTO 320 
        IF(P(I1,5).LT.PMTH(2,KFLDA)) GOTO 320   
        IF(KFLDA.EQ.21) THEN    
          KFLGD1=IABS(K(I1,5))  
          KFLGD2=KFLGD1 
        ELSE    
          KFLGD1=KFLDA  
          KFLGD2=IABS(K(I1,5))  
        ENDIF   
        I2=2*N+3-I1 
        IF(IGM.EQ.0.OR.MSTJ(43).LE.2) THEN  
          PED=0.5*(V(IM,5)+V(I1,5)-V(I2,5))/P(IM,5) 
        ELSE    
          IF(I1.EQ.N+1) ZM=V(IM,1)  
          IF(I1.EQ.N+2) ZM=1.-V(IM,1)   
          PML=SQRT((V(IM,5)-V(N+1,5)-V(N+2,5))**2-  
     &    4.*V(N+1,5)*V(N+2,5)) 
          PED=PEM*(0.5*(V(IM,5)-PML+V(I1,5)-V(I2,5))+PML*ZM)/V(IM,5)    
        ENDIF   
        IF(MOD(MSTJ(43),2).EQ.1) THEN   
          PMQTH3=0.5*PARJ(82)   
          IF(KFLGD2.EQ.22) PMQTH3=0.5*PARJ(83)  
          PMQ1=(PMTH(1,KFLGD1)**2+PMQTH3**2)/V(I1,5)    
          PMQ2=(PMTH(1,KFLGD2)**2+PMQTH3**2)/V(I1,5)    
          ZD=SQRT(MAX(0.,(1.-V(I1,5)/PED**2)*((1.-PMQ1-PMQ2)**2-    
     &    4.*PMQ1*PMQ2)))   
          ZH=1.+PMQ1-PMQ2   
        ELSE    
          ZD=SQRT(MAX(0.,1.-V(I1,5)/PED**2))    
          ZH=1. 
        ENDIF   
        ZL=0.5*(ZH-ZD)  
        ZU=0.5*(ZH+ZD)  
        IF(I1.EQ.N+1.AND.(V(I1,1).LT.ZL.OR.V(I1,1).GT.ZU)) ISL(1)=1 
        IF(I1.EQ.N+2.AND.(V(I1,1).LT.ZL.OR.V(I1,1).GT.ZU)) ISL(2)=1 
        IF(KFLDA.EQ.21) V(I1,4)=LOG(ZU*(1.-ZL)/MAX(1E-20,ZL*(1.-ZU)))   
        IF(KFLDA.NE.21) V(I1,4)=LOG((1.-ZL)/MAX(1E-10,1.-ZU))   
  320   CONTINUE    
        IF(ISL(1).EQ.1.AND.ISL(2).EQ.1.AND.ISLM.NE.0) THEN  
          ISL(3-ISLM)=0 
          ISLM=3-ISLM   
        ELSEIF(ISL(1).EQ.1.AND.ISL(2).EQ.1) THEN    
          ZDR1=MAX(0.,V(N+1,3)/V(N+1,4)-1.) 
          ZDR2=MAX(0.,V(N+2,3)/V(N+2,4)-1.) 
          IF(ZDR2.GT.RLU(0)*(ZDR1+ZDR2)) ISL(1)=0   
          IF(ISL(1).EQ.1) ISL(2)=0  
          IF(ISL(1).EQ.0) ISLM=1    
          IF(ISL(2).EQ.0) ISLM=2    
        ENDIF   
        IF(ISL(1).EQ.1.OR.ISL(2).EQ.1) GOTO 200 
      ENDIF 
      IF(IGM.GT.0.AND.MOD(MSTJ(43),2).EQ.1.AND.(P(N+1,5).GE.    
     &PMTH(2,KFLD(1)).OR.P(N+2,5).GE.PMTH(2,KFLD(2)))) THEN 
        PMQ1=V(N+1,5)/V(IM,5)   
        PMQ2=V(N+2,5)/V(IM,5)   
        ZD=SQRT(MAX(0.,(1.-V(IM,5)/PEM**2)*((1.-PMQ1-PMQ2)**2-  
     &  4.*PMQ1*PMQ2))) 
        ZH=1.+PMQ1-PMQ2 
        ZL=0.5*(ZH-ZD)  
        ZU=0.5*(ZH+ZD)  
        IF(V(IM,1).LT.ZL.OR.V(IM,1).GT.ZU) GOTO 200 
      ENDIF 
    
C...Accepted branch. Construct four-momentum for initial partons.   
  330 MAZIP=0   
      MAZIC=0   
      IF(NEP.EQ.1) THEN 
        P(N+1,1)=0. 
        P(N+1,2)=0. 
        P(N+1,3)=SQRT(MAX(0.,(P(IPA(1),4)+P(N+1,5))*(P(IPA(1),4)-   
     &  P(N+1,5)))) 
        P(N+1,4)=P(IPA(1),4)    
        V(N+1,2)=P(N+1,4)   
      ELSEIF(IGM.EQ.0.AND.NEP.EQ.2) THEN    
        PED1=0.5*(V(IM,5)+V(N+1,5)-V(N+2,5))/P(IM,5)    
        P(N+1,1)=0. 
        P(N+1,2)=0. 
        P(N+1,3)=SQRT(MAX(0.,(PED1+P(N+1,5))*(PED1-P(N+1,5))))  
        P(N+1,4)=PED1   
        P(N+2,1)=0. 
        P(N+2,2)=0. 
        P(N+2,3)=-P(N+1,3)  
        P(N+2,4)=P(IM,5)-PED1   
        V(N+1,2)=P(N+1,4)   
        V(N+2,2)=P(N+2,4)   
      ELSEIF(NEP.EQ.3) THEN 
        P(N+1,1)=0. 
        P(N+1,2)=0. 
        P(N+1,3)=SQRT(MAX(0.,PA1S)) 
        P(N+2,1)=SQRT(PTS)  
        P(N+2,2)=0. 
        P(N+2,3)=0.5*(PA3S-PA2S-PA1S)/P(N+1,3)  
        P(N+3,1)=-P(N+2,1)  
        P(N+3,2)=0. 
        P(N+3,3)=-(P(N+1,3)+P(N+2,3))   
        V(N+1,2)=P(N+1,4)   
        V(N+2,2)=P(N+2,4)   
        V(N+3,2)=P(N+3,4)   
    
C...Construct transverse momentum for ordinary branching in shower. 
      ELSE  
        ZM=V(IM,1)  
        PZM=SQRT(MAX(0.,(PEM+P(IM,5))*(PEM-P(IM,5))))   
        PMLS=(V(IM,5)-V(N+1,5)-V(N+2,5))**2-4.*V(N+1,5)*V(N+2,5)    
        IF(PZM.LE.0.) THEN  
          PTS=0.    
        ELSEIF(MOD(MSTJ(43),2).EQ.1) THEN   
          PTS=(PEM**2*(ZM*(1.-ZM)*V(IM,5)-(1.-ZM)*V(N+1,5)- 
     &    ZM*V(N+2,5))-0.25*PMLS)/PZM**2    
        ELSE    
          PTS=PMLS*(ZM*(1.-ZM)*PEM**2/V(IM,5)-0.25)/PZM**2  
        ENDIF   
        PT=SQRT(MAX(0.,PTS))    
    
C...Find coefficient of azimuthal asymmetry due to gluon polarization.  
        HAZIP=0.    
        IF(MSTJ(49).NE.1.AND.MOD(MSTJ(46),2).EQ.1.AND.K(IM,2).EQ.21.    
     &  AND.IAU.NE.0) THEN  
          IF(K(IGM,3).NE.0) MAZIP=1 
          ZAU=V(IGM,1)  
          IF(IAU.EQ.IM+1) ZAU=1.-V(IGM,1)   
          IF(MAZIP.EQ.0) ZAU=0. 
          IF(K(IGM,2).NE.21) THEN   
            HAZIP=2.*ZAU/(1.+ZAU**2)    
          ELSE  
            HAZIP=(ZAU/(1.-ZAU*(1.-ZAU)))**2    
          ENDIF 
          IF(K(N+1,2).NE.21) THEN   
            HAZIP=HAZIP*(-2.*ZM*(1.-ZM))/(1.-2.*ZM*(1.-ZM)) 
          ELSE  
            HAZIP=HAZIP*(ZM*(1.-ZM)/(1.-ZM*(1.-ZM)))**2 
          ENDIF 
        ENDIF   
    
C...Find coefficient of azimuthal asymmetry due to soft gluon   
C...interference.   
        HAZIC=0.    
        IF(MSTJ(46).GE.2.AND.(K(N+1,2).EQ.21.OR.K(N+2,2).EQ.21).    
     &  AND.IAU.NE.0) THEN  
          IF(K(IGM,3).NE.0) MAZIC=N+1   
          IF(K(IGM,3).NE.0.AND.K(N+1,2).NE.21) MAZIC=N+2    
          IF(K(IGM,3).NE.0.AND.K(N+1,2).EQ.21.AND.K(N+2,2).EQ.21.AND.   
     &    ZM.GT.0.5) MAZIC=N+2  
          IF(K(IAU,2).EQ.22) MAZIC=0    
          ZS=ZM 
          IF(MAZIC.EQ.N+2) ZS=1.-ZM 
          ZGM=V(IGM,1)  
          IF(IAU.EQ.IM-1) ZGM=1.-V(IGM,1)   
          IF(MAZIC.EQ.0) ZGM=1. 
          HAZIC=(P(IM,5)/P(IGM,5))*SQRT((1.-ZS)*(1.-ZGM)/(ZS*ZGM))  
          HAZIC=MIN(0.95,HAZIC) 
        ENDIF   
      ENDIF 
    
C...Construct kinematics for ordinary branching in shower.  
  340 IF(NEP.EQ.2.AND.IGM.GT.0) THEN    
        IF(MOD(MSTJ(43),2).EQ.1) THEN   
          P(N+1,4)=PEM*V(IM,1)  
        ELSE    
          P(N+1,4)=PEM*(0.5*(V(IM,5)-SQRT(PMLS)+V(N+1,5)-V(N+2,5))+ 
     &    SQRT(PMLS)*ZM)/V(IM,5)    
        ENDIF   
        PHI=PARU(2)*RLU(0)  
        P(N+1,1)=PT*COS(PHI)    
        P(N+1,2)=PT*SIN(PHI)    
        IF(PZM.GT.0.) THEN  
          P(N+1,3)=0.5*(V(N+2,5)-V(N+1,5)-V(IM,5)+2.*PEM*P(N+1,4))/PZM  
        ELSE    
          P(N+1,3)=0.   
        ENDIF   
        P(N+2,1)=-P(N+1,1)  
        P(N+2,2)=-P(N+1,2)  
        P(N+2,3)=PZM-P(N+1,3)   
        P(N+2,4)=PEM-P(N+1,4)   
        IF(MSTJ(43).LE.2) THEN  
          V(N+1,2)=(PEM*P(N+1,4)-PZM*P(N+1,3))/P(IM,5)  
          V(N+2,2)=(PEM*P(N+2,4)-PZM*P(N+2,3))/P(IM,5)  
        ENDIF   
      ENDIF 
    
C...Rotate and boost daughters. 
      IF(IGM.GT.0) THEN 
        IF(MSTJ(43).LE.2) THEN  
          BEX=P(IGM,1)/P(IGM,4) 
          BEY=P(IGM,2)/P(IGM,4) 
          BEZ=P(IGM,3)/P(IGM,4) 
          GA=P(IGM,4)/P(IGM,5)  
          GABEP=GA*(GA*(BEX*P(IM,1)+BEY*P(IM,2)+BEZ*P(IM,3))/(1.+GA)-   
     &    P(IM,4))  
        ELSE    
          BEX=0.    
          BEY=0.    
          BEZ=0.    
          GA=1. 
          GABEP=0.  
        ENDIF   
        THE=ULANGL(P(IM,3)+GABEP*BEZ,SQRT((P(IM,1)+GABEP*BEX)**2+   
     &  (P(IM,2)+GABEP*BEY)**2))    
        PHI=ULANGL(P(IM,1)+GABEP*BEX,P(IM,2)+GABEP*BEY) 
        DO 350 I=N+1,N+2    
        DP(1)=dble(COS(THE)*COS(PHI)*P(I,1)-SIN(PHI)*P(I,2)+ 
     &  SIN(THE)*COS(PHI)*P(I,3))
        DP(2)=dble(COS(THE)*SIN(PHI)*P(I,1)+COS(PHI)*P(I,2)+ 
     &  SIN(THE)*SIN(PHI)*P(I,3))
        DP(3)=dble(-SIN(THE)*P(I,1)+COS(THE)*P(I,3))
        DP(4)=dble(P(I,4))
        DBP=dble(BEX)*DP(1)+dble(BEY)*DP(2)+dble(BEZ)*DP(3)   
        DGABP=dble(GA)*(dble(GA)*DBP/(1D0+dble(GA))+DP(4))    
        P(I,1)=sngl(DP(1)+DGABP*dble(BEX))
        P(I,2)=sngl(DP(2)+DGABP*dble(BEY))
        P(I,3)=sngl(DP(3)+DGABP*dble(BEZ))
  350   P(I,4)=GA*sngl(DP(4)+DBP)   
      ENDIF 
    
C...Weight with azimuthal distribution, if required.    
      IF(MAZIP.NE.0.OR.MAZIC.NE.0) THEN 
        DO 360 J=1,3    
        DPT(1,J)=dble(P(IM,J))
        DPT(2,J)=dble(P(IAU,J))  
  360   DPT(3,J)=dble(P(N+1,J))
        DPMA=DPT(1,1)*DPT(2,1)+DPT(1,2)*DPT(2,2)+DPT(1,3)*DPT(2,3)  
        DPMD=DPT(1,1)*DPT(3,1)+DPT(1,2)*DPT(3,2)+DPT(1,3)*DPT(3,3)  
        DPMM=DPT(1,1)**2+DPT(1,2)**2+DPT(1,3)**2    
        DO 370 J=1,3    
        DPT(4,J)=DPT(2,J)-DPMA*DPT(1,J)/DPMM    
  370   DPT(5,J)=DPT(3,J)-DPMD*DPT(1,J)/DPMM    
        DPT(4,4)=DSQRT(DPT(4,1)**2+DPT(4,2)**2+DPT(4,3)**2)  
        DPT(5,4)=DSQRT(DPT(5,1)**2+DPT(5,2)**2+DPT(5,3)**2)  
clin-5/2012:
c        IF(MIN(DPT(4,4),DPT(5,4)).GT.0.1*PARJ(82)) THEN 
        IF(sngl(MIN(DPT(4,4),DPT(5,4))).GT.(0.1*PARJ(82))) THEN 
           CAD=sngl((DPT(4,1)*DPT(5,1)+DPT(4,2)*DPT(5,2)+ 
     &    DPT(4,3)*DPT(5,3))/(DPT(4,4)*DPT(5,4)))
          IF(MAZIP.NE.0) THEN   
            IF(1.+HAZIP*(2.*CAD**2-1.).LT.RLU(0)*(1.+ABS(HAZIP)))   
     &      GOTO 340    
          ENDIF 
          IF(MAZIC.NE.0) THEN   
            IF(MAZIC.EQ.N+2) CAD=-CAD   
            IF((1.-HAZIC)*(1.-HAZIC*CAD)/(1.+HAZIC**2-2.*HAZIC*CAD).    
     &      LT.RLU(0)) GOTO 340 
          ENDIF 
        ENDIF   
      ENDIF 
    
C...Continue loop over partons that may branch, until none left.    
      IF(IGM.GE.0) K(IM,1)=14   
      N=N+NEP   
      NEP=2 
      IF(N.GT.MSTU(4)-MSTU(32)-5) THEN  
        CALL LUERRM(11,'(LUSHOW:) no more memory left in LUJETS')   
        IF(MSTU(21).GE.1) N=NS  
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      GOTO 140  
    
C...Set information on imagined shower initiator.   
  380 IF(NPA.GE.2) THEN 
        K(NS+1,1)=11    
        K(NS+1,2)=94    
        K(NS+1,3)=IP1   
        IF(IP2.GT.0.AND.IP2.LT.IP1) K(NS+1,3)=IP2   
        K(NS+1,4)=NS+2  
        K(NS+1,5)=NS+1+NPA  
        IIM=1   
      ELSE  
        IIM=0   
      ENDIF 
    
C...Reconstruct string drawing information. 
      DO 390 I=NS+1+IIM,N   
      IF(K(I,1).LE.10.AND.K(I,2).EQ.22) THEN    
        K(I,1)=1    
      ELSEIF(K(I,1).LE.10) THEN 
        K(I,4)=MSTU(5)*(K(I,4)/MSTU(5)) 
        K(I,5)=MSTU(5)*(K(I,5)/MSTU(5)) 
      ELSEIF(K(MOD(K(I,4),MSTU(5))+1,2).NE.22) THEN 
        ID1=MOD(K(I,4),MSTU(5)) 
        IF(K(I,2).GE.1.AND.K(I,2).LE.8) ID1=MOD(K(I,4),MSTU(5))+1   
        ID2=2*MOD(K(I,4),MSTU(5))+1-ID1 
        K(I,4)=MSTU(5)*(K(I,4)/MSTU(5))+ID1 
        K(I,5)=MSTU(5)*(K(I,5)/MSTU(5))+ID2 
        K(ID1,4)=K(ID1,4)+MSTU(5)*I 
        K(ID1,5)=K(ID1,5)+MSTU(5)*ID2   
        K(ID2,4)=K(ID2,4)+MSTU(5)*ID1   
        K(ID2,5)=K(ID2,5)+MSTU(5)*I 
      ELSE  
        ID1=MOD(K(I,4),MSTU(5)) 
        ID2=ID1+1   
        K(I,4)=MSTU(5)*(K(I,4)/MSTU(5))+ID1 
        K(I,5)=MSTU(5)*(K(I,5)/MSTU(5))+ID1 
        K(ID1,4)=K(ID1,4)+MSTU(5)*I 
        K(ID1,5)=K(ID1,5)+MSTU(5)*I 
        K(ID2,4)=0  
        K(ID2,5)=0  
      ENDIF 
  390 CONTINUE  
    
C...Transformation from CM frame.   
      IF(NPA.GE.2) THEN 
        BEX=PS(1)/PS(4) 
        BEY=PS(2)/PS(4) 
        BEZ=PS(3)/PS(4) 
        GA=PS(4)/PS(5)  
        GABEP=GA*(GA*(BEX*P(IPA(1),1)+BEY*P(IPA(1),2)+BEZ*P(IPA(1),3))  
     &  /(1.+GA)-P(IPA(1),4))   
      ELSE  
        BEX=0.  
        BEY=0.  
        BEZ=0.  
        GABEP=0.    
      ENDIF 
      THE=ULANGL(P(IPA(1),3)+GABEP*BEZ,SQRT((P(IPA(1),1)    
     &+GABEP*BEX)**2+(P(IPA(1),2)+GABEP*BEY)**2))   
      PHI=ULANGL(P(IPA(1),1)+GABEP*BEX,P(IPA(1),2)+GABEP*BEY)   
      IF(NPA.EQ.3) THEN 
        CHI=ULANGL(COS(THE)*COS(PHI)*(P(IPA(2),1)+GABEP*BEX)+COS(THE)*  
     &  SIN(PHI)*(P(IPA(2),2)+GABEP*BEY)-SIN(THE)*(P(IPA(2),3)+GABEP*   
     &  BEZ),-SIN(PHI)*(P(IPA(2),1)+GABEP*BEX)+COS(PHI)*(P(IPA(2),2)+   
     &  GABEP*BEY)) 
        CALL LUDBRB(NS+1,N,0.,CHI,0D0,0D0,0D0)  
      ENDIF 
      DBEX=DBLE(BEX)    
      DBEY=DBLE(BEY)    
      DBEZ=DBLE(BEZ)    
      CALL LUDBRB(NS+1,N,THE,PHI,DBEX,DBEY,DBEZ)    
    
C...Decay vertex of shower. 
      DO 400 I=NS+1,N   
      DO 400 J=1,5  
  400 V(I,J)=V(IP1,J)   
    
C...Delete trivial shower, else connect initiators. 
      IF(N.EQ.NS+NPA+IIM) THEN  
        N=NS    
      ELSE  
        DO 410 IP=1,NPA 
        K(IPA(IP),1)=14 
        K(IPA(IP),4)=K(IPA(IP),4)+NS+IIM+IP 
        K(IPA(IP),5)=K(IPA(IP),5)+NS+IIM+IP 
        K(NS+IIM+IP,3)=IPA(IP)  
        IF(IIM.EQ.1.AND.MSTU(16).NE.2) K(NS+IIM+IP,3)=NS+1  
        K(NS+IIM+IP,4)=MSTU(5)*IPA(IP)+K(NS+IIM+IP,4)   
  410   K(NS+IIM+IP,5)=MSTU(5)*IPA(IP)+K(NS+IIM+IP,5)   
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUBOEI(NSAV)   
    
C...Purpose: to modify event so as to approximately take into account   
C...Bose-Einstein effects according to a simple phenomenological    
C...parametrization.    
      IMPLICIT DOUBLE PRECISION(D)  
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      DIMENSION DPS(4),KFBE(9),NBE(0:9),BEI(100)    
      DATA KFBE/211,-211,111,321,-321,130,310,221,331/  
    
C...Boost event to overall CM frame. Calculate CM energy.   
      IF((MSTJ(51).NE.1.AND.MSTJ(51).NE.2).OR.N-NSAV.LE.1) RETURN   
      DO 100 J=1,4  
  100 DPS(J)=0.d0
      DO 120 I=1,N  
      IF(K(I,1).LE.0.OR.K(I,1).GT.10) GOTO 120  
      DO 110 J=1,4  
  110 DPS(J)=DPS(J)+dble(P(I,J))
  120 CONTINUE  
      CALL LUDBRB(0,0,0.,0.,-DPS(1)/DPS(4),-DPS(2)/DPS(4),  
     &-DPS(3)/DPS(4))   
      PECM=0.   
      DO 130 I=1,N  
  130 IF(K(I,1).GE.1.AND.K(I,1).LE.10) PECM=PECM+P(I,4) 
    
C...Reserve copy of particles by species at end of record.  
      NBE(0)=N+MSTU(3)  
      DO 160 IBE=1,MIN(9,MSTJ(51))  
      NBE(IBE)=NBE(IBE-1)   
      DO 150 I=NSAV+1,N 
      IF(K(I,2).NE.KFBE(IBE)) GOTO 150  
      IF(K(I,1).LE.0.OR.K(I,1).GT.10) GOTO 150  
      IF(NBE(IBE).GE.MSTU(4)-MSTU(32)-5) THEN   
        CALL LUERRM(11,'(LUBOEI:) no more memory left in LUJETS')   
        RETURN  
      ENDIF 
      NBE(IBE)=NBE(IBE)+1   
      K(NBE(IBE),1)=I   
      DO 140 J=1,3  
  140 P(NBE(IBE),J)=0.  
  150 CONTINUE  
  160 CONTINUE  
    
C...Tabulate integral for subsequent momentum shift.    
      DO 210 IBE=1,MIN(9,MSTJ(51))  
      IF(IBE.NE.1.AND.IBE.NE.4.AND.IBE.LE.7) GOTO 180   
      IF(IBE.EQ.1.AND.MAX(NBE(1)-NBE(0),NBE(2)-NBE(1),NBE(3)-NBE(2)).   
     &LE.1) GOTO 180    
      IF(IBE.EQ.4.AND.MAX(NBE(4)-NBE(3),NBE(5)-NBE(4),NBE(6)-NBE(5),    
     &NBE(7)-NBE(6)).LE.1) GOTO 180 
      IF(IBE.GE.8.AND.NBE(IBE)-NBE(IBE-1).LE.1) GOTO 180    
      IF(IBE.EQ.1) PMHQ=2.*ULMASS(211)  
      IF(IBE.EQ.4) PMHQ=2.*ULMASS(321)  
      IF(IBE.EQ.8) PMHQ=2.*ULMASS(221)  
      IF(IBE.EQ.9) PMHQ=2.*ULMASS(331)  
      QDEL=0.1*MIN(PMHQ,PARJ(93))   
      IF(MSTJ(51).EQ.1) THEN    
        NBIN=MIN(100,NINT(9.*PARJ(93)/QDEL))    
        BEEX=EXP(0.5*QDEL/PARJ(93)) 
        BERT=EXP(-QDEL/PARJ(93))    
      ELSE  
        NBIN=MIN(100,NINT(3.*PARJ(93)/QDEL))    
      ENDIF 
      DO 170 IBIN=1,NBIN    
      QBIN=QDEL*(IBIN-0.5)  
      BEI(IBIN)=QDEL*(QBIN**2+QDEL**2/12.)/SQRT(QBIN**2+PMHQ**2)    
      IF(MSTJ(51).EQ.1) THEN    
        BEEX=BEEX*BERT  
        BEI(IBIN)=BEI(IBIN)*BEEX    
      ELSE  
        BEI(IBIN)=BEI(IBIN)*EXP(-(QBIN/PARJ(93))**2)    
      ENDIF 
  170 IF(IBIN.GE.2) BEI(IBIN)=BEI(IBIN)+BEI(IBIN-1) 
    
C...Loop through particle pairs and find old relative momentum. 
  180 DO 200 I1M=NBE(IBE-1)+1,NBE(IBE)-1    
      I1=K(I1M,1)   
      DO 200 I2M=I1M+1,NBE(IBE) 
      I2=K(I2M,1)   
      Q2OLD=MAX(0.,(P(I1,4)+P(I2,4))**2-(P(I1,1)+P(I2,1))**2-(P(I1,2)+  
     &P(I2,2))**2-(P(I1,3)+P(I2,3))**2-(P(I1,5)+P(I2,5))**2)    
      QOLD=SQRT(Q2OLD)  
    
C...Calculate new relative momentum.    
      IF(QOLD.LT.0.5*QDEL) THEN 
        QMOV=QOLD/3.    
      ELSEIF(QOLD.LT.(NBIN-0.1)*QDEL) THEN  
        RBIN=QOLD/QDEL  
        IBIN=int(RBIN)
        RINP=(RBIN**3-IBIN**3)/(3*IBIN*(IBIN+1)+1)  
        QMOV=(BEI(IBIN)+RINP*(BEI(IBIN+1)-BEI(IBIN)))*  
     &  SQRT(Q2OLD+PMHQ**2)/Q2OLD   
      ELSE  
        QMOV=BEI(NBIN)*SQRT(Q2OLD+PMHQ**2)/Q2OLD    
      ENDIF 
      Q2NEW=Q2OLD*(QOLD/(QOLD+3.*PARJ(92)*QMOV))**(2./3.)   
    
C...Calculate and save shift to be performed on three-momenta.  
      HC1=(P(I1,4)+P(I2,4))**2-(Q2OLD-Q2NEW)    
      HC2=(Q2OLD-Q2NEW)*(P(I1,4)-P(I2,4))**2    
      HA=0.5*(1.-SQRT(HC1*Q2NEW/(HC1*Q2OLD-HC2)))   
      DO 190 J=1,3  
      PD=HA*(P(I2,J)-P(I1,J))   
      P(I1M,J)=P(I1M,J)+PD  
  190 P(I2M,J)=P(I2M,J)-PD  
  200 CONTINUE  
  210 CONTINUE  
    
C...Shift momenta and recalculate energies. 
      DO 230 IM=NBE(0)+1,NBE(MIN(9,MSTJ(51)))   
      I=K(IM,1) 
      DO 220 J=1,3  
  220 P(I,J)=P(I,J)+P(IM,J) 
  230 P(I,4)=SQRT(P(I,5)**2+P(I,1)**2+P(I,2)**2+P(I,3)**2)  
    
C...Rescale all momenta for energy conservation.    
      PES=0.    
      PQS=0.    
      DO 240 I=1,N  
      IF(K(I,1).LE.0.OR.K(I,1).GT.10) GOTO 240  
      PES=PES+P(I,4)    
      PQS=PQS+P(I,5)**2/P(I,4)  
  240 CONTINUE  
      FAC=(PECM-PQS)/(PES-PQS)  
      DO 260 I=1,N  
      IF(K(I,1).LE.0.OR.K(I,1).GT.10) GOTO 260  
      DO 250 J=1,3  
  250 P(I,J)=FAC*P(I,J) 
      P(I,4)=SQRT(P(I,5)**2+P(I,1)**2+P(I,2)**2+P(I,3)**2)  
  260 CONTINUE  
    
C...Boost back to correct reference frame.  
      CALL LUDBRB(0,0,0.,0.,DPS(1)/DPS(4),DPS(2)/DPS(4),DPS(3)/DPS(4))  
    
      RETURN    
      END   
    
C*********************************************************************  
    
      FUNCTION ULMASS(KF)   
    
C...Purpose: to give the mass of a particle/parton. 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
    
C...Reset variables. Compressed code.   
      ULMASS=0. 
      KFA=IABS(KF)  
      KC=LUCOMP(KF) 
      IF(KC.EQ.0) RETURN    
      PARF(106)=PMAS(6,1)   
      PARF(107)=PMAS(7,1)   
      PARF(108)=PMAS(8,1)   
    
C...Guarantee use of constituent masses for internal checks.    
      IF((MSTJ(93).EQ.1.OR.MSTJ(93).EQ.2).AND.KFA.LE.10) THEN   
        ULMASS=PARF(100+KFA)    
        IF(MSTJ(93).EQ.2) ULMASS=MAX(0.,ULMASS-PARF(121))   
    
C...Masses that can be read directly off table. 
      ELSEIF(KFA.LE.100.OR.KC.LE.80.OR.KC.GT.100) THEN  
        ULMASS=PMAS(KC,1)   
    
C...Find constituent partons and their masses.  
      ELSE  
        KFLA=MOD(KFA/1000,10)   
        KFLB=MOD(KFA/100,10)    
        KFLC=MOD(KFA/10,10) 
        KFLS=MOD(KFA,10)    
        KFLR=MOD(KFA/10000,10)  
        PMA=PARF(100+KFLA)  
        PMB=PARF(100+KFLB)  
        PMC=PARF(100+KFLC)  
    
C...Construct masses for various meson, diquark and baryon cases.   
        IF(KFLA.EQ.0.AND.KFLR.EQ.0.AND.KFLS.LE.3) THEN  
          IF(KFLS.EQ.1) PMSPL=-3./(PMB*PMC) 
          IF(KFLS.GE.3) PMSPL=1./(PMB*PMC)  
          ULMASS=PARF(111)+PMB+PMC+PARF(113)*PARF(101)**2*PMSPL 
        ELSEIF(KFLA.EQ.0) THEN  
          KMUL=2    
          IF(KFLS.EQ.1) KMUL=3  
          IF(KFLR.EQ.2) KMUL=4  
          IF(KFLS.EQ.5) KMUL=5  
          ULMASS=PARF(113+KMUL)+PMB+PMC 
        ELSEIF(KFLC.EQ.0) THEN  
          IF(KFLS.EQ.1) PMSPL=-3./(PMA*PMB) 
          IF(KFLS.EQ.3) PMSPL=1./(PMA*PMB)  
          ULMASS=2.*PARF(112)/3.+PMA+PMB+PARF(114)*PARF(101)**2*PMSPL   
          IF(MSTJ(93).EQ.1) ULMASS=PMA+PMB  
          IF(MSTJ(93).EQ.2) ULMASS=MAX(0.,ULMASS-PARF(122)- 
     &    2.*PARF(112)/3.)  
        ELSE    
          IF(KFLS.EQ.2.AND.KFLA.EQ.KFLB) THEN   
            PMSPL=1./(PMA*PMB)-2./(PMA*PMC)-2./(PMB*PMC)    
          ELSEIF(KFLS.EQ.2.AND.KFLB.GE.KFLC) THEN   
            PMSPL=-2./(PMA*PMB)-2./(PMA*PMC)+1./(PMB*PMC)   
          ELSEIF(KFLS.EQ.2) THEN    
            PMSPL=-3./(PMB*PMC) 
          ELSE  
            PMSPL=1./(PMA*PMB)+1./(PMA*PMC)+1./(PMB*PMC)    
          ENDIF 
          ULMASS=PARF(112)+PMA+PMB+PMC+PARF(114)*PARF(101)**2*PMSPL 
        ENDIF   
      ENDIF 
    
C...Optional mass broadening according to truncated Breit-Wigner    
C...(either in m or in m^2).    
      IF(MSTJ(24).GE.1.AND.PMAS(KC,2).GT.1E-4) THEN 
        IF(MSTJ(24).EQ.1.OR.(MSTJ(24).EQ.2.AND.KFA.GT.100)) THEN    
          ULMASS=ULMASS+0.5*PMAS(KC,2)*TAN((2.*RLU(0)-1.)*  
     &    ATAN(2.*PMAS(KC,3)/PMAS(KC,2)))   
        ELSE    
          PM0=ULMASS    
          PMLOW=ATAN((MAX(0.,PM0-PMAS(KC,3))**2-PM0**2)/    
     &    (PM0*PMAS(KC,2))) 
          PMUPP=ATAN((PM0+PMAS(KC,3))**2-PM0**2)/(PM0*PMAS(KC,2))   
          ULMASS=SQRT(MAX(0.,PM0**2+PM0*PMAS(KC,2)*TAN(PMLOW+   
     &    (PMUPP-PMLOW)*RLU(0))))   
        ENDIF   
      ENDIF 
      MSTJ(93)=0    
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUNAME(KF,CHAU)    
    
C...Purpose: to give the particle/parton name as a character string.    
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT4/CHAF(500)   
      CHARACTER CHAF*8  
      SAVE /LUDAT4/ 
      CHARACTER CHAU*16 
    
C...Initial values. Charge. Subdivide code. 
      CHAU=' '  
      KFA=IABS(KF)  
      KC=LUCOMP(KF) 
      IF(KC.EQ.0) RETURN    
      KQ=LUCHGE(KF) 
      KFLA=MOD(KFA/1000,10) 
      KFLB=MOD(KFA/100,10)  
      KFLC=MOD(KFA/10,10)   
      KFLS=MOD(KFA,10)  
      KFLR=MOD(KFA/10000,10)    
    
C...Read out root name and spin for simple particle.    
      IF(KFA.LE.100.OR.(KFA.GT.100.AND.KC.GT.100)) THEN 
        CHAU=CHAF(KC)   
        LEN=0   
        DO 100 LEM=1,8  
  100   IF(CHAU(LEM:LEM).NE.' ') LEN=LEM    
    
C...Construct root name for diquark. Add on spin.   
      ELSEIF(KFLC.EQ.0) THEN    
        CHAU(1:2)=CHAF(KFLA)(1:1)//CHAF(KFLB)(1:1)  
        IF(KFLS.EQ.1) CHAU(3:4)='_0'    
        IF(KFLS.EQ.3) CHAU(3:4)='_1'    
        LEN=4   
    
C...Construct root name for heavy meson. Add on spin and heavy flavour. 
      ELSEIF(KFLA.EQ.0) THEN    
        IF(KFLB.EQ.5) CHAU(1:1)='B' 
        IF(KFLB.EQ.6) CHAU(1:1)='T' 
        IF(KFLB.EQ.7) CHAU(1:1)='L' 
        IF(KFLB.EQ.8) CHAU(1:1)='H' 
        LEN=1   
        IF(KFLR.EQ.0.AND.KFLS.EQ.1) THEN    
        ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.3) THEN    
          CHAU(2:2)='*' 
          LEN=2 
        ELSEIF(KFLR.EQ.1.AND.KFLS.EQ.3) THEN    
          CHAU(2:3)='_1'    
          LEN=3 
        ELSEIF(KFLR.EQ.1.AND.KFLS.EQ.1) THEN    
          CHAU(2:4)='*_0'   
          LEN=4 
        ELSEIF(KFLR.EQ.2) THEN  
          CHAU(2:4)='*_1'   
          LEN=4 
        ELSEIF(KFLS.EQ.5) THEN  
          CHAU(2:4)='*_2'   
          LEN=4 
        ENDIF   
        IF(KFLC.GE.3.AND.KFLR.EQ.0.AND.KFLS.LE.3) THEN  
          CHAU(LEN+1:LEN+2)='_'//CHAF(KFLC)(1:1)    
          LEN=LEN+2 
        ELSEIF(KFLC.GE.3) THEN  
          CHAU(LEN+1:LEN+1)=CHAF(KFLC)(1:1) 
          LEN=LEN+1 
        ENDIF   
    
C...Construct root name and spin for heavy baryon.  
      ELSE  
        IF(KFLB.LE.2.AND.KFLC.LE.2) THEN    
          CHAU='Sigma ' 
          IF(KFLC.GT.KFLB) CHAU='Lambda'    
          IF(KFLS.EQ.4) CHAU='Sigma*'   
          LEN=5 
          IF(CHAU(6:6).NE.' ') LEN=6    
        ELSEIF(KFLB.LE.2.OR.KFLC.LE.2) THEN 
          CHAU='Xi '    
          IF(KFLA.GT.KFLB.AND.KFLB.GT.KFLC) CHAU='Xi''' 
          IF(KFLS.EQ.4) CHAU='Xi*'  
          LEN=2 
          IF(CHAU(3:3).NE.' ') LEN=3    
        ELSE    
          CHAU='Omega ' 
          IF(KFLA.GT.KFLB.AND.KFLB.GT.KFLC) CHAU='Omega'''  
          IF(KFLS.EQ.4) CHAU='Omega*'   
          LEN=5 
          IF(CHAU(6:6).NE.' ') LEN=6    
        ENDIF   
    
C...Add on heavy flavour content for heavy baryon.  
        CHAU(LEN+1:LEN+2)='_'//CHAF(KFLA)(1:1)  
        LEN=LEN+2   
        IF(KFLB.GE.KFLC.AND.KFLC.GE.4) THEN 
          CHAU(LEN+1:LEN+2)=CHAF(KFLB)(1:1)//CHAF(KFLC)(1:1)    
          LEN=LEN+2 
        ELSEIF(KFLB.GE.KFLC.AND.KFLB.GE.4) THEN 
          CHAU(LEN+1:LEN+1)=CHAF(KFLB)(1:1) 
          LEN=LEN+1 
        ELSEIF(KFLC.GT.KFLB.AND.KFLB.GE.4) THEN 
          CHAU(LEN+1:LEN+2)=CHAF(KFLC)(1:1)//CHAF(KFLB)(1:1)    
          LEN=LEN+2 
        ELSEIF(KFLC.GT.KFLB.AND.KFLC.GE.4) THEN 
          CHAU(LEN+1:LEN+1)=CHAF(KFLC)(1:1) 
          LEN=LEN+1 
        ENDIF   
      ENDIF 
    
C...Add on bar sign for antiparticle (where necessary). 
      IF(KF.GT.0.OR.LEN.EQ.0) THEN  
      ELSEIF(KFA.GT.10.AND.KFA.LE.40.AND.KQ.NE.0) THEN  
      ELSEIF(KFA.EQ.89.OR.(KFA.GE.91.AND.KFA.LE.99)) THEN   
      ELSEIF(KFA.GT.100.AND.KFLA.EQ.0.AND.KQ.NE.0) THEN 
      ELSEIF(MSTU(15).LE.1) THEN    
        CHAU(LEN+1:LEN+1)='~'   
        LEN=LEN+1   
      ELSE  
        CHAU(LEN+1:LEN+3)='bar' 
        LEN=LEN+3   
      ENDIF 
    
C...Add on charge where applicable (conventional cases skipped).    
      IF(KQ.EQ.6) CHAU(LEN+1:LEN+2)='++'    
      IF(KQ.EQ.-6) CHAU(LEN+1:LEN+2)='--'   
      IF(KQ.EQ.3) CHAU(LEN+1:LEN+1)='+' 
      IF(KQ.EQ.-3) CHAU(LEN+1:LEN+1)='-'    
      IF(KQ.EQ.0.AND.(KFA.LE.22.OR.LEN.EQ.0)) THEN  
      ELSEIF(KQ.EQ.0.AND.(KFA.GE.81.AND.KFA.LE.100)) THEN   
      ELSEIF(KFA.GT.100.AND.KFLA.EQ.0.AND.KFLB.EQ.KFLC.AND. 
     &KFLB.NE.1) THEN   
      ELSEIF(KQ.EQ.0) THEN  
        CHAU(LEN+1:LEN+1)='0'   
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      FUNCTION LUCHGE(KF)   
    
C...Purpose: to give three times the charge for a particle/parton.  
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
    
C...Initial values. Simple case of direct readout.  
      LUCHGE=0  
      KFA=IABS(KF)  
      KC=LUCOMP(KFA)    
      IF(KC.EQ.0) THEN  
      ELSEIF(KFA.LE.100.OR.KC.LE.80.OR.KC.GT.100) THEN  
        LUCHGE=KCHG(KC,1)   
    
C...Construction from quark content for heavy meson, diquark, baryon.   
      ELSEIF(MOD(KFA/1000,10).EQ.0) THEN    
        LUCHGE=(KCHG(MOD(KFA/100,10),1)-KCHG(MOD(KFA/10,10),1))*    
     &  (-1)**MOD(KFA/100,10)   
      ELSEIF(MOD(KFA/10,10).EQ.0) THEN  
        LUCHGE=KCHG(MOD(KFA/1000,10),1)+KCHG(MOD(KFA/100,10),1) 
      ELSE  
        LUCHGE=KCHG(MOD(KFA/1000,10),1)+KCHG(MOD(KFA/100,10),1)+    
     &  KCHG(MOD(KFA/10,10),1)  
      ENDIF 
    
C...Add on correct sign.    
      LUCHGE=LUCHGE*ISIGN(1,KF) 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      FUNCTION LUCOMP(KF)   
    
C...Purpose: to compress the standard KF codes for use in mass and decay    
C...arrays; also to check whether a given code actually is defined. 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
    
C...Subdivide KF code into constituent pieces.  
      LUCOMP=0  
      KFA=IABS(KF)  
      KFLA=MOD(KFA/1000,10) 
      KFLB=MOD(KFA/100,10)  
      KFLC=MOD(KFA/10,10)   
      KFLS=MOD(KFA,10)  
      KFLR=MOD(KFA/10000,10)    
    
C...Simple cases: direct translation or special codes.  
      IF(KFA.EQ.0.OR.KFA.GE.100000) THEN    
      ELSEIF(KFA.LE.100) THEN   
        LUCOMP=KFA  
        IF(KF.LT.0.AND.KCHG(KFA,3).EQ.0) LUCOMP=0   
      ELSEIF(KFLS.EQ.0) THEN    
        IF(KF.EQ.130) LUCOMP=221    
        IF(KF.EQ.310) LUCOMP=222    
        IF(KFA.EQ.210) LUCOMP=281   
        IF(KFA.EQ.2110) LUCOMP=282  
        IF(KFA.EQ.2210) LUCOMP=283  
    
C...Mesons. 
      ELSEIF(KFA-10000*KFLR.LT.1000) THEN   
        IF(KFLB.EQ.0.OR.KFLB.EQ.9.OR.KFLC.EQ.0.OR.KFLC.EQ.9) THEN   
        ELSEIF(KFLB.LT.KFLC) THEN   
        ELSEIF(KF.LT.0.AND.KFLB.EQ.KFLC) THEN   
        ELSEIF(KFLB.EQ.KFLC) THEN   
          IF(KFLR.EQ.0.AND.KFLS.EQ.1) THEN  
            LUCOMP=110+KFLB 
          ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.3) THEN  
            LUCOMP=130+KFLB 
          ELSEIF(KFLR.EQ.1.AND.KFLS.EQ.3) THEN  
            LUCOMP=150+KFLB 
          ELSEIF(KFLR.EQ.1.AND.KFLS.EQ.1) THEN  
            LUCOMP=170+KFLB 
          ELSEIF(KFLR.EQ.2.AND.KFLS.EQ.3) THEN  
            LUCOMP=190+KFLB 
          ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.5) THEN  
            LUCOMP=210+KFLB 
          ENDIF 
        ELSEIF(KFLB.LE.5.AND.KFLC.LE.3) THEN    
          IF(KFLR.EQ.0.AND.KFLS.EQ.1) THEN  
            LUCOMP=100+((KFLB-1)*(KFLB-2))/2+KFLC   
          ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.3) THEN  
            LUCOMP=120+((KFLB-1)*(KFLB-2))/2+KFLC   
          ELSEIF(KFLR.EQ.1.AND.KFLS.EQ.3) THEN  
            LUCOMP=140+((KFLB-1)*(KFLB-2))/2+KFLC   
          ELSEIF(KFLR.EQ.1.AND.KFLS.EQ.1) THEN  
            LUCOMP=160+((KFLB-1)*(KFLB-2))/2+KFLC   
          ELSEIF(KFLR.EQ.2.AND.KFLS.EQ.3) THEN  
            LUCOMP=180+((KFLB-1)*(KFLB-2))/2+KFLC   
          ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.5) THEN  
            LUCOMP=200+((KFLB-1)*(KFLB-2))/2+KFLC   
          ENDIF 
        ELSEIF((KFLS.EQ.1.AND.KFLR.LE.1).OR.(KFLS.EQ.3.AND.KFLR.LE.2).  
     &  OR.(KFLS.EQ.5.AND.KFLR.EQ.0)) THEN  
          LUCOMP=80+KFLB    
        ENDIF   
    
C...Diquarks.   
      ELSEIF((KFLR.EQ.0.OR.KFLR.EQ.1).AND.KFLC.EQ.0) THEN   
        IF(KFLS.NE.1.AND.KFLS.NE.3) THEN    
        ELSEIF(KFLA.EQ.9.OR.KFLB.EQ.0.OR.KFLB.EQ.9) THEN    
        ELSEIF(KFLA.LT.KFLB) THEN   
        ELSEIF(KFLS.EQ.1.AND.KFLA.EQ.KFLB) THEN 
        ELSE    
          LUCOMP=90 
        ENDIF   
    
C...Spin 1/2 baryons.   
      ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.2) THEN  
        IF(KFLA.EQ.9.OR.KFLB.EQ.0.OR.KFLB.EQ.9.OR.KFLC.EQ.9) THEN   
        ELSEIF(KFLA.LE.KFLC.OR.KFLA.LT.KFLB) THEN   
        ELSEIF(KFLA.GE.6.OR.KFLB.GE.4.OR.KFLC.GE.4) THEN    
          LUCOMP=80+KFLA    
        ELSEIF(KFLB.LT.KFLC) THEN   
          LUCOMP=300+((KFLA+1)*KFLA*(KFLA-1))/6+(KFLC*(KFLC-1))/2+KFLB  
        ELSE    
          LUCOMP=330+((KFLA+1)*KFLA*(KFLA-1))/6+(KFLB*(KFLB-1))/2+KFLC  
        ENDIF   
    
C...Spin 3/2 baryons.   
      ELSEIF(KFLR.EQ.0.AND.KFLS.EQ.4) THEN  
        IF(KFLA.EQ.9.OR.KFLB.EQ.0.OR.KFLB.EQ.9.OR.KFLC.EQ.9) THEN   
        ELSEIF(KFLA.LT.KFLB.OR.KFLB.LT.KFLC) THEN   
        ELSEIF(KFLA.GE.6.OR.KFLB.GE.4) THEN 
          LUCOMP=80+KFLA    
        ELSE    
          LUCOMP=360+((KFLA+1)*KFLA*(KFLA-1))/6+(KFLB*(KFLB-1))/2+KFLC  
        ENDIF   
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUERRM(MERR,CHMESS)    
    
C...Purpose: to inform user of errors in program execution. 
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      CHARACTER CHMESS*(*)  

      write (6,*) 'merr,chmess=',merr,chmess
    
C...Write first few warnings, then be silent.   
      IF(MERR.LE.10) THEN   
        MSTU(27)=MSTU(27)+1 
        MSTU(28)=MERR   
        IF(MSTU(25).EQ.1.AND.MSTU(27).LE.MSTU(26)) WRITE(MSTU(11),1000) 
     &  MERR,MSTU(31),CHMESS    
    
C...Write first few errors, then be silent or stop program. 
      ELSEIF(MERR.LE.20) THEN   
        MSTU(23)=MSTU(23)+1 
        MSTU(24)=MERR-10    
        IF(MSTU(21).GE.1.AND.MSTU(23).LE.MSTU(22)) WRITE(MSTU(11),1100) 
     &  MERR-10,MSTU(31),CHMESS 
        IF(MSTU(21).GE.2.AND.MSTU(23).GT.MSTU(22)) THEN 
          WRITE(MSTU(11),1100) MERR-10,MSTU(31),CHMESS  
          WRITE(MSTU(11),1200)  
          IF(MERR.NE.17) CALL LULIST(2) 
          STOP  
        ENDIF   
    
C...Stop program in case of irreparable error.  
      ELSE  
        WRITE(MSTU(11),1300) MERR-20,MSTU(31),CHMESS    
        STOP    
      ENDIF 
    
C...Formats for output. 
 1000 FORMAT(/5X,'Advisory warning type',I2,' given after',I6,  
     &' LUEXEC calls:'/5X,A)    
 1100 FORMAT(/5X,'Error type',I2,' has occured after',I6,   
     &' LUEXEC calls:'/5X,A)    
 1200 FORMAT(5X,'Execution will be stopped after listing of last ', 
     &'event!') 
 1300 FORMAT(/5X,'Fatal error type',I2,' has occured after',I6, 
     &' LUEXEC calls:'/5X,A/5X,'Execution will now be stopped!')    
    
      RETURN    
      END   
    
C*********************************************************************  
    
      FUNCTION ULALPS(Q2)   
    
C...Purpose: to give the value of alpha_strong. 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
    
C...Constant alpha_strong trivial.  
      IF(MSTU(111).LE.0) THEN   
        ULALPS=PARU(111)    
        MSTU(118)=MSTU(112) 
        PARU(117)=0.    
        PARU(118)=PARU(111) 
        RETURN  
      ENDIF 
    
C...Find effective Q2, number of flavours and Lambda.   
      Q2EFF=Q2  
      IF(MSTU(115).GE.2) Q2EFF=MAX(Q2,PARU(114))    
      NF=MSTU(112)  
      ALAM2=PARU(112)**2    
  100 IF(NF.GT.MAX(2,MSTU(113))) THEN   
        Q2THR=PARU(113)*PMAS(NF,1)**2   
        IF(Q2EFF.LT.Q2THR) THEN 
          NF=NF-1   
          ALAM2=ALAM2*(Q2THR/ALAM2)**(2./(33.-2.*NF))   
          GOTO 100  
        ENDIF   
      ENDIF 
  110 IF(NF.LT.MIN(8,MSTU(114))) THEN   
        Q2THR=PARU(113)*PMAS(NF+1,1)**2 
        IF(Q2EFF.GT.Q2THR) THEN 
          NF=NF+1   
          ALAM2=ALAM2*(ALAM2/Q2THR)**(2./(33.-2.*NF))   
          GOTO 110  
        ENDIF   
      ENDIF 
      IF(MSTU(115).EQ.1) Q2EFF=Q2EFF+ALAM2  
      PARU(117)=SQRT(ALAM2) 
    
C...Evaluate first or second order alpha_strong.    
      B0=(33.-2.*NF)/6. 
      ALGQ=LOG(Q2EFF/ALAM2) 
      IF(MSTU(111).EQ.1) THEN   
        ULALPS=PARU(2)/(B0*ALGQ)    
      ELSE  
        B1=(153.-19.*NF)/6. 
        ULALPS=PARU(2)/(B0*ALGQ)*(1.-B1*LOG(ALGQ)/(B0**2*ALGQ)) 
      ENDIF 
      MSTU(118)=NF  
      PARU(118)=ULALPS  
    
      RETURN    
      END   
    
C*********************************************************************  
    
      FUNCTION ULANGL(X,Y)  
    
C...Purpose: to reconstruct an angle from given x and y coordinates.    
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
    
      ULANGL=0. 
      R=SQRT(X**2+Y**2) 
      IF(R.LT.1E-20) RETURN 
      IF(ABS(X)/R.LT.0.8) THEN  
        ULANGL=SIGN(ACOS(X/R),Y)    
      ELSE  
        ULANGL=ASIN(Y/R)    
        IF(X.LT.0..AND.ULANGL.GE.0.) THEN   
          ULANGL=PARU(1)-ULANGL 
        ELSEIF(X.LT.0.) THEN    
          ULANGL=-PARU(1)-ULANGL    
        ENDIF   
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      FUNCTION RLU(IDUM)    
    
C...Purpose: to generate random numbers uniformly distributed between   
C...0 and 1, excluding the endpoints.   
      COMMON/LUDATR/MRLU(6),RRLU(100)   
      SAVE /LUDATR/ 
      EQUIVALENCE (MRLU1,MRLU(1)),(MRLU2,MRLU(2)),(MRLU3,MRLU(3)),  
     &(MRLU4,MRLU(4)),(MRLU5,MRLU(5)),(MRLU6,MRLU(6)),  
     &(RRLU98,RRLU(98)),(RRLU99,RRLU(99)),(RRLU00,RRLU(100))    
    
C...Initialize generation from given seed.  
      IF(MRLU2.EQ.0) THEN   
        IJ=MOD(MRLU1/30082,31329)   
        KL=MOD(MRLU1,30082) 
        I=MOD(IJ/177,177)+2 
        J=MOD(IJ,177)+2 
        K=MOD(KL/169,178)+1 
        L=MOD(KL,169)   
        DO 110 II=1,97  
        S=0.    
        T=0.5   
        DO 100 JJ=1,24  
        M=MOD(MOD(I*J,179)*K,179)   
        I=J 
        J=K 
        K=M 
        L=MOD(53*L+1,169)   
        IF(MOD(L*M,64).GE.32) S=S+T 
  100   T=0.5*T 
  110   RRLU(II)=S  
        TWOM24=1.   
        DO 120 I24=1,24 
  120   TWOM24=0.5*TWOM24   
        RRLU98=362436.*TWOM24   
        RRLU99=7654321.*TWOM24  
        RRLU00=16777213.*TWOM24 
        MRLU2=1 
        MRLU3=0 
        MRLU4=97    
        MRLU5=33    
      ENDIF 
    
C...Generate next random number.    
  130 RUNI=RRLU(MRLU4)-RRLU(MRLU5)  
      IF(RUNI.LT.0.) RUNI=RUNI+1.   
      RRLU(MRLU4)=RUNI  
      MRLU4=MRLU4-1 
      IF(MRLU4.EQ.0) MRLU4=97   
      MRLU5=MRLU5-1 
      IF(MRLU5.EQ.0) MRLU5=97   
      RRLU98=RRLU98-RRLU99  
      IF(RRLU98.LT.0.) RRLU98=RRLU98+RRLU00 
      RUNI=RUNI-RRLU98  
      IF(RUNI.LT.0.) RUNI=RUNI+1.   
      IF(RUNI.LE.0.OR.RUNI.GE.1.) GOTO 130  
    
C...Update counters. Random number to output.   
      MRLU3=MRLU3+1 
      IF(MRLU3.EQ.1000000000) THEN  
        MRLU2=MRLU2+1   
        MRLU3=0 
      ENDIF 
      RLU=RUNI  
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUROBO(THE,PHI,BEX,BEY,BEZ)    
    
C...Purpose: to perform rotations and boosts.   
      IMPLICIT DOUBLE PRECISION(D)  
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      DIMENSION ROT(3,3),PR(3),VR(3),DP(4),DV(4)    
    
C...Find range of rotation/boost. Convert boost to double precision.    
      IMIN=1    
      IF(MSTU(1).GT.0) IMIN=MSTU(1) 
      IMAX=N    
      IF(MSTU(2).GT.0) IMAX=MSTU(2) 
      DBX=dble(BEX)
      DBY=dble(BEY)
      DBZ=dble(BEZ)
      GOTO 100  
    
C...Entry for specific range and double precision boost.    
      ENTRY LUDBRB(IMI,IMA,THE,PHI,DBEX,DBEY,DBEZ)  
      IMIN=IMI  
      IF(IMIN.LE.0) IMIN=1  
      IMAX=IMA  
      IF(IMAX.LE.0) IMAX=N  
      DBX=DBEX  
      DBY=DBEY  
      DBZ=DBEZ  
    
C...Check range of rotation/boost.  
  100 IF(IMIN.GT.MSTU(4).OR.IMAX.GT.MSTU(4)) THEN   
        CALL LUERRM(11,'(LUROBO:) range outside LUJETS memory') 
        RETURN  
      ENDIF 
    
C...Rotate, typically from z axis to direction (theta,phi). 
clin-5/2012:
c      IF(THE**2+PHI**2.GT.1E-20) THEN   
      IF((THE**2+PHI**2).GT.1E-20) THEN   
        ROT(1,1)=COS(THE)*COS(PHI)  
        ROT(1,2)=-SIN(PHI)  
        ROT(1,3)=SIN(THE)*COS(PHI)  
        ROT(2,1)=COS(THE)*SIN(PHI)  
        ROT(2,2)=COS(PHI)   
        ROT(2,3)=SIN(THE)*SIN(PHI)  
        ROT(3,1)=-SIN(THE)  
        ROT(3,2)=0. 
        ROT(3,3)=COS(THE)   
        DO 130 I=IMIN,IMAX  
        IF(K(I,1).LE.0) GOTO 130    
        DO 110 J=1,3    
        PR(J)=P(I,J)    
  110   VR(J)=V(I,J)    
        DO 120 J=1,3    
        P(I,J)=ROT(J,1)*PR(1)+ROT(J,2)*PR(2)+ROT(J,3)*PR(3) 
  120   V(I,J)=ROT(J,1)*VR(1)+ROT(J,2)*VR(2)+ROT(J,3)*VR(3) 
  130   CONTINUE    
      ENDIF 
    
C...Boost, typically from rest to momentum/energy=beta. 
clin-5/2012:
c      IF(DBX**2+DBY**2+DBZ**2.GT.1E-20) THEN    
      IF((DBX**2+DBY**2+DBZ**2).GT.1D-20) THEN    
        DB=SQRT(DBX**2+DBY**2+DBZ**2)   
        IF(DB.GT.0.99999999D0) THEN 
C...Rescale boost vector if too close to unity. 
          CALL LUERRM(3,'(LUROBO:) boost vector too large') 
          DBX=DBX*(0.99999999D0/DB) 
          DBY=DBY*(0.99999999D0/DB) 
          DBZ=DBZ*(0.99999999D0/DB) 
          DB=0.99999999D0   
        ENDIF   
        DGA=1D0/SQRT(1D0-DB**2) 
        DO 150 I=IMIN,IMAX  
        IF(K(I,1).LE.0) GOTO 150    
        DO 140 J=1,4    
        DP(J)=dble(P(I,J))
  140   DV(J)=dble(V(I,J))
        DBP=DBX*DP(1)+DBY*DP(2)+DBZ*DP(3)   
        DGABP=DGA*(DGA*DBP/(1D0+DGA)+DP(4)) 
        P(I,1)=sngl(DP(1)+DGABP*DBX)
        P(I,2)=sngl(DP(2)+DGABP*DBY) 
        P(I,3)=sngl(DP(3)+DGABP*DBZ) 
        P(I,4)=sngl(DGA*(DP(4)+DBP)) 
        DBV=DBX*DV(1)+DBY*DV(2)+DBZ*DV(3)   
        DGABV=DGA*(DGA*DBV/(1D0+DGA)+DV(4)) 
        V(I,1)=sngl(DV(1)+DGABV*DBX) 
        V(I,2)=sngl(DV(2)+DGABV*DBY) 
        V(I,3)=sngl(DV(3)+DGABV*DBZ) 
        V(I,4)=sngl(DGA*(DV(4)+DBV))
  150   CONTINUE    
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
C THIS SUBROUTINE IS ONLY FOR THE USE OF HIJING TO ROTATE OR BOOST
C        THE FOUR MOMENTUM ONLY
C*********************************************************************
    
      SUBROUTINE HIROBO(THE,PHI,BEX,BEY,BEZ)    
    
C...Purpose: to perform rotations and boosts.   
      IMPLICIT DOUBLE PRECISION(D)  
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      DIMENSION ROT(3,3),PR(3),VR(3),DP(4),DV(4)    
    
C...Find range of rotation/boost. Convert boost to double precision.    
      IMIN=1    
      IF(MSTU(1).GT.0) IMIN=MSTU(1) 
      IMAX=N    
      IF(MSTU(2).GT.0) IMAX=MSTU(2) 
      DBX=dble(BEX)
      DBY=dble(BEY) 
      DBZ=dble(BEZ)  
    
C...Check range of rotation/boost.  
      IF(IMIN.GT.MSTU(4).OR.IMAX.GT.MSTU(4)) THEN   
        CALL LUERRM(11,'(LUROBO:) range outside LUJETS memory') 
        RETURN  
      ENDIF 
    
C...Rotate, typically from z axis to direction (theta,phi). 
clin-5/2012:
c      IF(THE**2+PHI**2.GT.1E-20) THEN   
      IF((THE**2+PHI**2).GT.1E-20) THEN   
        ROT(1,1)=COS(THE)*COS(PHI)  
        ROT(1,2)=-SIN(PHI)  
        ROT(1,3)=SIN(THE)*COS(PHI)  
        ROT(2,1)=COS(THE)*SIN(PHI)  
        ROT(2,2)=COS(PHI)   
        ROT(2,3)=SIN(THE)*SIN(PHI)  
        ROT(3,1)=-SIN(THE)  
        ROT(3,2)=0. 
        ROT(3,3)=COS(THE)   
        DO 130 I=IMIN,IMAX  
        IF(K(I,1).LE.0) GOTO 130    
        DO 110 J=1,3    
  110   PR(J)=P(I,J)   
        DO 120 J=1,3    
  120   P(I,J)=ROT(J,1)*PR(1)+ROT(J,2)*PR(2)+ROT(J,3)*PR(3) 
  130   CONTINUE    
      ENDIF 
    
C...Boost, typically from rest to momentum/energy=beta. 
clin-5/2012:
c      IF(DBX**2+DBY**2+DBZ**2.GT.1E-20) THEN    
      IF((DBX**2+DBY**2+DBZ**2).GT.1D-20) THEN    
        DB=SQRT(DBX**2+DBY**2+DBZ**2)   
        IF(DB.GT.0.99999999D0) THEN 
C...Rescale boost vector if too close to unity. 
          CALL LUERRM(3,'(LUROBO:) boost vector too large') 
          DBX=DBX*(0.99999999D0/DB) 
          DBY=DBY*(0.99999999D0/DB) 
          DBZ=DBZ*(0.99999999D0/DB) 
          DB=0.99999999D0   
        ENDIF   
        DGA=1D0/SQRT(1D0-DB**2) 
        DO 150 I=IMIN,IMAX  
        IF(K(I,1).LE.0) GOTO 150    
        DO 140 J=1,4    
  140   DP(J)=dble(P(I,J))
        DBP=DBX*DP(1)+DBY*DP(2)+DBZ*DP(3)   
        DGABP=DGA*(DGA*DBP/(1D0+DGA)+DP(4)) 
        P(I,1)=sngl(DP(1)+DGABP*DBX)
        P(I,2)=sngl(DP(2)+DGABP*DBY) 
        P(I,3)=sngl(DP(3)+DGABP*DBZ) 
        P(I,4)=sngl(DGA*(DP(4)+DBP)) 
  150   CONTINUE    
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LUEDIT(MEDIT)  
    
C...Purpose: to perform global manipulations on the event record,   
C...in particular to exclude unstable or undetectable partons/particles.    
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      DIMENSION NS(2),PTS(2),PLS(2) 
    
C...Remove unwanted partons/particles.  
      IF((MEDIT.GE.0.AND.MEDIT.LE.3).OR.MEDIT.EQ.5) THEN    
        IMAX=N  
        IF(MSTU(2).GT.0) IMAX=MSTU(2)   
        I1=MAX(1,MSTU(1))-1 
        DO 110 I=MAX(1,MSTU(1)),IMAX    
        IF(K(I,1).EQ.0.OR.K(I,1).GT.20) GOTO 110    
        IF(MEDIT.EQ.1) THEN 
          IF(K(I,1).GT.10) GOTO 110 
        ELSEIF(MEDIT.EQ.2) THEN 
          IF(K(I,1).GT.10) GOTO 110 
          KC=LUCOMP(K(I,2)) 
          IF(KC.EQ.0.OR.KC.EQ.12.OR.KC.EQ.14.OR.KC.EQ.16.OR.KC.EQ.18)   
     &    GOTO 110  
        ELSEIF(MEDIT.EQ.3) THEN 
          IF(K(I,1).GT.10) GOTO 110 
          KC=LUCOMP(K(I,2)) 
          IF(KC.EQ.0) GOTO 110  
          IF(KCHG(KC,2).EQ.0.AND.LUCHGE(K(I,2)).EQ.0) GOTO 110  
        ELSEIF(MEDIT.EQ.5) THEN 
          IF(K(I,1).EQ.13.OR.K(I,1).EQ.14) GOTO 110 
          KC=LUCOMP(K(I,2)) 
          IF(KC.EQ.0) GOTO 110  
          IF(K(I,1).GE.11.AND.KCHG(KC,2).EQ.0) GOTO 110 
        ENDIF   
    
C...Pack remaining partons/particles. Origin no longer known.   
        I1=I1+1 
        DO 100 J=1,5    
        K(I1,J)=K(I,J)  
        P(I1,J)=P(I,J)  
  100   V(I1,J)=V(I,J)  
        K(I1,3)=0   
  110   CONTINUE    
        N=I1    
    
C...Selective removal of class of entries. New position of retained.    
      ELSEIF(MEDIT.GE.11.AND.MEDIT.LE.15) THEN  
        I1=0    
        DO 120 I=1,N    
        K(I,3)=MOD(K(I,3),MSTU(5))  
        IF(MEDIT.EQ.11.AND.K(I,1).LT.0) GOTO 120    
        IF(MEDIT.EQ.12.AND.K(I,1).EQ.0) GOTO 120    
        IF(MEDIT.EQ.13.AND.(K(I,1).EQ.11.OR.K(I,1).EQ.12.OR.    
     &  K(I,1).EQ.15).AND.K(I,2).NE.94) GOTO 120    
        IF(MEDIT.EQ.14.AND.(K(I,1).EQ.13.OR.K(I,1).EQ.14.OR.    
     &  K(I,2).EQ.94)) GOTO 120 
        IF(MEDIT.EQ.15.AND.K(I,1).GE.21) GOTO 120   
        I1=I1+1 
        K(I,3)=K(I,3)+MSTU(5)*I1    
  120   CONTINUE    
    
C...Find new event history information and replace old. 
        DO 140 I=1,N    
        IF(K(I,1).LE.0.OR.K(I,1).GT.20.OR.K(I,3)/MSTU(5).EQ.0) GOTO 140 
        ID=I    
  130   IM=MOD(K(ID,3),MSTU(5)) 
        IF(MEDIT.EQ.13.AND.IM.GT.0.AND.IM.LE.N) THEN    
          IF((K(IM,1).EQ.11.OR.K(IM,1).EQ.12.OR.K(IM,1).EQ.15).AND. 
     &    K(IM,2).NE.94) THEN   
            ID=IM   
            GOTO 130    
          ENDIF 
        ELSEIF(MEDIT.EQ.14.AND.IM.GT.0.AND.IM.LE.N) THEN    
          IF(K(IM,1).EQ.13.OR.K(IM,1).EQ.14.OR.K(IM,2).EQ.94) THEN  
            ID=IM   
            GOTO 130    
          ENDIF 
        ENDIF   
        K(I,3)=MSTU(5)*(K(I,3)/MSTU(5)) 
        IF(IM.NE.0) K(I,3)=K(I,3)+K(IM,3)/MSTU(5)   
        IF(K(I,1).NE.3.AND.K(I,1).NE.13.AND.K(I,1).NE.14) THEN  
          IF(K(I,4).GT.0.AND.K(I,4).LE.MSTU(4)) K(I,4)= 
     &    K(K(I,4),3)/MSTU(5)   
          IF(K(I,5).GT.0.AND.K(I,5).LE.MSTU(4)) K(I,5)= 
     &    K(K(I,5),3)/MSTU(5)   
        ELSE    
          KCM=MOD(K(I,4)/MSTU(5),MSTU(5))   
          IF(KCM.GT.0.AND.KCM.LE.MSTU(4)) KCM=K(KCM,3)/MSTU(5)  
          KCD=MOD(K(I,4),MSTU(5))   
          IF(KCD.GT.0.AND.KCD.LE.MSTU(4)) KCD=K(KCD,3)/MSTU(5)  
          K(I,4)=MSTU(5)**2*(K(I,4)/MSTU(5)**2)+MSTU(5)*KCM+KCD 
          KCM=MOD(K(I,5)/MSTU(5),MSTU(5))   
          IF(KCM.GT.0.AND.KCM.LE.MSTU(4)) KCM=K(KCM,3)/MSTU(5)  
          KCD=MOD(K(I,5),MSTU(5))   
          IF(KCD.GT.0.AND.KCD.LE.MSTU(4)) KCD=K(KCD,3)/MSTU(5)  
          K(I,5)=MSTU(5)**2*(K(I,5)/MSTU(5)**2)+MSTU(5)*KCM+KCD 
        ENDIF   
  140   CONTINUE    
    
C...Pack remaining entries. 
        I1=0    
        DO 160 I=1,N    
        IF(K(I,3)/MSTU(5).EQ.0) GOTO 160    
        I1=I1+1 
        DO 150 J=1,5    
        K(I1,J)=K(I,J)  
        P(I1,J)=P(I,J)  
  150   V(I1,J)=V(I,J)  
        K(I1,3)=MOD(K(I1,3),MSTU(5))    
  160   CONTINUE    
        N=I1    
    
C...Save top entries at bottom of LUJETS commonblock.   
      ELSEIF(MEDIT.EQ.21) THEN  
        IF(2*N.GE.MSTU(4)) THEN 
          CALL LUERRM(11,'(LUEDIT:) no more memory left in LUJETS') 
          RETURN    
        ENDIF   
        DO 170 I=1,N    
        DO 170 J=1,5    
        K(MSTU(4)-I,J)=K(I,J)   
        P(MSTU(4)-I,J)=P(I,J)   
  170   V(MSTU(4)-I,J)=V(I,J)   
        MSTU(32)=N  
    
C...Restore bottom entries of commonblock LUJETS to top.    
      ELSEIF(MEDIT.EQ.22) THEN  
        DO 180 I=1,MSTU(32) 
        DO 180 J=1,5    
        K(I,J)=K(MSTU(4)-I,J)   
        P(I,J)=P(MSTU(4)-I,J)   
  180   V(I,J)=V(MSTU(4)-I,J)   
        N=MSTU(32)  
    
C...Mark primary entries at top of commonblock LUJETS as untreated. 
      ELSEIF(MEDIT.EQ.23) THEN  
        I1=0    
        DO 190 I=1,N    
        KH=K(I,3)   
        IF(KH.GE.1) THEN    
          IF(K(KH,1).GT.20) KH=0    
        ENDIF   
        IF(KH.NE.0) GOTO 200    
        I1=I1+1 
  190   IF(K(I,1).GT.10.AND.K(I,1).LE.20) K(I,1)=K(I,1)-10  
  200   N=I1    
    
C...Place largest axis along z axis and second largest in xy plane. 
      ELSEIF(MEDIT.EQ.31.OR.MEDIT.EQ.32) THEN   
        CALL LUDBRB(1,N+MSTU(3),0.,-ULANGL(P(MSTU(61),1),   
     &  P(MSTU(61),2)),0D0,0D0,0D0) 
        CALL LUDBRB(1,N+MSTU(3),-ULANGL(P(MSTU(61),3),  
     &  P(MSTU(61),1)),0.,0D0,0D0,0D0)  
        CALL LUDBRB(1,N+MSTU(3),0.,-ULANGL(P(MSTU(61)+1,1), 
     &  P(MSTU(61)+1,2)),0D0,0D0,0D0)   
        IF(MEDIT.EQ.31) RETURN  
    
C...Rotate to put slim jet along +z axis.   
        DO 210 IS=1,2   
        NS(IS)=0    
        PTS(IS)=0.  
  210   PLS(IS)=0.  
        DO 220 I=1,N    
        IF(K(I,1).LE.0.OR.K(I,1).GT.10) GOTO 220    
        IF(MSTU(41).GE.2) THEN  
          KC=LUCOMP(K(I,2)) 
          IF(KC.EQ.0.OR.KC.EQ.12.OR.KC.EQ.14.OR.KC.EQ.16.OR.    
     &    KC.EQ.18) GOTO 220    
          IF(MSTU(41).GE.3.AND.KCHG(KC,2).EQ.0.AND.LUCHGE(K(I,2)).EQ.0) 
     &    GOTO 220  
        ENDIF   
        IS=int(2.-SIGN(0.5,P(I,3)))
        NS(IS)=NS(IS)+1 
        PTS(IS)=PTS(IS)+SQRT(P(I,1)**2+P(I,2)**2)   
  220   CONTINUE    
        IF(NS(1)*PTS(2)**2.LT.NS(2)*PTS(1)**2)  
     &  CALL LUDBRB(1,N+MSTU(3),PARU(1),0.,0D0,0D0,0D0) 
    
C...Rotate to put second largest jet into -z,+x quadrant.   
        DO 230 I=1,N    
        IF(P(I,3).GE.0.) GOTO 230   
        IF(K(I,1).LE.0.OR.K(I,1).GT.10) GOTO 230    
        IF(MSTU(41).GE.2) THEN  
          KC=LUCOMP(K(I,2)) 
          IF(KC.EQ.0.OR.KC.EQ.12.OR.KC.EQ.14.OR.KC.EQ.16.OR.    
     &    KC.EQ.18) GOTO 230    
          IF(MSTU(41).GE.3.AND.KCHG(KC,2).EQ.0.AND.LUCHGE(K(I,2)).EQ.0) 
     &    GOTO 230  
        ENDIF   
        IS=int(2.-SIGN(0.5,P(I,1)))
        PLS(IS)=PLS(IS)-P(I,3)  
  230   CONTINUE    
        IF(PLS(2).GT.PLS(1)) CALL LUDBRB(1,N+MSTU(3),0.,PARU(1),    
     &  0D0,0D0,0D0)    
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE LULIST(MLIST)  
    
C...Purpose: to give program heading, or list an event, or particle 
C...data, or current parameter values.  
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      CHARACTER CHAP*16,CHAC*16,CHAN*16,CHAD(5)*16,CHMO(12)*3,CHDL(7)*4 
      DIMENSION PS(6)   
      DATA CHMO/'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep',  
     &'Oct','Nov','Dec'/,CHDL/'(())',' ','()','!!','<>','==','(==)'/    
    
C...Initialization printout: version number and date of last change.    
C      IF(MLIST.EQ.0.OR.MSTU(12).EQ.1) THEN  
C        WRITE(MSTU(11),1000) MSTU(181),MSTU(182),MSTU(185), 
C     &  CHMO(MSTU(184)),MSTU(183)   
C        MSTU(12)=0  
C        IF(MLIST.EQ.0) RETURN   
C      ENDIF 
    
C...List event data, including additional lines after N.    
      IF(MLIST.GE.1.AND.MLIST.LE.3) THEN    
        IF(MLIST.EQ.1) WRITE(MSTU(11),1100) 
        IF(MLIST.EQ.2) WRITE(MSTU(11),1200) 
        IF(MLIST.EQ.3) WRITE(MSTU(11),1300) 
        LMX=12  
        IF(MLIST.GE.2) LMX=16   
        ISTR=0  
        IMAX=N  
        IF(MSTU(2).GT.0) IMAX=MSTU(2)   
        DO 120 I=MAX(1,MSTU(1)),MAX(IMAX,N+MAX(0,MSTU(3)))  
        IF((I.GT.IMAX.AND.I.LE.N).OR.K(I,1).LT.0) GOTO 120  
    
C...Get particle name, pad it and check it is not too long. 
        CALL LUNAME(K(I,2),CHAP)    
        LEN=0   
        DO 100 LEM=1,16 
  100   IF(CHAP(LEM:LEM).NE.' ') LEN=LEM    
        MDL=(K(I,1)+19)/10  
        LDL=0   
        IF(MDL.EQ.2.OR.MDL.GE.8) THEN   
          CHAC=CHAP 
          IF(LEN.GT.LMX) CHAC(LMX:LMX)='?'  
        ELSE    
          LDL=1 
          IF(MDL.EQ.1.OR.MDL.EQ.7) LDL=2    
          IF(LEN.EQ.0) THEN 
            CHAC=CHDL(MDL)(1:2*LDL)//' '    
          ELSE  
            CHAC=CHDL(MDL)(1:LDL)//CHAP(1:MIN(LEN,LMX-2*LDL))// 
     &      CHDL(MDL)(LDL+1:2*LDL)//' ' 
            IF(LEN+2*LDL.GT.LMX) CHAC(LMX:LMX)='?'  
          ENDIF 
        ENDIF   
    
C...Add information on string connection.   
        IF(K(I,1).EQ.1.OR.K(I,1).EQ.2.OR.K(I,1).EQ.11.OR.K(I,1).EQ.12)  
     &  THEN    
          KC=LUCOMP(K(I,2)) 
          KCC=0 
          IF(KC.NE.0) KCC=KCHG(KC,2)    
          IF(KCC.NE.0.AND.ISTR.EQ.0) THEN   
            ISTR=1  
            IF(LEN+2*LDL+3.LE.LMX) CHAC(LMX-1:LMX-1)='A'    
          ELSEIF(KCC.NE.0.AND.(K(I,1).EQ.2.OR.K(I,1).EQ.12)) THEN   
            IF(LEN+2*LDL+3.LE.LMX) CHAC(LMX-1:LMX-1)='I'    
          ELSEIF(KCC.NE.0) THEN 
            ISTR=0  
            IF(LEN+2*LDL+3.LE.LMX) CHAC(LMX-1:LMX-1)='V'    
          ENDIF 
        ENDIF   
    
C...Write data for particle/jet.    
        IF(MLIST.EQ.1.AND.ABS(P(I,4)).LT.9999.) THEN    
          WRITE(MSTU(11),1400) I,CHAC(1:12),(K(I,J1),J1=1,3),   
     &    (P(I,J2),J2=1,5)  
        ELSEIF(MLIST.EQ.1.AND.ABS(P(I,4)).LT.99999.) THEN   
          WRITE(MSTU(11),1500) I,CHAC(1:12),(K(I,J1),J1=1,3),   
     &    (P(I,J2),J2=1,5)  
        ELSEIF(MLIST.EQ.1) THEN 
          WRITE(MSTU(11),1600) I,CHAC(1:12),(K(I,J1),J1=1,3),   
     &    (P(I,J2),J2=1,5)  
        ELSEIF(MSTU(5).EQ.10000.AND.(K(I,1).EQ.3.OR.K(I,1).EQ.13.OR.    
     &  K(I,1).EQ.14)) THEN 
          WRITE(MSTU(11),1700) I,CHAC,(K(I,J1),J1=1,3), 
     &    K(I,4)/100000000,MOD(K(I,4)/10000,10000),MOD(K(I,4),10000),   
     &    K(I,5)/100000000,MOD(K(I,5)/10000,10000),MOD(K(I,5),10000),   
     &    (P(I,J2),J2=1,5)  
        ELSE    
          WRITE(MSTU(11),1800) I,CHAC,(K(I,J1),J1=1,5),(P(I,J2),J2=1,5) 
        ENDIF   
        IF(MLIST.EQ.3) WRITE(MSTU(11),1900) (V(I,J),J=1,5)  
    
C...Insert extra separator lines specified by user. 
        IF(MSTU(70).GE.1) THEN  
          ISEP=0    
          DO 110 J=1,MIN(10,MSTU(70))   
  110     IF(I.EQ.MSTU(70+J)) ISEP=1    
          IF(ISEP.EQ.1.AND.MLIST.EQ.1) WRITE(MSTU(11),2000) 
          IF(ISEP.EQ.1.AND.MLIST.GE.2) WRITE(MSTU(11),2100) 
        ENDIF   
  120   CONTINUE    
    
C...Sum of charges and momenta. 
        DO 130 J=1,6    
  130   PS(J)=PLU(0,J)  
        IF(MLIST.EQ.1.AND.ABS(PS(4)).LT.9999.) THEN 
          WRITE(MSTU(11),2200) PS(6),(PS(J),J=1,5)  
        ELSEIF(MLIST.EQ.1.AND.ABS(PS(4)).LT.99999.) THEN    
          WRITE(MSTU(11),2300) PS(6),(PS(J),J=1,5)  
        ELSEIF(MLIST.EQ.1) THEN 
          WRITE(MSTU(11),2400) PS(6),(PS(J),J=1,5)  
        ELSE    
          WRITE(MSTU(11),2500) PS(6),(PS(J),J=1,5)  
        ENDIF   
    
C...Give simple list of KF codes defined in program.    
      ELSEIF(MLIST.EQ.11) THEN  
        WRITE(MSTU(11),2600)    
        DO 140 KF=1,40  
        CALL LUNAME(KF,CHAP)    
        CALL LUNAME(-KF,CHAN)   
        IF(CHAP.NE.' '.AND.CHAN.EQ.' ') WRITE(MSTU(11),2700) KF,CHAP    
  140   IF(CHAN.NE.' ') WRITE(MSTU(11),2700) KF,CHAP,-KF,CHAN   
        DO 150 KFLS=1,3,2   
        DO 150 KFLA=1,8 
        DO 150 KFLB=1,KFLA-(3-KFLS)/2   
        KF=1000*KFLA+100*KFLB+KFLS  
        CALL LUNAME(KF,CHAP)    
        CALL LUNAME(-KF,CHAN)   
  150   WRITE(MSTU(11),2700) KF,CHAP,-KF,CHAN   
        DO 170 KMUL=0,5 
        KFLS=3  
        IF(KMUL.EQ.0.OR.KMUL.EQ.3) KFLS=1   
        IF(KMUL.EQ.5) KFLS=5    
        KFLR=0  
        IF(KMUL.EQ.2.OR.KMUL.EQ.3) KFLR=1   
        IF(KMUL.EQ.4) KFLR=2    
        DO 170 KFLB=1,8 
        DO 160 KFLC=1,KFLB-1    
        KF=10000*KFLR+100*KFLB+10*KFLC+KFLS 
        CALL LUNAME(KF,CHAP)    
        CALL LUNAME(-KF,CHAN)   
  160   WRITE(MSTU(11),2700) KF,CHAP,-KF,CHAN   
        KF=10000*KFLR+110*KFLB+KFLS 
        CALL LUNAME(KF,CHAP)    
  170   WRITE(MSTU(11),2700) KF,CHAP    
        KF=130  
        CALL LUNAME(KF,CHAP)    
        WRITE(MSTU(11),2700) KF,CHAP    
        KF=310  
        CALL LUNAME(KF,CHAP)    
        WRITE(MSTU(11),2700) KF,CHAP    
        DO 190 KFLSP=1,3    
        KFLS=2+2*(KFLSP/3)  
        DO 190 KFLA=1,8 
        DO 190 KFLB=1,KFLA  
        DO 180 KFLC=1,KFLB  
        IF(KFLSP.EQ.1.AND.(KFLA.EQ.KFLB.OR.KFLB.EQ.KFLC)) GOTO 180  
        IF(KFLSP.EQ.2.AND.KFLA.EQ.KFLC) GOTO 180    
        IF(KFLSP.EQ.1) KF=1000*KFLA+100*KFLC+10*KFLB+KFLS   
        IF(KFLSP.GE.2) KF=1000*KFLA+100*KFLB+10*KFLC+KFLS   
        CALL LUNAME(KF,CHAP)    
        CALL LUNAME(-KF,CHAN)   
        WRITE(MSTU(11),2700) KF,CHAP,-KF,CHAN   
  180   CONTINUE    
  190   CONTINUE    
    
C...List parton/particle data table. Check whether to be listed.    
      ELSEIF(MLIST.EQ.12) THEN  
        WRITE(MSTU(11),2800)    
        MSTJ24=MSTJ(24) 
        MSTJ(24)=0  
        KFMAX=20883 
        IF(MSTU(2).NE.0) KFMAX=MSTU(2)  
        DO 220 KF=MAX(1,MSTU(1)),KFMAX  
        KC=LUCOMP(KF)   
        IF(KC.EQ.0) GOTO 220    
        IF(MSTU(14).EQ.0.AND.KF.GT.100.AND.KC.LE.100) GOTO 220  
        IF(MSTU(14).GT.0.AND.KF.GT.100.AND.MAX(MOD(KF/1000,10), 
     &  MOD(KF/100,10)).GT.MSTU(14)) GOTO 220   
    
C...Find particle name and mass. Print information. 
        CALL LUNAME(KF,CHAP)    
        IF(KF.LE.100.AND.CHAP.EQ.' '.AND.MDCY(KC,2).EQ.0) GOTO 220  
        CALL LUNAME(-KF,CHAN)   
        PM=ULMASS(KF)   
        WRITE(MSTU(11),2900) KF,KC,CHAP,CHAN,KCHG(KC,1),KCHG(KC,2), 
     &  KCHG(KC,3),PM,PMAS(KC,2),PMAS(KC,3),PMAS(KC,4),MDCY(KC,1)   
    
C...Particle decay: channel number, branching ration, matrix element,   
C...decay products. 
        IF(KF.GT.100.AND.KC.LE.100) GOTO 220    
        DO 210 IDC=MDCY(KC,2),MDCY(KC,2)+MDCY(KC,3)-1   
        DO 200 J=1,5    
  200   CALL LUNAME(KFDP(IDC,J),CHAD(J))    
  210   WRITE(MSTU(11),3000) IDC,MDME(IDC,1),MDME(IDC,2),BRAT(IDC), 
     &  (CHAD(J),J=1,5) 
  220   CONTINUE    
        MSTJ(24)=MSTJ24 
    
C...List parameter value table. 
      ELSEIF(MLIST.EQ.13) THEN  
        WRITE(MSTU(11),3100)    
        DO 230 I=1,200  
  230   WRITE(MSTU(11),3200) I,MSTU(I),PARU(I),MSTJ(I),PARJ(I),PARF(I)  
      ENDIF 
    
C...Format statements for output on unit MSTU(11) (by default 6).   
clin 1000 FORMAT(///20X,'The Lund Monte Carlo - JETSET version ',I1,'.',I1/ 
clin     &20X,'**  Last date of change:  ',I2,1X,A3,1X,I4,'  **'/)  
 1100 FORMAT(///28X,'Event listing (summary)'//4X,'I  particle/jet KS', 
     &5X,'KF orig    p_x      p_y      p_z       E        m'/)  
 1200 FORMAT(///28X,'Event listing (standard)'//4X,'I  particle/jet',   
     &'  K(I,1)   K(I,2) K(I,3)     K(I,4)      K(I,5)       P(I,1)',   
     &'       P(I,2)       P(I,3)       P(I,4)       P(I,5)'/)  
 1300 FORMAT(///28X,'Event listing (with vertices)'//4X,'I  particle/j',    
     &'et  K(I,1)   K(I,2) K(I,3)     K(I,4)      K(I,5)       P(I,1)', 
     &'       P(I,2)       P(I,3)       P(I,4)       P(I,5)'/73X,   
     &'V(I,1)       V(I,2)       V(I,3)       V(I,4)       V(I,5)'/)    
 1400 FORMAT(1X,I4,2X,A12,1X,I2,1X,I6,1X,I4,5F9.3)  
 1500 FORMAT(1X,I4,2X,A12,1X,I2,1X,I6,1X,I4,5F9.2)  
 1600 FORMAT(1X,I4,2X,A12,1X,I2,1X,I6,1X,I4,5F9.1)  
 1700 FORMAT(1X,I4,2X,A16,1X,I3,1X,I8,2X,I4,2(3X,I1,2I4),5F13.5)    
 1800 FORMAT(1X,I4,2X,A16,1X,I3,1X,I8,2X,I4,2(3X,I9),5F13.5)    
 1900 FORMAT(66X,5(1X,F12.3))   
 2000 FORMAT(1X,78('='))    
 2100 FORMAT(1X,130('='))   
 2200 FORMAT(19X,'sum:',F6.2,5X,5F9.3)  
 2300 FORMAT(19X,'sum:',F6.2,5X,5F9.2)  
 2400 FORMAT(19X,'sum:',F6.2,5X,5F9.1)  
 2500 FORMAT(19X,'sum charge:',F6.2,3X,'sum momentum and inv. mass:',   
     &5F13.5)   
 2600 FORMAT(///20X,'List of KF codes in program'/) 
 2700 FORMAT(4X,I6,4X,A16,6X,I6,4X,A16) 
 2800 FORMAT(///30X,'Particle/parton data table'//5X,'KF',5X,'KC',4X,   
     &'particle',8X,'antiparticle',6X,'chg  col  anti',8X,'mass',7X,    
     &'width',7X,'w-cut',5X,'lifetime',1X,'decay'/11X,'IDC',1X,'on/off',    
     &1X,'ME',3X,'Br.rat.',4X,'decay products') 
 2900 FORMAT(/1X,I6,3X,I4,4X,A16,A16,3I5,1X,F12.5,2(1X,F11.5),  
     &2X,F12.5,3X,I2)   
 3000 FORMAT(10X,I4,2X,I3,2X,I3,2X,F8.5,4X,5A16)    
 3100 FORMAT(///20X,'Parameter value table'//4X,'I',3X,'MSTU(I)',   
     &8X,'PARU(I)',3X,'MSTJ(I)',8X,'PARJ(I)',8X,'PARF(I)')  
 3200 FORMAT(1X,I4,1X,I9,1X,F14.5,1X,I9,1X,F14.5,1X,F14.5)  
    
      RETURN    
      END   
    
C*********************************************************************  
    
      FUNCTION PLU(I,J) 
    
C...Purpose: to provide various real-valued event related data. 
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      DIMENSION PSUM(4) 
    
C...Set default value. For I = 0 sum of momenta or charges, 
C...or invariant mass of system.    
      PLU=0.    
      IF(I.LT.0.OR.I.GT.MSTU(4).OR.J.LE.0) THEN 
      ELSEIF(I.EQ.0.AND.J.LE.4) THEN    
        DO 100 I1=1,N   
  100   IF(K(I1,1).GT.0.AND.K(I1,1).LE.10) PLU=PLU+P(I1,J)  
      ELSEIF(I.EQ.0.AND.J.EQ.5) THEN    
        DO 110 J1=1,4   
        PSUM(J1)=0. 
        DO 110 I1=1,N   
  110   IF(K(I1,1).GT.0.AND.K(I1,1).LE.10) PSUM(J1)=PSUM(J1)+P(I1,J1)   
        PLU=SQRT(MAX(0.,PSUM(4)**2-PSUM(1)**2-PSUM(2)**2-PSUM(3)**2))   
      ELSEIF(I.EQ.0.AND.J.EQ.6) THEN    
        DO 120 I1=1,N   
  120   IF(K(I1,1).GT.0.AND.K(I1,1).LE.10) PLU=PLU+LUCHGE(K(I1,2))/3.   
      ELSEIF(I.EQ.0) THEN   
    
C...Direct readout of P matrix. 
      ELSEIF(J.LE.5) THEN   
        PLU=P(I,J)  
    
C...Charge, total momentum, transverse momentum, transverse mass.   
      ELSEIF(J.LE.12) THEN  
        IF(J.EQ.6) PLU=LUCHGE(K(I,2))/3.    
        IF(J.EQ.7.OR.J.EQ.8) PLU=P(I,1)**2+P(I,2)**2+P(I,3)**2  
        IF(J.EQ.9.OR.J.EQ.10) PLU=P(I,1)**2+P(I,2)**2   
        IF(J.EQ.11.OR.J.EQ.12) PLU=P(I,5)**2+P(I,1)**2+P(I,2)**2    
        IF(J.EQ.8.OR.J.EQ.10.OR.J.EQ.12) PLU=SQRT(PLU)  
    
C...Theta and phi angle in radians or degrees.  
      ELSEIF(J.LE.16) THEN  
        IF(J.LE.14) PLU=ULANGL(P(I,3),SQRT(P(I,1)**2+P(I,2)**2))    
        IF(J.GE.15) PLU=ULANGL(P(I,1),P(I,2))   
        IF(J.EQ.14.OR.J.EQ.16) PLU=PLU*180./PARU(1) 
    
C...True rapidity, rapidity with pion mass, pseudorapidity. 
      ELSEIF(J.LE.19) THEN  
        PMR=0.  
        IF(J.EQ.17) PMR=P(I,5)  
        IF(J.EQ.18) PMR=ULMASS(211) 
        PR=MAX(1E-20,PMR**2+P(I,1)**2+P(I,2)**2)    
        PLU=SIGN(LOG(MIN((SQRT(PR+P(I,3)**2)+ABS(P(I,3)))/SQRT(PR), 
     &  1E20)),P(I,3))  
    
C...Energy and momentum fractions (only to be used in CM frame).    
      ELSEIF(J.LE.25) THEN  
        IF(J.EQ.20) PLU=2.*SQRT(P(I,1)**2+P(I,2)**2+P(I,3)**2)/PARU(21) 
        IF(J.EQ.21) PLU=2.*P(I,3)/PARU(21)  
        IF(J.EQ.22) PLU=2.*SQRT(P(I,1)**2+P(I,2)**2)/PARU(21)   
        IF(J.EQ.23) PLU=2.*P(I,4)/PARU(21)  
        IF(J.EQ.24) PLU=(P(I,4)+P(I,3))/PARU(21)    
        IF(J.EQ.25) PLU=(P(I,4)-P(I,3))/PARU(21)    
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      BLOCK DATA LUDATA 
    
C...Purpose: to give default values to parameters and particle and  
C...decay data. 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      COMMON/LUDAT4/CHAF(500)   
      CHARACTER CHAF*8  
      SAVE /LUDAT4/ 
      COMMON/LUDATR/MRLU(6),RRLU(100)   
      SAVE /LUDATR/ 
    
C...LUDAT1, containing status codes and most parameters.    
      DATA MSTU/    
     &    0,    0,    0, 9000,10000,  500, 2000,    0,    0,    2,  
     1    6,    1,    1,    0,    1,    1,    0,    0,    0,    0,  
     2    2,   10,    0,    0,    1,   10,    0,    0,    0,    0,  
     3    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     4    2,    2,    1,    4,    2,    1,    1,    0,    0,    0,  
     5   25,   24,    0,    1,    0,    0,    0,    0,    0,    0,  
     6    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     7  40*0,   
     1    1,    5,    3,    5,    0,    0,    0,    0,    0,    0,  
     2  60*0,   
     8    7,    2, 1989,   11,   25,    0,    0,    0,    0,    0,  
     9    0,    0,    0,    0,    0,    0,    0,    0,    0,    0/  
      DATA PARU/    
     & 3.1415927, 6.2831854, 0.1973, 5.068, 0.3894, 2.568,   4*0.,  
     1 0.001, 0.09, 0.01,  0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     2   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     3   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     4  2.0,  1.0, 0.25,  2.5, 0.05,   0.,   0., 0.0001, 0.,   0.,  
     5  2.5,  1.5,  7.0,  1.0,  0.5,  2.0,  3.2,   0.,   0.,   0.,  
     6  40*0.,  
     & 0.0072974, 0.230, 0., 0., 0.,   0.,   0.,   0.,   0.,   0.,  
     1 0.20, 0.25,  1.0,  4.0,   0.,   0.,   0.,   0.,   0.,   0.,  
     2  1.0,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     3  70*0./  
      DATA MSTJ/    
     &    1,    3,    0,    0,    0,    0,    0,    0,    0,    0,  
     1    1,    2,    0,    1,    0,    0,    0,    0,    0,    0,  
     2    2,    1,    1,    2,    1,    0,    0,    0,    0,    0,  
     3    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     4    1,    2,    4,    2,    5,    0,    1,    0,    0,    0,  
     5    0,    3,    0,    0,    0,    0,    0,    0,    0,    0,  
     6  40*0,   
     &    5,    2,    7,    5,    1,    1,    0,    2,    0,    1,  
     1    0,    0,    0,    0,    1,    1,    0,    0,    0,    0,  
     2  80*0/   
      DATA PARJ/    
     & 0.10, 0.30, 0.40, 0.05, 0.50, 0.50, 0.50,   0.,   0.,   0.,  
     1 0.50, 0.60, 0.75,   0.,   0.,   0.,   0.,  1.0,  1.0,   0.,  
     2 0.35,  1.0,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     3 0.10,  1.0,  0.8,  1.5,  0.8,  2.0,  0.2,  2.5,  0.6,  2.5,  
     4  0.5,  0.9,  0.5,  0.9,  0.5,   0.,   0.,   0.,   0.,   0.,  
     5 0.77, 0.77, 0.77,   0.,   0.,   0.,   0.,   0.,  1.0,   0.,  
     6  4.5,  0.7,  0., 0.003,  0.5,  0.5,   0.,   0.,   0.,   0.,  
     7  10., 1000., 100., 1000., 0.,   0.,   0.,   0.,   0.,   0.,  
     8  0.4,  1.0,  1.0,   0.,  10.,  10.,   0.,   0.,   0.,   0.,  
     9 0.02,  1.0,  0.2,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     &   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     1   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     2  1.5,  0.5, 91.2, 2.40, 0.02,  2.0,  1.0, 0.25,0.002,   0.,  
     3   0.,   0.,   0.,   0., 0.01, 0.99,   0.,   0.,  0.2,   0.,  
     4  60*0./  
    
C...LUDAT2, with particle data and flavour treatment parameters.    
      DATA (KCHG(I,1),I=   1, 500)/-1,2,-1,2,-1,2,-1,2,2*0,-3,0,-3,0,   
     &-3,0,-3,6*0,3,9*0,3,2*0,3,46*0,2,-1,2,-1,2,3,11*0,3,0,2*3,    
     &0,3,0,3,12*0,3,0,2*3,0,3,0,3,12*0,3,0,2*3,0,3,0,3,12*0,3,0,2*3,0, 
     &3,0,3,12*0,3,0,2*3,0,3,0,3,12*0,3,0,2*3,0,3,0,3,72*0,3,0,3,28*0,  
     &3,2*0,3,8*0,-3,8*0,3,0,-3,0,3,-3,3*0,3,6,0,3,5*0,-3,0,3,-3,0,-3,  
     &4*0,-3,0,3,6,-3,0,3,-3,0,-3,0,3,6,0,3,5*0,-3,0,3,-3,0,-3,114*0/   
      DATA (KCHG(I,2),I=   1, 500)/8*1,12*0,2,68*0,-1,410*0/    
      DATA (KCHG(I,3),I=   1, 500)/8*1,2*0,8*1,5*0,1,9*0,1,2*0,1,2*0,1, 
     &41*0,1,0,7*1,10*0,9*1,11*0,9*1,11*0,9*1,11*0,9*1,11*0,9*1,    
     &11*0,9*1,71*0,3*1,22*0,1,5*0,1,0,2*1,6*0,1,0,2*1,6*0,2*1,0,5*1,   
     &0,6*1,4*0,6*1,4*0,16*1,4*0,6*1,114*0/ 
      DATA (PMAS(I,1),I=   1, 500)/.0099,.0056,.199,1.35,5.,90.,120.,   
     &200.,2*0.,.00051,0.,.1057,0.,1.7841,0.,60.,5*0.,91.2,80.,15., 
     &6*0.,300.,900.,600.,300.,900.,300.,2*0.,5000.,60*0.,.1396,.4977,  
     &.4936,1.8693,1.8645,1.9693,5.2794,5.2776,5.47972,0.,.135,.5488,   
     &.9575,2.9796,9.4,117.99,238.,397.,2*0.,.7669,.8962,.8921, 
     &2.0101,2.0071,2.1127,2*5.3354,5.5068,0.,.77,.782,1.0194,3.0969,   
     &9.4603,118.,238.,397.,2*0.,1.233,2*1.3,2*2.322,2.51,2*5.73,5.97,  
     &0.,1.233,1.17,1.41,3.46,9.875,118.42,238.42,397.42,2*0.,  
     &.983,2*1.429,2*2.272,2.46,2*5.68,5.92,0.,.983,1.,1.4,3.4151,  
     &9.8598,118.4,238.4,397.4,2*0.,1.26,2*1.401,2*2.372,   
     &2.56,2*5.78,6.02,0.,1.26,1.283,1.422,3.5106,9.8919,118.5,238.5,   
     &397.5,2*0.,1.318,2*1.426,2*2.422,2.61,2*5.83,6.07,0.,1.318,1.274, 
     &1.525,3.5563,9.9132,118.45,238.45,397.45,2*0.,2*.4977,    
     &83*0.,1.1156,5*0.,2.2849,0.,2*2.46,6*0.,5.62,0.,2*5.84,6*0.,  
     &.9396,.9383,0.,1.1974,1.1926,1.1894,1.3213,1.3149,0.,2.454,   
     &2.4529,2.4522,2*2.55,2.73,4*0.,3*5.8,2*5.96,6.12,4*0.,1.234,  
     &1.233,1.232,1.231,1.3872,1.3837,1.3828,1.535,1.5318,1.6724,3*2.5, 
     &2*2.63,2.8,4*0.,3*5.81,2*5.97,6.13,114*0./    
      DATA (PMAS(I,2),I=   1, 500)/22*0.,2.4,2.3,88*0.,.0002,.001,  
     &6*0.,.149,.0505,.0513,7*0.,.153,.0085,.0044,7*0.,.15,2*.09,2*.06, 
     &.04,3*.1,0.,.15,.335,.08,2*.01,5*0.,.057,2*.287,2*.06,.04,3*.1,   
     &0.,.057,0.,.25,.0135,6*0.,.4,2*.184,2*.06,.04,3*.1,0.,.4,.025,    
     &.055,.0135,6*0.,.11,.115,.099,2*.06,4*.1,0.,.11,.185,.076,.0026,  
     &146*0.,4*.115,.039,2*.036,.0099,.0091,131*0./ 
      DATA (PMAS(I,3),I=   1, 500)/22*0.,2*20.,88*0.,.002,.005,6*0.,.4, 
     &2*.2,7*0.,.4,.1,.015,7*0.,.25,2*.01,3*.08,2*.2,.12,0.,.25,.2, 
     &.001,2*.02,5*0.,.05,2*.4,3*.08,2*.2,.12,0.,.05,0.,.35,.05,6*0.,   
     &3*.3,2*.08,.06,2*.2,.12,0.,.3,.05,.025,.001,6*0.,.25,4*.12,4*.2,  
     &0.,.25,.17,.2,.01,146*0.,4*.14,.04,2*.035,2*.05,131*0./   
      DATA (PMAS(I,4),I=   1, 500)/12*0.,658650.,0.,.091,68*0.,.1,.43,  
     &15*0.,7803.,0.,3709.,.32,.128,.131,3*.393,84*0.,.004,26*0.,   
     &15540.,26.75,83*0.,78.88,5*0.,.054,0.,2*.13,6*0.,.393,0.,2*.393,  
     &9*0.,44.3,0.,24.,49.1,86.9,6*0.,.13,9*0.,.393,13*0.,24.6,130*0./  
      DATA PARF/    
     &  0.5, 0.25,  0.5, 0.25,   1.,  0.5,   0.,   0.,   0.,   0.,  
     1  0.5,   0.,  0.5,   0.,   1.,   1.,   0.,   0.,   0.,   0.,  
     2  0.5,   0.,  0.5,   0.,   1.,   1.,   0.,   0.,   0.,   0.,  
     3  0.5,   0.,  0.5,   0.,   1.,   1.,   0.,   0.,   0.,   0.,  
     4  0.5,   0.,  0.5,   0.,   1.,   1.,   0.,   0.,   0.,   0.,  
     5  0.5,   0.,  0.5,   0.,   1.,   1.,   0.,   0.,   0.,   0.,  
     6 0.75,  0.5,   0., 0.1667, 0.0833, 0.1667, 0., 0., 0.,   0.,  
     7   0.,   0.,   1., 0.3333, 0.6667, 0.3333, 0., 0., 0.,   0.,  
     8   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     9   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     & 0.325, 0.325, 0.5, 1.6,  5.0,   0.,   0.,   0.,   0.,   0.,  
     1   0., 0.11, 0.16, 0.048, 0.50, 0.45, 0.55, 0.60,  0.,   0.,  
     2  0.2,  0.1,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  
     3  1870*0./    
      DATA ((VCKM(I,J),J=1,4),I=1,4)/   
     1  0.95150,  0.04847,  0.00003,  0.00000,  
     2  0.04847,  0.94936,  0.00217,  0.00000,  
     3  0.00003,  0.00217,  0.99780,  0.00000,  
     4  0.00000,  0.00000,  0.00000,  1.00000/  
    
C...LUDAT3, with particle decay parameters and data.    
      DATA (MDCY(I,1),I=   1, 500)/14*0,1,0,1,5*0,3*1,6*0,1,4*0,1,2*0,  
     &1,42*0,7*1,12*0,1,0,6*1,0,8*1,2*0,9*1,0,8*1,2*0,9*1,0,8*1,2*0,    
     &9*1,0,8*1,2*0,9*1,0,8*1,2*0,9*1,0,8*1,3*0,1,83*0,1,5*0,1,0,2*1,   
     &6*0,1,0,2*1,9*0,5*1,0,6*1,4*0,6*1,4*0,16*1,4*0,6*1,114*0/ 
      DATA (MDCY(I,2),I=   1, 500)/1,9,17,25,33,41,49,57,2*0,65,69,71,  
     &76,78,118,120,125,2*0,127,136,149,166,186,6*0,203,4*0,219,2*0,    
     &227,42*0,236,237,241,250,252,254,256,11*0,276,277,279,285,406,    
     &574,606,607,608,0,609,611,617,623,624,625,626,627,2*0,628,629,    
     &632,635,638,640,641,642,643,0,644,645,650,658,661,670,685,686,    
     &2*0,687,688,693,698,700,702,703,705,707,0,709,710,713,717,718,    
     &719,721,722,2*0,723,726,728,730,734,738,740,744,748,0,752,755,    
     &759,763,765,767,769,770,2*0,771,773,775,777,779,781,784,786,788,  
     &0,791,793,806,810,812,814,816,817,2*0,818,824,835,846,854,862,    
     &867,875,883,0,888,895,903,905,907,909,911,912,2*0,913,921,83*0,   
     &923,5*0,927,0,1001,1002,6*0,1003,0,1004,1005,9*0,1006,1008,1009,  
     &1012,1013,0,1015,1016,1017,1018,1019,1020,4*0,1021,1022,1023, 
     &1024,1025,1026,4*0,1027,1028,1031,1034,1035,1038,1041,1044,1046,  
     &1048,1052,1053,1054,1055,1057,1059,4*0,1060,1061,1062,1063,1064,  
     &1065,114*0/   
      DATA (MDCY(I,3),I=   1, 500)/8*8,2*0,4,2,5,2,40,2,5,2,2*0,9,13,   
     &17,20,17,6*0,16,4*0,8,2*0,9,42*0,1,4,9,3*2,20,11*0,1,2,6,121,168, 
     &32,3*1,0,2,2*6,5*1,2*0,1,3*3,2,4*1,0,1,5,8,3,9,15,2*1,2*0,1,2*5,  
     &2*2,1,3*2,0,1,3,4,2*1,2,2*1,2*0,3,2*2,2*4,2,3*4,0,3,2*4,3*2,2*1,  
     &2*0,5*2,3,2*2,3,0,2,13,4,3*2,2*1,2*0,6,2*11,2*8,5,2*8,5,0,7,8,    
     &4*2,2*1,2*0,8,2,83*0,4,5*0,74,0,2*1,6*0,1,0,2*1,9*0,2,1,3,1,2,0,  
     &6*1,4*0,6*1,4*0,1,2*3,1,3*3,2*2,4,3*1,2*2,1,4*0,6*1,114*0/    
      DATA (MDME(I,1),I=   1,2000)/6*1,-1,7*1,-1,7*1,-1,7*1,-1,7*1,-1,  
     &7*1,-1,85*1,2*-1,7*1,2*-1,3*1,2*-1,6*1,2*-1,6*1,3*-1,3*1,-1,3*1,  
     &-1,3*1,5*-1,3*1,-1,6*1,2*-1,3*1,-1,11*1,2*-1,6*1,2*-1,3*1,-1,3*1, 
     &-1,4*1,2*-1,2*1,-1,488*1,2*0,1275*1/  
      DATA (MDME(I,2),I=   1,2000)/70*102,42,6*102,2*42,2*0,7*41,2*0,   
     &23*41,6*102,45,28*102,8*32,9*0,16*32,4*0,8*32,4*0,32,4*0,8*32,    
     &8*0,4*32,4*0,6*32,3*0,12,2*42,2*11,9*42,6*45,20*46,7*0,34*42, 
     &86*0,2*25,26,24*42,142*0,25,26,0,10*42,19*0,2*13,3*85,0,2,4*0,2,  
     &8*0,2*32,87,88,3*3,0,2*3,0,2*3,0,3,5*0,3,1,0,3,2*0,2*3,3*0,1,4*0, 
     &12,3*0,4*32,2*4,6*0,5*32,2*4,2*45,87,88,30*0,12,32,0,32,87,88,    
     &41*0,12,0,32,0,32,87,88,40*0,12,0,32,0,32,87,88,88*0,12,0,32,0,   
     &32,87,88,2*0,4*42,8*0,14*42,50*0,10*13,2*84,3*85,14*0,84,5*0,85,  
     &974*0/    
      DATA (BRAT(I)  ,I=   1, 525)/70*0.,1.,6*0.,2*.177,.108,.225,.003, 
     &.06,.02,.025,.013,2*.004,.007,.014,2*.002,2*.001,.054,.014,.016,  
     &.005,2*.012,5*.006,.002,2*.001,5*.002,6*0.,1.,28*0.,.143,.111,    
     &.143,.111,.143,.085,2*0.,.03,.058,.03,.058,.03,.058,3*0.,.25,.01, 
     &2*0.,.01,.25,4*0.,.24,5*0.,3*.08,3*0.,.01,.08,.82,5*0.,.09,6*0.,  
     &.143,.111,.143,.111,.143,.085,2*0.,.03,.058,.03,.058,.03,.058,    
     &4*0.,1.,5*0.,4*.215,2*0.,2*.07,0.,1.,2*.08,.76,.08,2*.112,.05,    
     &.476,.08,.14,.01,.015,.005,1.,0.,1.,0.,1.,0.,.25,.01,2*0.,.01,    
     &.25,4*0.,.24,5*0.,3*.08,0.,1.,2*.5,.635,.212,.056,.017,.048,.032, 
     &.035,.03,2*.015,.044,2*.022,9*.001,.035,.03,2*.015,.044,2*.022,   
     &9*.001,.028,.017,.066,.02,.008,2*.006,.003,.001,2*.002,.003,.001, 
     &2*.002,.005,.002,.005,.006,.004,.012,2*.005,.008,2*.005,.037, 
     &.004,.067,2*.01,2*.001,3*.002,.003,8*.002,.005,4*.004,.015,.005,  
     &.027,2*.005,.007,.014,.007,.01,.008,.012,.015,11*.002,3*.004, 
     &.002,.004,6*.002,2*.004,.005,.011,.005,.015,.02,2*.01,3*.004, 
     &5*.002,.015,.02,2*.01,3*.004,5*.002,.038,.048,.082,.06,.028,.021, 
     &2*.005,2*.002,.005,.018,.005,.01,.008,.005,3*.004,.001,3*.003,    
     &.001,2*.002,.003,2*.002,2*.001,.002,.001,.002,.001,.005,4*.003,   
     &.001,2*.002,.003,2*.001,.013,.03,.058,.055,3*.003,2*.01,.007, 
     &.019,4*.005,.015,3*.005,8*.002,3*.001,.002,2*.001,.003,16*.001/   
      DATA (BRAT(I)  ,I= 526, 893)/.019,2*.003,.002,.005,.004,.008, 
     &.003,.006,.003,.01,5*.002,2*.001,2*.002,11*.001,.002,14*.001, 
     &.018,.005,.01,2*.015,.017,4*.015,.017,3*.015,.025,.08,2*.025,.04, 
     &.001,2*.005,.02,.04,2*.06,.04,.01,4*.005,.25,.115,3*1.,.988,.012, 
     &.389,.319,.237,.049,.005,.001,.441,.205,.301,.03,.022,.001,6*1.,  
     &.665,.333,.002,.666,.333,.001,.49,.34,.17,.52,.48,5*1.,.893,.08,  
     &.017,2*.005,.495,.343,3*.043,.019,.013,.001,2*.069,.862,3*.027,   
     &.015,.045,.015,.045,.77,.029,6*.02,5*.05,.115,.015,.5,0.,3*1.,    
     &.28,.14,.313,.157,.11,.28,.14,.313,.157,.11,.667,.333,.667,.333,  
     &1.,.667,.333,.667,.333,2*.5,1.,.333,.334,.333,4*.25,2*1.,.3,.7,   
     &2*1.,.8,2*.1,.667,.333,.667,.333,.6,.3,.067,.033,.6,.3,.067,.033, 
     &2*.5,.6,.3,.067,.033,.6,.3,.067,.033,2*.4,2*.1,.8,2*.1,.52,.26,   
     &2*.11,.62,.31,2*.035,.007,.993,.02,.98,.3,.7,2*1.,2*.5,.667,.333, 
     &.667,.333,.667,.333,.667,.333,2*.35,.3,.667,.333,.667,.333,2*.35, 
     &.3,2*.5,3*.14,.1,.05,4*.08,.028,.027,.028,.027,4*.25,.273,.727,   
     &.35,.65,.3,.7,2*1.,2*.35,.144,.105,.048,.003,.332,.166,.168,.084, 
     &.086,.043,.059,2*.029,2*.002,.332,.166,.168,.084,.086,.043,.059,  
     &2*.029,2*.002,.3,.15,.16,.08,.13,.06,.08,.04,.3,.15,.16,.08,.13,  
     &.06,.08,.04,2*.4,.1,2*.05,.3,.15,.16,.08,.13,.06,.08,.04,.3,.15,  
     &.16,.08,.13,.06,.08,.04,2*.4,.1,2*.05,2*.35,.144,.105,2*.024/ 
      DATA (BRAT(I)  ,I= 894,2000)/.003,.573,.287,.063,.028,2*.021, 
     &.004,.003,2*.5,.15,.85,.22,.78,.3,.7,2*1.,.217,.124,2*.193,   
     &2*.135,.002,.001,.686,.314,.641,.357,2*.001,.018,2*.005,.003, 
     &.002,2*.006,.018,2*.005,.003,.002,2*.006,.005,.025,.015,.006, 
     &2*.005,.004,.005,5*.004,2*.002,2*.004,.003,.002,2*.003,3*.002,    
     &2*.001,.002,2*.001,2*.002,5*.001,4*.003,2*.005,2*.002,2*.001, 
     &2*.002,2*.001,.255,.057,2*.035,.15,2*.075,.03,2*.015,5*1.,.999,   
     &.001,1.,.516,.483,.001,1.,.995,.005,13*1.,.331,.663,.006,.663,    
     &.331,.006,1.,.88,2*.06,.88,2*.06,.88,2*.06,.667,2*.333,.667,.676, 
     &.234,.085,.005,3*1.,4*.5,7*1.,935*0./ 
      DATA (KFDP(I,1),I=   1, 499)/21,22,23,4*-24,25,21,22,23,4*24,25,  
     &21,22,23,4*-24,25,21,22,23,4*24,25,21,22,23,4*-24,25,21,22,23,    
     &4*24,25,21,22,23,4*-24,25,21,22,23,4*24,25,22,23,-24,25,23,24,    
     &-12,22,23,-24,25,23,24,-12,-14,34*16,22,23,-24,25,23,24,-89,22,   
     &23,-24,25,23,24,1,2,3,4,5,6,7,8,21,1,2,3,4,5,6,7,8,11,13,15,17,   
     &37,1,2,3,4,5,6,7,8,11,12,13,14,15,16,17,18,37,4*-1,4*-3,4*-5, 
     &4*-7,-11,-13,-15,-17,1,2,3,4,5,6,7,8,11,13,15,17,21,2*22,23,24,1, 
     &2,3,4,5,6,7,8,11,12,13,14,15,16,17,18,-1,-3,-5,-7,-11,-13,-15,    
     &-17,1,2,3,4,5,6,11,13,15,82,-11,-13,2*2,-12,-14,-16,2*-2,2*-4,-2, 
     &-4,2*89,2*-89,2*89,4*-1,4*-3,4*-5,4*-7,-11,-13,-15,-17,-13,130,   
     &310,-13,3*211,12,14,16*-11,16*-13,-311,-313,-311,-313,-311,-313,  
     &-311,-313,2*111,2*221,2*331,2*113,2*223,2*333,-311,-313,2*-311,   
     &-313,3*-311,-321,-323,-321,2*211,2*213,-213,113,3*213,3*211,  
     &2*213,2*-311,-313,-321,2*-311,-313,-311,-313,4*-311,-321,-323,    
     &2*-321,3*211,213,2*211,213,5*211,213,4*211,3*213,211,213,321,311, 
     &3,2*2,12*-11,12*-13,-321,-323,-321,-323,-311,-313,-311,-313,-311, 
     &-313,-311,-313,-311,-313,-311,-321,-323,-321,-323,211,213,211,    
     &213,111,221,331,113,223,333,221,331,113,223,113,223,113,223,333,  
     &223,333,321,323,321,323,311,313,-321,-323,3*-321,-323,2*-321, 
     &-323,-321,-311,-313,3*-311,-313,2*-311,-313,-321,-323,3*-321/ 
      DATA (KFDP(I,1),I= 500, 873)/-323,2*-321,-311,2*333,211,213,  
     &2*211,2*213,4*211,10*111,-321,-323,5*-321,-323,2*-321,-311,-313,  
     &4*-311,-313,4*-311,-321,-323,2*-321,-323,-321,-313,-311,-313, 
     &-311,211,213,2*211,213,4*211,111,221,113,223,113,223,2*3,-15, 
     &5*-11,5*-13,221,331,333,221,331,333,211,213,211,213,321,323,321,  
     &323,2212,221,331,333,221,2*2,3*0,3*22,111,211,2*22,2*211,111, 
     &3*22,111,3*21,2*0,211,321,3*311,2*321,421,2*411,2*421,431,511,    
     &521,531,2*211,22,211,2*111,321,130,-213,113,213,211,22,111,11,13, 
     &82,11,13,15,1,2,3,4,21,22,11,12,13,14,15,16,1,2,3,4,5,21,22,2*89, 
     &2*0,223,321,311,323,313,2*311,321,313,323,321,421,2*411,421,433,  
     &521,2*511,521,523,513,223,213,113,-213,313,-313,323,-323,82,21,   
     &663,21,2*0,221,213,113,321,2*311,321,421,411,423,413,411,421,413, 
     &423,431,433,521,511,523,513,511,521,513,523,521,511,531,533,221,  
     &213,-213,211,111,321,130,211,111,321,130,443,82,553,21,663,21,    
     &2*0,113,213,323,2*313,323,423,2*413,423,421,411,433,523,2*513,    
     &523,521,511,533,213,-213,10211,10111,-10211,2*221,213,2*113,-213, 
     &2*321,2*311,313,-313,323,-323,443,82,553,21,663,21,2*0,213,113,   
     &221,223,321,211,321,311,323,313,323,313,321,5*311,321,313,323,    
     &313,323,311,4*321,421,411,423,413,423,413,421,2*411,421,413,423,  
     &413,423,411,2*421,411,433,2*431,521,511,523,513,523,513,521/  
      DATA (KFDP(I,1),I= 874,2000)/2*511,521,513,523,513,523,511,2*521, 
     &511,533,2*531,213,-213,221,223,321,130,111,211,111,2*211,321,130, 
     &221,111,321,130,443,82,553,21,663,21,2*0,111,211,-12,12,-14,14,   
     &211,111,211,111,2212,2*2112,-12,7*-11,7*-13,2*2224,2*2212,2*2214, 
     &2*3122,2*3212,2*3214,5*3222,4*3224,2*3322,3324,2*2224,5*2212, 
     &5*2214,2*2112,2*2114,2*3122,2*3212,2*3214,2*3222,2*3224,4*2,3,    
     &2*2,1,2*2,5*0,2112,-12,3122,2212,2112,2212,3*3122,3*4122,4132,    
     &4232,0,3*5122,5132,5232,0,2112,2212,2*2112,2212,2112,2*2212,3122, 
     &3212,3112,3122,3222,3112,3122,3222,3212,3322,3312,3322,3312,3122, 
     &3322,3312,-12,3*4122,2*4132,2*4232,4332,3*5122,5132,5232,5332,    
     &935*0/    
      DATA (KFDP(I,2),I=   1, 496)/3*1,2,4,6,8,1,3*2,1,3,5,7,2,3*3,2,4, 
     &6,8,3,3*4,1,3,5,7,4,3*5,2,4,6,8,5,3*6,1,3,5,7,6,3*7,2,4,6,8,7,    
     &3*8,1,3,5,7,8,2*11,12,11,12,2*11,2*13,14,13,14,13,11,13,-211, 
     &-213,-211,-213,-211,-213,3*-211,-321,-323,-321,-323,2*-321,   
     &4*-211,-213,-211,-213,-211,-213,-211,-213,-211,-213,6*-211,2*15,  
     &16,15,16,15,18,2*17,18,17,18,17,-1,-2,-3,-4,-5,-6,-7,-8,21,-1,-2, 
     &-3,-4,-5,-6,-7,-8,-11,-13,-15,-17,-37,-1,-2,-3,-4,-5,-6,-7,-8,    
     &-11,-12,-13,-14,-15,-16,-17,-18,-37,2,4,6,8,2,4,6,8,2,4,6,8,2,4,  
     &6,8,12,14,16,18,-1,-2,-3,-4,-5,-6,-7,-8,-11,-13,-15,-17,21,22,    
     &2*23,-24,-1,-2,-3,-4,-5,-6,-7,-8,-11,-12,-13,-14,-15,-16,-17,-18, 
     &2,4,6,8,12,14,16,18,-3,-4,-5,-6,-7,-8,-13,-15,-17,-82,12,14,-1,   
     &-3,11,13,15,1,4,3,4,1,3,5,3,6,4,7,5,2,4,6,8,2,4,6,8,2,4,6,8,2,4,  
     &6,8,12,14,16,18,14,2*0,14,111,211,111,-11,-13,16*12,16*14,2*211,  
     &2*213,2*321,2*323,211,213,211,213,211,213,211,213,211,213,211,    
     &213,2*211,213,7*211,213,211,111,211,111,2*211,-213,213,2*113,223, 
     &2*113,221,321,2*311,321,313,4*211,213,113,213,-213,2*211,213,113, 
     &111,221,331,111,113,223,4*113,223,6*211,213,4*211,-321,-311,3*-1, 
     &12*12,12*14,2*211,2*213,2*111,2*221,2*331,2*113,2*223,333,2*321,  
     &2*323,2*-211,2*-213,6*111,4*221,2*331,3*113,2*223,2*-211,2*-213,  
     &113,111,2*211,213,6*211,321,2*211,213,211,2*111,113,2*223,2*321/  
      DATA (KFDP(I,2),I= 497, 863)/323,321,2*311,313,2*311,111,211, 
     &2*-211,-213,-211,-213,-211,-213,3*-211,5*111,2*113,223,113,223,   
     &2*211,213,5*211,213,3*211,213,2*211,2*111,221,113,223,3*321,323,  
     &2*321,323,311,313,311,313,3*211,2*-211,-213,3*-211,4*111,2*113,   
     &2*-1,16,5*12,5*14,3*211,3*213,2*111,2*113,2*-311,2*-313,-2112,    
     &3*321,323,2*-1,3*0,22,11,22,111,-211,211,11,2*-211,111,113,223,   
     &22,111,3*21,2*0,111,-211,111,22,211,111,22,211,111,22,111,5*22,   
     &2*-211,111,-211,2*111,-321,310,211,111,2*-211,221,22,-11,-13,-82, 
     &-11,-13,-15,-1,-2,-3,-4,2*21,-11,-12,-13,-14,-15,-16,-1,-2,-3,-4, 
     &-5,2*21,5,3,2*0,211,-213,113,-211,111,223,211,111,211,111,223,    
     &211,111,-211,2*111,-211,111,211,111,-321,-311,111,-211,111,211,   
     &-311,311,-321,321,-82,21,22,21,2*0,211,111,211,-211,111,211,111,  
     &211,111,211,111,-211,111,-211,3*111,-211,111,-211,111,211,111,    
     &211,111,-321,-311,3*111,-211,211,-211,111,-321,310,-211,111,-321, 
     &310,22,-82,22,21,22,21,2*0,211,111,-211,111,211,111,211,111,-211, 
     &111,321,311,111,-211,111,211,111,-321,-311,111,-211,211,-211,111, 
     &2*211,111,-211,211,111,211,-321,2*-311,-321,-311,311,-321,321,22, 
     &-82,22,21,22,21,2*0,111,3*211,-311,22,-211,111,-211,111,-211,211, 
     &-213,113,223,221,22,211,111,211,111,2*211,213,113,223,221,22,211, 
     &111,211,111,4*211,-211,111,-211,111,-211,211,-211,211,321,311/    
      DATA (KFDP(I,2),I= 864,2000)/2*111,211,-211,111,-211,111,-211,    
     &211,-211,2*211,111,211,111,4*211,-321,-311,2*111,211,-211,211,    
     &111,211,-321,310,22,-211,111,2*-211,-321,310,221,111,-321,310,22, 
     &-82,22,21,22,21,2*0,111,-211,11,-11,13,-13,-211,111,-211,111, 
     &-211,111,22,11,7*12,7*14,-321,-323,-311,-313,-311,-313,211,213,   
     &211,213,211,213,111,221,331,113,223,111,221,113,223,321,323,321,  
     &-211,-213,111,221,331,113,223,111,221,331,113,223,211,213,211,    
     &213,321,323,321,323,321,323,311,313,311,313,2*-1,-3,-1,2203,  
     &2*3201,2203,2101,2103,5*0,-211,11,22,111,211,22,-211,111,22,-211, 
     &111,211,2*22,0,-211,111,211,2*22,0,2*-211,111,22,111,211,22,211,  
     &2*-211,2*111,-211,2*211,111,211,-211,2*111,211,-321,-211,111,11,  
     &-211,111,211,111,22,111,2*22,-211,111,211,3*22,935*0/ 
      DATA (KFDP(I,3),I=   1, 918)/70*0,14,6*0,2*16,2*0,5*111,310,130,  
     &2*0,2*111,310,130,113,211,223,221,2*113,2*211,2*223,2*221,2*113,  
     &221,113,2*213,-213,123*0,4*3,4*4,1,4,3,2*2,6*81,25*0,-211,3*111,  
     &-311,-313,-311,2*-321,2*-311,111,221,331,113,223,211,111,211,111, 
     &-311,-313,-311,2*-321,2*-311,111,221,331,113,223,211,111,211,111, 
     &20*0,3*111,2*221,331,113,223,3*211,-211,111,-211,111,211,111,211, 
     &-211,111,113,111,223,2*111,-311,4*211,2*111,2*211,111,7*211,  
     &7*111,113,221,2*223,2*-211,-213,4*-211,-213,-211,-213,-211,2*211, 
     &2,2*0,-321,-323,-311,-321,-311,2*-321,-211,-213,2*-211,211,-321,  
     &-323,-311,-321,-311,2*-321,-211,-213,2*-211,211,46*0,3*111,113,   
     &2*221,331,2*223,-311,3*-211,-213,8*111,113,3*211,213,2*111,-211,  
     &3*111,113,111,2*113,221,331,223,111,221,331,113,223,113,2*223,    
     &2*221,3*111,221,113,223,4*211,3*-211,-213,-211,5*111,-321,3*211,  
     &3*111,2*211,2*111,2*-211,-213,3*111,221,113,223,6*111,3*0,221,    
     &331,333,321,311,221,331,333,321,311,19*0,3,5*0,-11,0,2*111,-211,  
     &-11,11,2*221,3*0,111,22*0,111,2*0,22,111,5*0,111,12*0,2*21,11*0,  
     &2*21,2*-6,111*0,-211,2*111,-211,3*111,-211,111,211,15*0,111,6*0,  
     &111,-211,9*0,111,-211,9*0,111,-211,111,-211,4*0,111,-211,111, 
     &-211,4*0,-211,4*0,111,-211,111,-211,4*0,111,-211,111,-211,4*0,    
     &-211,3*0,-211,5*0,111,211,3*0,111,10*0,2*111,211,-211,211,-211/   
      DATA (KFDP(I,3),I= 919,2000)/7*0,2212,3122,3212,3214,2112,2114,   
     &2212,2112,3122,3212,3214,2112,2114,2212,2112,50*0,3*3,1,12*0, 
     &2112,43*0,3322,949*0/ 
      DATA (KFDP(I,4),I=   1,2000)/83*0,3*111,9*0,-211,3*0,111,2*-211,  
     &0,111,0,2*111,113,221,111,-213,-211,211,123*0,13*81,37*0,111, 
     &3*211,111,5*0,-211,111,-211,111,2*0,111,3*211,111,5*0,-211,111,   
     &-211,111,50*0,2*111,2*-211,2*111,-211,211,3*111,211,14*111,221,   
     &113,223,2*111,2*113,223,2*111,-1,4*0,-211,111,-211,211,111,2*0,   
     &2*111,-211,2*0,-211,111,-211,211,111,2*0,2*111,-211,96*0,6*111,   
     &3*-211,-213,4*111,113,6*111,3*-211,3*111,2*-211,2*111,3*-211, 
     &12*111,6*0,-321,-311,3*0,-321,-311,19*0,-3,11*0,-11,280*0,111,    
     &-211,3*0,111,29*0,-211,111,5*0,-211,111,50*0,2101,2103,2*2101,    
     &1006*0/   
      DATA (KFDP(I,5),I=   1,2000)/85*0,111,15*0,111,7*0,111,0,2*111,   
     &175*0,111,-211,111,7*0,2*111,4*0,111,-211,111,7*0,2*111,93*0,111, 
     &-211,111,3*0,111,-211,4*0,111,-211,111,3*0,111,-211,1571*0/   
    
C...LUDAT4, with character strings. 
      DATA (CHAF(I)  ,I=   1, 331)/'d','u','s','c','b','t','l','h', 
     &2*' ','e','nu_e','mu','nu_mu','tau','nu_tau','chi','nu_chi',  
     &2*' ','g','gamma','Z','W','H',6*' ','Z''','Z"','W''','H''','H"',  
     &'H',2*' ','R',40*' ','specflav','rndmflav','phasespa','c-hadron', 
     &'b-hadron','t-hadron','l-hadron','h-hadron','Wvirt','diquark',    
     &'cluster','string','indep.','CMshower','SPHEaxis','THRUaxis', 
     &'CLUSjet','CELLjet','table',' ','pi',2*'K',2*'D','D_s',2*'B', 
     &'B_s',' ','pi','eta','eta''','eta_c','eta_b','eta_t','eta_l', 
     &'eta_h',2*' ','rho',2*'K*',2*'D*','D*_s',2*'B*','B*_s',' ','rho', 
     &'omega','phi','J/psi','Upsilon','Theta','Theta_l','Theta_h',  
     &2*' ','b_1',2*'K_1',2*'D_1','D_1s',2*'B_1','B_1s',' ','b_1',  
     &'h_1','h''_1','h_1c','h_1b','h_1t','h_1l','h_1h',2*' ','a_0', 
     &2*'K*_0',2*'D*_0','D*_0s',2*'B*_0','B*_0s',' ','a_0','f_0',   
     &'f''_0','chi_0c','chi_0b','chi_0t','chi_0l','chi_0h',2*' ','a_1', 
     &2*'K*_1',2*'D*_1','D*_1s',2*'B*_1','B*_1s',' ','a_1','f_1',   
     &'f''_1','chi_1c','chi_1b','chi_1t','chi_1l','chi_1h',2*' ','a_2', 
     &2*'K*_2',2*'D*_2','D*_2s',2*'B*_2','B*_2s',' ','a_2','f_2',   
     &'f''_2','chi_2c','chi_2b','chi_2t','chi_2l','chi_2h',2*' ','K_L', 
     &'K_S',58*' ','pi_diffr','n_diffr','p_diffr',22*' ','Lambda',5*' ',    
     &'Lambda_c',' ',2*'Xi_c',6*' ','Lambda_b',' ',2*'Xi_b',6*' '/  
      DATA (CHAF(I)  ,I= 332, 500)/'n','p',' ',3*'Sigma',2*'Xi',' ',    
     &3*'Sigma_c',2*'Xi''_c','Omega_c', 
     &4*' ',3*'Sigma_b',2*'Xi''_b','Omega_b',4*' ',4*'Delta',   
     &3*'Sigma*',2*'Xi*','Omega',3*'Sigma*_c',2*'Xi*_c','Omega*_c', 
     &4*' ',3*'Sigma*_b',2*'Xi*_b','Omega*_b',114*' '/  
    
C...LUDATR, with initial values for the random number generator.    
      DATA MRLU/19780503,0,0,97,33,0/   
    
      END   
      SUBROUTINE PYINIT(FRAME,BEAM,TARGET,WIN)  
    
C...Initializes the generation procedure; finds maxima of the   
C...differential cross-sections to be used for weighting.   
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      COMMON/LUDAT4/CHAF(500)   
      CHARACTER CHAF*8  
      SAVE /LUDAT4/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3) 
      SAVE /PYINT5/ 
      CHARACTER*(*) FRAME,BEAM,TARGET   
      CHARACTER CHFRAM*8,CHBEAM*8,CHTARG*8,CHMO(12)*3,CHLH(2)*6 
      DATA CHMO/'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep',  
     &'Oct','Nov','Dec'/, CHLH/'lepton','hadron'/   
    
clin-12/2012 correct NN differential cross section in HIJING:
      WRITE(MSTU(11),*) 'In PYINIT: BEAM,TARGET= ',BEAM,TARGET

C...Write headers.  
C      IF(MSTP(122).GE.1) WRITE(MSTU(11),1000) MSTP(181),MSTP(182),  
C     &MSTP(185),CHMO(MSTP(184)),MSTP(183)   
      CALL LULIST(0)
C      IF(MSTP(122).GE.1) WRITE(MSTU(11),1100)  
    
C...Identify beam and target particles and initialize kinematics.   
      CHFRAM=FRAME//' ' 
      CHBEAM=BEAM//' '  
      CHTARG=TARGET//' '    
      CALL PYINKI(CHFRAM,CHBEAM,CHTARG,WIN) 
    
C...Select partonic subprocesses to be included in the simulation.  
      IF(MSEL.NE.0) THEN    
        DO 100 I=1,200  
  100   MSUB(I)=0   
      ENDIF 
      IF(MINT(43).EQ.1.AND.(MSEL.EQ.1.OR.MSEL.EQ.2)) THEN   
C...Lepton+lepton -> gamma/Z0 or W. 
        IF(MINT(11)+MINT(12).EQ.0) MSUB(1)=1    
        IF(MINT(11)+MINT(12).NE.0) MSUB(2)=1    
      ELSEIF(MSEL.EQ.1) THEN    
C...High-pT QCD processes:  
        MSUB(11)=1  
        MSUB(12)=1  
        MSUB(13)=1  
        MSUB(28)=1  
        MSUB(53)=1  
        MSUB(68)=1  
        IF(MSTP(82).LE.1.AND.CKIN(3).LT.PARP(81)) MSUB(95)=1    
        IF(MSTP(82).GE.2.AND.CKIN(3).LT.PARP(82)) MSUB(95)=1    
      ELSEIF(MSEL.EQ.2) THEN    
C...All QCD processes:  
        MSUB(11)=1  
        MSUB(12)=1  
        MSUB(13)=1  
        MSUB(28)=1  
        MSUB(53)=1  
        MSUB(68)=1  
        MSUB(91)=1  
        MSUB(92)=1  
        MSUB(93)=1  
        MSUB(95)=1  
      ELSEIF(MSEL.GE.4.AND.MSEL.LE.8) THEN  
C...Heavy quark production. 
        MSUB(81)=1  
        MSUB(82)=1  
        DO 110 J=1,MIN(8,MDCY(21,3))    
  110   MDME(MDCY(21,2)+J-1,1)=0    
        MDME(MDCY(21,2)+MSEL-1,1)=1 
      ELSEIF(MSEL.EQ.10) THEN   
C...Prompt photon production:   
        MSUB(14)=1  
        MSUB(18)=1  
        MSUB(29)=1  
      ELSEIF(MSEL.EQ.11) THEN   
C...Z0/gamma* production:   
        MSUB(1)=1   
      ELSEIF(MSEL.EQ.12) THEN   
C...W+/- production:    
        MSUB(2)=1   
      ELSEIF(MSEL.EQ.13) THEN   
C...Z0 + jet:   
        MSUB(15)=1  
        MSUB(30)=1  
      ELSEIF(MSEL.EQ.14) THEN   
C...W+/- + jet: 
        MSUB(16)=1  
        MSUB(31)=1  
      ELSEIF(MSEL.EQ.15) THEN   
C...Z0 & W+/- pair production:  
        MSUB(19)=1  
        MSUB(20)=1  
        MSUB(22)=1  
        MSUB(23)=1  
        MSUB(25)=1  
      ELSEIF(MSEL.EQ.16) THEN   
C...H0 production:  
        MSUB(3)=1   
        MSUB(5)=1   
        MSUB(8)=1   
        MSUB(102)=1 
      ELSEIF(MSEL.EQ.17) THEN   
C...H0 & Z0 or W+/- pair production:    
        MSUB(24)=1  
        MSUB(26)=1  
      ELSEIF(MSEL.EQ.21) THEN   
C...Z'0 production: 
        MSUB(141)=1 
      ELSEIF(MSEL.EQ.22) THEN   
C...H+/- production:    
        MSUB(142)=1 
      ELSEIF(MSEL.EQ.23) THEN   
C...R production:   
        MSUB(143)=1 
      ENDIF 
    
C...Count number of subprocesses on.    
      MINT(44)=0    
      DO 120 ISUB=1,200 
      IF(MINT(43).LT.4.AND.ISUB.GE.91.AND.ISUB.LE.96.AND.   
     &MSUB(ISUB).EQ.1) THEN 
        WRITE(MSTU(11),1200) ISUB,CHLH(MINT(41)),CHLH(MINT(42)) 
        STOP    
      ELSEIF(MSUB(ISUB).EQ.1.AND.ISET(ISUB).EQ.-1) THEN 
        WRITE(MSTU(11),1300) ISUB   
        STOP    
      ELSEIF(MSUB(ISUB).EQ.1.AND.ISET(ISUB).LE.-2) THEN 
        WRITE(MSTU(11),1400) ISUB   
        STOP    
      ELSEIF(MSUB(ISUB).EQ.1) THEN  
        MINT(44)=MINT(44)+1 
      ENDIF 
  120 CONTINUE  
      IF(MINT(44).EQ.0) THEN    
        WRITE(MSTU(11),1500)    
        STOP    
      ENDIF 
      MINT(45)=MINT(44)-MSUB(91)-MSUB(92)-MSUB(93)-MSUB(94) 
    
C...Maximum 4 generations; set maximum number of allowed flavours.  
      MSTP(1)=MIN(4,MSTP(1))    
      MSTU(114)=MIN(MSTU(114),2*MSTP(1))    
      MSTP(54)=MIN(MSTP(54),2*MSTP(1))  
    
C...Sum up Cabibbo-Kobayashi-Maskawa factors for each quark/lepton. 
      DO 140 I=-20,20   
      VINT(180+I)=0.    
      IA=IABS(I)    
      IF(IA.GE.1.AND.IA.LE.2*MSTP(1)) THEN  
        DO 130 J=1,MSTP(1)  
        IB=2*J-1+MOD(IA,2)  
        IPM=(5-ISIGN(1,I))/2    
        IDC=J+MDCY(IA,2)+2  
  130   IF(MDME(IDC,1).EQ.1.OR.MDME(IDC,1).EQ.IPM) VINT(180+I)= 
     &  VINT(180+I)+VCKM((IA+1)/2,(IB+1)/2) 
      ELSEIF(IA.GE.11.AND.IA.LE.10+2*MSTP(1)) THEN  
        VINT(180+I)=1.  
      ENDIF 
  140 CONTINUE  
    
C...Choose Lambda value to use in alpha-strong. 
      MSTU(111)=MSTP(2) 
      IF(MSTP(3).GE.1) THEN 
        ALAM=PARP(1)    
        IF(MSTP(51).EQ.1) ALAM=0.2  
        IF(MSTP(51).EQ.2) ALAM=0.29 
        IF(MSTP(51).EQ.3) ALAM=0.2  
        IF(MSTP(51).EQ.4) ALAM=0.4  
        IF(MSTP(51).EQ.11) ALAM=0.16    
        IF(MSTP(51).EQ.12) ALAM=0.26    
        IF(MSTP(51).EQ.13) ALAM=0.36    
        PARP(1)=ALAM    
        PARP(61)=ALAM   
        PARU(112)=ALAM  
        PARJ(81)=ALAM   
      ENDIF 
    
C...Initialize widths and partial widths for resonances.    
      CALL PYINRE   
    
C...Reset variables for cross-section calculation.  
      DO 150 I=0,200    
      DO 150 J=1,3  
      NGEN(I,J)=0   
  150 XSEC(I,J)=0.  
      VINT(108)=0.  
    
C...Find parametrized total cross-sections. 
      IF(MINT(43).EQ.4) CALL PYXTOT 
    
C...Maxima of differential cross-sections.  
      IF(MSTP(121).LE.0) CALL PYMAXI    
    
C...Initialize possibility of overlayed events. 
      IF(MSTP(131).NE.0) CALL PYOVLY(1) 
    
C...Initialize multiple interactions with variable impact parameter.    
      IF(MINT(43).EQ.4.AND.(MINT(45).NE.0.OR.MSTP(131).NE.0).AND.   
     &MSTP(82).GE.2) CALL PYMULT(1) 
C      IF(MSTP(122).GE.1) WRITE(MSTU(11),1600)  
    
C...Formats for initialization information. 
clin 1000 FORMAT(///20X,'The Lund Monte Carlo - PYTHIA version ',I1,'.',I1/ 
clin     &20X,'**  Last date of change:  ',I2,1X,A3,1X,I4,'  **'/)  
clin 1100 FORMAT('1',18('*'),1X,'PYINIT: initialization of PYTHIA ',    
clin     &'routines',1X,17('*'))    
 1200 FORMAT(1X,'Error: process number ',I3,' not meaningful for ',A6,  
     &'-',A6,' interactions.'/1X,'Execution stopped!')  
 1300 FORMAT(1X,'Error: requested subprocess',I4,' not implemented.'/   
     &1X,'Execution stopped!')  
 1400 FORMAT(1X,'Error: requested subprocess',I4,' not existing.'/  
     &1X,'Execution stopped!')  
 1500 FORMAT(1X,'Error: no subprocess switched on.'/    
     &1X,'Execution stopped.')  
clin 1600 FORMAT(/1X,22('*'),1X,'PYINIT: initialization completed',1X,  
clin     &22('*'))  
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYTHIA 
    
C...Administers the generation of a high-pt event via calls to a number 
C...of subroutines; also computes cross-sections.   
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3) 
      SAVE /PYINT5/ 
    
C...Loop over desired number of overlayed events (normally 1).  
      MINT(7)=0 
      MINT(8)=0 
      NOVL=1    
      IF(MSTP(131).NE.0) CALL PYOVLY(2) 
      IF(MSTP(131).NE.0) NOVL=MINT(81)  
      MINT(83)=0    
      MINT(84)=MSTP(126)    
      MSTU(70)=0    
      DO 190 IOVL=1,NOVL    
      IF(MINT(84)+100.GE.MSTU(4)) THEN  
        CALL LUERRM(11, 
     &  '(PYTHIA:) no more space in LUJETS for overlayed events')   
        IF(MSTU(21).GE.1) GOTO 200  
      ENDIF 
      MINT(82)=IOVL 
    
C...Generate variables of hard scattering.  
  100 CONTINUE  
      IF(IOVL.EQ.1) NGEN(0,2)=NGEN(0,2)+1   
      MINT(31)=0    
      MINT(51)=0    
      CALL PYRAND   
      ISUB=MINT(1)  
      IF(IOVL.EQ.1) THEN    
        NGEN(ISUB,2)=NGEN(ISUB,2)+1 
    
C...Store information on hard interaction.  
        DO 110 J=1,200  
        MSTI(J)=0   
  110   PARI(J)=0.  
        MSTI(1)=MINT(1) 
        MSTI(2)=MINT(2) 
        MSTI(11)=MINT(11)   
        MSTI(12)=MINT(12)   
        MSTI(15)=MINT(15)   
        MSTI(16)=MINT(16)   
        MSTI(17)=MINT(17)   
        MSTI(18)=MINT(18)   
        PARI(11)=VINT(1)    
        PARI(12)=VINT(2)    
        IF(ISUB.NE.95) THEN 
          DO 120 J=13,22    
  120     PARI(J)=VINT(30+J)    
          PARI(33)=VINT(41) 
          PARI(34)=VINT(42) 
          PARI(35)=PARI(33)-PARI(34)    
          PARI(36)=VINT(21) 
          PARI(37)=VINT(22) 
          PARI(38)=VINT(26) 
          PARI(41)=VINT(23) 
        ENDIF   
      ENDIF 
    
      IF(MSTP(111).EQ.-1) GOTO 160  
      IF(ISUB.LE.90.OR.ISUB.GE.95) THEN 
C...Hard scattering (including low-pT): 
C...reconstruct kinematics and colour flow of hard scattering.  
        CALL PYSCAT 
        IF(MINT(51).EQ.1) GOTO 100  
    
C...Showering of initial state partons (optional).  
        IPU1=MINT(84)+1 
        IPU2=MINT(84)+2 
        IF(MSTP(61).GE.1.AND.MINT(43).NE.1.AND.ISUB.NE.95)  
     &  CALL PYSSPA(IPU1,IPU2)  
        NSAV1=N 
    
C...Multiple interactions.  
        IF(MSTP(81).GE.1.AND.MINT(43).EQ.4.AND.ISUB.NE.95)  
     &  CALL PYMULT(6)  
        MINT(1)=ISUB    
        NSAV2=N 
    
C...Hadron remnants and primordial kT.  
        CALL PYREMN(IPU1,IPU2)  
        IF(MINT(51).EQ.1) GOTO 100  
        NSAV3=N 
    
C...Showering of final state partons (optional).    
        IPU3=MINT(84)+3 
        IPU4=MINT(84)+4 
        IF(MSTP(71).GE.1.AND.ISUB.NE.95.AND.K(IPU3,1).GT.0.AND. 
     &  K(IPU3,1).LE.10.AND.K(IPU4,1).GT.0.AND.K(IPU4,1).LE.10) THEN    
          QMAX=SQRT(PARP(71)*VINT(52))  
          IF(ISUB.EQ.5) QMAX=SQRT(PMAS(23,1)**2)    
          IF(ISUB.EQ.8) QMAX=SQRT(PMAS(24,1)**2)    
          CALL LUSHOW(IPU3,IPU4,QMAX)   
        ENDIF   
    
C...Sum up transverse and longitudinal momenta. 
        IF(IOVL.EQ.1) THEN  
          PARI(65)=2.*PARI(17)  
          DO 130 I=MSTP(126)+1,N    
          IF(K(I,1).LE.0.OR.K(I,1).GT.10) GOTO 130  
          PT=SQRT(P(I,1)**2+P(I,2)**2)  
          PARI(69)=PARI(69)+PT  
          IF(I.LE.NSAV1.OR.I.GT.NSAV3) PARI(66)=PARI(66)+PT 
          IF(I.GT.NSAV1.AND.I.LE.NSAV2) PARI(68)=PARI(68)+PT    
  130     CONTINUE  
          PARI(67)=PARI(68) 
          PARI(71)=VINT(151)    
          PARI(72)=VINT(152)    
          PARI(73)=VINT(151)    
          PARI(74)=VINT(152)    
        ENDIF   
    
C...Decay of final state resonances.    
        IF(MSTP(41).GE.1.AND.ISUB.NE.95) CALL PYRESD    
    
      ELSE  
C...Diffractive and elastic scattering. 
        CALL PYDIFF 
        IF(IOVL.EQ.1) THEN  
          PARI(65)=2.*PARI(17)  
          PARI(66)=PARI(65) 
          PARI(69)=PARI(65) 
        ENDIF   
      ENDIF 
    
C...Recalculate energies from momenta and masses (if desired).  
      IF(MSTP(113).GE.1) THEN   
        DO 140 I=MINT(83)+1,N   
  140   IF(K(I,1).GT.0.AND.K(I,1).LE.10) P(I,4)=SQRT(P(I,1)**2+ 
     &  P(I,2)**2+P(I,3)**2+P(I,5)**2)  
      ENDIF 
    
C...Rearrange partons along strings, check invariant mass cuts. 
      MSTU(28)=0    
      CALL LUPREP(MINT(84)+1)   
      IF(MSTP(112).EQ.1.AND.MSTU(28).EQ.3) GOTO 100 
      IF(MSTP(125).EQ.0.OR.MSTP(125).EQ.1) THEN 
        DO 150 I=MINT(84)+1,N   
        IF(K(I,2).NE.94) GOTO 150   
        K(I+1,3)=MOD(K(I+1,4)/MSTU(5),MSTU(5))  
        K(I+2,3)=MOD(K(I+2,4)/MSTU(5),MSTU(5))  
  150   CONTINUE    
        CALL LUEDIT(12) 
        CALL LUEDIT(14) 
        IF(MSTP(125).EQ.0) CALL LUEDIT(15)  
        IF(MSTP(125).EQ.0) MINT(4)=0    
      ENDIF 
    
C...Introduce separators between sections in LULIST event listing.  
      IF(IOVL.EQ.1.AND.MSTP(125).LE.0) THEN 
        MSTU(70)=1  
        MSTU(71)=N  
      ELSEIF(IOVL.EQ.1) THEN    
        MSTU(70)=3  
        MSTU(71)=2  
        MSTU(72)=MINT(4)    
        MSTU(73)=N  
      ENDIF 
    
C...Perform hadronization (if desired). 
      IF(MSTP(111).GE.1) CALL LUEXEC    
      IF(MSTP(125).EQ.0.OR.MSTP(125).EQ.1) CALL LUEDIT(14)  
    
C...Calculate Monte Carlo estimates of cross-sections.  
  160 IF(IOVL.EQ.1) THEN    
        IF(MSTP(111).NE.-1) NGEN(ISUB,3)=NGEN(ISUB,3)+1 
        NGEN(0,3)=NGEN(0,3)+1   
        XSEC(0,3)=0.    
        DO 170 I=1,200  
        IF(I.EQ.96) THEN    
          XSEC(I,3)=0.  
        ELSEIF(MSUB(95).EQ.1.AND.(I.EQ.11.OR.I.EQ.12.OR.I.EQ.13.OR. 
     &  I.EQ.28.OR.I.EQ.53.OR.I.EQ.68)) THEN    
          XSEC(I,3)=XSEC(96,2)*NGEN(I,3)/MAX(1.,FLOAT(NGEN(96,1))*  
     &    FLOAT(NGEN(96,2)))    
        ELSEIF(NGEN(I,1).EQ.0) THEN 
          XSEC(I,3)=0.  
        ELSEIF(NGEN(I,2).EQ.0) THEN 
          XSEC(I,3)=XSEC(I,2)*NGEN(0,3)/(FLOAT(NGEN(I,1))*  
     &    FLOAT(NGEN(0,2))) 
        ELSE    
          XSEC(I,3)=XSEC(I,2)*NGEN(I,3)/(FLOAT(NGEN(I,1))*  
     &    FLOAT(NGEN(I,2))) 
        ENDIF   
  170   XSEC(0,3)=XSEC(0,3)+XSEC(I,3)   
        IF(MSUB(95).EQ.1) THEN  
          NGENS=NGEN(91,3)+NGEN(92,3)+NGEN(93,3)+NGEN(94,3)+NGEN(95,3)  
          XSECS=XSEC(91,3)+XSEC(92,3)+XSEC(93,3)+XSEC(94,3)+XSEC(95,3)  
          XMAXS=XSEC(95,1)  
          IF(MSUB(91).EQ.1) XMAXS=XMAXS+XSEC(91,1)  
          IF(MSUB(92).EQ.1) XMAXS=XMAXS+XSEC(92,1)  
          IF(MSUB(93).EQ.1) XMAXS=XMAXS+XSEC(93,1)  
          IF(MSUB(94).EQ.1) XMAXS=XMAXS+XSEC(94,1)  
          FAC=1.    
          IF(NGENS.LT.NGEN(0,3)) FAC=(XMAXS-XSECS)/(XSEC(0,3)-XSECS)    
          XSEC(11,3)=FAC*XSEC(11,3) 
          XSEC(12,3)=FAC*XSEC(12,3) 
          XSEC(13,3)=FAC*XSEC(13,3) 
          XSEC(28,3)=FAC*XSEC(28,3) 
          XSEC(53,3)=FAC*XSEC(53,3) 
          XSEC(68,3)=FAC*XSEC(68,3) 
          XSEC(0,3)=XSEC(91,3)+XSEC(92,3)+XSEC(93,3)+XSEC(94,3)+    
     &    XSEC(95,1)    
        ENDIF   
    
C...Store final information.    
        MINT(5)=MINT(5)+1   
        MSTI(3)=MINT(3) 
        MSTI(4)=MINT(4) 
        MSTI(5)=MINT(5) 
        MSTI(6)=MINT(6) 
        MSTI(7)=MINT(7) 
        MSTI(8)=MINT(8) 
        MSTI(13)=MINT(13)   
        MSTI(14)=MINT(14)   
        MSTI(21)=MINT(21)   
        MSTI(22)=MINT(22)   
        MSTI(23)=MINT(23)   
        MSTI(24)=MINT(24)   
        MSTI(25)=MINT(25)   
        MSTI(26)=MINT(26)   
        MSTI(31)=MINT(31)   
        PARI(1)=XSEC(0,3)   
        PARI(2)=XSEC(0,3)/MINT(5)   
        PARI(31)=VINT(141)  
        PARI(32)=VINT(142)  
        IF(ISUB.NE.95.AND.MINT(7)*MINT(8).NE.0) THEN    
          PARI(42)=2.*VINT(47)/VINT(1)  
          DO 180 IS=7,8 
          PARI(36+IS)=P(MINT(IS),3)/VINT(1) 
          PARI(38+IS)=P(MINT(IS),4)/VINT(1) 
          I=MINT(IS)    
          PR=MAX(1E-20,P(I,5)**2+P(I,1)**2+P(I,2)**2)   
          PARI(40+IS)=SIGN(LOG(MIN((SQRT(PR+P(I,3)**2)+ABS(P(I,3)))/    
     &    SQRT(PR),1E20)),P(I,3))   
          PR=MAX(1E-20,P(I,1)**2+P(I,2)**2) 
          PARI(42+IS)=SIGN(LOG(MIN((SQRT(PR+P(I,3)**2)+ABS(P(I,3)))/    
     &    SQRT(PR),1E20)),P(I,3))   
          PARI(44+IS)=P(I,3)/SQRT(P(I,1)**2+P(I,2)**2+P(I,3)**2)    
          PARI(46+IS)=ULANGL(P(I,3),SQRT(P(I,1)**2+P(I,2)**2))  
          PARI(48+IS)=ULANGL(P(I,1),P(I,2)) 
  180     CONTINUE  
        ENDIF   
        PARI(61)=VINT(148)  
        IF(ISET(ISUB).EQ.1.OR.ISET(ISUB).EQ.3) THEN 
          MSTU(161)=MINT(21)    
          MSTU(162)=0   
        ELSE    
          MSTU(161)=MINT(21)    
          MSTU(162)=MINT(22)    
        ENDIF   
      ENDIF 
    
C...Prepare to go to next overlayed event.  
      MSTI(41)=IOVL 
      IF(IOVL.GE.2.AND.IOVL.LE.10) MSTI(40+IOVL)=ISUB   
      IF(MSTU(70).LT.10) THEN   
        MSTU(70)=MSTU(70)+1 
        MSTU(70+MSTU(70))=N 
      ENDIF 
      MINT(83)=N    
      MINT(84)=N+MSTP(126)  
  190 CONTINUE  
    
C...Information on overlayed events.    
      IF(MSTP(131).EQ.1.AND.MSTP(133).GE.1) THEN    
        PARI(91)=VINT(132)  
        PARI(92)=VINT(133)  
        PARI(93)=VINT(134)  
        IF(MSTP(133).EQ.2) PARI(93)=PARI(93)*XSEC(0,3)/VINT(131)    
      ENDIF 
    
C...Transform to the desired coordinate frame.  
  200 CALL PYFRAM(MSTP(124))    
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYINKI(CHFRAM,CHBEAM,CHTARG,WIN)   
    
C...Identifies the two incoming particles and sets up kinematics,   
C...including rotations and boosts to/from CM frame.    
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      CHARACTER CHFRAM*8,CHBEAM*8,CHTARG*8,CHCOM(3)*8,CHALP(2)*26,  
     &CHIDNT(3)*8,CHTEMP*8,CHCDE(18)*8,CHINIT*76    
      DIMENSION LEN(3),KCDE(18) 
      DATA CHALP/'abcdefghijklmnopqrstuvwxyz',  
     &'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/ 
      DATA CHCDE/'e-      ','e+      ','nue     ','nue~    ',   
     &'mu-     ','mu+     ','numu    ','numu~   ','tau-    ',   
     &'tau+    ','nutau   ','nutau~  ','pi+     ','pi-     ',   
     &'n       ','n~      ','p       ','p~      '/  
      DATA KCDE/11,-11,12,-12,13,-13,14,-14,15,-15,16,-16,  
     &211,-211,2112,-2112,2212,-2212/   
    
C...Convert character variables to lowercase and find their length. 
      CHCOM(1)=CHFRAM   
      CHCOM(2)=CHBEAM   
      CHCOM(3)=CHTARG   
      DO 120 I=1,3  
      LEN(I)=8  
      DO 100 LL=8,1,-1  
      IF(LEN(I).EQ.LL.AND.CHCOM(I)(LL:LL).EQ.' ') LEN(I)=LL-1   
      DO 100 LA=1,26    
  100 IF(CHCOM(I)(LL:LL).EQ.CHALP(2)(LA:LA)) CHCOM(I)(LL:LL)=   
     &CHALP(1)(LA:LA)   
      CHIDNT(I)=CHCOM(I)    
      DO 110 LL=1,6 
      IF(CHIDNT(I)(LL:LL+2).EQ.'bar') THEN  
        CHTEMP=CHIDNT(I)    
        CHIDNT(I)=CHTEMP(1:LL-1)//'~'//CHTEMP(LL+3:8)//'  ' 
      ENDIF 
  110 CONTINUE  
      DO 120 LL=1,8 
      IF(CHIDNT(I)(LL:LL).EQ.'_') THEN  
        CHTEMP=CHIDNT(I)    
        CHIDNT(I)=CHTEMP(1:LL-1)//CHTEMP(LL+1:8)//' '   
      ENDIF 
  120 CONTINUE  
    
C...Set initial state. Error for unknown codes. Reset variables.    
      N=2   
      DO 140 I=1,2  
      K(I,2)=0  
      DO 130 J=1,18 
  130 IF(CHIDNT(I+1).EQ.CHCDE(J)) K(I,2)=KCDE(J)    
      P(I,5)=ULMASS(K(I,2)) 
      MINT(40+I)=1  
      IF(IABS(K(I,2)).GT.100) MINT(40+I)=2  
      DO 140 J=1,5  
  140 V(I,J)=0. 
      IF(K(1,2).EQ.0) WRITE(MSTU(11),1000) CHBEAM(1:LEN(2)) 
      IF(K(2,2).EQ.0) WRITE(MSTU(11),1100) CHTARG(1:LEN(3)) 
      IF(K(1,2).EQ.0.OR.K(2,2).EQ.0) STOP   
      DO 150 J=6,10 
  150 VINT(J)=0.    
      CHINIT=' '    
    
C...Set up kinematics for events defined in CM frame.   
      IF(CHCOM(1)(1:2).EQ.'cm') THEN    
        IF(CHCOM(2)(1:1).NE.'e') THEN   
          LOFFS=(34-(LEN(2)+LEN(3)))/2  
          CHINIT(LOFFS+1:76)='PYTHIA will be initialized for a '//  
     &    CHCOM(2)(1:LEN(2))//'-'//CHCOM(3)(1:LEN(3))//' collider'//' ' 
        ELSE    
          LOFFS=(33-(LEN(2)+LEN(3)))/2  
          CHINIT(LOFFS+1:76)='PYTHIA will be initialized for an '// 
     &    CHCOM(2)(1:LEN(2))//'-'//CHCOM(3)(1:LEN(3))//' collider'//' ' 
        ENDIF   
C        WRITE(MSTU(11),1200) CHINIT 
C        WRITE(MSTU(11),1300) WIN    
        S=WIN**2    
        P(1,1)=0.   
        P(1,2)=0.   
        P(2,1)=0.   
        P(2,2)=0.   
        P(1,3)=SQRT(((S-P(1,5)**2-P(2,5)**2)**2-(2.*P(1,5)*P(2,5))**2)/ 
     &  (4.*S)) 
        P(2,3)=-P(1,3)  
        P(1,4)=SQRT(P(1,3)**2+P(1,5)**2)    
        P(2,4)=SQRT(P(2,3)**2+P(2,5)**2)    
    
C...Set up kinematics for fixed target events.  
      ELSEIF(CHCOM(1)(1:3).EQ.'fix') THEN   
        LOFFS=(29-(LEN(2)+LEN(3)))/2    
        CHINIT(LOFFS+1:76)='PYTHIA will be initialized for '//  
     &  CHCOM(2)(1:LEN(2))//' on '//CHCOM(3)(1:LEN(3))//    
     &  ' fixed target'//' '    
C        WRITE(MSTU(11),1200) CHINIT 
C        WRITE(MSTU(11),1400) WIN    
        P(1,1)=0.   
        P(1,2)=0.   
        P(2,1)=0.   
        P(2,2)=0.   
        P(1,3)=WIN  
        P(1,4)=SQRT(P(1,3)**2+P(1,5)**2)    
        P(2,3)=0.   
        P(2,4)=P(2,5)   
        S=P(1,5)**2+P(2,5)**2+2.*P(2,4)*P(1,4)  
        VINT(10)=P(1,3)/(P(1,4)+P(2,4)) 
        CALL LUROBO(0.,0.,0.,0.,-VINT(10))  
C        WRITE(MSTU(11),1500) SQRT(S)    
    
C...Set up kinematics for events in user-defined frame. 
      ELSEIF(CHCOM(1)(1:3).EQ.'use') THEN   
        LOFFS=(13-(LEN(1)+LEN(2)))/2    
        CHINIT(LOFFS+1:76)='PYTHIA will be initialized for '//  
     &  CHCOM(2)(1:LEN(2))//' on '//CHCOM(3)(1:LEN(3))//    
     &  'user-specified configuration'//' ' 
C        WRITE(MSTU(11),1200) CHINIT 
C        WRITE(MSTU(11),1600)    
C        WRITE(MSTU(11),1700) CHCOM(2),P(1,1),P(1,2),P(1,3)  
C        WRITE(MSTU(11),1700) CHCOM(3),P(2,1),P(2,2),P(2,3)  
        P(1,4)=SQRT(P(1,1)**2+P(1,2)**2+P(1,3)**2+P(1,5)**2)    
        P(2,4)=SQRT(P(2,1)**2+P(2,2)**2+P(2,3)**2+P(2,5)**2)    
        DO 160 J=1,3    
  160   VINT(7+J)=sngl((DBLE(P(1,J))+DBLE(P(2,J)))
     &          /DBLE(P(1,4)+P(2,4)))
        CALL LUROBO(0.,0.,-VINT(8),-VINT(9),-VINT(10))  
        VINT(7)=ULANGL(P(1,1),P(1,2))   
        CALL LUROBO(0.,-VINT(7),0.,0.,0.)   
        VINT(6)=ULANGL(P(1,3),P(1,1))   
        CALL LUROBO(-VINT(6),0.,0.,0.,0.)   
        S=P(1,5)**2+P(2,5)**2+2.*(P(1,4)*P(2,4)-P(1,3)*P(2,3))  
C        WRITE(MSTU(11),1500) SQRT(S)    
    
C...Unknown frame. Error for too low CM energy. 
      ELSE  
        WRITE(MSTU(11),1800) CHFRAM(1:LEN(1))   
        STOP    
      ENDIF 
      IF(S.LT.PARP(2)**2) THEN  
        WRITE(MSTU(11),1900) SQRT(S)    
        STOP    
      ENDIF 
    
C...Save information on incoming particles. 
      MINT(11)=K(1,2)   
      MINT(12)=K(2,2)   
      MINT(43)=2*MINT(41)+MINT(42)-2    
      VINT(1)=SQRT(S)   
      VINT(2)=S 
      VINT(3)=P(1,5)    
      VINT(4)=P(2,5)    
      VINT(5)=P(1,3)    
    
C...Store constants to be used in generation.   
      IF(MSTP(82).LE.1) VINT(149)=4.*PARP(81)**2/S  
      IF(MSTP(82).GE.2) VINT(149)=4.*PARP(82)**2/S  
    
C...Formats for initialization and error information.   
 1000 FORMAT(1X,'Error: unrecognized beam particle ''',A,'''.'/ 
     &1X,'Execution stopped!')  
 1100 FORMAT(1X,'Error: unrecognized target particle ''',A,'''.'/   
     &1X,'Execution stopped!')  
clin 1200 FORMAT(/1X,78('=')/1X,'I',76X,'I'/1X,'I',A76,'I') 
c 1300 FORMAT(1X,'I',18X,'at',1X,F10.3,1X,'GeV center-of-mass energy',   
c     &19X,'I'/1X,'I',76X,'I'/1X,78('='))    
c 1400 FORMAT(1X,'I',22X,'at',1X,F10.3,1X,'GeV/c lab-momentum',22X,'I')  
c 1500 FORMAT(1X,'I',76X,'I'/1X,'I',11X,'corresponding to',1X,F10.3,1X,  
c     &'GeV center-of-mass energy',12X,'I'/1X,'I',76X,'I'/1X,78('='))    
c 1600 FORMAT(1X,'I',76X,'I'/1X,'I',24X,'px (GeV/c)',3X,'py (GeV/c)',3X, 
c     &'pz (GeV/c)',16X,'I') 
clin 1700 FORMAT(1X,'I',15X,A8,3(2X,F10.3,1X),15X,'I')  
 1800 FORMAT(1X,'Error: unrecognized coordinate frame ''',A,'''.'/  
     &1X,'Execution stopped!')  
 1900 FORMAT(1X,'Error: too low CM energy,',F8.3,' GeV for event ', 
     &'generation.'/1X,'Execution stopped!')    
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYINRE 
    
C...Calculates full and effective widths of guage bosons, stores masses 
C...and widths, rescales coefficients to be used for resonance  
C...production generation.  
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT4/WIDP(21:40,0:40),WIDE(21:40,0:40),WIDS(21:40,3) 
      SAVE /PYINT4/ 
      COMMON/PYINT6/PROC(0:200) 
      CHARACTER PROC*28 
      SAVE /PYINT6/ 
      DIMENSION WDTP(0:40),WDTE(0:40,0:5)   
    
C...Calculate full and effective widths of gauge bosons.    
      AEM=PARU(101) 
      XW=PARU(102)  
      DO 100 I=21,40    
      DO 100 J=0,40 
      WIDP(I,J)=0.  
  100 WIDE(I,J)=0.  
    
C...W+/-:   
      WMAS=PMAS(24,1)   
      WFAC=AEM/(24.*XW)*WMAS    
      CALL PYWIDT(24,WMAS,WDTP,WDTE)    
      WIDS(24,1)=((WDTE(0,1)+WDTE(0,2))*(WDTE(0,1)+WDTE(0,3))+  
     &(WDTE(0,1)+WDTE(0,2)+WDTE(0,1)+WDTE(0,3))*(WDTE(0,4)+WDTE(0,5))+  
     &2.*WDTE(0,4)*WDTE(0,5))/WDTP(0)**2    
      WIDS(24,2)=(WDTE(0,1)+WDTE(0,2)+WDTE(0,4))/WDTP(0)    
      WIDS(24,3)=(WDTE(0,1)+WDTE(0,3)+WDTE(0,4))/WDTP(0)    
      DO 110 I=0,40 
      WIDP(24,I)=WFAC*WDTP(I)   
  110 WIDE(24,I)=WFAC*WDTE(I,0) 
    
C...H+/-:   
      HCMAS=PMAS(37,1)  
      HCFAC=AEM/(8.*XW)*(HCMAS/WMAS)**2*HCMAS   
      CALL PYWIDT(37,HCMAS,WDTP,WDTE)   
      WIDS(37,1)=((WDTE(0,1)+WDTE(0,2))*(WDTE(0,1)+WDTE(0,3))+  
     &(WDTE(0,1)+WDTE(0,2)+WDTE(0,1)+WDTE(0,3))*(WDTE(0,4)+WDTE(0,5))+  
     &2.*WDTE(0,4)*WDTE(0,5))/WDTP(0)**2    
      WIDS(37,2)=(WDTE(0,1)+WDTE(0,2)+WDTE(0,4))/WDTP(0)    
      WIDS(37,3)=(WDTE(0,1)+WDTE(0,3)+WDTE(0,4))/WDTP(0)    
      DO 120 I=0,40 
      WIDP(37,I)=HCFAC*WDTP(I)  
  120 WIDE(37,I)=HCFAC*WDTE(I,0)    
    
C...Z0: 
      ZMAS=PMAS(23,1)   
      ZFAC=AEM/(48.*XW*(1.-XW))*ZMAS    
      CALL PYWIDT(23,ZMAS,WDTP,WDTE)    
      WIDS(23,1)=((WDTE(0,1)+WDTE(0,2))**2+ 
     &2.*(WDTE(0,1)+WDTE(0,2))*(WDTE(0,4)+WDTE(0,5))+   
     &2.*WDTE(0,4)*WDTE(0,5))/WDTP(0)**2    
      WIDS(23,2)=(WDTE(0,1)+WDTE(0,2)+WDTE(0,4))/WDTP(0)    
      WIDS(23,3)=0. 
      DO 130 I=0,40 
      WIDP(23,I)=ZFAC*WDTP(I)   
  130 WIDE(23,I)=ZFAC*WDTE(I,0) 
    
C...H0: 
      HMAS=PMAS(25,1)   
      HFAC=AEM/(8.*XW)*(HMAS/WMAS)**2*HMAS  
      CALL PYWIDT(25,HMAS,WDTP,WDTE)    
      WIDS(25,1)=((WDTE(0,1)+WDTE(0,2))**2+ 
     &2.*(WDTE(0,1)+WDTE(0,2))*(WDTE(0,4)+WDTE(0,5))+   
     &2.*WDTE(0,4)*WDTE(0,5))/WDTP(0)**2    
      WIDS(25,2)=(WDTE(0,1)+WDTE(0,2)+WDTE(0,4))/WDTP(0)    
      WIDS(25,3)=0. 
      DO 140 I=0,40 
      WIDP(25,I)=HFAC*WDTP(I)   
  140 WIDE(25,I)=HFAC*WDTE(I,0) 
    
C...Z'0:    
      ZPMAS=PMAS(32,1)  
      ZPFAC=AEM/(48.*XW*(1.-XW))*ZPMAS  
      CALL PYWIDT(32,ZPMAS,WDTP,WDTE)   
      WIDS(32,1)=((WDTE(0,1)+WDTE(0,2)+WDTE(0,3))**2+   
     &2.*(WDTE(0,1)+WDTE(0,2))*(WDTE(0,4)+WDTE(0,5))+   
     &2.*WDTE(0,4)*WDTE(0,5))/WDTP(0)**2    
      WIDS(32,2)=(WDTE(0,1)+WDTE(0,2)+WDTE(0,4))/WDTP(0)    
      WIDS(32,3)=0. 
      DO 150 I=0,40 
      WIDP(32,I)=ZPFAC*WDTP(I)  
  150 WIDE(32,I)=ZPFAC*WDTE(I,0)    
    
C...R:  
      RMAS=PMAS(40,1)   
      RFAC=0.08*RMAS/((MSTP(1)-1)*(1.+6.*(1.+ULALPS(RMAS**2)/PARU(1)))) 
      CALL PYWIDT(40,RMAS,WDTP,WDTE)    
      WIDS(40,1)=((WDTE(0,1)+WDTE(0,2))*(WDTE(0,1)+WDTE(0,3))+  
     &(WDTE(0,1)+WDTE(0,2)+WDTE(0,1)+WDTE(0,3))*(WDTE(0,4)+WDTE(0,5))+  
     &2.*WDTE(0,4)*WDTE(0,5))/WDTP(0)**2    
      WIDS(40,2)=(WDTE(0,1)+WDTE(0,2)+WDTE(0,4))/WDTP(0)    
      WIDS(40,3)=(WDTE(0,1)+WDTE(0,3)+WDTE(0,4))/WDTP(0)    
      DO 160 I=0,40 
      WIDP(40,I)=WFAC*WDTP(I)   
  160 WIDE(40,I)=WFAC*WDTE(I,0) 
    
C...Q:  
      KFLQM=1   
      DO 170 I=1,MIN(8,MDCY(21,3))  
      IDC=I+MDCY(21,2)-1    
      IF(MDME(IDC,1).LE.0) GOTO 170 
      KFLQM=I   
  170 CONTINUE  
      MINT(46)=KFLQM    
      KFPR(81,1)=KFLQM  
      KFPR(81,2)=KFLQM  
      KFPR(82,1)=KFLQM  
      KFPR(82,2)=KFLQM  
    
C...Set resonance widths and branching ratios in JETSET.    
      DO 180 I=1,6  
      IF(I.LE.3) KC=I+22    
      IF(I.EQ.4) KC=32  
      IF(I.EQ.5) KC=37  
      IF(I.EQ.6) KC=40  
      PMAS(KC,2)=WIDP(KC,0) 
      PMAS(KC,3)=MIN(0.9*PMAS(KC,1),10.*PMAS(KC,2)) 
      DO 180 J=1,MDCY(KC,3) 
      IDC=J+MDCY(KC,2)-1    
      BRAT(IDC)=WIDE(KC,J)/WIDE(KC,0)   
  180 CONTINUE  
    
C...Special cases in treatment of gamma*/Z0: redefine process name. 
      IF(MSTP(43).EQ.1) THEN    
        PROC(1)='f + fb -> gamma*'  
      ELSEIF(MSTP(43).EQ.2) THEN    
        PROC(1)='f + fb -> Z0'  
      ELSEIF(MSTP(43).EQ.3) THEN    
        PROC(1)='f + fb -> gamma*/Z0'   
      ENDIF 
    
C...Special cases in treatment of gamma*/Z0/Z'0: redefine process name. 
      IF(MSTP(44).EQ.1) THEN    
        PROC(141)='f + fb -> gamma*'    
      ELSEIF(MSTP(44).EQ.2) THEN    
        PROC(141)='f + fb -> Z0'    
      ELSEIF(MSTP(44).EQ.3) THEN    
        PROC(141)='f + fb -> Z''0'  
      ELSEIF(MSTP(44).EQ.4) THEN    
        PROC(141)='f + fb -> gamma*/Z0' 
      ELSEIF(MSTP(44).EQ.5) THEN    
        PROC(141)='f + fb -> gamma*/Z''0'   
      ELSEIF(MSTP(44).EQ.6) THEN    
        PROC(141)='f + fb -> Z0/Z''0'   
      ELSEIF(MSTP(44).EQ.7) THEN    
        PROC(141)='f + fb -> gamma*/Z0/Z''0'    
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYXTOT 
    
C...Parametrizes total, double diffractive, single diffractive and  
C...elastic cross-sections for different energies and beams.    
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3) 
      SAVE /PYINT5/ 
      DIMENSION BCS(5,8),BCB(2,5),BCC(3)    
    
C...The following data lines are coefficients needed in the 
C...Block, Cahn parametrization of total cross-section and nuclear  
C...slope parameter; see below. 
      DATA ((BCS(I,J),J=1,8),I=1,5)/    
     1 41.74, 0.66, 0.0000, 337.,  0.0, 0.0, -39.3, 0.48,   
     2 41.66, 0.60, 0.0000, 306.,  0.0, 0.0, -34.6, 0.51,   
     3 41.36, 0.63, 0.0000, 299.,  7.3, 0.5, -40.4, 0.47,   
     4 41.68, 0.63, 0.0083, 330.,  0.0, 0.0, -39.0, 0.48,   
     5 41.13, 0.59, 0.0074, 278., 10.5, 0.5, -41.2, 0.46/   
      DATA ((BCB(I,J),J=1,5),I=1,2)/    
     1 10.79, -0.049, 0.040, 21.5, 1.23,    
     2  9.92, -0.027, 0.013, 18.9, 1.07/    
      DATA BCC/2.0164346,-0.5590311,0.0376279/  
    
C...Total cross-section and nuclear slope parameter for pp and p-pbar   
      NFIT=MIN(5,MAX(1,MSTP(31)))   
      SIGP=BCS(NFIT,1)+BCS(NFIT,2)*(-0.25*PARU(1)**2*   
     &(1.-0.25*BCS(NFIT,3)*PARU(1)**2)+(1.+0.5*BCS(NFIT,3)*PARU(1)**2)* 
     &(LOG(VINT(2)/BCS(NFIT,4)))**2+BCS(NFIT,3)*    
     &(LOG(VINT(2)/BCS(NFIT,4)))**4)/   
     &((1.-0.25*BCS(NFIT,3)*PARU(1)**2)**2+2.*BCS(NFIT,3)*  
     &(1.+0.25*BCS(NFIT,3)*PARU(1)**2)*(LOG(VINT(2)/BCS(NFIT,4)))**2+   
     &BCS(NFIT,3)**2*(LOG(VINT(2)/BCS(NFIT,4)))**4)+BCS(NFIT,5)*    
     &VINT(2)**(BCS(NFIT,6)-1.)*SIN(0.5*PARU(1)*BCS(NFIT,6))    
      SIGM=-BCS(NFIT,7)*VINT(2)**(BCS(NFIT,8)-1.)*  
     &COS(0.5*PARU(1)*BCS(NFIT,8))  
      REFP=BCS(NFIT,2)*PARU(1)*LOG(VINT(2)/BCS(NFIT,4))/    
     &((1.-0.25*BCS(NFIT,3)*PARU(1)**2)**2+2.*BCS(NFIT,3)*  
     &(1.+0.25*BCS(NFIT,3)*PARU(1)**2)+(LOG(VINT(2)/BCS(NFIT,4)))**2+   
     &BCS(NFIT,3)**2*(LOG(VINT(2)/BCS(NFIT,4)))**4)-BCS(NFIT,5)*    
     &VINT(2)**(BCS(NFIT,6)-1.)*COS(0.5*PARU(1)*BCS(NFIT,6))    
      REFM=-BCS(NFIT,7)*VINT(2)**(BCS(NFIT,8)-1.)*  
     &SIN(0.5*PARU(1)*BCS(NFIT,8))  
      SIGMA=SIGP-ISIGN(1,MINT(11)*MINT(12))*SIGM    
      RHO=(REFP-ISIGN(1,MINT(11)*MINT(12))*REFM)/SIGMA  
    
C...Nuclear slope parameter B, curvature C: 
      NFIT=1    
      IF(MSTP(31).GE.4) NFIT=2  
      BP=BCB(NFIT,1)+BCB(NFIT,2)*LOG(VINT(2))+  
     &BCB(NFIT,3)*(LOG(VINT(2)))**2 
      BM=BCB(NFIT,4)+BCB(NFIT,5)*LOG(VINT(2))   
      B=BP-ISIGN(1,MINT(11)*MINT(12))*SIGM/SIGP*(BM-BP) 
      VINT(121)=B   
      C=-0.5*BCC(2)/BCC(3)*(1.-SQRT(MAX(0.,1.+4.*BCC(3)/BCC(2)**2*  
     &(1.E-03*VINT(1)-BCC(1)))))    
      VINT(122)=C   
    
C...Elastic scattering cross-section (fixed by sigma-tot, rho and B).   
      SIGEL=SIGMA**2*(1.+RHO**2)/(16.*PARU(1)*PARU(5)*B)    
    
C...Single diffractive scattering cross-section from Goulianos: 
      SIGSD=2.*0.68*(1.+36./VINT(2))*LOG(0.6+0.1*VINT(2))   
    
C...Double diffractive scattering cross-section (essentially fixed by   
C...sigma-sd and sigma-el). 
      SIGDD=SIGSD**2/(3.*SIGEL) 
    
C...Total non-elastic, non-diffractive cross-section.   
      SIGND=SIGMA-SIGDD-SIGSD-SIGEL 
    
C...Rescale for pions.  
      IF(IABS(MINT(11)).EQ.211.AND.IABS(MINT(12)).EQ.211) THEN  
        SIGMA=4./9.*SIGMA   
        SIGDD=4./9.*SIGDD   
        SIGSD=4./9.*SIGSD   
        SIGEL=4./9.*SIGEL   
        SIGND=4./9.*SIGND   
      ELSEIF(IABS(MINT(11)).EQ.211.OR.IABS(MINT(12)).EQ.211) THEN   
        SIGMA=2./3.*SIGMA   
        SIGDD=2./3.*SIGDD   
        SIGSD=2./3.*SIGSD   
        SIGEL=2./3.*SIGEL   
        SIGND=2./3.*SIGND   
      ENDIF 
    
C...Save cross-sections in common block PYPARA. 
      VINT(101)=SIGMA   
      VINT(102)=SIGEL   
      VINT(103)=SIGSD   
      VINT(104)=SIGDD   
      VINT(106)=SIGND   
      XSEC(95,1)=SIGND  
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYMAXI 
    
C...Finds optimal set of coefficients for kinematical variable selection    
C...and the maximum of the part of the differential cross-section used  
C...in the event weighting. 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT3/XSFX(2,-40:40),ISIG(1000,3),SIGH(1000)  
      SAVE /PYINT3/ 
      COMMON/PYINT4/WIDP(21:40,0:40),WIDE(21:40,0:40),WIDS(21:40,3) 
      SAVE /PYINT4/ 
      COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3) 
      SAVE /PYINT5/ 
      COMMON/PYINT6/PROC(0:200) 
      CHARACTER PROC*28 
      SAVE /PYINT6/ 
      CHARACTER CVAR(4)*4   
      DIMENSION NPTS(4),MVARPT(200,4),VINTPT(200,30),SIGSPT(200),   
     &NAREL(6),WTREL(6),WTMAT(6,6),COEFU(6),IACCMX(4),SIGSMX(4),    
     &SIGSSM(3) 
      DATA CVAR/'tau ','tau''','y*  ','cth '/   
    
C...Select subprocess to study: skip cases not applicable.  
      VINT(143)=1.  
      VINT(144)=1.  
      XSEC(0,1)=0.  
      DO 350 ISUB=1,200 
      IF(ISUB.GE.91.AND.ISUB.LE.95) THEN    
        XSEC(ISUB,1)=VINT(ISUB+11)  
        IF(MSUB(ISUB).NE.1) GOTO 350    
        GOTO 340    
      ELSEIF(ISUB.EQ.96) THEN   
        IF(MINT(43).NE.4) GOTO 350  
        IF(MSUB(95).NE.1.AND.MSTP(81).LE.0.AND.MSTP(131).LE.0) GOTO 350 
      ELSEIF(ISUB.EQ.11.OR.ISUB.EQ.12.OR.ISUB.EQ.13.OR.ISUB.EQ.28.OR.   
     &ISUB.EQ.53.OR.ISUB.EQ.68) THEN    
        IF(MSUB(ISUB).NE.1.OR.MSUB(95).EQ.1) GOTO 350   
      ELSE  
        IF(MSUB(ISUB).NE.1) GOTO 350    
      ENDIF 
      MINT(1)=ISUB  
      ISTSB=ISET(ISUB)  
      IF(ISUB.EQ.96) ISTSB=2    
      IF(MSTP(122).GE.2) WRITE(MSTU(11),1000) ISUB  
    
C...Find resonances (explicit or implicit in cross-section).    
      MINT(72)=0    
      KFR1=0    
      IF(ISTSB.EQ.1.OR.ISTSB.EQ.3) THEN 
        KFR1=KFPR(ISUB,1)   
      ELSEIF(ISUB.GE.71.AND.ISUB.LE.77) THEN    
        KFR1=25 
      ENDIF 
      IF(KFR1.NE.0) THEN    
        TAUR1=PMAS(KFR1,1)**2/VINT(2)   
        GAMR1=PMAS(KFR1,1)*PMAS(KFR1,2)/VINT(2) 
        MINT(72)=1  
        MINT(73)=KFR1   
        VINT(73)=TAUR1  
        VINT(74)=GAMR1  
      ENDIF 
      IF(ISUB.EQ.141) THEN  
        KFR2=23 
        TAUR2=PMAS(KFR2,1)**2/VINT(2)   
        GAMR2=PMAS(KFR2,1)*PMAS(KFR2,2)/VINT(2) 
        MINT(72)=2  
        MINT(74)=KFR2   
        VINT(75)=TAUR2  
        VINT(76)=GAMR2  
      ENDIF 
    
C...Find product masses and minimum pT of process.  
      SQM3=0.   
      SQM4=0.   
      MINT(71)=0    
      VINT(71)=CKIN(3)  
      IF(ISTSB.EQ.2.OR.ISTSB.EQ.4) THEN 
        IF(KFPR(ISUB,1).NE.0) SQM3=PMAS(KFPR(ISUB,1),1)**2  
        IF(KFPR(ISUB,2).NE.0) SQM4=PMAS(KFPR(ISUB,2),1)**2  
        IF(MIN(SQM3,SQM4).LT.CKIN(6)**2) MINT(71)=1 
        IF(MINT(71).EQ.1) VINT(71)=MAX(CKIN(3),CKIN(5)) 
        IF(ISUB.EQ.96.AND.MSTP(82).LE.1) VINT(71)=PARP(81)  
        IF(ISUB.EQ.96.AND.MSTP(82).GE.2) VINT(71)=0.08*PARP(82) 
      ENDIF 
      VINT(63)=SQM3 
      VINT(64)=SQM4 
    
C...Number of points for each variable: tau, tau', y*, cos(theta-hat).  
      NPTS(1)=2+2*MINT(72)  
      IF(MINT(43).EQ.1.AND.(ISTSB.EQ.1.OR.ISTSB.EQ.2)) NPTS(1)=1    
      NPTS(2)=1 
      IF(MINT(43).GE.2.AND.(ISTSB.EQ.3.OR.ISTSB.EQ.4)) NPTS(2)=2    
      NPTS(3)=1 
      IF(MINT(43).EQ.4) NPTS(3)=3   
      NPTS(4)=1 
      IF(ISTSB.EQ.2.OR.ISTSB.EQ.4) NPTS(4)=5    
      NTRY=NPTS(1)*NPTS(2)*NPTS(3)*NPTS(4)  
    
C...Reset coefficients of cross-section weighting.  
      DO 100 J=1,20 
  100 COEF(ISUB,J)=0.   
      COEF(ISUB,1)=1.   
      COEF(ISUB,7)=0.5  
      COEF(ISUB,8)=0.5  
      COEF(ISUB,10)=1.  
      COEF(ISUB,15)=1.  
      MCTH=0    
      MTAUP=0   
      CTH=0.    
      TAUP=0.   
      SIGSAM=0. 
    
C...Find limits and select tau, y*, cos(theta-hat) and tau' values, 
C...in grid of phase space points.  
      CALL PYKLIM(1)    
      NACC=0    
      DO 120 ITRY=1,NTRY    
      IF(MOD(ITRY-1,NPTS(2)*NPTS(3)*NPTS(4)).EQ.0) THEN 
        MTAU=1+(ITRY-1)/(NPTS(2)*NPTS(3)*NPTS(4))   
        CALL PYKMAP(1,MTAU,0.5) 
        IF(ISTSB.EQ.3.OR.ISTSB.EQ.4) CALL PYKLIM(4) 
      ENDIF 
      IF((ISTSB.EQ.3.OR.ISTSB.EQ.4).AND.MOD(ITRY-1,NPTS(3)*NPTS(4)).    
     &EQ.0) THEN    
        MTAUP=1+MOD((ITRY-1)/(NPTS(3)*NPTS(4)),NPTS(2)) 
        CALL PYKMAP(4,MTAUP,0.5)    
      ENDIF 
      IF(MOD(ITRY-1,NPTS(3)*NPTS(4)).EQ.0) CALL PYKLIM(2)   
      IF(MOD(ITRY-1,NPTS(4)).EQ.0) THEN 
        MYST=1+MOD((ITRY-1)/NPTS(4),NPTS(3))    
        CALL PYKMAP(2,MYST,0.5) 
        CALL PYKLIM(3)  
      ENDIF 
      IF(ISTSB.EQ.2.OR.ISTSB.EQ.4) THEN 
        MCTH=1+MOD(ITRY-1,NPTS(4))  
        CALL PYKMAP(3,MCTH,0.5) 
      ENDIF 
      IF(ISUB.EQ.96) VINT(25)=VINT(21)*(1.-VINT(23)**2) 
    
C...Calculate and store cross-section.  
      MINT(51)=0    
      CALL PYKLIM(0)    
      IF(MINT(51).EQ.1) GOTO 120    
      NACC=NACC+1   
      MVARPT(NACC,1)=MTAU   
      MVARPT(NACC,2)=MTAUP  
      MVARPT(NACC,3)=MYST   
      MVARPT(NACC,4)=MCTH   
      DO 110 J=1,30 
  110 VINTPT(NACC,J)=VINT(10+J) 
      CALL PYSIGH(NCHN,SIGS)    
      SIGSPT(NACC)=SIGS 
      IF(SIGS.GT.SIGSAM) SIGSAM=SIGS    
      IF(MSTP(122).GE.2) WRITE(MSTU(11),1100) MTAU,MTAUP,MYST,MCTH, 
     &VINT(21),VINT(22),VINT(23),VINT(26),SIGS  
  120 CONTINUE  
      IF(SIGSAM.EQ.0.) THEN 
        WRITE(MSTU(11),1200) ISUB   
        STOP    
      ENDIF 
    
C...Calculate integrals in tau and y* over maximal phase space limits.  
      TAUMIN=VINT(11)   
      TAUMAX=VINT(31)   
      ATAU1=LOG(TAUMAX/TAUMIN)  
      ATAU2=(TAUMAX-TAUMIN)/(TAUMAX*TAUMIN) 
      IF(NPTS(1).GE.3) THEN 
        ATAU3=LOG(TAUMAX/TAUMIN*(TAUMIN+TAUR1)/(TAUMAX+TAUR1))/TAUR1    
        ATAU4=(ATAN((TAUMAX-TAUR1)/GAMR1)-ATAN((TAUMIN-TAUR1)/GAMR1))/  
     &  GAMR1   
      ENDIF 
      IF(NPTS(1).GE.5) THEN 
        ATAU5=LOG(TAUMAX/TAUMIN*(TAUMIN+TAUR2)/(TAUMAX+TAUR2))/TAUR2    
        ATAU6=(ATAN((TAUMAX-TAUR2)/GAMR2)-ATAN((TAUMIN-TAUR2)/GAMR2))/  
     &  GAMR2   
      ENDIF 
      YSTMIN=0.5*LOG(TAUMIN)    
      YSTMAX=-YSTMIN    
      AYST0=YSTMAX-YSTMIN   
      AYST1=0.5*(YSTMAX-YSTMIN)**2  
      AYST3=2.*(ATAN(EXP(YSTMAX))-ATAN(EXP(YSTMIN)))    
    
C...Reset. Sum up cross-sections in points calculated.  
      DO 230 IVAR=1,4   
      IF(NPTS(IVAR).EQ.1) GOTO 230  
      IF(ISUB.EQ.96.AND.IVAR.EQ.4) GOTO 230 
      NBIN=NPTS(IVAR)   
      DO 130 J1=1,NBIN  
      NAREL(J1)=0   
      WTREL(J1)=0.  
      COEFU(J1)=0.  
      DO 130 J2=1,NBIN  
  130 WTMAT(J1,J2)=0.   
      DO 140 IACC=1,NACC    
      IBIN=MVARPT(IACC,IVAR)    
      NAREL(IBIN)=NAREL(IBIN)+1 
      WTREL(IBIN)=WTREL(IBIN)+SIGSPT(IACC)  
    
C...Sum up tau cross-section pieces in points used. 
      IF(IVAR.EQ.1) THEN    
        TAU=VINTPT(IACC,11) 
        WTMAT(IBIN,1)=WTMAT(IBIN,1)+1.  
        WTMAT(IBIN,2)=WTMAT(IBIN,2)+(ATAU1/ATAU2)/TAU   
        IF(NBIN.GE.3) THEN  
          WTMAT(IBIN,3)=WTMAT(IBIN,3)+(ATAU1/ATAU3)/(TAU+TAUR1) 
          WTMAT(IBIN,4)=WTMAT(IBIN,4)+(ATAU1/ATAU4)*TAU/    
     &    ((TAU-TAUR1)**2+GAMR1**2) 
        ENDIF   
        IF(NBIN.GE.5) THEN  
          WTMAT(IBIN,5)=WTMAT(IBIN,5)+(ATAU1/ATAU5)/(TAU+TAUR2) 
          WTMAT(IBIN,6)=WTMAT(IBIN,6)+(ATAU1/ATAU6)*TAU/    
     &    ((TAU-TAUR2)**2+GAMR2**2) 
        ENDIF   
    
C...Sum up tau' cross-section pieces in points used.    
      ELSEIF(IVAR.EQ.2) THEN    
        TAU=VINTPT(IACC,11) 
        TAUP=VINTPT(IACC,16)    
        TAUPMN=VINTPT(IACC,6)   
        TAUPMX=VINTPT(IACC,26)  
        ATAUP1=LOG(TAUPMX/TAUPMN)   
        ATAUP2=((1.-TAU/TAUPMX)**4-(1.-TAU/TAUPMN)**4)/(4.*TAU) 
        WTMAT(IBIN,1)=WTMAT(IBIN,1)+1.  
        WTMAT(IBIN,2)=WTMAT(IBIN,2)+(ATAUP1/ATAUP2)*(1.-TAU/TAUP)**3/   
     &  TAUP    
    
C...Sum up y* and cos(theta-hat) cross-section pieces in points used.   
      ELSEIF(IVAR.EQ.3) THEN    
        YST=VINTPT(IACC,12) 
        WTMAT(IBIN,1)=WTMAT(IBIN,1)+(AYST0/AYST1)*(YST-YSTMIN)  
        WTMAT(IBIN,2)=WTMAT(IBIN,2)+(AYST0/AYST1)*(YSTMAX-YST)  
        WTMAT(IBIN,3)=WTMAT(IBIN,3)+(AYST0/AYST3)/COSH(YST) 
      ELSE  
        RM34=2.*SQM3*SQM4/(VINTPT(IACC,11)*VINT(2))**2  
        RSQM=1.+RM34    
        CTHMAX=SQRT(1.-4.*VINT(71)**2/(TAUMAX*VINT(2))) 
        CTHMIN=-CTHMAX  
        IF(CTHMAX.GT.0.9999) RM34=MAX(RM34,2.*VINT(71)**2/  
     &  (TAUMAX*VINT(2)))   
        ACTH1=CTHMAX-CTHMIN 
        ACTH2=LOG(MAX(RM34,RSQM-CTHMIN)/MAX(RM34,RSQM-CTHMAX))  
        ACTH3=LOG(MAX(RM34,RSQM+CTHMAX)/MAX(RM34,RSQM+CTHMIN))  
        ACTH4=1./MAX(RM34,RSQM-CTHMAX)-1./MAX(RM34,RSQM-CTHMIN) 
        ACTH5=1./MAX(RM34,RSQM+CTHMIN)-1./MAX(RM34,RSQM+CTHMAX) 
        CTH=VINTPT(IACC,13) 
        WTMAT(IBIN,1)=WTMAT(IBIN,1)+1.  
        WTMAT(IBIN,2)=WTMAT(IBIN,2)+(ACTH1/ACTH2)/MAX(RM34,RSQM-CTH)    
        WTMAT(IBIN,3)=WTMAT(IBIN,3)+(ACTH1/ACTH3)/MAX(RM34,RSQM+CTH)    
        WTMAT(IBIN,4)=WTMAT(IBIN,4)+(ACTH1/ACTH4)/MAX(RM34,RSQM-CTH)**2 
        WTMAT(IBIN,5)=WTMAT(IBIN,5)+(ACTH1/ACTH5)/MAX(RM34,RSQM+CTH)**2 
      ENDIF 
  140 CONTINUE  
    
C...Check that equation system solvable; else trivial way out.  
      IF(MSTP(122).GE.2) WRITE(MSTU(11),1300) CVAR(IVAR)    
      MSOLV=1   
      DO 150 IBIN=1,NBIN    
      IF(MSTP(122).GE.2) WRITE(MSTU(11),1400) (WTMAT(IBIN,IRED),    
     &IRED=1,NBIN),WTREL(IBIN)  
  150 IF(NAREL(IBIN).EQ.0) MSOLV=0  
      IF(MSOLV.EQ.0) THEN   
        DO 160 IBIN=1,NBIN  
  160   COEFU(IBIN)=1.  
    
C...Solve to find relative importance of cross-section pieces.  
      ELSE  
        DO 170 IRED=1,NBIN-1    
        DO 170 IBIN=IRED+1,NBIN 
        RQT=WTMAT(IBIN,IRED)/WTMAT(IRED,IRED)   
        WTREL(IBIN)=WTREL(IBIN)-RQT*WTREL(IRED) 
        DO 170 ICOE=IRED,NBIN   
  170   WTMAT(IBIN,ICOE)=WTMAT(IBIN,ICOE)-RQT*WTMAT(IRED,ICOE)  
        DO 190 IRED=NBIN,1,-1   
        DO 180 ICOE=IRED+1,NBIN 
  180   WTREL(IRED)=WTREL(IRED)-WTMAT(IRED,ICOE)*COEFU(ICOE)    
  190   COEFU(IRED)=WTREL(IRED)/WTMAT(IRED,IRED)    
      ENDIF 
    
C...Normalize coefficients, with piece shared democratically.   
      COEFSU=0. 
      DO 200 IBIN=1,NBIN    
      COEFU(IBIN)=MAX(0.,COEFU(IBIN))   
  200 COEFSU=COEFSU+COEFU(IBIN) 
      IF(IVAR.EQ.1) IOFF=0  
      IF(IVAR.EQ.2) IOFF=14 
      IF(IVAR.EQ.3) IOFF=6  
      IF(IVAR.EQ.4) IOFF=9  
      IF(COEFSU.GT.0.) THEN 
        DO 210 IBIN=1,NBIN  
  210   COEF(ISUB,IOFF+IBIN)=PARP(121)/NBIN+(1.-PARP(121))*COEFU(IBIN)/ 
     &  COEFSU  
      ELSE  
        DO 220 IBIN=1,NBIN  
  220   COEF(ISUB,IOFF+IBIN)=1./NBIN    
      ENDIF 
      IF(MSTP(122).GE.2) WRITE(MSTU(11),1500) CVAR(IVAR),   
     &(COEF(ISUB,IOFF+IBIN),IBIN=1,NBIN)    
  230 CONTINUE  
    
C...Find two most promising maxima among points previously determined.  
      DO 240 J=1,4  
      IACCMX(J)=0   
  240 SIGSMX(J)=0.  
      NMAX=0    
      DO 290 IACC=1,NACC    
      DO 250 J=1,30 
  250 VINT(10+J)=VINTPT(IACC,J) 
      CALL PYSIGH(NCHN,SIGS)    
      IEQ=0 
      DO 260 IMV=1,NMAX 
  260 IF(ABS(SIGS-SIGSMX(IMV)).LT.1E-4*(SIGS+SIGSMX(IMV))) IEQ=IMV  
      IF(IEQ.EQ.0) THEN 
        DO 270 IMV=NMAX,1,-1    
        IIN=IMV+1   
        IF(SIGS.LE.SIGSMX(IMV)) GOTO 280    
        IACCMX(IMV+1)=IACCMX(IMV)   
  270   SIGSMX(IMV+1)=SIGSMX(IMV)   
        IIN=1   
  280   IACCMX(IIN)=IACC    
        SIGSMX(IIN)=SIGS    
        IF(NMAX.LE.1) NMAX=NMAX+1   
      ENDIF 
  290 CONTINUE  
    
C...Read out starting position for search.  
      IF(MSTP(122).GE.2) WRITE(MSTU(11),1600)   
      SIGSAM=SIGSMX(1)  
      DO 330 IMAX=1,NMAX    
      IACC=IACCMX(IMAX) 
      MTAU=MVARPT(IACC,1)   
      MTAUP=MVARPT(IACC,2)  
      MYST=MVARPT(IACC,3)   
      MCTH=MVARPT(IACC,4)   
      VTAU=0.5  
      VYST=0.5  
      VCTH=0.5  
      VTAUP=0.5 
    
C...Starting point and step size in parameter space.    
      DO 320 IRPT=1,2   
      DO 310 IVAR=1,4   
      IF(NPTS(IVAR).EQ.1) GOTO 310  
      IF(IVAR.EQ.1) VVAR=VTAU   
      IF(IVAR.EQ.2) VVAR=VTAUP  
      IF(IVAR.EQ.3) VVAR=VYST   
      IF(IVAR.EQ.4) VVAR=VCTH   
      IF(IVAR.EQ.1) MVAR=MTAU   
      IF(IVAR.EQ.2) MVAR=MTAUP  
      IF(IVAR.EQ.3) MVAR=MYST   
      IF(IVAR.EQ.4) MVAR=MCTH   
      IF(IRPT.EQ.1) VDEL=0.1    
      IF(IRPT.EQ.2) VDEL=MAX(0.01,MIN(0.05,VVAR-0.02,0.98-VVAR))    
      IF(IRPT.EQ.1) VMAR=0.02   
      IF(IRPT.EQ.2) VMAR=0.002  
      IMOV0=1   
      IF(IRPT.EQ.1.AND.IVAR.EQ.1) IMOV0=0   
      DO 300 IMOV=IMOV0,8   
    
C...Define new point in parameter space.    
      IF(IMOV.EQ.0) THEN    
        INEW=2  
        VNEW=VVAR   
      ELSEIF(IMOV.EQ.1) THEN    
        INEW=3  
        VNEW=VVAR+VDEL  
      ELSEIF(IMOV.EQ.2) THEN    
        INEW=1  
        VNEW=VVAR-VDEL  
      ELSEIF(SIGSSM(3).GE.MAX(SIGSSM(1),SIGSSM(2)).AND. 
     &VVAR+2.*VDEL.LT.1.-VMAR) THEN 
        VVAR=VVAR+VDEL  
        SIGSSM(1)=SIGSSM(2) 
        SIGSSM(2)=SIGSSM(3) 
        INEW=3  
        VNEW=VVAR+VDEL  
      ELSEIF(SIGSSM(1).GE.MAX(SIGSSM(2),SIGSSM(3)).AND. 
     &VVAR-2.*VDEL.GT.VMAR) THEN    
        VVAR=VVAR-VDEL  
        SIGSSM(3)=SIGSSM(2) 
        SIGSSM(2)=SIGSSM(1) 
        INEW=1  
        VNEW=VVAR-VDEL  
      ELSEIF(SIGSSM(3).GE.SIGSSM(1)) THEN   
        VDEL=0.5*VDEL   
        VVAR=VVAR+VDEL  
        SIGSSM(1)=SIGSSM(2) 
        INEW=2  
        VNEW=VVAR   
      ELSE  
        VDEL=0.5*VDEL   
        VVAR=VVAR-VDEL  
        SIGSSM(3)=SIGSSM(2) 
        INEW=2  
        VNEW=VVAR   
      ENDIF 
    
C...Convert to relevant variables and find derived new limits.  
      IF(IVAR.EQ.1) THEN    
        VTAU=VNEW   
        CALL PYKMAP(1,MTAU,VTAU)    
        IF(ISTSB.EQ.3.OR.ISTSB.EQ.4) CALL PYKLIM(4) 
      ENDIF 
      IF(IVAR.LE.2.AND.(ISTSB.EQ.3.OR.ISTSB.EQ.4)) THEN 
        IF(IVAR.EQ.2) VTAUP=VNEW    
        CALL PYKMAP(4,MTAUP,VTAUP)  
      ENDIF 
      IF(IVAR.LE.2) CALL PYKLIM(2)  
      IF(IVAR.LE.3) THEN    
        IF(IVAR.EQ.3) VYST=VNEW 
        CALL PYKMAP(2,MYST,VYST)    
        CALL PYKLIM(3)  
      ENDIF 
      IF(ISTSB.EQ.2.OR.ISTSB.EQ.4) THEN 
        IF(IVAR.EQ.4) VCTH=VNEW 
        CALL PYKMAP(3,MCTH,VCTH)    
      ENDIF 
      IF(ISUB.EQ.96) VINT(25)=VINT(21)*(1.-VINT(23)**2) 
    
C...Evaluate cross-section. Save new maximum. Final maximum.    
      CALL PYSIGH(NCHN,SIGS)    
      SIGSSM(INEW)=SIGS 
      IF(SIGS.GT.SIGSAM) SIGSAM=SIGS    
      IF(MSTP(122).GE.2) WRITE(MSTU(11),1700) IMAX,IVAR,MVAR,IMOV,  
     &VNEW,VINT(21),VINT(22),VINT(23),VINT(26),SIGS 
  300 CONTINUE  
  310 CONTINUE  
  320 CONTINUE  
      IF(IMAX.EQ.1) SIGS11=SIGSAM   
  330 CONTINUE  
      XSEC(ISUB,1)=1.05*SIGSAM  
  340 IF(ISUB.NE.96) XSEC(0,1)=XSEC(0,1)+XSEC(ISUB,1)   
  350 CONTINUE  
    
C...Print summary table.    
      IF(MSTP(122).GE.1) THEN   
        WRITE(MSTU(11),1800)    
        WRITE(MSTU(11),1900)    
        DO 360 ISUB=1,200   
        IF(MSUB(ISUB).NE.1.AND.ISUB.NE.96) GOTO 360 
        IF(ISUB.EQ.96.AND.MINT(43).NE.4) GOTO 360   
        IF(ISUB.EQ.96.AND.MSUB(95).NE.1.AND.MSTP(81).LE.0) GOTO 360 
        IF(MSUB(95).EQ.1.AND.(ISUB.EQ.11.OR.ISUB.EQ.12.OR.ISUB.EQ.13.OR.    
     &  ISUB.EQ.28.OR.ISUB.EQ.53.OR.ISUB.EQ.68)) GOTO 360   
        WRITE(MSTU(11),2000) ISUB,PROC(ISUB),XSEC(ISUB,1)   
  360   CONTINUE    
        WRITE(MSTU(11),2100)    
      ENDIF 
    
C...Format statements for maximization results. 
 1000 FORMAT(/1X,'Coefficient optimization and maximum search for ',    
     &'subprocess no',I4/1X,'Coefficient modes     tau',10X,'y*',9X,    
     &'cth',9X,'tau''',7X,'sigma')  
 1100 FORMAT(1X,4I4,F12.8,F12.6,F12.7,F12.8,1P,E12.4)   
 1200 FORMAT(1X,'Error: requested subprocess ',I3,' has vanishing ',    
     &'cross-section.'/1X,'Execution stopped!')
 1300 FORMAT(1X,'Coefficients of equation system to be solved for ',A4) 
 1400 FORMAT(1X,1P,7E11.3)  
 1500 FORMAT(1X,'Result for ',A4,':',6F9.4) 
 1600 FORMAT(1X,'Maximum search for given coefficients'/2X,'MAX VAR ',  
     &'MOD MOV   VNEW',7X,'tau',7X,'y*',8X,'cth',7X,'tau''',7X,'sigma') 
 1700 FORMAT(1X,4I4,F8.4,F11.7,F9.3,F11.6,F11.7,1P,E12.4)   
 1800 FORMAT(/1X,8('*'),1X,'PYMAXI: summary of differential ',  
     &'cross-section maximum search',1X,8('*')) 
 1900 FORMAT(/11X,58('=')/11X,'I',38X,'I',17X,'I'/11X,'I  ISUB  ',  
     &'Subprocess name',15X,'I  Maximum value  I'/11X,'I',38X,'I',  
     &17X,'I'/11X,58('=')/11X,'I',38X,'I',17X,'I')  
 2000 FORMAT(11X,'I',2X,I3,3X,A28,2X,'I',2X,1P,E12.4,3X,'I')    
 2100 FORMAT(11X,'I',38X,'I',17X,'I'/11X,58('='))   
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYOVLY(MOVLY)  
    
C...Initializes multiplicity distribution and selects mutliplicity  
C...of overlayed events, i.e. several events occuring at the same   
C...beam crossing.  
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      DIMENSION WTI(0:100)  
      SAVE IMAX,WTI,WTS 
    
C...Sum of allowed cross-sections for overlayed events. 
      IF(MOVLY.EQ.1) THEN   
        VINT(131)=VINT(106) 
        IF(MSTP(132).GE.2) VINT(131)=VINT(131)+VINT(104)    
        IF(MSTP(132).GE.3) VINT(131)=VINT(131)+VINT(103)    
        IF(MSTP(132).GE.4) VINT(131)=VINT(131)+VINT(102)    
    
C...Initialize multiplicity distribution for unbiased events.   
        IF(MSTP(133).EQ.1) THEN 
          XNAVE=VINT(131)*PARP(131) 
          IF(XNAVE.GT.40.) WRITE(MSTU(11),1000) XNAVE   
          WTI(0)=EXP(-MIN(50.,XNAVE))   
          WTS=0.    
          WTN=0.    
          DO 100 I=1,100    
          WTI(I)=WTI(I-1)*XNAVE/I   
          IF(I-2.5.GT.XNAVE.AND.WTI(I).LT.1E-6) GOTO 110    
          WTS=WTS+WTI(I)    
          WTN=WTN+WTI(I)*I  
  100     IMAX=I    
  110     VINT(132)=XNAVE   
          VINT(133)=WTN/WTS 
          VINT(134)=WTS 
    
C...Initialize mutiplicity distribution for biased events.  
        ELSEIF(MSTP(133).EQ.2) THEN 
          XNAVE=VINT(131)*PARP(131) 
          IF(XNAVE.GT.40.) WRITE(MSTU(11),1000) XNAVE   
          WTI(1)=EXP(-MIN(50.,XNAVE))*XNAVE 
          WTS=WTI(1)    
          WTN=WTI(1)    
          DO 120 I=2,100    
          WTI(I)=WTI(I-1)*XNAVE/(I-1)   
          IF(I-2.5.GT.XNAVE.AND.WTI(I).LT.1E-6) GOTO 130    
          WTS=WTS+WTI(I)    
          WTN=WTN+WTI(I)*I  
  120     IMAX=I    
  130     VINT(132)=XNAVE   
          VINT(133)=WTN/WTS 
          VINT(134)=WTS 
        ENDIF   
    
C...Pick multiplicity of overlayed events.  
      ELSE  
        IF(MSTP(133).EQ.0) THEN 
          MINT(81)=MAX(1,MSTP(134)) 
        ELSE    
          WTR=WTS*RLU(0)    
          DO 140 I=1,IMAX   
          MINT(81)=I    
          WTR=WTR-WTI(I)    
          IF(WTR.LE.0.) GOTO 150    
  140     CONTINUE  
  150     CONTINUE  
        ENDIF   
      ENDIF 
    
C...Format statement for error message. 
 1000 FORMAT(1X,'Warning: requested average number of events per bunch',    
     &'crossing too large, ',1P,E12.4)  
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYRAND 
    
C...Generates quantities characterizing the high-pT scattering at the   
C...parton level according to the matrix elements. Chooses incoming,    
C...reacting partons, their momentum fractions and one of the possible  
C...subprocesses.   
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT3/XSFX(2,-40:40),ISIG(1000,3),SIGH(1000)  
      SAVE /PYINT3/ 
      COMMON/PYINT4/WIDP(21:40,0:40),WIDE(21:40,0:40),WIDS(21:40,3) 
      SAVE /PYINT4/ 
      COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3) 
      SAVE /PYINT5/ 
    
C...Initial values, specifically for (first) semihard interaction.  
      MINT(17)=0    
      MINT(18)=0    
      VINT(143)=1.  
      VINT(144)=1.  
      IF(MSUB(95).EQ.1.OR.MINT(82).GE.2) CALL PYMULT(2) 
      ISUB=0    
  100 MINT(51)=0    
    
C...Choice of process type - first event of overlay.    
      IF(MINT(82).EQ.1.AND.(ISUB.LE.90.OR.ISUB.GT.96)) THEN 
        RSUB=XSEC(0,1)*RLU(0)   
        DO 110 I=1,200  
        IF(MSUB(I).NE.1) GOTO 110   
        ISUB=I  
        RSUB=RSUB-XSEC(I,1) 
        IF(RSUB.LE.0.) GOTO 120 
  110   CONTINUE    
  120   IF(ISUB.EQ.95) ISUB=96  
    
C...Choice of inclusive process type - overlayed events.    
      ELSEIF(MINT(82).GE.2.AND.ISUB.EQ.0) THEN  
        RSUB=VINT(131)*RLU(0)   
        ISUB=96 
        IF(RSUB.GT.VINT(106)) ISUB=93   
        IF(RSUB.GT.VINT(106)+VINT(104)) ISUB=92 
        IF(RSUB.GT.VINT(106)+VINT(104)+VINT(103)) ISUB=91   
      ENDIF 
      IF(MINT(82).EQ.1) NGEN(0,1)=NGEN(0,1)+1   
      IF(MINT(82).EQ.1) NGEN(ISUB,1)=NGEN(ISUB,1)+1 
      MINT(1)=ISUB  
    
C...Find resonances (explicit or implicit in cross-section).    
      MINT(72)=0    
      KFR1=0    
      IF(ISET(ISUB).EQ.1.OR.ISET(ISUB).EQ.3) THEN   
        KFR1=KFPR(ISUB,1)   
      ELSEIF(ISUB.GE.71.AND.ISUB.LE.77) THEN    
        KFR1=25 
      ENDIF 
      IF(KFR1.NE.0) THEN    
        TAUR1=PMAS(KFR1,1)**2/VINT(2)   
        GAMR1=PMAS(KFR1,1)*PMAS(KFR1,2)/VINT(2) 
        MINT(72)=1  
        MINT(73)=KFR1   
        VINT(73)=TAUR1  
        VINT(74)=GAMR1  
      ENDIF 
      IF(ISUB.EQ.141) THEN  
        KFR2=23 
        TAUR2=PMAS(KFR2,1)**2/VINT(2)   
        GAMR2=PMAS(KFR2,1)*PMAS(KFR2,2)/VINT(2) 
        MINT(72)=2  
        MINT(74)=KFR2   
        VINT(75)=TAUR2  
        VINT(76)=GAMR2  
      ENDIF 
    
C...Find product masses and minimum pT of process,  
C...optionally with broadening according to a truncated Breit-Wigner.   
      VINT(63)=0.   
      VINT(64)=0.   
      MINT(71)=0    
      VINT(71)=CKIN(3)  
      IF(MINT(82).GE.2) VINT(71)=0. 
      IF(ISET(ISUB).EQ.2.OR.ISET(ISUB).EQ.4) THEN   
        DO 130 I=1,2    
        IF(KFPR(ISUB,I).EQ.0) THEN  
        ELSEIF(MSTP(42).LE.0) THEN  
          VINT(62+I)=PMAS(KFPR(ISUB,I),1)**2    
        ELSE    
          VINT(62+I)=ULMASS(KFPR(ISUB,I))**2    
        ENDIF   
  130   CONTINUE    
        IF(MIN(VINT(63),VINT(64)).LT.CKIN(6)**2) MINT(71)=1 
        IF(MINT(71).EQ.1) VINT(71)=MAX(CKIN(3),CKIN(5)) 
      ENDIF 
    
      IF(ISET(ISUB).EQ.0) THEN  
C...Double or single diffractive, or elastic scattering:    
C...choose m^2 according to 1/m^2 (diffractive), constant (elastic) 
        IS=INT(1.5+RLU(0))  
        VINT(63)=VINT(3)**2 
        VINT(64)=VINT(4)**2 
        IF(ISUB.EQ.92.OR.ISUB.EQ.93) VINT(62+IS)=PARP(111)**2   
        IF(ISUB.EQ.93) VINT(65-IS)=PARP(111)**2 
        SH=VINT(2)  
        SQM1=VINT(3)**2 
        SQM2=VINT(4)**2 
        SQM3=VINT(63)   
        SQM4=VINT(64)   
        SQLA12=(SH-SQM1-SQM2)**2-4.*SQM1*SQM2   
        SQLA34=(SH-SQM3-SQM4)**2-4.*SQM3*SQM4   
        THTER1=SQM1+SQM2+SQM3+SQM4-(SQM1-SQM2)*(SQM3-SQM4)/SH-SH    
        THTER2=SQRT(MAX(0.,SQLA12))*SQRT(MAX(0.,SQLA34))/SH 
        THL=0.5*(THTER1-THTER2) 
        THU=0.5*(THTER1+THTER2) 
        THM=MIN(MAX(THL,PARP(101)),THU) 
        JTMAX=0 
        IF(ISUB.EQ.92.OR.ISUB.EQ.93) JTMAX=ISUB-91  
        DO 140 JT=1,JTMAX   
        MINT(13+3*JT-IS*(2*JT-3))=1 
        SQMMIN=VINT(59+3*JT-IS*(2*JT-3))    
        SQMI=VINT(8-3*JT+IS*(2*JT-3))**2    
        SQMJ=VINT(3*JT-1-IS*(2*JT-3))**2    
        SQMF=VINT(68-3*JT+IS*(2*JT-3))  
        SQUA=0.5*SH/SQMI*((1.+(SQMI-SQMJ)/SH)*THM+SQMI-SQMF-    
     &  SQMJ**2/SH+(SQMI+SQMJ)*SQMF/SH+(SQMI-SQMJ)**2/SH**2*SQMF)   
        QUAR=SH/SQMI*(THM*(THM+SH-SQMI-SQMJ-SQMF*(1.-(SQMI-SQMJ)/SH))+  
     &  SQMI*SQMJ-SQMJ*SQMF*(1.+(SQMI-SQMJ-SQMF)/SH))   
        SQMMAX=SQUA+SQRT(MAX(0.,SQUA**2-QUAR))  
        IF(ABS(QUAR/SQUA**2).LT.1.E-06) SQMMAX=0.5*QUAR/SQUA    
        SQMMAX=MIN(SQMMAX,(VINT(1)-SQRT(SQMF))**2)  
        VINT(59+3*JT-IS*(2*JT-3))=SQMMIN*(SQMMAX/SQMMIN)**RLU(0)    
  140   CONTINUE    
C...Choose t-hat according to exp(B*t-hat+C*t-hat^2).   
        SQM3=VINT(63)   
        SQM4=VINT(64)   
        SQLA34=(SH-SQM3-SQM4)**2-4.*SQM3*SQM4   
        THTER1=SQM1+SQM2+SQM3+SQM4-(SQM1-SQM2)*(SQM3-SQM4)/SH-SH    
        THTER2=SQRT(MAX(0.,SQLA12))*SQRT(MAX(0.,SQLA34))/SH 
        THL=0.5*(THTER1-THTER2) 
        THU=0.5*(THTER1+THTER2) 
        B=VINT(121) 
        C=VINT(122) 
        IF(ISUB.EQ.92.OR.ISUB.EQ.93) THEN   
          B=0.5*B   
          C=0.5*C   
        ENDIF   
        THM=MIN(MAX(THL,PARP(101)),THU) 
        EXPTH=0.    
        THARG=B*(THM-THU)   
        IF(THARG.GT.-20.) EXPTH=EXP(THARG)  
  150   TH=THU+LOG(EXPTH+(1.-EXPTH)*RLU(0))/B   
        TH=MAX(THM,MIN(THU,TH)) 
        RATLOG=MIN((B+C*(TH+THM))*(TH-THM),(B+C*(TH+THU))*(TH-THU)) 
        IF(RATLOG.LT.LOG(RLU(0))) GOTO 150  
        VINT(21)=1. 
        VINT(22)=0. 
        VINT(23)=MIN(1.,MAX(-1.,(2.*TH-THTER1)/THTER2)) 
    
C...Note: in the following, by In is meant the integral over the    
C...quantity multiplying coefficient cn.    
C...Choose tau according to h1(tau)/tau, where  
C...h1(tau) = c0 + I0/I1*c1*1/tau + I0/I2*c2*1/(tau+tau_R) +    
C...I0/I3*c3*tau/((s*tau-m^2)^2+(m*Gamma)^2) +  
C...I0/I4*c4*1/(tau+tau_R') +   
C...I0/I5*c5*tau/((s*tau-m'^2)^2+(m'*Gamma')^2), and    
C...c0 + c1 + c2 + c3 + c4 + c5 = 1 
      ELSEIF(ISET(ISUB).GE.1.AND.ISET(ISUB).LE.4) THEN  
        CALL PYKLIM(1)  
        IF(MINT(51).NE.0) GOTO 100  
        RTAU=RLU(0) 
        MTAU=1  
        IF(RTAU.GT.COEF(ISUB,1)) MTAU=2 
        IF(RTAU.GT.COEF(ISUB,1)+COEF(ISUB,2)) MTAU=3    
        IF(RTAU.GT.COEF(ISUB,1)+COEF(ISUB,2)+COEF(ISUB,3)) MTAU=4   
        IF(RTAU.GT.COEF(ISUB,1)+COEF(ISUB,2)+COEF(ISUB,3)+COEF(ISUB,4)) 
     &  MTAU=5  
        IF(RTAU.GT.COEF(ISUB,1)+COEF(ISUB,2)+COEF(ISUB,3)+COEF(ISUB,4)+ 
     &  COEF(ISUB,5)) MTAU=6    
        CALL PYKMAP(1,MTAU,RLU(0))  
    
C...2 -> 3, 4 processes:    
C...Choose tau' according to h4(tau,tau')/tau', where   
C...h4(tau,tau') = c0 + I0/I1*c1*(1 - tau/tau')^3/tau', and 
C...c0 + c1 = 1.    
        IF(ISET(ISUB).EQ.3.OR.ISET(ISUB).EQ.4) THEN 
          CALL PYKLIM(4)    
          IF(MINT(51).NE.0) GOTO 100    
          RTAUP=RLU(0)  
          MTAUP=1   
          IF(RTAUP.GT.COEF(ISUB,15)) MTAUP=2    
          CALL PYKMAP(4,MTAUP,RLU(0))   
        ENDIF   
    
C...Choose y* according to h2(y*), where    
C...h2(y*) = I0/I1*c1*(y*-y*min) + I0/I2*c2*(y*max-y*) +    
C...I0/I3*c3*1/cosh(y*), I0 = y*max-y*min, and c1 + c2 + c3 = 1.    
        CALL PYKLIM(2)  
        IF(MINT(51).NE.0) GOTO 100  
        RYST=RLU(0) 
        MYST=1  
        IF(RYST.GT.COEF(ISUB,7)) MYST=2 
        IF(RYST.GT.COEF(ISUB,7)+COEF(ISUB,8)) MYST=3    
        CALL PYKMAP(2,MYST,RLU(0))  
    
C...2 -> 2 processes:   
C...Choose cos(theta-hat) (cth) according to h3(cth), where 
C...h3(cth) = c0 + I0/I1*c1*1/(A - cth) + I0/I2*c2*1/(A + cth) +    
C...I0/I3*c3*1/(A - cth)^2 + I0/I4*c4*1/(A + cth)^2,    
C...A = 1 + 2*(m3*m4/sh)^2 (= 1 for massless products), 
C...and c0 + c1 + c2 + c3 + c4 = 1. 
        CALL PYKLIM(3)  
        IF(MINT(51).NE.0) GOTO 100  
        IF(ISET(ISUB).EQ.2.OR.ISET(ISUB).EQ.4) THEN 
          RCTH=RLU(0)   
          MCTH=1    
          IF(RCTH.GT.COEF(ISUB,10)) MCTH=2  
          IF(RCTH.GT.COEF(ISUB,10)+COEF(ISUB,11)) MCTH=3    
          IF(RCTH.GT.COEF(ISUB,10)+COEF(ISUB,11)+COEF(ISUB,12)) MCTH=4  
          IF(RCTH.GT.COEF(ISUB,10)+COEF(ISUB,11)+COEF(ISUB,12)+ 
     &    COEF(ISUB,13)) MCTH=5 
          CALL PYKMAP(3,MCTH,RLU(0))    
        ENDIF   
    
C...Low-pT or multiple interactions (first semihard interaction).   
      ELSEIF(ISET(ISUB).EQ.5) THEN  
        CALL PYMULT(3)  
        ISUB=MINT(1)    
      ENDIF 
    
C...Choose azimuthal angle. 
      VINT(24)=PARU(2)*RLU(0)   
    
C...Check against user cuts on kinematics at parton level.  
      MINT(51)=0    
      IF(ISUB.LE.90.OR.ISUB.GT.100) CALL PYKLIM(0)  
      IF(MINT(51).NE.0) GOTO 100    
      IF(MINT(82).EQ.1.AND.MSTP(141).GE.1) THEN 
        MCUT=0  
        IF(MSUB(91)+MSUB(92)+MSUB(93)+MSUB(94)+MSUB(95).EQ.0)   
     &  CALL PYKCUT(MCUT)   
        IF(MCUT.NE.0) GOTO 100  
      ENDIF 
    
C...Calculate differential cross-section for different subprocesses.    
      CALL PYSIGH(NCHN,SIGS)    
    
C...Calculations for Monte Carlo estimate of all cross-sections.    
      IF(MINT(82).EQ.1.AND.ISUB.LE.90.OR.ISUB.GE.96) THEN   
        XSEC(ISUB,2)=XSEC(ISUB,2)+SIGS  
      ELSEIF(MINT(82).EQ.1) THEN    
        XSEC(ISUB,2)=XSEC(ISUB,2)+XSEC(ISUB,1)  
      ENDIF 
    
C...Multiple interactions: store results of cross-section calculation.  
      IF(MINT(43).EQ.4.AND.MSTP(82).GE.3) THEN  
        VINT(153)=SIGS  
        CALL PYMULT(4)  
      ENDIF 
    
C...Weighting using estimate of maximum of differential cross-section.  
      VIOL=SIGS/XSEC(ISUB,1)    
      IF(VIOL.LT.RLU(0)) GOTO 100   
    
C...Check for possible violation of estimated maximum of differential   
C...cross-section used in weighting.    
      IF(MSTP(123).LE.0) THEN   
        IF(VIOL.GT.1.) THEN 
          WRITE(MSTU(11),1000) VIOL,NGEN(0,3)+1 
          WRITE(MSTU(11),1100) ISUB,VINT(21),VINT(22),VINT(23),VINT(26) 
          STOP  
        ENDIF   
      ELSEIF(MSTP(123).EQ.1) THEN   
        IF(VIOL.GT.VINT(108)) THEN  
          VINT(108)=VIOL    
C          IF(VIOL.GT.1.) THEN   
C            WRITE(MSTU(11),1200) VIOL,NGEN(0,3)+1   
C            WRITE(MSTU(11),1100) ISUB,VINT(21),VINT(22),VINT(23),   
C     &      VINT(26)    
C          ENDIF 
        ENDIF   
      ELSEIF(VIOL.GT.VINT(108)) THEN    
        VINT(108)=VIOL  
        IF(VIOL.GT.1.) THEN 
          XDIF=XSEC(ISUB,1)*(VIOL-1.)   
          XSEC(ISUB,1)=XSEC(ISUB,1)+XDIF    
          IF(MSUB(ISUB).EQ.1.AND.(ISUB.LE.90.OR.ISUB.GT.96))    
     &    XSEC(0,1)=XSEC(0,1)+XDIF  
C          WRITE(MSTU(11),1200) VIOL,NGEN(0,3)+1 
C          WRITE(MSTU(11),1100) ISUB,VINT(21),VINT(22),VINT(23),VINT(26) 
C          IF(ISUB.LE.9) THEN    
C            WRITE(MSTU(11),1300) ISUB,XSEC(ISUB,1)  
C          ELSEIF(ISUB.LE.99) THEN   
C            WRITE(MSTU(11),1400) ISUB,XSEC(ISUB,1)  
C          ELSE  
C            WRITE(MSTU(11),1500) ISUB,XSEC(ISUB,1)  
C          ENDIF 
          VINT(108)=1.  
        ENDIF   
      ENDIF 
    
C...Multiple interactions: choose impact parameter. 
      VINT(148)=1.  
      IF(MINT(43).EQ.4.AND.(ISUB.LE.90.OR.ISUB.GE.96).AND.MSTP(82).GE.3)    
     &THEN  
        CALL PYMULT(5)  
        IF(VINT(150).LT.RLU(0)) GOTO 100    
      ENDIF 
      IF(MINT(82).EQ.1.AND.MSUB(95).EQ.1) THEN  
        IF(ISUB.LE.90.OR.ISUB.GE.95) NGEN(95,1)=NGEN(95,1)+1    
        IF(ISUB.LE.90.OR.ISUB.GE.96) NGEN(96,2)=NGEN(96,2)+1    
      ENDIF 
      IF(ISUB.LE.90.OR.ISUB.GE.96) MINT(31)=MINT(31)+1  
    
C...Choose flavour of reacting partons (and subprocess).    
      RSIGS=SIGS*RLU(0) 
      QT2=VINT(48)  
      RQQBAR=PARP(87)*(1.-(QT2/(QT2+(PARP(88)*PARP(82))**2))**2)    
      IF(ISUB.NE.95.AND.(ISUB.NE.96.OR.MSTP(82).LE.1.OR.    
     &RLU(0).GT.RQQBAR)) THEN   
        DO 190 ICHN=1,NCHN  
        KFL1=ISIG(ICHN,1)   
        KFL2=ISIG(ICHN,2)   
        MINT(2)=ISIG(ICHN,3)    
        RSIGS=RSIGS-SIGH(ICHN)  
        IF(RSIGS.LE.0.) GOTO 210    
  190   CONTINUE    
    
C...Multiple interactions: choose qqbar preferentially at small pT. 
      ELSEIF(ISUB.EQ.96) THEN   
        CALL PYSPLI(MINT(11),21,KFL1,KFLDUM)    
        CALL PYSPLI(MINT(12),21,KFL2,KFLDUM)    
        MINT(1)=11  
        MINT(2)=1   
        IF(KFL1.EQ.KFL2.AND.RLU(0).LT.0.5) MINT(2)=2    
    
C...Low-pT: choose string drawing configuration.    
      ELSE  
        KFL1=21 
        KFL2=21 
        RSIGS=6.*RLU(0) 
        MINT(2)=1   
        IF(RSIGS.GT.1.) MINT(2)=2   
        IF(RSIGS.GT.2.) MINT(2)=3   
      ENDIF 
    
C...Reassign QCD process. Partons before initial state radiation.   
  210 IF(MINT(2).GT.10) THEN    
        MINT(1)=MINT(2)/10  
        MINT(2)=MOD(MINT(2),10) 
      ENDIF 
      MINT(15)=KFL1 
      MINT(16)=KFL2 
      MINT(13)=MINT(15) 
      MINT(14)=MINT(16) 
      VINT(141)=VINT(41)    
      VINT(142)=VINT(42)    
    
C...Format statements for differential cross-section maximum violations.    
 1000 FORMAT(1X,'Error: maximum violated by',1P,E11.3,1X,   
     &'in event',1X,I7,'.'/1X,'Execution stopped!') 
 1100 FORMAT(1X,'ISUB = ',I3,'; Point of violation:'/1X,'tau=',1P, 
     &E11.3,', y* =',E11.3,', cthe = ',0P,F11.7,', tau'' =',1P,E11.3)   
clin 1200 FORMAT(1X,'Warning: maximum violated by',1P,E11.3,1X, 
c     &'in event',1X,I7) 
c 1300 FORMAT(1X,'XSEC(',I1,',1) increased to',1P,E11.3) 
c 1400 FORMAT(1X,'XSEC(',I2,',1) increased to',1P,E11.3) 
clin 1500 FORMAT(1X,'XSEC(',I3,',1) increased to',1P,E11.3) 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYSCAT 
    
C...Finds outgoing flavours and event type; sets up the kinematics  
C...and colour flow of the hard scattering. 
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT3/XSFX(2,-40:40),ISIG(1000,3),SIGH(1000)  
      SAVE /PYINT3/ 
      COMMON/PYINT4/WIDP(21:40,0:40),WIDE(21:40,0:40),WIDS(21:40,3) 
      SAVE /PYINT4/ 
      COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3) 
      SAVE /PYINT5/ 
      DIMENSION WDTP(0:40),WDTE(0:40,0:5),PMQ(2),Z(2),CTHE(2),PHI(2)    
    
C...Choice of subprocess, number of documentation lines.    
      ISUB=MINT(1)  
      IDOC=6+ISET(ISUB) 
      IF(ISUB.EQ.95) IDOC=8 
      MINT(3)=IDOC-6    
      IF(IDOC.GE.9) IDOC=IDOC+2 
      MINT(4)=IDOC  
      IPU1=MINT(84)+1   
      IPU2=MINT(84)+2   
      IPU3=MINT(84)+3   
      IPU4=MINT(84)+4   
      IPU5=MINT(84)+5   
      IPU6=MINT(84)+6   
    
C...Reset K, P and V vectors. Store incoming particles. 
      DO 100 JT=1,MSTP(126)+10  
      I=MINT(83)+JT 
      DO 100 J=1,5  
      K(I,J)=0  
      P(I,J)=0. 
  100 V(I,J)=0. 
      DO 110 JT=1,2 
      I=MINT(83)+JT 
      K(I,1)=21 
      K(I,2)=MINT(10+JT)    
      P(I,1)=0. 
      P(I,2)=0. 
      P(I,5)=VINT(2+JT) 
      P(I,3)=VINT(5)*(-1)**(JT+1)   
  110 P(I,4)=SQRT(P(I,3)**2+P(I,5)**2)  
      MINT(6)=2 
      KFRES=0   
    
C...Store incoming partons in their CM-frame.   
      SH=VINT(44)   
      SHR=SQRT(SH)  
      SHP=VINT(26)*VINT(2)  
      SHPR=SQRT(SHP)    
      SHUSER=SHR    
      IF(ISET(ISUB).GE.3) SHUSER=SHPR   
      DO 120 JT=1,2 
      I=MINT(84)+JT 
      K(I,1)=14 
      K(I,2)=MINT(14+JT)    
      K(I,3)=MINT(83)+2+JT  
  120 P(I,5)=ULMASS(K(I,2)) 
      IF(P(IPU1,5)+P(IPU2,5).GE.SHUSER) THEN    
        P(IPU1,5)=0.    
        P(IPU2,5)=0.    
      ENDIF 
      P(IPU1,4)=0.5*(SHUSER+(P(IPU1,5)**2-P(IPU2,5)**2)/SHUSER) 
      P(IPU1,3)=SQRT(MAX(0.,P(IPU1,4)**2-P(IPU1,5)**2)) 
      P(IPU2,4)=SHUSER-P(IPU1,4)    
      P(IPU2,3)=-P(IPU1,3)  
    
C...Copy incoming partons to documentation lines.   
      DO 130 JT=1,2 
      I1=MINT(83)+4+JT  
      I2=MINT(84)+JT    
      K(I1,1)=21    
      K(I1,2)=K(I2,2)   
      K(I1,3)=I1-2  
      DO 130 J=1,5  
  130 P(I1,J)=P(I2,J)   
    
C...Choose new quark flavour for relevant annihilation graphs.  
      IF(ISUB.EQ.12.OR.ISUB.EQ.53) THEN 
        CALL PYWIDT(21,SHR,WDTP,WDTE)   
        RKFL=(WDTE(0,1)+WDTE(0,2)+WDTE(0,4))*RLU(0) 
        DO 140 I=1,2*MSTP(1)    
        KFLQ=I  
        RKFL=RKFL-(WDTE(I,1)+WDTE(I,2)+WDTE(I,4))   
        IF(RKFL.LE.0.) GOTO 150 
  140   CONTINUE    
  150   CONTINUE    
      ENDIF 
    
C...Final state flavours and colour flow: default values.   
      JS=1  
      MINT(21)=MINT(15) 
      MINT(22)=MINT(16) 
      MINT(23)=0    
      MINT(24)=0    
      KCC=20    
      KCS=ISIGN(1,MINT(15)) 
    
      IF(ISUB.LE.10) THEN   
      IF(ISUB.EQ.1) THEN    
C...f + fb -> gamma*/Z0.    
        KFRES=23    
    
      ELSEIF(ISUB.EQ.2) THEN    
C...f + fb' -> W+/- .   
        KCH1=KCHG(IABS(MINT(15)),1)*ISIGN(1,MINT(15))   
        KCH2=KCHG(IABS(MINT(16)),1)*ISIGN(1,MINT(16))   
        KFRES=ISIGN(24,KCH1+KCH2)   
    
      ELSEIF(ISUB.EQ.3) THEN    
C...f + fb -> H0.   
        KFRES=25    
    
      ELSEIF(ISUB.EQ.4) THEN    
C...gamma + W+/- -> W+/-.   
    
      ELSEIF(ISUB.EQ.5) THEN    
C...Z0 + Z0 -> H0.  
        XH=SH/SHP   
        MINT(21)=MINT(15)   
        MINT(22)=MINT(16)   
        PMQ(1)=ULMASS(MINT(21)) 
        PMQ(2)=ULMASS(MINT(22)) 
  240   JT=INT(1.5+RLU(0))  
        ZMIN=2.*PMQ(JT)/SHPR    
        ZMAX=1.-PMQ(3-JT)/SHPR-(SH-PMQ(JT)**2)/(SHPR*(SHPR-PMQ(3-JT)))  
        ZMAX=MIN(1.-XH,ZMAX)    
        Z(JT)=ZMIN+(ZMAX-ZMIN)*RLU(0)   
        IF(-1.+(1.+XH)/(1.-Z(JT))-XH/(1.-Z(JT))**2.LT.  
     &  (1.-XH)**2/(4.*XH)*RLU(0)) GOTO 240 
        SQC1=1.-4.*PMQ(JT)**2/(Z(JT)**2*SHP)    
        IF(SQC1.LT.1.E-8) GOTO 240  
        C1=SQRT(SQC1)   
        C2=1.+2.*(PMAS(23,1)**2-PMQ(JT)**2)/(Z(JT)*SHP) 
        CTHE(JT)=(C2-(C2**2-C1**2)/(C2+(2.*RLU(0)-1.)*C1))/C1   
        CTHE(JT)=MIN(1.,MAX(-1.,CTHE(JT)))  
        Z(3-JT)=1.-XH/(1.-Z(JT))    
        SQC1=1.-4.*PMQ(3-JT)**2/(Z(3-JT)**2*SHP)    
        IF(SQC1.LT.1.E-8) GOTO 240  
        C1=SQRT(SQC1)   
        C2=1.+2.*(PMAS(23,1)**2-PMQ(3-JT)**2)/(Z(3-JT)*SHP) 
        CTHE(3-JT)=(C2-(C2**2-C1**2)/(C2+(2.*RLU(0)-1.)*C1))/C1 
        CTHE(3-JT)=MIN(1.,MAX(-1.,CTHE(3-JT)))  
        PHIR=PARU(2)*RLU(0) 
        CPHI=COS(PHIR)  
        ANG=CTHE(1)*CTHE(2)-SQRT(1.-CTHE(1)**2)*SQRT(1.-CTHE(2)**2)*CPHI    
        Z1=2.-Z(JT) 
        Z2=ANG*SQRT(Z(JT)**2-4.*PMQ(JT)**2/SHP) 
        Z3=1.-Z(JT)-XH+(PMQ(1)**2+PMQ(2)**2)/SHP    
        Z(3-JT)=2./(Z1**2-Z2**2)*(Z1*Z3+Z2*SQRT(Z3**2-(Z1**2-Z2**2)*    
     &  PMQ(3-JT)**2/SHP))  
        ZMIN=2.*PMQ(3-JT)/SHPR  
        ZMAX=1.-PMQ(JT)/SHPR-(SH-PMQ(3-JT)**2)/(SHPR*(SHPR-PMQ(JT)))    
        ZMAX=MIN(1.-XH,ZMAX)    
        IF(Z(3-JT).LT.ZMIN.OR.Z(3-JT).GT.ZMAX) GOTO 240 
        KCC=22  
        KFRES=25    
    
      ELSEIF(ISUB.EQ.6) THEN    
C...Z0 + W+/- -> W+/-.  
    
      ELSEIF(ISUB.EQ.7) THEN    
C...W+ + W- -> Z0.  
    
      ELSEIF(ISUB.EQ.8) THEN    
C...W+ + W- -> H0.  
        XH=SH/SHP   
  250   DO 280 JT=1,2   
        I=MINT(14+JT)   
        IA=IABS(I)  
        IF(IA.LE.10) THEN   
          RVCKM=VINT(180+I)*RLU(0)  
          DO 270 J=1,MSTP(1)    
          IB=2*J-1+MOD(IA,2)    
          IPM=(5-ISIGN(1,I))/2  
          IDC=J+MDCY(IA,2)+2    
          IF(MDME(IDC,1).NE.1.AND.MDME(IDC,1).NE.IPM) GOTO 270  
          MINT(20+JT)=ISIGN(IB,I)   
          RVCKM=RVCKM-VCKM((IA+1)/2,(IB+1)/2)   
          IF(RVCKM.LE.0.) GOTO 280  
  270     CONTINUE  
        ELSE    
          IB=2*((IA+1)/2)-1+MOD(IA,2)   
          MINT(20+JT)=ISIGN(IB,I)   
        ENDIF   
  280   PMQ(JT)=ULMASS(MINT(20+JT)) 
        JT=INT(1.5+RLU(0))  
        ZMIN=2.*PMQ(JT)/SHPR    
        ZMAX=1.-PMQ(3-JT)/SHPR-(SH-PMQ(JT)**2)/(SHPR*(SHPR-PMQ(3-JT)))  
        ZMAX=MIN(1.-XH,ZMAX)    
        Z(JT)=ZMIN+(ZMAX-ZMIN)*RLU(0)   
        IF(-1.+(1.+XH)/(1.-Z(JT))-XH/(1.-Z(JT))**2.LT.  
     &  (1.-XH)**2/(4.*XH)*RLU(0)) GOTO 250 
        SQC1=1.-4.*PMQ(JT)**2/(Z(JT)**2*SHP)    
        IF(SQC1.LT.1.E-8) GOTO 250  
        C1=SQRT(SQC1)   
        C2=1.+2.*(PMAS(24,1)**2-PMQ(JT)**2)/(Z(JT)*SHP) 
        CTHE(JT)=(C2-(C2**2-C1**2)/(C2+(2.*RLU(0)-1.)*C1))/C1   
        CTHE(JT)=MIN(1.,MAX(-1.,CTHE(JT)))  
        Z(3-JT)=1.-XH/(1.-Z(JT))    
        SQC1=1.-4.*PMQ(3-JT)**2/(Z(3-JT)**2*SHP)    
        IF(SQC1.LT.1.E-8) GOTO 250  
        C1=SQRT(SQC1)   
        C2=1.+2.*(PMAS(24,1)**2-PMQ(3-JT)**2)/(Z(3-JT)*SHP) 
        CTHE(3-JT)=(C2-(C2**2-C1**2)/(C2+(2.*RLU(0)-1.)*C1))/C1 
        CTHE(3-JT)=MIN(1.,MAX(-1.,CTHE(3-JT)))  
        PHIR=PARU(2)*RLU(0) 
        CPHI=COS(PHIR)  
        ANG=CTHE(1)*CTHE(2)-SQRT(1.-CTHE(1)**2)*SQRT(1.-CTHE(2)**2)*CPHI    
        Z1=2.-Z(JT) 
        Z2=ANG*SQRT(Z(JT)**2-4.*PMQ(JT)**2/SHP) 
        Z3=1.-Z(JT)-XH+(PMQ(1)**2+PMQ(2)**2)/SHP    
        Z(3-JT)=2./(Z1**2-Z2**2)*(Z1*Z3+Z2*SQRT(Z3**2-(Z1**2-Z2**2)*    
     &  PMQ(3-JT)**2/SHP))  
        ZMIN=2.*PMQ(3-JT)/SHPR  
        ZMAX=1.-PMQ(JT)/SHPR-(SH-PMQ(3-JT)**2)/(SHPR*(SHPR-PMQ(JT)))    
        ZMAX=MIN(1.-XH,ZMAX)    
        IF(Z(3-JT).LT.ZMIN.OR.Z(3-JT).GT.ZMAX) GOTO 250 
        KCC=22  
        KFRES=25    
      ENDIF 
    
      ELSEIF(ISUB.LE.20) THEN   
      IF(ISUB.EQ.11) THEN   
C...f + f' -> f + f'; th = (p(f)-p(f))**2.  
        KCC=MINT(2) 
        IF(MINT(15)*MINT(16).LT.0) KCC=KCC+2    
    
      ELSEIF(ISUB.EQ.12) THEN   
C...f + fb -> f' + fb'; th = (p(f)-p(f'))**2.   
        MINT(21)=ISIGN(KFLQ,MINT(15))   
        MINT(22)=-MINT(21)  
        KCC=4   
    
      ELSEIF(ISUB.EQ.13) THEN   
C...f + fb -> g + g; th arbitrary.  
        MINT(21)=21 
        MINT(22)=21 
        KCC=MINT(2)+4   
    
      ELSEIF(ISUB.EQ.14) THEN   
C...f + fb -> g + gam; th arbitrary.    
        IF(RLU(0).GT.0.5) JS=2  
        MINT(20+JS)=21  
        MINT(23-JS)=22  
        KCC=17+JS   
    
      ELSEIF(ISUB.EQ.15) THEN   
C...f + fb -> g + Z0; th arbitrary. 
        IF(RLU(0).GT.0.5) JS=2  
        MINT(20+JS)=21  
        MINT(23-JS)=23  
        KCC=17+JS   
    
      ELSEIF(ISUB.EQ.16) THEN   
C...f + fb' -> g + W+/-; th = (p(f)-p(W-))**2 or (p(fb')-p(W+))**2. 
        KCH1=KCHG(IABS(MINT(15)),1)*ISIGN(1,MINT(15))   
        KCH2=KCHG(IABS(MINT(16)),1)*ISIGN(1,MINT(16))   
        IF(MINT(15)*(KCH1+KCH2).LT.0) JS=2  
        MINT(20+JS)=21  
        MINT(23-JS)=ISIGN(24,KCH1+KCH2) 
        KCC=17+JS   
    
      ELSEIF(ISUB.EQ.17) THEN   
C...f + fb -> g + H0; th arbitrary. 
        IF(RLU(0).GT.0.5) JS=2  
        MINT(20+JS)=21  
        MINT(23-JS)=25  
        KCC=17+JS   
    
      ELSEIF(ISUB.EQ.18) THEN   
C...f + fb -> gamma + gamma; th arbitrary.  
        MINT(21)=22 
        MINT(22)=22 
    
      ELSEIF(ISUB.EQ.19) THEN   
C...f + fb -> gamma + Z0; th arbitrary. 
        IF(RLU(0).GT.0.5) JS=2  
        MINT(20+JS)=22  
        MINT(23-JS)=23  
    
      ELSEIF(ISUB.EQ.20) THEN   
C...f + fb' -> gamma + W+/-; th = (p(f)-p(W-))**2 or (p(fb')-p(W+))**2. 
        KCH1=KCHG(IABS(MINT(15)),1)*ISIGN(1,MINT(15))   
        KCH2=KCHG(IABS(MINT(16)),1)*ISIGN(1,MINT(16))   
        IF(MINT(15)*(KCH1+KCH2).LT.0) JS=2  
        MINT(20+JS)=22  
        MINT(23-JS)=ISIGN(24,KCH1+KCH2) 
      ENDIF 
    
      ELSEIF(ISUB.LE.30) THEN   
      IF(ISUB.EQ.21) THEN   
C...f + fb -> gamma + H0; th arbitrary. 
        IF(RLU(0).GT.0.5) JS=2  
        MINT(20+JS)=22  
        MINT(23-JS)=25  
    
      ELSEIF(ISUB.EQ.22) THEN   
C...f + fb -> Z0 + Z0; th arbitrary.    
        MINT(21)=23 
        MINT(22)=23 
    
      ELSEIF(ISUB.EQ.23) THEN   
C...f + fb' -> Z0 + W+/-; th = (p(f)-p(W-))**2 or (p(fb')-p(W+))**2.    
        KCH1=KCHG(IABS(MINT(15)),1)*ISIGN(1,MINT(15))   
        KCH2=KCHG(IABS(MINT(16)),1)*ISIGN(1,MINT(16))   
        IF(MINT(15)*(KCH1+KCH2).LT.0) JS=2  
        MINT(20+JS)=23  
        MINT(23-JS)=ISIGN(24,KCH1+KCH2) 
    
      ELSEIF(ISUB.EQ.24) THEN   
C...f + fb -> Z0 + H0; th arbitrary.    
        IF(RLU(0).GT.0.5) JS=2  
        MINT(20+JS)=23  
        MINT(23-JS)=25  
    
      ELSEIF(ISUB.EQ.25) THEN   
C...f + fb -> W+ + W-; th = (p(f)-p(W-))**2.    
        MINT(21)=-ISIGN(24,MINT(15))    
        MINT(22)=-MINT(21)  
    
      ELSEIF(ISUB.EQ.26) THEN   
C...f + fb' -> W+/- + H0; th = (p(f)-p(W-))**2 or (p(fb')-p(W+))**2.    
        KCH1=KCHG(IABS(MINT(15)),1)*ISIGN(1,MINT(15))   
        KCH2=KCHG(IABS(MINT(16)),1)*ISIGN(1,MINT(16))   
        IF(MINT(15)*(KCH1+KCH2).GT.0) JS=2  
        MINT(20+JS)=ISIGN(24,KCH1+KCH2) 
        MINT(23-JS)=25  
    
      ELSEIF(ISUB.EQ.27) THEN   
C...f + fb -> H0 + H0.  
    
      ELSEIF(ISUB.EQ.28) THEN   
C...f + g -> f + g; th = (p(f)-p(f))**2.    
        KCC=MINT(2)+6   
        IF(MINT(15).EQ.21) KCC=KCC+2    
        IF(MINT(15).NE.21) KCS=ISIGN(1,MINT(15))    
        IF(MINT(16).NE.21) KCS=ISIGN(1,MINT(16))    
    
      ELSEIF(ISUB.EQ.29) THEN   
C...f + g -> f + gamma; th = (p(f)-p(f))**2.    
        IF(MINT(15).EQ.21) JS=2 
        MINT(23-JS)=22  
        KCC=15+JS   
        KCS=ISIGN(1,MINT(14+JS))    
    
      ELSEIF(ISUB.EQ.30) THEN   
C...f + g -> f + Z0; th = (p(f)-p(f))**2.   
        IF(MINT(15).EQ.21) JS=2 
        MINT(23-JS)=23  
        KCC=15+JS   
        KCS=ISIGN(1,MINT(14+JS))    
      ENDIF 
    
      ELSEIF(ISUB.LE.40) THEN   
      IF(ISUB.EQ.31) THEN   
C...f + g -> f' + W+/-; th = (p(f)-p(f'))**2; choose flavour f'.    
        IF(MINT(15).EQ.21) JS=2 
        I=MINT(14+JS)   
        IA=IABS(I)  
        MINT(23-JS)=ISIGN(24,KCHG(IA,1)*I)  
        RVCKM=VINT(180+I)*RLU(0)    
        DO 220 J=1,MSTP(1)  
        IB=2*J-1+MOD(IA,2)  
        IPM=(5-ISIGN(1,I))/2    
        IDC=J+MDCY(IA,2)+2  
        IF(MDME(IDC,1).NE.1.AND.MDME(IDC,1).NE.IPM) GOTO 220    
        MINT(20+JS)=ISIGN(IB,I) 
        RVCKM=RVCKM-VCKM((IA+1)/2,(IB+1)/2) 
        IF(RVCKM.LE.0.) GOTO 230    
  220   CONTINUE    
  230   KCC=15+JS   
        KCS=ISIGN(1,MINT(14+JS))    
    
      ELSEIF(ISUB.EQ.32) THEN   
C...f + g -> f + H0; th = (p(f)-p(f))**2.   
        IF(MINT(15).EQ.21) JS=2 
        MINT(23-JS)=25  
        KCC=15+JS   
        KCS=ISIGN(1,MINT(14+JS))    
    
      ELSEIF(ISUB.EQ.33) THEN   
C...f + gamma -> f + g. 
    
      ELSEIF(ISUB.EQ.34) THEN   
C...f + gamma -> f + gamma. 
    
      ELSEIF(ISUB.EQ.35) THEN   
C...f + gamma -> f + Z0.    
    
      ELSEIF(ISUB.EQ.36) THEN   
C...f + gamma -> f' + W+/-. 
    
      ELSEIF(ISUB.EQ.37) THEN   
C...f + gamma -> f + H0.    
    
      ELSEIF(ISUB.EQ.38) THEN   
C...f + Z0 -> f + g.    
    
      ELSEIF(ISUB.EQ.39) THEN   
C...f + Z0 -> f + gamma.    
    
      ELSEIF(ISUB.EQ.40) THEN   
C...f + Z0 -> f + Z0.   
      ENDIF 
    
      ELSEIF(ISUB.LE.50) THEN   
      IF(ISUB.EQ.41) THEN   
C...f + Z0 -> f' + W+/-.    
    
      ELSEIF(ISUB.EQ.42) THEN   
C...f + Z0 -> f + H0.   
    
      ELSEIF(ISUB.EQ.43) THEN   
C...f + W+/- -> f' + g. 
    
      ELSEIF(ISUB.EQ.44) THEN   
C...f + W+/- -> f' + gamma. 
    
      ELSEIF(ISUB.EQ.45) THEN   
C...f + W+/- -> f' + Z0.    
    
      ELSEIF(ISUB.EQ.46) THEN   
C...f + W+/- -> f' + W+/-.  
    
      ELSEIF(ISUB.EQ.47) THEN   
C...f + W+/- -> f' + H0.    
    
      ELSEIF(ISUB.EQ.48) THEN   
C...f + H0 -> f + g.    
    
      ELSEIF(ISUB.EQ.49) THEN   
C...f + H0 -> f + gamma.    
    
      ELSEIF(ISUB.EQ.50) THEN   
C...f + H0 -> f + Z0.   
      ENDIF 
    
      ELSEIF(ISUB.LE.60) THEN   
      IF(ISUB.EQ.51) THEN   
C...f + H0 -> f' + W+/-.    
    
      ELSEIF(ISUB.EQ.52) THEN   
C...f + H0 -> f + H0.   
    
      ELSEIF(ISUB.EQ.53) THEN   
C...g + g -> f + fb; th arbitrary.  
        KCS=(-1)**INT(1.5+RLU(0))   
        MINT(21)=ISIGN(KFLQ,KCS)    
        MINT(22)=-MINT(21)  
        KCC=MINT(2)+10  
    
      ELSEIF(ISUB.EQ.54) THEN   
C...g + gamma -> f + fb.    
    
      ELSEIF(ISUB.EQ.55) THEN   
C...g + Z0 -> f + fb.   
    
      ELSEIF(ISUB.EQ.56) THEN   
C...g + W+/- -> f + fb'.    
    
      ELSEIF(ISUB.EQ.57) THEN   
C...g + H0 -> f + fb.   
    
      ELSEIF(ISUB.EQ.58) THEN   
C...gamma + gamma -> f + fb.    
    
      ELSEIF(ISUB.EQ.59) THEN   
C...gamma + Z0 -> f + fb.   
    
      ELSEIF(ISUB.EQ.60) THEN   
C...gamma + W+/- -> f + fb'.    
      ENDIF 
    
      ELSEIF(ISUB.LE.70) THEN   
      IF(ISUB.EQ.61) THEN   
C...gamma + H0 -> f + fb.   
    
      ELSEIF(ISUB.EQ.62) THEN   
C...Z0 + Z0 -> f + fb.  
    
      ELSEIF(ISUB.EQ.63) THEN   
C...Z0 + W+/- -> f + fb'.   
    
      ELSEIF(ISUB.EQ.64) THEN   
C...Z0 + H0 -> f + fb.  
    
      ELSEIF(ISUB.EQ.65) THEN   
C...W+ + W- -> f + fb.  
    
      ELSEIF(ISUB.EQ.66) THEN   
C...W+/- + H0 -> f + fb'.   
    
      ELSEIF(ISUB.EQ.67) THEN   
C...H0 + H0 -> f + fb.  
    
      ELSEIF(ISUB.EQ.68) THEN   
C...g + g -> g + g; th arbitrary.   
        KCC=MINT(2)+12  
        KCS=(-1)**INT(1.5+RLU(0))   
    
      ELSEIF(ISUB.EQ.69) THEN   
C...gamma + gamma -> W+ + W-.   
    
      ELSEIF(ISUB.EQ.70) THEN   
C...gamma + W+/- -> gamma + W+/-    
      ENDIF 
    
      ELSEIF(ISUB.LE.80) THEN   
      IF(ISUB.EQ.71.OR.ISUB.EQ.72) THEN 
C...Z0 + Z0 -> Z0 + Z0; Z0 + Z0 -> W+ + W-. 
        XH=SH/SHP   
        MINT(21)=MINT(15)   
        MINT(22)=MINT(16)   
        PMQ(1)=ULMASS(MINT(21)) 
        PMQ(2)=ULMASS(MINT(22)) 
  290   JT=INT(1.5+RLU(0))  
        ZMIN=2.*PMQ(JT)/SHPR    
        ZMAX=1.-PMQ(3-JT)/SHPR-(SH-PMQ(JT)**2)/(SHPR*(SHPR-PMQ(3-JT)))  
        ZMAX=MIN(1.-XH,ZMAX)    
        Z(JT)=ZMIN+(ZMAX-ZMIN)*RLU(0)   
        IF(-1.+(1.+XH)/(1.-Z(JT))-XH/(1.-Z(JT))**2.LT.  
     &  (1.-XH)**2/(4.*XH)*RLU(0)) GOTO 290 
        SQC1=1.-4.*PMQ(JT)**2/(Z(JT)**2*SHP)    
        IF(SQC1.LT.1.E-8) GOTO 290  
        C1=SQRT(SQC1)   
        C2=1.+2.*(PMAS(23,1)**2-PMQ(JT)**2)/(Z(JT)*SHP) 
        CTHE(JT)=(C2-(C2**2-C1**2)/(C2+(2.*RLU(0)-1.)*C1))/C1   
        CTHE(JT)=MIN(1.,MAX(-1.,CTHE(JT)))  
        Z(3-JT)=1.-XH/(1.-Z(JT))    
        SQC1=1.-4.*PMQ(3-JT)**2/(Z(3-JT)**2*SHP)    
        IF(SQC1.LT.1.E-8) GOTO 290  
        C1=SQRT(SQC1)   
        C2=1.+2.*(PMAS(23,1)**2-PMQ(3-JT)**2)/(Z(3-JT)*SHP) 
        CTHE(3-JT)=(C2-(C2**2-C1**2)/(C2+(2.*RLU(0)-1.)*C1))/C1 
        CTHE(3-JT)=MIN(1.,MAX(-1.,CTHE(3-JT)))  
        PHIR=PARU(2)*RLU(0) 
        CPHI=COS(PHIR)  
        ANG=CTHE(1)*CTHE(2)-SQRT(1.-CTHE(1)**2)*SQRT(1.-CTHE(2)**2)*CPHI    
        Z1=2.-Z(JT) 
        Z2=ANG*SQRT(Z(JT)**2-4.*PMQ(JT)**2/SHP) 
        Z3=1.-Z(JT)-XH+(PMQ(1)**2+PMQ(2)**2)/SHP    
        Z(3-JT)=2./(Z1**2-Z2**2)*(Z1*Z3+Z2*SQRT(Z3**2-(Z1**2-Z2**2)*    
     &  PMQ(3-JT)**2/SHP))  
        ZMIN=2.*PMQ(3-JT)/SHPR  
        ZMAX=1.-PMQ(JT)/SHPR-(SH-PMQ(3-JT)**2)/(SHPR*(SHPR-PMQ(JT)))    
        ZMAX=MIN(1.-XH,ZMAX)    
        IF(Z(3-JT).LT.ZMIN.OR.Z(3-JT).GT.ZMAX) GOTO 290 
        KCC=22  
    
      ELSEIF(ISUB.EQ.73) THEN   
C...Z0 + W+/- -> Z0 + W+/-. 
        XH=SH/SHP   
  300   JT=INT(1.5+RLU(0))  
        I=MINT(14+JT)   
        IA=IABS(I)  
        IF(IA.LE.10) THEN   
          RVCKM=VINT(180+I)*RLU(0)  
          DO 320 J=1,MSTP(1)    
          IB=2*J-1+MOD(IA,2)    
          IPM=(5-ISIGN(1,I))/2  
          IDC=J+MDCY(IA,2)+2    
          IF(MDME(IDC,1).NE.1.AND.MDME(IDC,1).NE.IPM) GOTO 320  
          MINT(20+JT)=ISIGN(IB,I)   
          RVCKM=RVCKM-VCKM((IA+1)/2,(IB+1)/2)   
          IF(RVCKM.LE.0.) GOTO 330  
  320     CONTINUE  
        ELSE    
          IB=2*((IA+1)/2)-1+MOD(IA,2)   
          MINT(20+JT)=ISIGN(IB,I)   
        ENDIF   
  330   PMQ(JT)=ULMASS(MINT(20+JT)) 
        MINT(23-JT)=MINT(17-JT) 
        PMQ(3-JT)=ULMASS(MINT(23-JT))   
        JT=INT(1.5+RLU(0))  
        ZMIN=2.*PMQ(JT)/SHPR    
        ZMAX=1.-PMQ(3-JT)/SHPR-(SH-PMQ(JT)**2)/(SHPR*(SHPR-PMQ(3-JT)))  
        ZMAX=MIN(1.-XH,ZMAX)    
        Z(JT)=ZMIN+(ZMAX-ZMIN)*RLU(0)   
        IF(-1.+(1.+XH)/(1.-Z(JT))-XH/(1.-Z(JT))**2.LT.  
     &  (1.-XH)**2/(4.*XH)*RLU(0)) GOTO 300 
        SQC1=1.-4.*PMQ(JT)**2/(Z(JT)**2*SHP)    
        IF(SQC1.LT.1.E-8) GOTO 300  
        C1=SQRT(SQC1)   
        C2=1.+2.*(PMAS(23,1)**2-PMQ(JT)**2)/(Z(JT)*SHP) 
        CTHE(JT)=(C2-(C2**2-C1**2)/(C2+(2.*RLU(0)-1.)*C1))/C1   
        CTHE(JT)=MIN(1.,MAX(-1.,CTHE(JT)))  
        Z(3-JT)=1.-XH/(1.-Z(JT))    
        SQC1=1.-4.*PMQ(3-JT)**2/(Z(3-JT)**2*SHP)    
        IF(SQC1.LT.1.E-8) GOTO 300  
        C1=SQRT(SQC1)   
        C2=1.+2.*(PMAS(23,1)**2-PMQ(3-JT)**2)/(Z(3-JT)*SHP) 
        CTHE(3-JT)=(C2-(C2**2-C1**2)/(C2+(2.*RLU(0)-1.)*C1))/C1 
        CTHE(3-JT)=MIN(1.,MAX(-1.,CTHE(3-JT)))  
        PHIR=PARU(2)*RLU(0) 
        CPHI=COS(PHIR)  
        ANG=CTHE(1)*CTHE(2)-SQRT(1.-CTHE(1)**2)*SQRT(1.-CTHE(2)**2)*CPHI    
        Z1=2.-Z(JT) 
        Z2=ANG*SQRT(Z(JT)**2-4.*PMQ(JT)**2/SHP) 
        Z3=1.-Z(JT)-XH+(PMQ(1)**2+PMQ(2)**2)/SHP    
        Z(3-JT)=2./(Z1**2-Z2**2)*(Z1*Z3+Z2*SQRT(Z3**2-(Z1**2-Z2**2)*    
     &  PMQ(3-JT)**2/SHP))  
        ZMIN=2.*PMQ(3-JT)/SHPR  
        ZMAX=1.-PMQ(JT)/SHPR-(SH-PMQ(3-JT)**2)/(SHPR*(SHPR-PMQ(JT)))    
        ZMAX=MIN(1.-XH,ZMAX)    
        IF(Z(3-JT).LT.ZMIN.OR.Z(3-JT).GT.ZMAX) GOTO 300 
        KCC=22  
    
      ELSEIF(ISUB.EQ.74) THEN   
C...Z0 + H0 -> Z0 + H0. 
    
      ELSEIF(ISUB.EQ.75) THEN   
C...W+ + W- -> gamma + gamma.   
    
      ELSEIF(ISUB.EQ.76.OR.ISUB.EQ.77) THEN 
C...W+ + W- -> Z0 + Z0; W+ + W- -> W+ + W-. 
        XH=SH/SHP   
  340   DO 370 JT=1,2   
        I=MINT(14+JT)   
        IA=IABS(I)  
        IF(IA.LE.10) THEN   
          RVCKM=VINT(180+I)*RLU(0)  
          DO 360 J=1,MSTP(1)    
          IB=2*J-1+MOD(IA,2)    
          IPM=(5-ISIGN(1,I))/2  
          IDC=J+MDCY(IA,2)+2    
          IF(MDME(IDC,1).NE.1.AND.MDME(IDC,1).NE.IPM) GOTO 360  
          MINT(20+JT)=ISIGN(IB,I)   
          RVCKM=RVCKM-VCKM((IA+1)/2,(IB+1)/2)   
          IF(RVCKM.LE.0.) GOTO 370  
  360     CONTINUE  
        ELSE    
          IB=2*((IA+1)/2)-1+MOD(IA,2)   
          MINT(20+JT)=ISIGN(IB,I)   
        ENDIF   
  370   PMQ(JT)=ULMASS(MINT(20+JT)) 
        JT=INT(1.5+RLU(0))  
        ZMIN=2.*PMQ(JT)/SHPR    
        ZMAX=1.-PMQ(3-JT)/SHPR-(SH-PMQ(JT)**2)/(SHPR*(SHPR-PMQ(3-JT)))  
        ZMAX=MIN(1.-XH,ZMAX)    
        Z(JT)=ZMIN+(ZMAX-ZMIN)*RLU(0)   
        IF(-1.+(1.+XH)/(1.-Z(JT))-XH/(1.-Z(JT))**2.LT.  
     &  (1.-XH)**2/(4.*XH)*RLU(0)) GOTO 340 
        SQC1=1.-4.*PMQ(JT)**2/(Z(JT)**2*SHP)    
        IF(SQC1.LT.1.E-8) GOTO 340  
        C1=SQRT(SQC1)   
        C2=1.+2.*(PMAS(24,1)**2-PMQ(JT)**2)/(Z(JT)*SHP) 
        CTHE(JT)=(C2-(C2**2-C1**2)/(C2+(2.*RLU(0)-1.)*C1))/C1   
        CTHE(JT)=MIN(1.,MAX(-1.,CTHE(JT)))  
        Z(3-JT)=1.-XH/(1.-Z(JT))    
        SQC1=1.-4.*PMQ(3-JT)**2/(Z(3-JT)**2*SHP)    
        IF(SQC1.LT.1.E-8) GOTO 340  
        C1=SQRT(SQC1)   
        C2=1.+2.*(PMAS(24,1)**2-PMQ(3-JT)**2)/(Z(3-JT)*SHP) 
        CTHE(3-JT)=(C2-(C2**2-C1**2)/(C2+(2.*RLU(0)-1.)*C1))/C1 
        CTHE(3-JT)=MIN(1.,MAX(-1.,CTHE(3-JT)))  
        PHIR=PARU(2)*RLU(0) 
        CPHI=COS(PHIR)  
        ANG=CTHE(1)*CTHE(2)-SQRT(1.-CTHE(1)**2)*SQRT(1.-CTHE(2)**2)*CPHI    
        Z1=2.-Z(JT) 
        Z2=ANG*SQRT(Z(JT)**2-4.*PMQ(JT)**2/SHP) 
        Z3=1.-Z(JT)-XH+(PMQ(1)**2+PMQ(2)**2)/SHP    
        Z(3-JT)=2./(Z1**2-Z2**2)*(Z1*Z3+Z2*SQRT(Z3**2-(Z1**2-Z2**2)*    
     &  PMQ(3-JT)**2/SHP))  
        ZMIN=2.*PMQ(3-JT)/SHPR  
        ZMAX=1.-PMQ(JT)/SHPR-(SH-PMQ(3-JT)**2)/(SHPR*(SHPR-PMQ(JT)))    
        ZMAX=MIN(1.-XH,ZMAX)    
        IF(Z(3-JT).LT.ZMIN.OR.Z(3-JT).GT.ZMAX) GOTO 340 
        KCC=22  
    
      ELSEIF(ISUB.EQ.78) THEN   
C...W+/- + H0 -> W+/- + H0. 
    
      ELSEIF(ISUB.EQ.79) THEN   
C...H0 + H0 -> H0 + H0. 
      ENDIF 
    
      ELSEIF(ISUB.LE.90) THEN   
      IF(ISUB.EQ.81) THEN   
C...q + qb -> Q' + Qb'; th = (p(q)-p(q'))**2.   
        MINT(21)=ISIGN(MINT(46),MINT(15))   
        MINT(22)=-MINT(21)  
        KCC=4   
    
      ELSEIF(ISUB.EQ.82) THEN   
C...g + g -> Q + Qb; th arbitrary.  
        KCS=(-1)**INT(1.5+RLU(0))   
        MINT(21)=ISIGN(MINT(46),KCS)    
        MINT(22)=-MINT(21)  
        KCC=MINT(2)+10  
      ENDIF 
    
      ELSEIF(ISUB.LE.100) THEN  
      IF(ISUB.EQ.95) THEN   
C...Low-pT ( = energyless g + g -> g + g).  
        KCC=MINT(2)+12  
        KCS=(-1)**INT(1.5+RLU(0))   
    
      ELSEIF(ISUB.EQ.96) THEN   
C...Multiple interactions (should be reassigned to QCD process).    
      ENDIF 
    
      ELSEIF(ISUB.LE.110) THEN  
      IF(ISUB.EQ.101) THEN  
C...g + g -> gamma*/Z0. 
        KCC=21  
        KFRES=22    
    
      ELSEIF(ISUB.EQ.102) THEN  
C...g + g -> H0.    
        KCC=21  
        KFRES=25    
      ENDIF 
    
      ELSEIF(ISUB.LE.120) THEN  
      IF(ISUB.EQ.111) THEN  
C...f + fb -> g + H0; th arbitrary. 
        IF(RLU(0).GT.0.5) JS=2  
        MINT(20+JS)=21  
        MINT(23-JS)=25  
        KCC=17+JS   
    
      ELSEIF(ISUB.EQ.112) THEN  
C...f + g -> f + H0; th = (p(f) - p(f))**2. 
        IF(MINT(15).EQ.21) JS=2 
        MINT(23-JS)=25  
        KCC=15+JS   
        KCS=ISIGN(1,MINT(14+JS))    
    
      ELSEIF(ISUB.EQ.113) THEN  
C...g + g -> g + H0; th arbitrary.  
        IF(RLU(0).GT.0.5) JS=2  
        MINT(23-JS)=25  
        KCC=22+JS   
        KCS=(-1)**INT(1.5+RLU(0))   
    
      ELSEIF(ISUB.EQ.114) THEN  
C...g + g -> gamma + gamma; th arbitrary.   
        IF(RLU(0).GT.0.5) JS=2  
        MINT(21)=22 
        MINT(22)=22 
        KCC=21  
    
      ELSEIF(ISUB.EQ.115) THEN  
C...g + g -> gamma + Z0.    
    
      ELSEIF(ISUB.EQ.116) THEN  
C...g + g -> Z0 + Z0.   
    
      ELSEIF(ISUB.EQ.117) THEN  
C...g + g -> W+ + W-.   
      ENDIF 
    
      ELSEIF(ISUB.LE.140) THEN  
      IF(ISUB.EQ.121) THEN  
C...g + g -> f + fb + H0.   
      ENDIF 
    
      ELSEIF(ISUB.LE.160) THEN  
      IF(ISUB.EQ.141) THEN  
C...f + fb -> gamma*/Z0/Z'0.    
        KFRES=32    
    
      ELSEIF(ISUB.EQ.142) THEN  
C...f + fb' -> H+/-.    
        KCH1=KCHG(IABS(MINT(15)),1)*ISIGN(1,MINT(15))   
        KCH2=KCHG(IABS(MINT(16)),1)*ISIGN(1,MINT(16))   
        KFRES=ISIGN(37,KCH1+KCH2)   
    
      ELSEIF(ISUB.EQ.143) THEN  
C...f + fb' -> R.   
        KFRES=ISIGN(40,MINT(15)+MINT(16))   
      ENDIF 
    
      ELSE  
      IF(ISUB.EQ.161) THEN  
C...g + f -> H+/- + f'; th = (p(f)-p(f))**2.    
        IF(MINT(16).EQ.21) JS=2 
        IA=IABS(MINT(17-JS))    
        MINT(20+JS)=ISIGN(37,KCHG(IA,1)*MINT(17-JS))    
        JA=IA+MOD(IA,2)-MOD(IA+1,2) 
        MINT(23-JS)=ISIGN(JA,MINT(17-JS))   
        KCC=18-JS   
        IF(MINT(15).NE.21) KCS=ISIGN(1,MINT(15))    
        IF(MINT(16).NE.21) KCS=ISIGN(1,MINT(16))    
      ENDIF 
      ENDIF 
    
      IF(IDOC.EQ.7) THEN    
C...Resonance not decaying: store colour connection indices.    
        I=MINT(83)+7    
        K(IPU3,1)=1 
        K(IPU3,2)=KFRES 
        K(IPU3,3)=I 
        P(IPU3,4)=SHUSER    
        P(IPU3,5)=SHUSER    
        K(IPU1,4)=IPU2  
        K(IPU1,5)=IPU2  
        K(IPU2,4)=IPU1  
        K(IPU2,5)=IPU1  
        K(I,1)=21   
        K(I,2)=KFRES    
        P(I,4)=SHUSER   
        P(I,5)=SHUSER   
        N=IPU3  
        MINT(21)=KFRES  
        MINT(22)=0  
    
      ELSEIF(IDOC.EQ.8) THEN    
C...2 -> 2 processes: store outgoing partons in their CM-frame. 
        DO 390 JT=1,2   
        I=MINT(84)+2+JT 
        K(I,1)=1    
        IF(IABS(MINT(20+JT)).LE.10.OR.MINT(20+JT).EQ.21) K(I,1)=3   
        K(I,2)=MINT(20+JT)  
        K(I,3)=MINT(83)+IDOC+JT-2   
        IF(IABS(K(I,2)).LE.10.OR.K(I,2).EQ.21) THEN 
          P(I,5)=ULMASS(K(I,2)) 
        ELSE    
          P(I,5)=SQRT(VINT(63+MOD(JS+JT,2)))    
        ENDIF   
  390   CONTINUE    
        IF(P(IPU3,5)+P(IPU4,5).GE.SHR) THEN 
          KFA1=IABS(MINT(21))   
          KFA2=IABS(MINT(22))   
          IF((KFA1.GT.3.AND.KFA1.NE.21).OR.(KFA2.GT.3.AND.KFA2.NE.21))  
     &    THEN  
            MINT(51)=1  
            RETURN  
          ENDIF 
          P(IPU3,5)=0.  
          P(IPU4,5)=0.  
        ENDIF   
        P(IPU3,4)=0.5*(SHR+(P(IPU3,5)**2-P(IPU4,5)**2)/SHR) 
        P(IPU3,3)=SQRT(MAX(0.,P(IPU3,4)**2-P(IPU3,5)**2))   
        P(IPU4,4)=SHR-P(IPU3,4) 
        P(IPU4,3)=-P(IPU3,3)    
        N=IPU4  
        MINT(7)=MINT(83)+7  
        MINT(8)=MINT(83)+8  
    
C...Rotate outgoing partons using cos(theta)=(th-uh)/lam(sh,sqm3,sqm4). 
        CALL LUDBRB(IPU3,IPU4,ACOS(VINT(23)),VINT(24),0D0,0D0,0D0)  
    
      ELSEIF(IDOC.EQ.9) THEN    
C'''2 -> 3 processes:   
    
      ELSEIF(IDOC.EQ.11) THEN   
C...Z0 + Z0 -> H0, W+ + W- -> H0: store Higgs and outgoing partons. 
        PHI(1)=PARU(2)*RLU(0)   
        PHI(2)=PHI(1)-PHIR  
        DO 400 JT=1,2   
        I=MINT(84)+2+JT 
        K(I,1)=1    
        IF(IABS(MINT(20+JT)).LE.10.OR.MINT(20+JT).EQ.21) K(I,1)=3   
        K(I,2)=MINT(20+JT)  
        K(I,3)=MINT(83)+IDOC+JT-2   
        P(I,5)=ULMASS(K(I,2))   
        IF(0.5*SHPR*Z(JT).LE.P(I,5)) P(I,5)=0.  
        PABS=SQRT(MAX(0.,(0.5*SHPR*Z(JT))**2-P(I,5)**2))    
        PTABS=PABS*SQRT(MAX(0.,1.-CTHE(JT)**2)) 
        P(I,1)=PTABS*COS(PHI(JT))   
        P(I,2)=PTABS*SIN(PHI(JT))   
        P(I,3)=PABS*CTHE(JT)*(-1)**(JT+1)   
        P(I,4)=0.5*SHPR*Z(JT)   
        IZW=MINT(83)+6+JT   
        K(IZW,1)=21 
        K(IZW,2)=23 
        IF(ISUB.EQ.8) K(IZW,2)=ISIGN(24,LUCHGE(MINT(14+JT)))    
        K(IZW,3)=IZW-2  
        P(IZW,1)=-P(I,1)    
        P(IZW,2)=-P(I,2)    
        P(IZW,3)=(0.5*SHPR-PABS*CTHE(JT))*(-1)**(JT+1)  
        P(IZW,4)=0.5*SHPR*(1.-Z(JT))    
  400   P(IZW,5)=-SQRT(MAX(0.,P(IZW,3)**2+PTABS**2-P(IZW,4)**2))    
        I=MINT(83)+9    
        K(IPU5,1)=1 
        K(IPU5,2)=KFRES 
        K(IPU5,3)=I 
        P(IPU5,5)=SHR   
        P(IPU5,1)=-P(IPU3,1)-P(IPU4,1)  
        P(IPU5,2)=-P(IPU3,2)-P(IPU4,2)  
        P(IPU5,3)=-P(IPU3,3)-P(IPU4,3)  
        P(IPU5,4)=SHPR-P(IPU3,4)-P(IPU4,4)  
        K(I,1)=21   
        K(I,2)=KFRES    
        DO 410 J=1,5    
  410   P(I,J)=P(IPU5,J)    
        N=IPU5  
        MINT(23)=KFRES  
    
      ELSEIF(IDOC.EQ.12) THEN   
C...Z0 and W+/- scattering: store bosons and outgoing partons.  
        PHI(1)=PARU(2)*RLU(0)   
        PHI(2)=PHI(1)-PHIR  
        DO 420 JT=1,2   
        I=MINT(84)+2+JT 
        K(I,1)=1    
        IF(IABS(MINT(20+JT)).LE.10.OR.MINT(20+JT).EQ.21) K(I,1)=3   
        K(I,2)=MINT(20+JT)  
        K(I,3)=MINT(83)+IDOC+JT-2   
        P(I,5)=ULMASS(K(I,2))   
        IF(0.5*SHPR*Z(JT).LE.P(I,5)) P(I,5)=0.  
        PABS=SQRT(MAX(0.,(0.5*SHPR*Z(JT))**2-P(I,5)**2))    
        PTABS=PABS*SQRT(MAX(0.,1.-CTHE(JT)**2)) 
        P(I,1)=PTABS*COS(PHI(JT))   
        P(I,2)=PTABS*SIN(PHI(JT))   
        P(I,3)=PABS*CTHE(JT)*(-1)**(JT+1)   
        P(I,4)=0.5*SHPR*Z(JT)   
        IZW=MINT(83)+6+JT   
        K(IZW,1)=21 
        IF(MINT(14+JT).EQ.MINT(20+JT)) THEN 
          K(IZW,2)=23   
        ELSE    
          K(IZW,2)=ISIGN(24,LUCHGE(MINT(14+JT))-LUCHGE(MINT(20+JT)))    
        ENDIF   
        K(IZW,3)=IZW-2  
        P(IZW,1)=-P(I,1)    
        P(IZW,2)=-P(I,2)    
        P(IZW,3)=(0.5*SHPR-PABS*CTHE(JT))*(-1)**(JT+1)  
        P(IZW,4)=0.5*SHPR*(1.-Z(JT))    
        P(IZW,5)=-SQRT(MAX(0.,P(IZW,3)**2+PTABS**2-P(IZW,4)**2))    
        IPU=MINT(84)+4+JT   
        K(IPU,1)=3  
        K(IPU,2)=KFPR(ISUB,JT)  
        K(IPU,3)=MINT(83)+8+JT  
        IF(IABS(K(IPU,2)).LE.10.OR.K(IPU,2).EQ.21) THEN 
          P(IPU,5)=ULMASS(K(IPU,2)) 
        ELSE    
          P(IPU,5)=SQRT(VINT(63+MOD(JS+JT,2)))  
        ENDIF   
        MINT(22+JT)=K(IZW,2)    
  420   CONTINUE    
        IF(ISUB.EQ.72) K(MINT(84)+4+INT(1.5+RLU(0)),2)=-24  
C...Find rotation and boost for hard scattering subsystem.  
        I1=MINT(83)+7   
        I2=MINT(83)+8   
        BEXCM=(P(I1,1)+P(I2,1))/(P(I1,4)+P(I2,4))   
        BEYCM=(P(I1,2)+P(I2,2))/(P(I1,4)+P(I2,4))   
        BEZCM=(P(I1,3)+P(I2,3))/(P(I1,4)+P(I2,4))   
        GAMCM=(P(I1,4)+P(I2,4))/SHR 
        BEPCM=BEXCM*P(I1,1)+BEYCM*P(I1,2)+BEZCM*P(I1,3) 
        PX=P(I1,1)+GAMCM*(GAMCM/(1.+GAMCM)*BEPCM-P(I1,4))*BEXCM 
        PY=P(I1,2)+GAMCM*(GAMCM/(1.+GAMCM)*BEPCM-P(I1,4))*BEYCM 
        PZ=P(I1,3)+GAMCM*(GAMCM/(1.+GAMCM)*BEPCM-P(I1,4))*BEZCM 
        THECM=ULANGL(PZ,SQRT(PX**2+PY**2))  
        PHICM=ULANGL(PX,PY) 
C...Store hard scattering subsystem. Rotate and boost it.   
        SQLAM=(SH-P(IPU5,5)**2-P(IPU6,5)**2)**2-4.*P(IPU5,5)**2*    
     &  P(IPU6,5)**2    
        PABS=SQRT(MAX(0.,SQLAM/(4.*SH)))    
        CTHWZ=VINT(23)  
        STHWZ=SQRT(MAX(0.,1.-CTHWZ**2)) 
        PHIWZ=VINT(24)-PHICM    
        P(IPU5,1)=PABS*STHWZ*COS(PHIWZ) 
        P(IPU5,2)=PABS*STHWZ*SIN(PHIWZ) 
        P(IPU5,3)=PABS*CTHWZ    
        P(IPU5,4)=SQRT(PABS**2+P(IPU5,5)**2)    
        P(IPU6,1)=-P(IPU5,1)    
        P(IPU6,2)=-P(IPU5,2)    
        P(IPU6,3)=-P(IPU5,3)    
        P(IPU6,4)=SQRT(PABS**2+P(IPU6,5)**2)    
        CALL LUDBRB(IPU5,IPU6,THECM,PHICM,DBLE(BEXCM),DBLE(BEYCM),  
     &  DBLE(BEZCM))    
        DO 430 JT=1,2   
        I1=MINT(83)+8+JT    
        I2=MINT(84)+4+JT    
        K(I1,1)=21  
        K(I1,2)=K(I2,2) 
        DO 430 J=1,5    
  430   P(I1,J)=P(I2,J) 
        N=IPU6  
        MINT(7)=MINT(83)+9  
        MINT(8)=MINT(83)+10 
      ENDIF 
    
      IF(IDOC.GE.8) THEN    
C...Store colour connection indices.    
        DO 440 J=1,2    
        JC=J    
        IF(KCS.EQ.-1) JC=3-J    
        IF(ICOL(KCC,1,JC).NE.0.AND.K(IPU1,1).EQ.14) K(IPU1,J+3)=    
     &  K(IPU1,J+3)+MINT(84)+ICOL(KCC,1,JC) 
        IF(ICOL(KCC,2,JC).NE.0.AND.K(IPU2,1).EQ.14) K(IPU2,J+3)=    
     &  K(IPU2,J+3)+MINT(84)+ICOL(KCC,2,JC) 
        IF(ICOL(KCC,3,JC).NE.0.AND.K(IPU3,1).EQ.3) K(IPU3,J+3)= 
     &  MSTU(5)*(MINT(84)+ICOL(KCC,3,JC))   
  440   IF(ICOL(KCC,4,JC).NE.0.AND.K(IPU4,1).EQ.3) K(IPU4,J+3)= 
     &  MSTU(5)*(MINT(84)+ICOL(KCC,4,JC))   
    
C...Copy outgoing partons to documentation lines.   
        DO 450 I=1,2    
        I1=MINT(83)+IDOC-2+I    
        I2=MINT(84)+2+I 
        K(I1,1)=21  
        K(I1,2)=K(I2,2) 
        IF(IDOC.LE.9) K(I1,3)=0 
        IF(IDOC.GE.11) K(I1,3)=MINT(83)+2+I 
        DO 450 J=1,5    
  450   P(I1,J)=P(I2,J) 
      ENDIF 
      MINT(52)=N    
    
C...Low-pT events: remove gluons used for string drawing purposes.  
      IF(ISUB.EQ.95) THEN   
        K(IPU3,1)=K(IPU3,1)+10  
        K(IPU4,1)=K(IPU4,1)+10  
        DO 460 J=41,66  
  460   VINT(J)=0.  
        DO 470 I=MINT(83)+5,MINT(83)+8  
        DO 470 J=1,5    
  470   P(I,J)=0.   
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYSSPA(IPU1,IPU2)  
    
C...Generates spacelike parton showers. 
      IMPLICIT DOUBLE PRECISION(D)  
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT3/XSFX(2,-40:40),ISIG(1000,3),SIGH(1000)  
      SAVE /PYINT3/ 
      DIMENSION KFLS(4),IS(2),XS(2),ZS(2),Q2S(2),TEVS(2),ROBO(5),   
     &XFS(2,-6:6),XFA(-6:6),XFB(-6:6),XFN(-6:6),WTAP(-6:6),WTSF(-6:6),  
     &THE2(2),ALAM(2),DQ2(3),DPC(3),DPD(4),DPB(4)   
    
C...Calculate maximum virtuality and check that evolution possible. 
      IPUS1=IPU1    
      IPUS2=IPU2    
      ISUB=MINT(1)  
      Q2E=VINT(52)  
      IF(ISET(ISUB).EQ.1) THEN  
        Q2E=Q2E/PARP(67)    
      ELSEIF(ISET(ISUB).EQ.3.OR.ISET(ISUB).EQ.4) THEN   
        Q2E=PMAS(23,1)**2   
        IF(ISUB.EQ.8.OR.ISUB.EQ.76.OR.ISUB.EQ.77) Q2E=PMAS(24,1)**2 
      ENDIF 
      TMAX=LOG(PARP(67)*PARP(63)*Q2E/PARP(61)**2)   
      IF(PARP(67)*Q2E.LT.MAX(PARP(62)**2,2.*PARP(61)**2).OR.    
     &TMAX.LT.0.2) RETURN   
    
C...Common constants and initial values. Save normal Lambda value.  
      XE0=2.*PARP(65)/VINT(1)   
      ALAMS=PARU(111)   
      PARU(111)=PARP(61)    
      NS=N  
  100 N=NS  
      DO 110 JT=1,2 
      KFLS(JT)=MINT(14+JT)  
      KFLS(JT+2)=KFLS(JT)   
      XS(JT)=VINT(40+JT)    
      ZS(JT)=1. 
      Q2S(JT)=PARP(67)*Q2E  
      TEVS(JT)=TMAX 
      ALAM(JT)=PARP(61) 
      THE2(JT)=100. 
      DO 110 KFL=-6,6   
  110 XFS(JT,KFL)=XSFX(JT,KFL)  
      DSH=dble(VINT(44))
      IF(ISET(ISUB).EQ.3.OR.ISET(ISUB).EQ.4) DSH=dble(VINT(26)*VINT(2))
    
C...Pick up leg with highest virtuality.    
  120 N=N+1 
      JT=1  
      IF(N.GT.NS+1.AND.Q2S(2).GT.Q2S(1)) JT=2   
      KFLB=KFLS(JT) 
      XB=XS(JT) 
      DO 130 KFL=-6,6   
  130 XFB(KFL)=XFS(JT,KFL)  
      DSHR=2D0*SQRT(DSH)    
      DSHZ=DSH/DBLE(ZS(JT)) 
      XE=MAX(XE0,XB*(1./(1.-PARP(66))-1.))  
      IF(XB+XE.GE.0.999) THEN   
        Q2B=0.  
        GOTO 220    
      ENDIF 
    
C...Maximum Q2 without or with Q2 ordering. Effective Lambda and n_f.   
      IF(MSTP(62).LE.1) THEN    
        Q2B=0.5*(1./ZS(JT)+1.)*Q2S(JT)+0.5*(1./ZS(JT)-1.)*(Q2S(3-JT)-   
     &  SNGL(DSH)+SQRT((SNGL(DSH)+Q2S(1)+Q2S(2))**2+8.*Q2S(1)*Q2S(2)*   
     &  ZS(JT)/(1.-ZS(JT))))    
        TEVB=LOG(PARP(63)*Q2B/ALAM(JT)**2)  
      ELSE  
        Q2B=Q2S(JT) 
        TEVB=TEVS(JT)   
      ENDIF 
      ALSDUM=ULALPS(PARP(63)*Q2B)   
      TEVB=TEVB+2.*LOG(ALAM(JT)/PARU(117))  
      TEVBSV=TEVB   
      ALAM(JT)=PARU(117)    
      B0=(33.-2.*MSTU(118))/6.  
    
C...Calculate Altarelli-Parisi and structure function weights.  
      DO 140 KFL=-6,6   
      WTAP(KFL)=0.  
  140 WTSF(KFL)=0.  
      IF(KFLB.EQ.21) THEN   
        WTAPQ=16.*(1.-SQRT(XB+XE))/(3.*SQRT(XB))    
        DO 150 KFL=-MSTP(54),MSTP(54)   
        IF(KFL.EQ.0) WTAP(KFL)=6.*LOG((1.-XB)/XE)   
  150   IF(KFL.NE.0) WTAP(KFL)=WTAPQ    
      ELSE  
        WTAP(0)=0.5*XB*(1./(XB+XE)-1.)  
        WTAP(KFLB)=8.*LOG((1.-XB)*(XB+XE)/XE)/3.    
      ENDIF 
  160 WTSUM=0.  
      IF(KFLB.NE.21) XFBO=XFB(KFLB) 
      IF(KFLB.EQ.21) XFBO=XFB(0)
C***************************************************************
C**********ERROR HAS OCCURED HERE
      IF(XFBO.EQ.0.0) THEN
                WRITE(MSTU(11),1000)
                WRITE(MSTU(11),1001) KFLB,XFB(KFLB)
                XFBO=0.00001
      ENDIF
C****************************************************************    
      DO 170 KFL=-MSTP(54),MSTP(54) 
      WTSF(KFL)=XFB(KFL)/XFBO   
  170 WTSUM=WTSUM+WTAP(KFL)*WTSF(KFL)   
      WTSUM=MAX(0.0001,WTSUM)   
    
C...Choose new t: fix alpha_s, alpha_s(Q2), alpha_s(k_T2).  
  180 IF(MSTP(64).LE.0) THEN    
        TEVB=TEVB+LOG(RLU(0))*PARU(2)/(PARU(111)*WTSUM) 
      ELSEIF(MSTP(64).EQ.1) THEN    
        TEVB=TEVB*EXP(MAX(-100.,LOG(RLU(0))*B0/WTSUM))  
      ELSE  
        TEVB=TEVB*EXP(MAX(-100.,LOG(RLU(0))*B0/(5.*WTSUM))) 
      ENDIF 
  190 Q2REF=ALAM(JT)**2*EXP(TEVB)   
      Q2B=Q2REF/PARP(63)    
    
C...Evolution ended or select flavour for branching parton. 
      IF(Q2B.LT.PARP(62)**2) THEN   
        Q2B=0.  
      ELSE  
        WTRAN=RLU(0)*WTSUM  
        KFLA=-MSTP(54)-1    
  200   KFLA=KFLA+1 
        WTRAN=WTRAN-WTAP(KFLA)*WTSF(KFLA)   
        IF(KFLA.LT.MSTP(54).AND.WTRAN.GT.0.) GOTO 200   
        IF(KFLA.EQ.0) KFLA=21   
    
C...Choose z value and corrective weight.   
        IF(KFLB.EQ.21.AND.KFLA.EQ.21) THEN  
          Z=1./(1.+((1.-XB)/XB)*(XE/(1.-XB))**RLU(0))   
          WTZ=(1.-Z*(1.-Z))**2  
        ELSEIF(KFLB.EQ.21) THEN 
          Z=XB/(1.-RLU(0)*(1.-SQRT(XB+XE)))**2  
          WTZ=0.5*(1.+(1.-Z)**2)*SQRT(Z)    
        ELSEIF(KFLA.EQ.21) THEN 
          Z=XB*(1.+RLU(0)*(1./(XB+XE)-1.))  
          WTZ=1.-2.*Z*(1.-Z)    
        ELSE    
          Z=1.-(1.-XB)*(XE/((XB+XE)*(1.-XB)))**RLU(0)   
          WTZ=0.5*(1.+Z**2) 
        ENDIF   
    
C...Option with resummation of soft gluon emission as effective z shift.    
        IF(MSTP(65).GE.1) THEN  
          RSOFT=6.  
          IF(KFLB.NE.21) RSOFT=8./3.    
          Z=Z*(TEVB/TEVS(JT))**(RSOFT*XE/((XB+XE)*B0))  
          IF(Z.LE.XB) GOTO 180  
        ENDIF   
    
C...Option with alpha_s(k_T2)Q2): demand k_T2 > cutoff, reweight.   
        IF(MSTP(64).GE.2) THEN  
          IF((1.-Z)*Q2B.LT.PARP(62)**2) GOTO 180    
          ALPRAT=TEVB/(TEVB+LOG(1.-Z))  
          IF(ALPRAT.LT.5.*RLU(0)) GOTO 180  
          IF(ALPRAT.GT.5.) WTZ=WTZ*ALPRAT/5.    
        ENDIF   
    
C...Option with angular ordering requirement.   
        IF(MSTP(62).GE.3) THEN  
          THE2T=(4.*Z**2*Q2B)/(VINT(2)*(1.-Z)*XB**2)    
          IF(THE2T.GT.THE2(JT)) GOTO 180    
        ENDIF   
    
C...Weighting with new structure functions. 
        CALL PYSTFU(MINT(10+JT),XB,Q2REF,XFN,JT)   
        IF(KFLB.NE.21) XFBN=XFN(KFLB)   
        IF(KFLB.EQ.21) XFBN=XFN(0)  
        IF(XFBN.LT.1E-20) THEN  
          IF(KFLA.EQ.KFLB) THEN 
            TEVB=TEVBSV 
            WTAP(KFLB)=0.   
            GOTO 160    
          ELSEIF(TEVBSV-TEVB.GT.0.2) THEN   
            TEVB=0.5*(TEVBSV+TEVB)  
            GOTO 190    
          ELSE  
            XFBN=1E-10  
          ENDIF 
        ENDIF   
        DO 210 KFL=-MSTP(54),MSTP(54)   
  210   XFB(KFL)=XFN(KFL)   
        XA=XB/Z 
        CALL PYSTFU(MINT(10+JT),XA,Q2REF,XFA,JT)   
        IF(KFLA.NE.21) XFAN=XFA(KFLA)   
        IF(KFLA.EQ.21) XFAN=XFA(0)  
        IF(XFAN.LT.1E-20) GOTO 160  
        IF(KFLA.NE.21) WTSFA=WTSF(KFLA) 
        IF(KFLA.EQ.21) WTSFA=WTSF(0)    
        IF(WTZ*XFAN/XFBN.LT.RLU(0)*WTSFA) GOTO 160  
      ENDIF 
    
C...Define two hard scatterers in their CM-frame.   
  220 IF(N.EQ.NS+2) THEN    
        DQ2(JT)=dble(Q2B)
        DPLCM=DSQRT((DSH+DQ2(1)+DQ2(2))**2-4D0*DQ2(1)*DQ2(2))/DSHR   
        DO 240 JR=1,2   
        I=NS+JR 
        IF(JR.EQ.1) IPO=IPUS1   
        IF(JR.EQ.2) IPO=IPUS2   
        DO 230 J=1,5    
        K(I,J)=0    
        P(I,J)=0.   
  230   V(I,J)=0.   
        K(I,1)=14   
        K(I,2)=KFLS(JR+2)   
        K(I,4)=IPO  
        K(I,5)=IPO  
        P(I,3)=sngl(DPLCM)*(-1)**(JR+1)   
        P(I,4)=sngl((DSH+DQ2(3-JR)-DQ2(JR))/DSHR)
        P(I,5)=-SQRT(SNGL(DQ2(JR))) 
        K(IPO,1)=14 
        K(IPO,3)=I  
        K(IPO,4)=MOD(K(IPO,4),MSTU(5))+MSTU(5)*I    
  240   K(IPO,5)=MOD(K(IPO,5),MSTU(5))+MSTU(5)*I    
    
C...Find maximum allowed mass of timelike parton.   
      ELSEIF(N.GT.NS+2) THEN    
        JR=3-JT 
        DQ2(3)=dble(Q2B)
        DPC(1)=dble(P(IS(1),4))
        DPC(2)=dble(P(IS(2),4))
        DPC(3)=dble(0.5*(ABS(P(IS(1),3))+ABS(P(IS(2),3))))
        DPD(1)=DSH+DQ2(JR)+DQ2(JT)  
        DPD(2)=DSHZ+DQ2(JR)+DQ2(3)  
        DPD(3)=SQRT(DPD(1)**2-4D0*DQ2(JR)*DQ2(JT))  
        DPD(4)=SQRT(DPD(2)**2-4D0*DQ2(JR)*DQ2(3))   
        IKIN=0  
        IF(Q2S(JR).GE.(0.5*PARP(62))**2.AND.DPD(1)-DPD(3).GE.   
     &  1D-10*DPD(1)) IKIN=1    
        IF(IKIN.EQ.0) DMSMA=(DQ2(JT)/DBLE(ZS(JT))-DQ2(3))*(DSH/ 
     &  (DSH+DQ2(JT))-DSH/(DSHZ+DQ2(3)))    
        IF(IKIN.EQ.1) DMSMA=(DPD(1)*DPD(2)-DPD(3)*DPD(4))/(2.d0*  
     &  DQ2(JR))-DQ2(JT)-DQ2(3) 
    
C...Generate timelike parton shower (if required).  
        IT=N    
        DO 250 J=1,5    
        K(IT,J)=0   
        P(IT,J)=0.  
  250   V(IT,J)=0.  
        K(IT,1)=3   
        K(IT,2)=21  
        IF(KFLB.EQ.21.AND.KFLS(JT+2).NE.21) K(IT,2)=-KFLS(JT+2) 
        IF(KFLB.NE.21.AND.KFLS(JT+2).EQ.21) K(IT,2)=KFLB    
        P(IT,5)=ULMASS(K(IT,2)) 
        IF(SNGL(DMSMA).LE.P(IT,5)**2) GOTO 100  
        IF(MSTP(63).GE.1) THEN  
          P(IT,4)=sngl((DSHZ-DSH-dble(P(IT,5))**2)/DSHR)
          P(IT,3)=SQRT(P(IT,4)**2-P(IT,5)**2)   
          IF(MSTP(63).EQ.1) THEN    
            Q2TIM=sngl(DMSMA)
          ELSEIF(MSTP(63).EQ.2) THEN    
            Q2TIM=MIN(SNGL(DMSMA),PARP(71)*Q2S(JT)) 
          ELSE  
C'''Here remains to introduce angular ordering in first branching.  
            Q2TIM=sngl(DMSMA)
          ENDIF 
          CALL LUSHOW(IT,0,SQRT(Q2TIM)) 
          IF(N.GE.IT+1) P(IT,5)=P(IT+1,5)   
        ENDIF   
    
C...Reconstruct kinematics of branching: timelike parton shower.    
        DMS=dble(P(IT,5)**2)
        IF(IKIN.EQ.0) DPT2=(DMSMA-DMS)*(DSHZ+DQ2(3))/(DSH+DQ2(JT))  
        IF(IKIN.EQ.1) DPT2=(DMSMA-DMS)*(0.5d0*DPD(1)*DPD(2)
     &       +0.5d0*DPD(3)*
     &  DPD(4)-DQ2(JR)*(DQ2(JT)+DQ2(3)+DMS))/(4.d0*DSH*DPC(3)**2) 
        IF(DPT2.LT.0.d0) GOTO 100 
        DPB(1)=(0.5d0*DPD(2)-DPC(JR)*(DSHZ+DQ2(JR)-DQ2(JT)-DMS)/  
     &  DSHR)/DPC(3)-DPC(3) 
        P(IT,1)=SQRT(SNGL(DPT2))    
        P(IT,3)=sngl(DPB(1))*(-1)**(JT+1) 
        P(IT,4)=sngl((DSHZ-DSH-DMS)/DSHR)
        IF(N.GE.IT+1) THEN  
          DPB(1)=SQRT(DPB(1)**2+DPT2)   
          DPB(2)=SQRT(DPB(1)**2+DMS)    
          DPB(3)=dble(P(IT+1,3))
          DPB(4)=SQRT(DPB(3)**2+DMS)    
          DBEZ=(DPB(4)*DPB(1)-DPB(3)*DPB(2))/(DPB(4)*DPB(2)-DPB(3)* 
     &    DPB(1))   
          CALL LUDBRB(IT+1,N,0.,0.,0D0,0D0,DBEZ)    
          THE=ULANGL(P(IT,3),P(IT,1))   
          CALL LUDBRB(IT+1,N,THE,0.,0D0,0D0,0D0)    
        ENDIF   
    
C...Reconstruct kinematics of branching: spacelike parton.  
        DO 260 J=1,5    
        K(N+1,J)=0  
        P(N+1,J)=0. 
  260   V(N+1,J)=0. 
        K(N+1,1)=14 
        K(N+1,2)=KFLB   
        P(N+1,1)=P(IT,1)    
        P(N+1,3)=P(IT,3)+P(IS(JT),3)    
        P(N+1,4)=P(IT,4)+P(IS(JT),4)    
        P(N+1,5)=-SQRT(SNGL(DQ2(3)))    
    
C...Define colour flow of branching.    
        K(IS(JT),3)=N+1 
        K(IT,3)=N+1 
        ID1=IT  
        IF((K(N+1,2).GT.0.AND.K(N+1,2).NE.21.AND.K(ID1,2).GT.0.AND. 
     &  K(ID1,2).NE.21).OR.(K(N+1,2).LT.0.AND.K(ID1,2).EQ.21).OR.   
     &  (K(N+1,2).EQ.21.AND.K(ID1,2).EQ.21.AND.RLU(0).GT.0.5).OR.   
     &  (K(N+1,2).EQ.21.AND.K(ID1,2).LT.0)) ID1=IS(JT)  
        ID2=IT+IS(JT)-ID1   
        K(N+1,4)=K(N+1,4)+ID1   
        K(N+1,5)=K(N+1,5)+ID2   
        K(ID1,4)=K(ID1,4)+MSTU(5)*(N+1) 
        K(ID1,5)=K(ID1,5)+MSTU(5)*ID2   
        K(ID2,4)=K(ID2,4)+MSTU(5)*ID1   
        K(ID2,5)=K(ID2,5)+MSTU(5)*(N+1) 
        N=N+1   
    
C...Boost to new CM-frame.  
        CALL LUDBRB(NS+1,N,0.,0.,-DBLE((P(N,1)+P(IS(JR),1))/(P(N,4)+    
     &  P(IS(JR),4))),0D0,-DBLE((P(N,3)+P(IS(JR),3))/(P(N,4)+   
     &  P(IS(JR),4))))  
        IR=N+(JT-1)*(IS(1)-N)   
        CALL LUDBRB(NS+1,N,-ULANGL(P(IR,3),P(IR,1)),PARU(2)*RLU(0), 
     &  0D0,0D0,0D0)    
      ENDIF 
    
C...Save quantities, loop back. 
      IS(JT)=N  
      Q2S(JT)=Q2B   
      DQ2(JT)=dble(Q2B)
      IF(MSTP(62).GE.3) THE2(JT)=THE2T  
      DSH=DSHZ  
      IF(Q2B.GE.(0.5*PARP(62))**2) THEN 
        KFLS(JT+2)=KFLS(JT) 
        KFLS(JT)=KFLA   
        XS(JT)=XA   
        ZS(JT)=Z    
        DO 270 KFL=-6,6 
  270   XFS(JT,KFL)=XFA(KFL)    
        TEVS(JT)=TEVB   
      ELSE  
        IF(JT.EQ.1) IPU1=N  
        IF(JT.EQ.2) IPU2=N  
      ENDIF 
      IF(N.GT.MSTU(4)-MSTU(32)-10) THEN 
        CALL LUERRM(11,'(PYSSPA:) no more memory left in LUJETS')   
        IF(MSTU(21).GE.1) N=NS  
        IF(MSTU(21).GE.1) RETURN    
      ENDIF 
      IF(MAX(Q2S(1),Q2S(2)).GE.(0.5*PARP(62))**2.OR.N.LE.NS+1) GOTO 120 
    
C...Boost hard scattering partons to frame of shower initiators.    
      DO 280 J=1,3  
  280 ROBO(J+2)=(P(NS+1,J)+P(NS+2,J))/(P(NS+1,4)+P(NS+2,4)) 
      DO 290 J=1,5  
  290 P(N+2,J)=P(NS+1,J)    
      ROBOT=ROBO(3)**2+ROBO(4)**2+ROBO(5)**2    
      IF(ROBOT.GE.0.999999) THEN    
        ROBOT=1.00001*SQRT(ROBOT)   
        ROBO(3)=ROBO(3)/ROBOT   
        ROBO(4)=ROBO(4)/ROBOT   
        ROBO(5)=ROBO(5)/ROBOT   
      ENDIF 
      CALL LUDBRB(N+2,N+2,0.,0.,-DBLE(ROBO(3)),-DBLE(ROBO(4)),  
     &-DBLE(ROBO(5)))   
      ROBO(2)=ULANGL(P(N+2,1),P(N+2,2)) 
      ROBO(1)=ULANGL(P(N+2,3),SQRT(P(N+2,1)**2+P(N+2,2)**2))    
      CALL LUDBRB(MINT(83)+5,NS,ROBO(1),ROBO(2),DBLE(ROBO(3)),  
     &DBLE(ROBO(4)),DBLE(ROBO(5)))  
    
C...Store user information. Reset Lambda value. 
      K(IPU1,3)=MINT(83)+3  
      K(IPU2,3)=MINT(83)+4  
      DO 300 JT=1,2 
      MINT(12+JT)=KFLS(JT)  
  300 VINT(140+JT)=XS(JT)   
      PARU(111)=ALAMS   
 1000 FORMAT(5X,'structure function has a zero point here')
 1001 FORMAT(5X,'xf(x,i=',I5,')=',F10.5)

      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYMULT(MMUL)   
    
C...Initializes treatment of multiple interactions, selects kinematics  
C...of hardest interaction if low-pT physics included in run, and   
C...generates all non-hardest interactions. 
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT3/XSFX(2,-40:40),ISIG(1000,3),SIGH(1000)  
      SAVE /PYINT3/ 
      COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3) 
      SAVE /PYINT5/ 
      DIMENSION NMUL(20),SIGM(20),KSTR(500,2)   
      SAVE XT2,XT2FAC,XC2,XTS,IRBIN,RBIN,NMUL,SIGM  
    
C...Initialization of multiple interaction treatment.   
      IF(MMUL.EQ.1) THEN    
        IF(MSTP(122).GE.1) WRITE(MSTU(11),1000) MSTP(82)    
        ISUB=96 
        MINT(1)=96  
        VINT(63)=0. 
        VINT(64)=0. 
        VINT(143)=1.    
        VINT(144)=1.    
    
C...Loop over phase space points: xT2 choice in 20 bins.    
  100   SIGSUM=0.   
        DO 120 IXT2=1,20    
        NMUL(IXT2)=MSTP(83) 
        SIGM(IXT2)=0.   
        DO 110 ITRY=1,MSTP(83)  
        RSCA=0.05*((21-IXT2)-RLU(0))    
        XT2=VINT(149)*(1.+VINT(149))/(VINT(149)+RSCA)-VINT(149) 
        XT2=MAX(0.01*VINT(149),XT2) 
        VINT(25)=XT2    
    
C...Choose tau and y*. Calculate cos(theta-hat).    
        IF(RLU(0).LE.COEF(ISUB,1)) THEN 
          TAUP=(2.*(1.+SQRT(1.-XT2))/XT2-1.)**RLU(0)    
          TAU=XT2*(1.+TAUP)**2/(4.*TAUP)    
        ELSE    
          TAU=XT2*(1.+TAN(RLU(0)*ATAN(SQRT(1./XT2-1.)))**2) 
        ENDIF   
        VINT(21)=TAU    
        CALL PYKLIM(2)  
        RYST=RLU(0) 
        MYST=1  
        IF(RYST.GT.COEF(ISUB,7)) MYST=2 
        IF(RYST.GT.COEF(ISUB,7)+COEF(ISUB,8)) MYST=3    
        CALL PYKMAP(2,MYST,RLU(0))  
        VINT(23)=SQRT(MAX(0.,1.-XT2/TAU))*(-1)**INT(1.5+RLU(0)) 
    
C...Calculate differential cross-section.   
        VINT(71)=0.5*VINT(1)*SQRT(XT2)  
        CALL PYSIGH(NCHN,SIGS)  
  110   SIGM(IXT2)=SIGM(IXT2)+SIGS  
  120   SIGSUM=SIGSUM+SIGM(IXT2)    
        SIGSUM=SIGSUM/(20.*MSTP(83))    
    
C...Reject result if sigma(parton-parton) is smaller than hadronic one. 
        IF(SIGSUM.LT.1.1*VINT(106)) THEN    
          IF(MSTP(122).GE.1) WRITE(MSTU(11),1100) PARP(82),SIGSUM   
          PARP(82)=0.9*PARP(82) 
          VINT(149)=4.*PARP(82)**2/VINT(2)  
          GOTO 100  
        ENDIF   
        IF(MSTP(122).GE.1) WRITE(MSTU(11),1200) PARP(82), SIGSUM    
    
C...Start iteration to find k factor.   
        YKE=SIGSUM/VINT(106)    
        SO=0.5  
        XI=0.   
        YI=0.   
        XK=0.5  
        IIT=0   
  130   IF(IIT.EQ.0) THEN   
          XK=2.*XK  
        ELSEIF(IIT.EQ.1) THEN   
          XK=0.5*XK 
        ELSE    
          XK=XI+(YKE-YI)*(XF-XI)/(YF-YI)    
        ENDIF   
    
C...Evaluate overlap integrals. 
        IF(MSTP(82).EQ.2) THEN  
          SP=0.5*PARU(1)*(1.-EXP(-XK))  
          SOP=SP/PARU(1)    
        ELSE    
          IF(MSTP(82).EQ.3) DELTAB=0.02 
          IF(MSTP(82).EQ.4) DELTAB=MIN(0.01,0.05*PARP(84))  
          SP=0. 
          SOP=0.    
          B=-0.5*DELTAB 
  140     B=B+DELTAB    
          IF(MSTP(82).EQ.3) THEN    
            OV=EXP(-B**2)/PARU(2)   
          ELSE  
            CQ2=PARP(84)**2 
            OV=((1.-PARP(83))**2*EXP(-MIN(100.,B**2))+2.*PARP(83)*  
     &      (1.-PARP(83))*2./(1.+CQ2)*EXP(-MIN(100.,B**2*2./(1.+CQ2)))+ 
     &      PARP(83)**2/CQ2*EXP(-MIN(100.,B**2/CQ2)))/PARU(2)   
          ENDIF 
          PACC=1.-EXP(-MIN(100.,PARU(1)*XK*OV)) 
          SP=SP+PARU(2)*B*DELTAB*PACC   
          SOP=SOP+PARU(2)*B*DELTAB*OV*PACC  
          IF(B.LT.1..OR.B*PACC.GT.1E-6) GOTO 140    
        ENDIF   
        YK=PARU(1)*XK*SO/SP 
    
C...Continue iteration until convergence.   
        IF(YK.LT.YKE) THEN  
          XI=XK 
          YI=YK 
          IF(IIT.EQ.1) IIT=2    
        ELSE    
          XF=XK 
          YF=YK 
          IF(IIT.EQ.0) IIT=1    
        ENDIF   
        IF(ABS(YK-YKE).GE.1E-5*YKE) GOTO 130    
    
C...Store some results for subsequent use.  
        VINT(145)=SIGSUM    
        VINT(146)=SOP/SO    
        VINT(147)=SOP/SP    
    
C...Initialize iteration in xT2 for hardest interaction.    
      ELSEIF(MMUL.EQ.2) THEN    
        IF(MSTP(82).LE.0) THEN  
        ELSEIF(MSTP(82).EQ.1) THEN  
          XT2=1.    
          XT2FAC=XSEC(96,1)/VINT(106)*VINT(149)/(1.-VINT(149))  
        ELSEIF(MSTP(82).EQ.2) THEN  
          XT2=1.    
          XT2FAC=VINT(146)*XSEC(96,1)/VINT(106)*VINT(149)*(1.+VINT(149))    
        ELSE    
          XC2=4.*CKIN(3)**2/VINT(2) 
          IF(CKIN(3).LE.CKIN(5).OR.MINT(82).GE.2) XC2=0.    
        ENDIF   
    
      ELSEIF(MMUL.EQ.3) THEN    
C...Low-pT or multiple interactions (first semihard interaction):   
C...choose xT2 according to dpT2/pT2**2*exp(-(sigma above pT2)/norm)    
C...or (MSTP(82)>=2) dpT2/(pT2+pT0**2)**2*exp(-....).   
        ISUB=MINT(1)    
        IF(MSTP(82).LE.0) THEN  
          XT2=0.    
        ELSEIF(MSTP(82).EQ.1) THEN  
          XT2=XT2FAC*XT2/(XT2FAC-XT2*LOG(RLU(0)))   
        ELSEIF(MSTP(82).EQ.2) THEN  
          IF(XT2.LT.1..AND.EXP(-XT2FAC*XT2/(VINT(149)*(XT2+ 
     &    VINT(149)))).GT.RLU(0)) XT2=1.    
          IF(XT2.GE.1.) THEN    
            XT2=(1.+VINT(149))*XT2FAC/(XT2FAC-(1.+VINT(149))*LOG(1.-    
     &      RLU(0)*(1.-EXP(-XT2FAC/(VINT(149)*(1.+VINT(149)))))))-  
     &      VINT(149)   
          ELSE  
            XT2=-XT2FAC/LOG(EXP(-XT2FAC/(XT2+VINT(149)))+RLU(0)*    
     &      (EXP(-XT2FAC/VINT(149))-EXP(-XT2FAC/(XT2+VINT(149)))))- 
     &      VINT(149)   
          ENDIF 
          XT2=MAX(0.01*VINT(149),XT2)   
        ELSE    
          XT2=(XC2+VINT(149))*(1.+VINT(149))/(1.+VINT(149)- 
     &    RLU(0)*(1.-XC2))-VINT(149)    
          XT2=MAX(0.01*VINT(149),XT2)   
        ENDIF   
        VINT(25)=XT2    
    
C...Low-pT: choose xT2, tau, y* and cos(theta-hat) fixed.   
        IF(MSTP(82).LE.1.AND.XT2.LT.VINT(149)) THEN 
          IF(MINT(82).EQ.1) NGEN(0,1)=NGEN(0,1)-1   
          IF(MINT(82).EQ.1) NGEN(ISUB,1)=NGEN(ISUB,1)-1 
          ISUB=95   
          MINT(1)=ISUB  
          VINT(21)=0.01*VINT(149)   
          VINT(22)=0.   
          VINT(23)=0.   
          VINT(25)=0.01*VINT(149)   
    
        ELSE    
C...Multiple interactions (first semihard interaction). 
C...Choose tau and y*. Calculate cos(theta-hat).    
          IF(RLU(0).LE.COEF(ISUB,1)) THEN   
            TAUP=(2.*(1.+SQRT(1.-XT2))/XT2-1.)**RLU(0)  
            TAU=XT2*(1.+TAUP)**2/(4.*TAUP)  
          ELSE  
            TAU=XT2*(1.+TAN(RLU(0)*ATAN(SQRT(1./XT2-1.)))**2)   
          ENDIF 
          VINT(21)=TAU  
          CALL PYKLIM(2)    
          RYST=RLU(0)   
          MYST=1    
          IF(RYST.GT.COEF(ISUB,7)) MYST=2   
          IF(RYST.GT.COEF(ISUB,7)+COEF(ISUB,8)) MYST=3  
          CALL PYKMAP(2,MYST,RLU(0))    
          VINT(23)=SQRT(MAX(0.,1.-XT2/TAU))*(-1)**INT(1.5+RLU(0))   
        ENDIF   
        VINT(71)=0.5*VINT(1)*SQRT(VINT(25)) 
    
C...Store results of cross-section calculation. 
      ELSEIF(MMUL.EQ.4) THEN    
        ISUB=MINT(1)    
        XTS=VINT(25)    
        IF(ISET(ISUB).EQ.1) XTS=VINT(21)    
        IF(ISET(ISUB).EQ.2) XTS=(4.*VINT(48)+2.*VINT(63)+2.*VINT(64))/  
     &  VINT(2) 
        IF(ISET(ISUB).EQ.3.OR.ISET(ISUB).EQ.4) XTS=VINT(26) 
        RBIN=MAX(0.000001,MIN(0.999999,XTS*(1.+VINT(149))/  
     &  (XTS+VINT(149))))   
        IRBIN=INT(1.+20.*RBIN)  
        IF(ISUB.EQ.96) NMUL(IRBIN)=NMUL(IRBIN)+1    
        IF(ISUB.EQ.96) SIGM(IRBIN)=SIGM(IRBIN)+VINT(153)    
    
C...Choose impact parameter.    
      ELSEIF(MMUL.EQ.5) THEN    
        IF(MSTP(82).EQ.3) THEN  
          VINT(148)=RLU(0)/(PARU(2)*VINT(147))  
        ELSE    
          RTYPE=RLU(0)  
          CQ2=PARP(84)**2   
          IF(RTYPE.LT.(1.-PARP(83))**2) THEN    
            B2=-LOG(RLU(0)) 
          ELSEIF(RTYPE.LT.1.-PARP(83)**2) THEN  
            B2=-0.5*(1.+CQ2)*LOG(RLU(0))    
          ELSE  
            B2=-CQ2*LOG(RLU(0)) 
          ENDIF 
          VINT(148)=((1.-PARP(83))**2*EXP(-MIN(100.,B2))+2.*PARP(83)*   
     &    (1.-PARP(83))*2./(1.+CQ2)*EXP(-MIN(100.,B2*2./(1.+CQ2)))+ 
     &    PARP(83)**2/CQ2*EXP(-MIN(100.,B2/CQ2)))/(PARU(2)*VINT(147))   
        ENDIF   
    
C...Multiple interactions (variable impact parameter) : reject with 
C...probability exp(-overlap*cross-section above pT/normalization). 
        RNCOR=(IRBIN-20.*RBIN)*NMUL(IRBIN)  
        SIGCOR=(IRBIN-20.*RBIN)*SIGM(IRBIN) 
        DO 150 IBIN=IRBIN+1,20  
        RNCOR=RNCOR+NMUL(IBIN)  
  150   SIGCOR=SIGCOR+SIGM(IBIN)    
        SIGABV=(SIGCOR/RNCOR)*VINT(149)*(1.-XTS)/(XTS+VINT(149))    
        VINT(150)=EXP(-MIN(100.,VINT(146)*VINT(148)*SIGABV/VINT(106)))  
    
C...Generate additional multiple semihard interactions. 
      ELSEIF(MMUL.EQ.6) THEN    
    
C...Reconstruct strings in hard scattering. 
        ISUB=MINT(1)    
        NMAX=MINT(84)+4 
        IF(ISET(ISUB).EQ.1) NMAX=MINT(84)+2 
        NSTR=0  
        DO 170 I=MINT(84)+1,NMAX    
        KCS=KCHG(LUCOMP(K(I,2)),2)*ISIGN(1,K(I,2))  
        IF(KCS.EQ.0) GOTO 170   
        DO 160 J=1,4    
        IF(KCS.EQ.1.AND.(J.EQ.2.OR.J.EQ.4)) GOTO 160    
        IF(KCS.EQ.-1.AND.(J.EQ.1.OR.J.EQ.3)) GOTO 160   
        IF(J.LE.2) THEN 
          IST=MOD(K(I,J+3)/MSTU(5),MSTU(5)) 
        ELSE    
          IST=MOD(K(I,J+1),MSTU(5)) 
        ENDIF   
        IF(IST.LT.MINT(84).OR.IST.GT.I) GOTO 160    
        IF(KCHG(LUCOMP(K(IST,2)),2).EQ.0) GOTO 160  
        NSTR=NSTR+1 
        IF(J.EQ.1.OR.J.EQ.4) THEN   
          KSTR(NSTR,1)=I    
          KSTR(NSTR,2)=IST  
        ELSE    
          KSTR(NSTR,1)=IST  
          KSTR(NSTR,2)=I    
        ENDIF   
  160   CONTINUE    
  170   CONTINUE    
    
C...Set up starting values for iteration in xT2.    
        XT2=VINT(25)    
        IF(ISET(ISUB).EQ.1) XT2=VINT(21)    
        IF(ISET(ISUB).EQ.2) XT2=(4.*VINT(48)+2.*VINT(63)+2.*VINT(64))/  
     &  VINT(2) 
        IF(ISET(ISUB).EQ.3.OR.ISET(ISUB).EQ.4) XT2=VINT(26) 
        ISUB=96 
        MINT(1)=96  
        IF(MSTP(82).LE.1) THEN  
          XT2FAC=XSEC(ISUB,1)*VINT(149)/((1.-VINT(149))*VINT(106))  
        ELSE    
          XT2FAC=VINT(146)*VINT(148)*XSEC(ISUB,1)/VINT(106)*    
     &    VINT(149)*(1.+VINT(149))  
        ENDIF   
        VINT(63)=0. 
        VINT(64)=0. 
        VINT(151)=0.    
        VINT(152)=0.    
        VINT(143)=1.-VINT(141)  
        VINT(144)=1.-VINT(142)  
    
C...Iterate downwards in xT2.   
  180   IF(MSTP(82).LE.1) THEN  
          XT2=XT2FAC*XT2/(XT2FAC-XT2*LOG(RLU(0)))   
          IF(XT2.LT.VINT(149)) GOTO 220 
        ELSE    
          IF(XT2.LE.0.01*VINT(149)) GOTO 220    
          XT2=XT2FAC*(XT2+VINT(149))/(XT2FAC-(XT2+VINT(149))*   
     &    LOG(RLU(0)))-VINT(149)    
          IF(XT2.LE.0.) GOTO 220    
          XT2=MAX(0.01*VINT(149),XT2)   
        ENDIF   
        VINT(25)=XT2    
    
C...Choose tau and y*. Calculate cos(theta-hat).    
        IF(RLU(0).LE.COEF(ISUB,1)) THEN 
          TAUP=(2.*(1.+SQRT(1.-XT2))/XT2-1.)**RLU(0)    
          TAU=XT2*(1.+TAUP)**2/(4.*TAUP)    
        ELSE    
          TAU=XT2*(1.+TAN(RLU(0)*ATAN(SQRT(1./XT2-1.)))**2) 
        ENDIF   
        VINT(21)=TAU    
        CALL PYKLIM(2)  
        RYST=RLU(0) 
        MYST=1  
        IF(RYST.GT.COEF(ISUB,7)) MYST=2 
        IF(RYST.GT.COEF(ISUB,7)+COEF(ISUB,8)) MYST=3    
        CALL PYKMAP(2,MYST,RLU(0))  
        VINT(23)=SQRT(MAX(0.,1.-XT2/TAU))*(-1)**INT(1.5+RLU(0)) 
    
C...Check that x not used up. Accept or reject kinematical variables.   
        X1M=SQRT(TAU)*EXP(VINT(22)) 
        X2M=SQRT(TAU)*EXP(-VINT(22))    
        IF(VINT(143)-X1M.LT.0.01.OR.VINT(144)-X2M.LT.0.01) GOTO 180 
        VINT(71)=0.5*VINT(1)*SQRT(XT2)  
        CALL PYSIGH(NCHN,SIGS)  
        IF(SIGS.LT.XSEC(ISUB,1)*RLU(0)) GOTO 180    
    
C...Reset K, P and V vectors. Select some variables.    
        DO 190 I=N+1,N+2    
        DO 190 J=1,5    
        K(I,J)=0    
        P(I,J)=0.   
  190   V(I,J)=0.   
        RFLAV=RLU(0)    
        PT=0.5*VINT(1)*SQRT(XT2)    
        PHI=PARU(2)*RLU(0)  
        CTH=VINT(23)    
    
C...Add first parton to event record.   
        K(N+1,1)=3  
        K(N+1,2)=21 
        IF(RFLAV.GE.MAX(PARP(85),PARP(86))) K(N+1,2)=   
     &  1+INT((2.+PARJ(2))*RLU(0))  
        P(N+1,1)=PT*COS(PHI)    
        P(N+1,2)=PT*SIN(PHI)    
        P(N+1,3)=0.25*VINT(1)*(VINT(41)*(1.+CTH)-VINT(42)*(1.-CTH)) 
        P(N+1,4)=0.25*VINT(1)*(VINT(41)*(1.+CTH)+VINT(42)*(1.-CTH)) 
        P(N+1,5)=0. 
    
C...Add second parton to event record.  
        K(N+2,1)=3  
        K(N+2,2)=21 
        IF(K(N+1,2).NE.21) K(N+2,2)=-K(N+1,2)   
        P(N+2,1)=-P(N+1,1)  
        P(N+2,2)=-P(N+1,2)  
        P(N+2,3)=0.25*VINT(1)*(VINT(41)*(1.-CTH)-VINT(42)*(1.+CTH)) 
        P(N+2,4)=0.25*VINT(1)*(VINT(41)*(1.-CTH)+VINT(42)*(1.+CTH)) 
        P(N+2,5)=0. 
    
        IF(RFLAV.LT.PARP(85).AND.NSTR.GE.1) THEN    
C....Choose relevant string pieces to place gluons on.  
          DO 210 I=N+1,N+2  
          DMIN=1E8  
          DO 200 ISTR=1,NSTR    
          I1=KSTR(ISTR,1)   
          I2=KSTR(ISTR,2)   
          DIST=(P(I,4)*P(I1,4)-P(I,1)*P(I1,1)-P(I,2)*P(I1,2)-   
     &    P(I,3)*P(I1,3))*(P(I,4)*P(I2,4)-P(I,1)*P(I2,1)-   
     &    P(I,2)*P(I2,2)-P(I,3)*P(I2,3))/MAX(1.,P(I1,4)*P(I2,4)-    
     &    P(I1,1)*P(I2,1)-P(I1,2)*P(I2,2)-P(I1,3)*P(I2,3))  
          IF(ISTR.EQ.1.OR.DIST.LT.DMIN) THEN    
            DMIN=DIST   
            IST1=I1 
            IST2=I2 
            ISTM=ISTR   
          ENDIF 
  200     CONTINUE  
    
C....Colour flow adjustments, new string pieces.    
          IF(K(IST1,4)/MSTU(5).EQ.IST2) K(IST1,4)=MSTU(5)*I+    
     &    MOD(K(IST1,4),MSTU(5))    
          IF(MOD(K(IST1,5),MSTU(5)).EQ.IST2) K(IST1,5)= 
     &    MSTU(5)*(K(IST1,5)/MSTU(5))+I 
          K(I,5)=MSTU(5)*IST1   
          K(I,4)=MSTU(5)*IST2   
          IF(K(IST2,5)/MSTU(5).EQ.IST1) K(IST2,5)=MSTU(5)*I+    
     &    MOD(K(IST2,5),MSTU(5))    
          IF(MOD(K(IST2,4),MSTU(5)).EQ.IST1) K(IST2,4)= 
     &    MSTU(5)*(K(IST2,4)/MSTU(5))+I 
          KSTR(ISTM,2)=I    
          KSTR(NSTR+1,1)=I  
          KSTR(NSTR+1,2)=IST2   
  210     NSTR=NSTR+1   
    
C...String drawing and colour flow for gluon loop.  
        ELSEIF(K(N+1,2).EQ.21) THEN 
          K(N+1,4)=MSTU(5)*(N+2)    
          K(N+1,5)=MSTU(5)*(N+2)    
          K(N+2,4)=MSTU(5)*(N+1)    
          K(N+2,5)=MSTU(5)*(N+1)    
          KSTR(NSTR+1,1)=N+1    
          KSTR(NSTR+1,2)=N+2    
          KSTR(NSTR+2,1)=N+2    
          KSTR(NSTR+2,2)=N+1    
          NSTR=NSTR+2   
    
C...String drawing and colour flow for q-qbar pair. 
        ELSE    
          K(N+1,4)=MSTU(5)*(N+2)    
          K(N+2,5)=MSTU(5)*(N+1)    
          KSTR(NSTR+1,1)=N+1    
          KSTR(NSTR+1,2)=N+2    
          NSTR=NSTR+1   
        ENDIF   
    
C...Update remaining energy; iterate.   
        N=N+2   
        IF(N.GT.MSTU(4)-MSTU(32)-10) THEN   
          CALL LUERRM(11,'(PYMULT:) no more memory left in LUJETS') 
          IF(MSTU(21).GE.1) RETURN  
        ENDIF   
        MINT(31)=MINT(31)+1 
        VINT(151)=VINT(151)+VINT(41)    
        VINT(152)=VINT(152)+VINT(42)    
        VINT(143)=VINT(143)-VINT(41)    
        VINT(144)=VINT(144)-VINT(42)    
        IF(MINT(31).LT.240) GOTO 180    
  220   CONTINUE    
      ENDIF 
    
C...Format statements for printout. 
 1000 FORMAT(/1X,'****** PYMULT: initialization of multiple inter', 
     &'actions for MSTP(82) =',I2,' ******')    
 1100 FORMAT(8X,'pT0 =',F5.2,' GeV gives sigma(parton-parton) =',1P,    
     &E9.2,' mb: rejected') 
 1200 FORMAT(8X,'pT0 =',F5.2,' GeV gives sigma(parton-parton) =',1P,    
     &E9.2,' mb: accepted') 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYREMN(IPU1,IPU2)  
    
C...Adds on target remnants (one or two from each side) and 
C...includes primordial kT. 
      COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
      SAVE /HPARNT/
      COMMON/HSTRNG/NFP(300,15),PPHI(300,15),NFT(300,15),PTHI(300,15)
      SAVE /HSTRNG/
C...COMMON BLOCK FROM HIJING
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      DIMENSION KFLCH(2),KFLSP(2),CHI(2),PMS(6),IS(2),ROBO(5)   
    
C...Special case for lepton-lepton interaction. 
      IF(MINT(43).EQ.1) THEN    
        DO 100 JT=1,2   
        I=MINT(83)+JT+2 
        K(I,1)=21   
        K(I,2)=K(I-2,2) 
        K(I,3)=I-2  
        DO 100 J=1,5    
  100   P(I,J)=P(I-2,J) 
      ENDIF 
    
C...Find event type, set pointers.  
      IF(IPU1.EQ.0.AND.IPU2.EQ.0) RETURN    
      ISUB=MINT(1)  
      ILEP=0    
      IF(IPU1.EQ.0) ILEP=1  
      IF(IPU2.EQ.0) ILEP=2  
      IF(ISUB.EQ.95) ILEP=-1    
      IF(ILEP.EQ.1) IQ=MINT(84)+1   
      IF(ILEP.EQ.2) IQ=MINT(84)+2   
      IP=MAX(IPU1,IPU2) 
      ILEPR=MINT(83)+5-ILEP 
      NS=N  
    
C...Define initial partons, including primordial kT.    
  110 DO 130 JT=1,2 
      I=MINT(83)+JT+2   
      IF(JT.EQ.1) IPU=IPU1  
      IF(JT.EQ.2) IPU=IPU2  
      K(I,1)=21 
      K(I,3)=I-2    
      IF(ISUB.EQ.95) THEN   
        K(I,2)=21   
        SHS=0.  
      ELSEIF(MINT(40+JT).EQ.1.AND.IPU.NE.0) THEN    
        K(I,2)=K(IPU,2) 
        P(I,5)=P(IPU,5) 
        P(I,1)=0.   
        P(I,2)=0.   
        PMS(JT)=P(I,5)**2   
      ELSEIF(IPU.NE.0) THEN 
        K(I,2)=K(IPU,2) 
        P(I,5)=P(IPU,5) 
C...No primordial kT or chosen according to truncated Gaussian or   
C...exponential.
C
c     X.N. Wang (7.22.97)
c
        RPT1=0.0
        RPT2=0.0
        ssw2=(PPHI(IHNT2(11),4)+PTHI(IHNT2(12),4))**2
     &       -(PPHI(IHNT2(11),1)+PTHI(IHNT2(12),1))**2
     &       -(PPHI(IHNT2(11),2)+PTHI(IHNT2(12),2))**2
     &       -(PPHI(IHNT2(11),3)+PTHI(IHNT2(12),3))**2
C
C********this is s of the current NN collision
        IF(ssw2.LE.4.0*PARP(93)**2) GOTO 1211
c
        IF(IHPR2(5).LE.0) THEN
120             IF(MSTP(91).LE.0) THEN
               PT=0. 
             ELSEIF(MSTP(91).EQ.1) THEN
               PT=PARP(91)*SQRT(-LOG(RLU(0)))
             ELSE    
               RPT1=RLU(0)   
               RPT2=RLU(0)   
               PT=-PARP(92)*LOG(RPT1*RPT2)   
             ENDIF   
             IF(PT.GT.PARP(93)) GOTO 120 
             PHI=PARU(2)*RLU(0)  
             RPT1=PT*COS(PHI)  
             RPT2=PT*SIN(PHI)
        ELSE IF(IHPR2(5).EQ.1) THEN
             IF(JT.EQ.1) JPT=NFP(IHNT2(11),11)
             IF(JT.EQ.2) JPT=NFT(IHNT2(12),11)
1205             PTGS=PARP(91)*SQRT(-LOG(RLU(0)))
             IF(PTGS.GT.PARP(93)) GO TO 1205
             PHI=2.0*HIPR1(40)*RLU(0)
             RPT1=PTGS*COS(PHI)
             RPT2=PTGS*SIN(PHI)
             DO 1210 iint=1,JPT-1
                PKCSQ=PARP(91)*SQRT(-LOG(RLU(0)))
                PHI=2.0*HIPR1(40)*RLU(0)
                RPT1=RPT1+PKCSQ*COS(PHI)
                RPT2=RPT2+PKCSQ*SIN(PHI)
1210             CONTINUE
             IF(RPT1**2+RPT2**2.GE.ssw2/4.0) GO TO 1205
        ENDIF
C     X.N. Wang
C                     ********When initial interaction among soft partons is
C                             assumed the primordial pt comes from the sum of
C                             pt of JPT-1 number of initial interaction, JPT
C                             is the number of interaction including present
C                             one that nucleon hassuffered 
1211    P(I,1)=RPT1
        P(I,2)=RPT2  
        PMS(JT)=P(I,5)**2+P(I,1)**2+P(I,2)**2   
      ELSE  
        K(I,2)=K(IQ,2)  
        Q2=VINT(52) 
        P(I,5)=-SQRT(Q2)    
        PMS(JT)=-Q2 
        SHS=(1.-VINT(43-JT))*Q2/VINT(43-JT)+VINT(5-JT)**2   
      ENDIF 
  130 CONTINUE  
    
C...Kinematics construction for initial partons.    
      I1=MINT(83)+3 
      I2=MINT(83)+4 
      IF(ILEP.EQ.0) SHS=VINT(141)*VINT(142)*VINT(2)+    
     &(P(I1,1)+P(I2,1))**2+(P(I1,2)+P(I2,2))**2 
      SHR=SQRT(MAX(0.,SHS)) 
      IF(ILEP.EQ.0) THEN    
        IF((SHS-PMS(1)-PMS(2))**2-4.*PMS(1)*PMS(2).LE.0.) GOTO 110  
        P(I1,4)=0.5*(SHR+(PMS(1)-PMS(2))/SHR)   
        P(I1,3)=SQRT(MAX(0.,P(I1,4)**2-PMS(1))) 
        P(I2,4)=SHR-P(I1,4) 
        P(I2,3)=-P(I1,3)    
      ELSEIF(ILEP.EQ.1) THEN    
        P(I1,4)=P(IQ,4) 
        P(I1,3)=P(IQ,3) 
        P(I2,4)=P(IP,4) 
        P(I2,3)=P(IP,3) 
      ELSEIF(ILEP.EQ.2) THEN    
        P(I1,4)=P(IP,4) 
        P(I1,3)=P(IP,3) 
        P(I2,4)=P(IQ,4) 
        P(I2,3)=P(IQ,3) 
      ENDIF 
      IF(MINT(43).EQ.1) RETURN  
    
C...Transform partons to overall CM-frame (not for leptoproduction).    
      IF(ILEP.EQ.0) THEN    
        ROBO(3)=(P(I1,1)+P(I2,1))/SHR   
        ROBO(4)=(P(I1,2)+P(I2,2))/SHR   
        CALL LUDBRB(I1,I2,0.,0.,-DBLE(ROBO(3)),-DBLE(ROBO(4)),0D0)  
        ROBO(2)=ULANGL(P(I1,1),P(I1,2)) 
        CALL LUDBRB(I1,I2,0.,-ROBO(2),0D0,0D0,0D0)  
        ROBO(1)=ULANGL(P(I1,3),P(I1,1)) 
        CALL LUDBRB(I1,I2,-ROBO(1),0.,0D0,0D0,0D0)  
        NMAX=MAX(MINT(52),IPU1,IPU2)    
        CALL LUDBRB(I1,NMAX,ROBO(1),ROBO(2),DBLE(ROBO(3)),DBLE(ROBO(4)),    
     &  0D0)    
        ROBO(5)=MAX(-0.999999,MIN(0.999999,(VINT(141)-VINT(142))/   
     &  (VINT(141)+VINT(142)))) 
        CALL LUDBRB(I1,NMAX,0.,0.,0D0,0D0,DBLE(ROBO(5)))    
      ENDIF 
    
C...Check invariant mass of remnant system: 
C...hadronic events or leptoproduction. 
      IF(ILEP.LE.0) THEN    
        IF(MSTP(81).LE.0.OR.MSTP(82).LE.0.OR.ISUB.EQ.95) THEN   
          VINT(151)=0.  
          VINT(152)=0.  
        ENDIF   
        PEH=P(I1,4)+P(I2,4)+0.5*VINT(1)*(VINT(151)+VINT(152))   
        PZH=P(I1,3)+P(I2,3)+0.5*VINT(1)*(VINT(151)-VINT(152))   
        SHH=(VINT(1)-PEH)**2-(P(I1,1)+P(I2,1))**2-(P(I1,2)+P(I2,2))**2- 
     &  PZH**2  
        PMMIN=P(MINT(83)+1,5)+P(MINT(83)+2,5)+ULMASS(K(I1,2))+  
     &  ULMASS(K(I2,2)) 
        IF(SHR.GE.VINT(1).OR.SHH.LE.(PMMIN+PARP(111))**2) THEN  
          MINT(51)=1    
          RETURN    
        ENDIF   
        SHR=SQRT(SHH+(P(I1,1)+P(I2,1))**2+(P(I1,2)+P(I2,2))**2) 
      ELSE  
        PEI=P(IQ,4)+P(IP,4) 
        PZI=P(IQ,3)+P(IP,3) 
        PMS(ILEP)=MAX(0.,PEI**2-PZI**2) 
        PMMIN=P(ILEPR-2,5)+ULMASS(K(ILEPR,2))+SQRT(PMS(ILEP))   
        IF(SHR.LE.PMMIN+PARP(111)) THEN 
          MINT(51)=1    
          RETURN    
        ENDIF   
      ENDIF 
    
C...Subdivide remnant if necessary, store first parton. 
  140 I=NS  
      DO 190 JT=1,2 
      IF(JT.EQ.ILEP) GOTO 190   
      IF(JT.EQ.1) IPU=IPU1  
      IF(JT.EQ.2) IPU=IPU2  
      CALL PYSPLI(MINT(10+JT),MINT(12+JT),KFLCH(JT),KFLSP(JT))  
      I=I+1 
      IS(JT)=I  
      DO 150 J=1,5  
      K(I,J)=0  
      P(I,J)=0. 
  150 V(I,J)=0. 
      K(I,1)=3  
      K(I,2)=KFLSP(JT)  
      K(I,3)=MINT(83)+JT    
      P(I,5)=ULMASS(K(I,2)) 
    
C...First parton colour connections and transverse mass.    
      KFLS=(3-KCHG(LUCOMP(KFLSP(JT)),2)*ISIGN(1,KFLSP(JT)))/2   
      K(I,KFLS+3)=IPU   
      K(IPU,6-KFLS)=MOD(K(IPU,6-KFLS),MSTU(5))+MSTU(5)*I    
      IF(KFLCH(JT).EQ.0) THEN   
        P(I,1)=-P(MINT(83)+JT+2,1)  
        P(I,2)=-P(MINT(83)+JT+2,2)  
        PMS(JT)=P(I,5)**2+P(I,1)**2+P(I,2)**2   
    
C...When extra remnant parton or hadron: find relative pT, store.   
      ELSE  
        CALL LUPTDI(1,P(I,1),P(I,2))    
        PMS(JT+2)=P(I,5)**2+P(I,1)**2+P(I,2)**2 
        I=I+1   
        DO 160 J=1,5    
        K(I,J)=0    
        P(I,J)=0.   
  160   V(I,J)=0.   
        K(I,1)=1    
        K(I,2)=KFLCH(JT)    
        K(I,3)=MINT(83)+JT  
        P(I,5)=ULMASS(K(I,2))   
        P(I,1)=-P(MINT(83)+JT+2,1)-P(I-1,1) 
        P(I,2)=-P(MINT(83)+JT+2,2)-P(I-1,2) 
        PMS(JT+4)=P(I,5)**2+P(I,1)**2+P(I,2)**2 
C...Relative distribution of energy for particle into two jets. 
        IMB=1   
        IF(MOD(MINT(10+JT)/1000,10).NE.0) IMB=2 
        IF(IABS(KFLCH(JT)).LE.10.OR.KFLCH(JT).EQ.21) THEN   
          CHIK=PARP(92+2*IMB)   
          IF(MSTP(92).LE.1) THEN    
            IF(IMB.EQ.1) CHI(JT)=RLU(0) 
            IF(IMB.EQ.2) CHI(JT)=1.-SQRT(RLU(0))    
          ELSEIF(MSTP(92).EQ.2) THEN    
            CHI(JT)=1.-RLU(0)**(1./(1.+CHIK))   
          ELSEIF(MSTP(92).EQ.3) THEN    
            CUT=2.*0.3/VINT(1)  
  170       CHI(JT)=RLU(0)**2   
            IF((CHI(JT)**2/(CHI(JT)**2+CUT**2))**0.25*(1.-CHI(JT))**CHIK    
     &      .LT.RLU(0)) GOTO 170    
          ELSE  
            CUT=2.*0.3/VINT(1)  
            CUTR=(1.+SQRT(1.+CUT**2))/CUT   
  180       CHIR=CUT*CUTR**RLU(0)   
            CHI(JT)=(CHIR**2-CUT**2)/(2.*CHIR)  
            IF((1.-CHI(JT))**CHIK.LT.RLU(0)) GOTO 180   
          ENDIF 
C...Relative distribution of energy for particle into jet plus particle.    
        ELSE    
          IF(MSTP(92).LE.1) THEN    
            IF(IMB.EQ.1) CHI(JT)=RLU(0) 
            IF(IMB.EQ.2) CHI(JT)=1.-SQRT(RLU(0))    
          ELSE  
            CHI(JT)=1.-RLU(0)**(1./(1.+PARP(93+2*IMB))) 
          ENDIF 
          IF(MOD(KFLCH(JT)/1000,10).NE.0) CHI(JT)=1.-CHI(JT)    
        ENDIF   
        PMS(JT)=PMS(JT+4)/CHI(JT)+PMS(JT+2)/(1.-CHI(JT))    
        KFLS=KCHG(LUCOMP(KFLCH(JT)),2)*ISIGN(1,KFLCH(JT))   
        IF(KFLS.NE.0) THEN  
          K(I,1)=3  
          KFLS=(3-KFLS)/2   
          K(I,KFLS+3)=IPU   
          K(IPU,6-KFLS)=MOD(K(IPU,6-KFLS),MSTU(5))+MSTU(5)*I    
        ENDIF   
      ENDIF 
  190 CONTINUE  
      IF(SHR.LE.SQRT(PMS(1))+SQRT(PMS(2))) GOTO 140 
      N=I   
    
C...Reconstruct kinematics of remnants. 
      DO 200 JT=1,2 
      IF(JT.EQ.ILEP) GOTO 200   
      PE=0.5*(SHR+(PMS(JT)-PMS(3-JT))/SHR)  
      PZ=SQRT(PE**2-PMS(JT))    
      IF(KFLCH(JT).EQ.0) THEN   
        P(IS(JT),4)=PE  
        P(IS(JT),3)=PZ*(-1)**(JT-1) 
      ELSE  
        PW1=CHI(JT)*(PE+PZ) 
        P(IS(JT)+1,4)=0.5*(PW1+PMS(JT+4)/PW1)   
        P(IS(JT)+1,3)=0.5*(PW1-PMS(JT+4)/PW1)*(-1)**(JT-1)  
        P(IS(JT),4)=PE-P(IS(JT)+1,4)    
        P(IS(JT),3)=PZ*(-1)**(JT-1)-P(IS(JT)+1,3)   
      ENDIF 
  200 CONTINUE  
    
C...Hadronic events: boost remnants to correct longitudinal frame.  
      IF(ILEP.LE.0) THEN    
        CALL LUDBRB(NS+1,N,0.,0.,0D0,0D0,-DBLE(PZH/(VINT(1)-PEH)))  
C...Leptoproduction events: boost colliding subsystem.  
      ELSE  
        NMAX=MAX(IP,MINT(52))   
        PEF=SHR-PE  
        PZF=PZ*(-1)**(ILEP-1)   
        PT2=P(ILEPR,1)**2+P(ILEPR,2)**2 
        PHIPT=ULANGL(P(ILEPR,1),P(ILEPR,2)) 
        CALL LUDBRB(MINT(84)+1,NMAX,0.,-PHIPT,0D0,0D0,0D0)  
        RQP=P(IQ,3)*(PT2+PEI**2)-P(IQ,4)*PEI*PZI    
        SINTH=P(IQ,4)*SQRT(PT2*(PT2+PEI**2)/(RQP**2+PT2*    
     &  P(IQ,4)**2*PZI**2))*SIGN(1.,-RQP)   
        CALL LUDBRB(MINT(84)+1,NMAX,ASIN(SINTH),0.,0D0,0D0,0D0) 
        BETAX=(-PEI*PZI*SINTH+SQRT(PT2*(PT2+PEI**2-(PZI*SINTH)**2)))/   
     &  (PT2+PEI**2)    
        CALL LUDBRB(MINT(84)+1,NMAX,0.,0.,DBLE(BETAX),0D0,0D0)  
        CALL LUDBRB(MINT(84)+1,NMAX,0.,PHIPT,0D0,0D0,0D0)   
        PEM=P(IQ,4)+P(IP,4) 
        PZM=P(IQ,3)+P(IP,3) 
        BETAZ=(-PEM*PZM+PZF*SQRT(PZF**2+PEM**2-PZM**2))/(PZF**2+PEM**2) 
        CALL LUDBRB(MINT(84)+1,NMAX,0.,0.,0D0,0D0,DBLE(BETAZ))  
        CALL LUDBRB(I1,I2,ASIN(SINTH),0.,DBLE(BETAX),0D0,0D0)   
        CALL LUDBRB(I1,I2,0.,PHIPT,0D0,0D0,DBLE(BETAZ)) 
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYRESD 
    
C...Allows resonances to decay (including parton showers for hadronic   
C...channels).  
      IMPLICIT DOUBLE PRECISION(D)  
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT4/WIDP(21:40,0:40),WIDE(21:40,0:40),WIDS(21:40,3) 
      SAVE /PYINT4/ 
      DIMENSION IREF(10,6),KDCY(2),KFL1(2),KFL2(2),NSD(2),ILIN(6),  
     &COUP(6,4),PK(6,4),PKK(6,6),CTHE(2),PHI(2),WDTP(0:40), 
     &WDTE(0:40,0:5)    
      COMPLEX FGK,HA(6,6),HC(6,6)   
    
C...The F, Xi and Xj functions of Gunion and Kunszt 
C...(Phys. Rev. D33, 665, plus errata from the authors).    
      FGK(I1,I2,I3,I4,I5,I6)=4.*HA(I1,I3)*HC(I2,I6)*(HA(I1,I5)* 
     &HC(I1,I4)+HA(I3,I5)*HC(I3,I4))    
      DIGK(DT,DU)=-4.d0*D34*D56+DT*(3.d0*DT+4.d0*DU)
     &     +DT**2*(DT*DU/(D34*D56)-  
     &2.d0*(1.d0/D34+1.d0/D56)*(DT+DU)+2.d0*(D34/D56+D56/D34))
      DJGK(DT,DU)=8.d0*(D34+D56)**2-8.d0*(D34+D56)*(DT+DU)-6.d0*DT*DU-    
     &2.d0*DT*DU*(DT*DU/(D34*D56)-2.d0*(1.d0/D34+1.d0/D56)*(DT+DU)+ 
     &2.d0*(D34/D56+D56/D34)) 
    
C...Define initial two objects, initialize loop.    
      ISUB=MINT(1)  
      SH=VINT(44)   
      IREF(1,5)=0   
      IREF(1,6)=0   
      IF(ISET(ISUB).EQ.1.OR.ISET(ISUB).EQ.3) THEN   
        IREF(1,1)=MINT(84)+2+ISET(ISUB) 
        IREF(1,2)=0 
        IREF(1,3)=MINT(83)+6+ISET(ISUB) 
        IREF(1,4)=0 
      ELSEIF(ISET(ISUB).EQ.2.OR.ISET(ISUB).EQ.4) THEN   
        IREF(1,1)=MINT(84)+1+ISET(ISUB) 
        IREF(1,2)=MINT(84)+2+ISET(ISUB) 
        IREF(1,3)=MINT(83)+5+ISET(ISUB) 
        IREF(1,4)=MINT(83)+6+ISET(ISUB) 
      ENDIF 
      NP=1  
      IP=0  
  100 IP=IP+1   
      NINH=0    
    
C...Loop over one/two resonances; reset decay rates.    
      JTMAX=2   
      IF(IP.EQ.1.AND.(ISET(ISUB).EQ.1.OR.ISET(ISUB).EQ.3)) JTMAX=1  
      DO 140 JT=1,JTMAX 
      KDCY(JT)=0    
      KFL1(JT)=0    
      KFL2(JT)=0    
      NSD(JT)=IREF(IP,JT)   
      ID=IREF(IP,JT)    
      IF(ID.EQ.0) GOTO 140  
      KFA=IABS(K(ID,2)) 
      IF(KFA.LT.23.OR.KFA.GT.40) GOTO 140   
      IF(MDCY(KFA,1).NE.0) THEN 
        IF(ISUB.EQ.1.OR.ISUB.EQ.141) MINT(61)=1 
        CALL PYWIDT(KFA,P(ID,5),WDTP,WDTE)  
        IF(KCHG(KFA,3).EQ.0) THEN   
          IPM=2 
        ELSE    
          IPM=(5+ISIGN(1,K(ID,2)))/2    
        ENDIF   
        IF(JTMAX.EQ.1.OR.IABS(K(IREF(IP,1),2)).NE.IABS(K(IREF(IP,2),2)))    
     &  THEN    
          I12=4 
        ELSE    
          IF(JT.EQ.1) I12=INT(4.5+RLU(0))   
          I12=9-I12 
        ENDIF   
        RKFL=(WDTE(0,1)+WDTE(0,IPM)+WDTE(0,I12))*RLU(0) 
        DO 120 I=1,MDCY(KFA,3)  
        IDC=I+MDCY(KFA,2)-1 
        KFL1(JT)=KFDP(IDC,1)*ISIGN(1,K(ID,2))   
        KFL2(JT)=KFDP(IDC,2)*ISIGN(1,K(ID,2))   
        RKFL=RKFL-(WDTE(I,1)+WDTE(I,IPM)+WDTE(I,I12))   
        IF(RKFL.LE.0.) GOTO 130 
  120   CONTINUE    
  130   CONTINUE    
      ENDIF 
    
C...Summarize result on decay channel chosen.   
      IF((KFA.EQ.23.OR.KFA.EQ.24).AND.KFL1(JT).EQ.0) NINH=NINH+1    
      IF(KFL1(JT).EQ.0) GOTO 140    
      KDCY(JT)=2    
      IF(IABS(KFL1(JT)).LE.10.OR.KFL1(JT).EQ.21) KDCY(JT)=1 
      IF((IABS(KFL1(JT)).GE.23.AND.IABS(KFL1(JT)).LE.25).OR.    
     &(IABS(KFL1(JT)).EQ.37)) KDCY(JT)=3    
      NSD(JT)=N 
    
C...Fill decay products, prepared for parton showers for quarks.    
clin-8/19/02 avoid actual argument in common blocks of LU2ENT:
      pid5=P(ID,5)
      IF(KDCY(JT).EQ.1) THEN    
c        CALL LU2ENT(-(N+1),KFL1(JT),KFL2(JT),P(ID,5))   
        CALL LU2ENT(-(N+1),KFL1(JT),KFL2(JT),pid5)   
      ELSE  
c        CALL LU2ENT(N+1,KFL1(JT),KFL2(JT),P(ID,5))  
        CALL LU2ENT(N+1,KFL1(JT),KFL2(JT),pid5)  
      ENDIF 

      IF(JTMAX.EQ.1) THEN   
        CTHE(JT)=VINT(13)+(VINT(33)-VINT(13)+VINT(34)-VINT(14))*RLU(0)  
        IF(CTHE(JT).GT.VINT(33)) CTHE(JT)=CTHE(JT)+VINT(14)-VINT(33)    
        PHI(JT)=VINT(24)    
      ELSE  
        CTHE(JT)=2.*RLU(0)-1.   
        PHI(JT)=PARU(2)*RLU(0)  
      ENDIF 
  140 CONTINUE  
      IF(MINT(3).EQ.1.AND.IP.EQ.1) THEN 
        MINT(25)=KFL1(1)    
        MINT(26)=KFL2(1)    
      ENDIF 
      IF(JTMAX.EQ.1.AND.KDCY(1).EQ.0) GOTO 530  
      IF(JTMAX.EQ.2.AND.KDCY(1).EQ.0.AND.KDCY(2).EQ.0) GOTO 530 
      IF(MSTP(45).LE.0.OR.IREF(IP,2).EQ.0.OR.NINH.GE.1) GOTO 500    
      IF(K(IREF(1,1),2).EQ.25.AND.IP.EQ.1) GOTO 500 
      IF(K(IREF(1,1),2).EQ.25.AND.KDCY(1)*KDCY(2).EQ.0) GOTO 500    
    
C...Order incoming partons and outgoing resonances. 
      ILIN(1)=MINT(84)+1    
      IF(K(MINT(84)+1,2).GT.0) ILIN(1)=MINT(84)+2   
      IF(K(ILIN(1),2).EQ.21) ILIN(1)=2*MINT(84)+3-ILIN(1)   
      ILIN(2)=2*MINT(84)+3-ILIN(1)  
      IMIN=1    
      IF(IREF(IP,5).EQ.25) IMIN=3   
      IMAX=2    
      IORD=1    
      IF(K(IREF(IP,1),2).EQ.23) IORD=2  
      IF(K(IREF(IP,1),2).EQ.24.AND.K(IREF(IP,2),2).EQ.-24) IORD=2   
      IF(IABS(K(IREF(IP,IORD),2)).EQ.25) IORD=3-IORD    
      IF(KDCY(IORD).EQ.0) IORD=3-IORD   
    
C...Order decay products of resonances. 
      DO 390 JT=IORD,3-IORD,3-2*IORD    
      IF(KDCY(JT).EQ.0) THEN    
        ILIN(IMAX+1)=NSD(JT)    
        IMAX=IMAX+1 
      ELSEIF(K(NSD(JT)+1,2).GT.0) THEN  
        ILIN(IMAX+1)=N+2*JT-1   
        ILIN(IMAX+2)=N+2*JT 
        IMAX=IMAX+2 
        K(N+2*JT-1,2)=K(NSD(JT)+1,2)    
        K(N+2*JT,2)=K(NSD(JT)+2,2)  
      ELSE  
        ILIN(IMAX+1)=N+2*JT 
        ILIN(IMAX+2)=N+2*JT-1   
        IMAX=IMAX+2 
        K(N+2*JT-1,2)=K(NSD(JT)+1,2)    
        K(N+2*JT,2)=K(NSD(JT)+2,2)  
      ENDIF 
  390 CONTINUE  
    
C...Find charge, isospin, left- and righthanded couplings.  
      XW=PARU(102)  
      DO 410 I=IMIN,IMAX    
      DO 400 J=1,4  
  400 COUP(I,J)=0.  
      KFA=IABS(K(ILIN(I),2))    
      IF(KFA.GT.20) GOTO 410    
      COUP(I,1)=LUCHGE(KFA)/3.  
      COUP(I,2)=(-1)**MOD(KFA,2)    
      COUP(I,4)=-2.*COUP(I,1)*XW    
      COUP(I,3)=COUP(I,2)+COUP(I,4) 
  410 CONTINUE  
      SQMZ=PMAS(23,1)**2    
      GZMZ=PMAS(23,1)*PMAS(23,2)    
      SQMW=PMAS(24,1)**2    
      GZMW=PMAS(24,1)*PMAS(24,2)    
      SQMZP=PMAS(32,1)**2   
      GZMZP=PMAS(32,1)*PMAS(32,2)   
    
C...Select random angles; construct massless four-vectors.  
  420 DO 430 I=N+1,N+4  
      K(I,1)=1  
      DO 430 J=1,5  
  430 P(I,J)=0. 
      DO 440 JT=1,JTMAX 
      IF(KDCY(JT).EQ.0) GOTO 440    
      ID=IREF(IP,JT)    
      P(N+2*JT-1,3)=0.5*P(ID,5) 
      P(N+2*JT-1,4)=0.5*P(ID,5) 
      P(N+2*JT,3)=-0.5*P(ID,5)  
      P(N+2*JT,4)=0.5*P(ID,5)   
      CTHE(JT)=2.*RLU(0)-1. 
      PHI(JT)=PARU(2)*RLU(0)    
      CALL LUDBRB(N+2*JT-1,N+2*JT,ACOS(CTHE(JT)),PHI(JT),   
     &DBLE(P(ID,1)/P(ID,4)),DBLE(P(ID,2)/P(ID,4)),DBLE(P(ID,3)/P(ID,4)))    
  440 CONTINUE  
    
C...Store incoming and outgoing momenta, with random rotation to    
C...avoid accidental zeroes in HA expressions.  
      DO 450 I=1,IMAX   
      K(N+4+I,1)=1  
      P(N+4+I,4)=SQRT(P(ILIN(I),1)**2+P(ILIN(I),2)**2+P(ILIN(I),3)**2+  
     &P(ILIN(I),5)**2)  
      P(N+4+I,5)=P(ILIN(I),5)   
      DO 450 J=1,3  
  450 P(N+4+I,J)=P(ILIN(I),J)   
      THERR=ACOS(2.*RLU(0)-1.)  
      PHIRR=PARU(2)*RLU(0)  
      CALL LUDBRB(N+5,N+4+IMAX,THERR,PHIRR,0D0,0D0,0D0) 
      DO 460 I=1,IMAX   
      DO 460 J=1,4  
  460 PK(I,J)=P(N+4+I,J)    
    
C...Calculate internal products.    
      IF(ISUB.EQ.22.OR.ISUB.EQ.23.OR.ISUB.EQ.25) THEN   
        DO 470 I1=IMIN,IMAX-1   
        DO 470 I2=I1+1,IMAX 
        HA(I1,I2)=SQRT((PK(I1,4)-PK(I1,3))*(PK(I2,4)+PK(I2,3))/ 
     &  (1E-20+PK(I1,1)**2+PK(I1,2)**2))*CMPLX(PK(I1,1),PK(I1,2))-  
     &  SQRT((PK(I1,4)+PK(I1,3))*(PK(I2,4)-PK(I2,3))/   
     &  (1E-20+PK(I2,1)**2+PK(I2,2)**2))*CMPLX(PK(I2,1),PK(I2,2))   
        HC(I1,I2)=CONJG(HA(I1,I2))  
        IF(I1.LE.2) HA(I1,I2)=CMPLX(0.,1.)*HA(I1,I2)    
        IF(I1.LE.2) HC(I1,I2)=CMPLX(0.,1.)*HC(I1,I2)    
        HA(I2,I1)=-HA(I1,I2)    
  470   HC(I2,I1)=-HC(I1,I2)    
      ENDIF 
      DO 480 I=1,2  
      DO 480 J=1,4  
  480 PK(I,J)=-PK(I,J)  
      DO 490 I1=IMIN,IMAX-1 
      DO 490 I2=I1+1,IMAX   
      PKK(I1,I2)=2.*(PK(I1,4)*PK(I2,4)-PK(I1,1)*PK(I2,1)-   
     &PK(I1,2)*PK(I2,2)-PK(I1,3)*PK(I2,3))  
  490 PKK(I2,I1)=PKK(I1,I2) 
    
      IF(IREF(IP,5).EQ.25) THEN 
C...Angular weight for H0 -> Z0 + Z0 or W+ + W- -> 4 quarks/leptons 
        WT=16.*PKK(3,5)*PKK(4,6)    
        IF(IP.EQ.1) WTMAX=SH**2 
        IF(IP.GE.2) WTMAX=P(IREF(IP,6),5)**4    
    
      ELSEIF(ISUB.EQ.1) THEN    
        IF(KFA.NE.37) THEN  
C...Angular weight for gamma*/Z0 -> 2 quarks/leptons    
          EI=KCHG(IABS(MINT(15)),1)/3.  
          AI=SIGN(1.,EI+0.1)    
          VI=AI-4.*EI*XW    
          EF=KCHG(KFA,1)/3. 
          AF=SIGN(1.,EF+0.1)    
          VF=AF-4.*EF*XW    
          GG=1. 
          GZ=1./(8.*XW*(1.-XW))*SH*(SH-SQMZ)/((SH-SQMZ)**2+GZMZ**2) 
          ZZ=1./(16.*XW*(1.-XW))**2*SH**2/((SH-SQMZ)**2+GZMZ**2)    
          IF(MSTP(43).EQ.1) THEN    
C...Only gamma* production included 
            GZ=0.   
            ZZ=0.   
          ELSEIF(MSTP(43).EQ.2) THEN    
C...Only Z0 production included 
            GG=0.   
            GZ=0.   
          ENDIF 
          ASYM=2.*(EI*AI*GZ*EF*AF+4.*VI*AI*ZZ*VF*AF)/(EI**2*GG*EF**2+   
     &    EI*VI*GZ*EF*VF+(VI**2+AI**2)*ZZ*(VF**2+AF**2))    
          WT=1.+ASYM*CTHE(JT)+CTHE(JT)**2   
          WTMAX=2.+ABS(ASYM)    
        ELSE    
C...Angular weight for gamma*/Z0 -> H+ + H- 
          WT=1.-CTHE(JT)**2 
          WTMAX=1.  
        ENDIF   
    
      ELSEIF(ISUB.EQ.2) THEN    
C...Angular weight for W+/- -> 2 quarks/leptons 
        WT=(1.+CTHE(JT))**2 
        WTMAX=4.    
    
      ELSEIF(ISUB.EQ.15.OR.ISUB.EQ.19) THEN 
C...Angular weight for f + fb -> gluon/gamma + Z0 ->    
C...-> gluon/gamma + 2 quarks/leptons   
        WT=((COUP(1,3)*COUP(3,3))**2+(COUP(1,4)*COUP(3,4))**2)* 
     &  (PKK(1,3)**2+PKK(2,4)**2)+((COUP(1,3)*COUP(3,4))**2+    
     &  (COUP(1,4)*COUP(3,3))**2)*(PKK(1,4)**2+PKK(2,3)**2) 
        WTMAX=(COUP(1,3)**2+COUP(1,4)**2)*(COUP(3,3)**2+COUP(3,4)**2)*  
     &  ((PKK(1,3)+PKK(1,4))**2+(PKK(2,3)+PKK(2,4))**2) 
    
      ELSEIF(ISUB.EQ.16.OR.ISUB.EQ.20) THEN 
C...Angular weight for f + fb' -> gluon/gamma + W+/- -> 
C...-> gluon/gamma + 2 quarks/leptons   
        WT=PKK(1,3)**2+PKK(2,4)**2  
        WTMAX=(PKK(1,3)+PKK(1,4))**2+(PKK(2,3)+PKK(2,4))**2 
    
      ELSEIF(ISUB.EQ.22) THEN   
C...Angular weight for f + fb -> Z0 + Z0 -> 4 quarks/leptons    
        S34=P(IREF(IP,IORD),5)**2   
        S56=P(IREF(IP,3-IORD),5)**2 
        TI=PKK(1,3)+PKK(1,4)+S34    
        UI=PKK(1,5)+PKK(1,6)+S56    
        WT=COUP(1,3)**4*((COUP(3,3)*COUP(5,3)*ABS(FGK(1,2,3,4,5,6)/ 
     &  TI+FGK(1,2,5,6,3,4)/UI))**2+(COUP(3,4)*COUP(5,3)*ABS(   
     &  FGK(1,2,4,3,5,6)/TI+FGK(1,2,5,6,4,3)/UI))**2+(COUP(3,3)*    
     &  COUP(5,4)*ABS(FGK(1,2,3,4,6,5)/TI+FGK(1,2,6,5,3,4)/UI))**2+ 
     &  (COUP(3,4)*COUP(5,4)*ABS(FGK(1,2,4,3,6,5)/TI+FGK(1,2,6,5,4,3)/  
     &  UI))**2)+COUP(1,4)**4*((COUP(3,3)*COUP(5,3)*ABS(    
     &  FGK(2,1,5,6,3,4)/TI+FGK(2,1,3,4,5,6)/UI))**2+(COUP(3,4)*    
     &  COUP(5,3)*ABS(FGK(2,1,6,5,3,4)/TI+FGK(2,1,3,4,6,5)/UI))**2+ 
     &  (COUP(3,3)*COUP(5,4)*ABS(FGK(2,1,5,6,4,3)/TI+FGK(2,1,4,3,5,6)/  
     &  UI))**2+(COUP(3,4)*COUP(5,4)*ABS(FGK(2,1,6,5,4,3)/TI+   
     &  FGK(2,1,4,3,6,5)/UI))**2)   
        WTMAX=4.*S34*S56*(COUP(1,3)**4+COUP(1,4)**4)*(COUP(3,3)**2+ 
     &  COUP(3,4)**2)*(COUP(5,3)**2+COUP(5,4)**2)*4.*(TI/UI+UI/TI+  
     &  2.*SH*(S34+S56)/(TI*UI)-S34*S56*(1./TI**2+1./UI**2))    
    
      ELSEIF(ISUB.EQ.23) THEN   
C...Angular weight for f + fb' -> Z0 + W +/- -> 4 quarks/leptons    
        D34=dble(P(IREF(IP,IORD),5)**2)
        D56=dble(P(IREF(IP,3-IORD),5)**2)
        DT=dble(PKK(1,3)+PKK(1,4))+D34    
        DU=dble(PKK(1,5)+PKK(1,6))+D56    
        CAWZ=COUP(2,3)/SNGL(DT)-2.*(1.-XW)*COUP(1,2)/(SH-SQMW)  
        CBWZ=COUP(1,3)/SNGL(DU)+2.*(1.-XW)*COUP(1,2)/(SH-SQMW)  
        WT=COUP(5,3)**2*ABS(CAWZ*FGK(1,2,3,4,5,6)+CBWZ* 
     &  FGK(1,2,5,6,3,4))**2+COUP(5,4)**2*ABS(CAWZ* 
     &  FGK(1,2,3,4,6,5)+CBWZ*FGK(1,2,6,5,3,4))**2  
        WTMAX=4.*sngl(D34*D56)*(COUP(5,3)**2+COUP(5,4)**2)*(CAWZ**2*  
     &       sngl(DIGK(DT,DU))+CBWZ**2*sngl(DIGK(DU,DT))
     &       +CAWZ*CBWZ*sngl(DJGK(DT,DU)))  
    
      ELSEIF(ISUB.EQ.24) THEN   
C...Angular weight for f + fb -> Z0 + H0 -> 2 quarks/leptons + H0   
        WT=((COUP(1,3)*COUP(3,3))**2+(COUP(1,4)*COUP(3,4))**2)* 
     &  PKK(1,3)*PKK(2,4)+((COUP(1,3)*COUP(3,4))**2+(COUP(1,4)* 
     &  COUP(3,3))**2)*PKK(1,4)*PKK(2,3)    
        WTMAX=(COUP(1,3)**2+COUP(1,4)**2)*(COUP(3,3)**2+COUP(3,4)**2)*  
     &  (PKK(1,3)+PKK(1,4))*(PKK(2,3)+PKK(2,4)) 
    
      ELSEIF(ISUB.EQ.25) THEN   
C...Angular weight for f + fb -> W+ + W- -> 4 quarks/leptons    
        D34=dble(P(IREF(IP,IORD),5)**2)
        D56=dble(P(IREF(IP,3-IORD),5)**2)
        DT=dble(PKK(1,3)+PKK(1,4))+D34    
        DU=dble(PKK(1,5)+PKK(1,6))+D56    
        CDWW=(COUP(1,3)*SQMZ/(SH-SQMZ)+COUP(1,2))/SH    
        CAWW=CDWW+0.5*(COUP(1,2)+1.)/SNGL(DT)   
        CBWW=CDWW+0.5*(COUP(1,2)-1.)/SNGL(DU)   
        CCWW=COUP(1,4)*SQMZ/(SH-SQMZ)/SH    
        WT=ABS(CAWW*FGK(1,2,3,4,5,6)-CBWW*FGK(1,2,5,6,3,4))**2+ 
     &  CCWW**2*ABS(FGK(2,1,5,6,3,4)-FGK(2,1,3,4,5,6))**2   
        WTMAX=4.*sngl(D34*D56)*(CAWW**2*sngl(DIGK(DT,DU))
     &       +CBWW**2*sngl(DIGK(DU,DT))-CAWW*CBWW*sngl(DJGK(DT,DU))
     &       +CCWW**2*sngl(DIGK(DT,DU)+DIGK(DU,DT)-DJGK(DT,DU)))
    
      ELSEIF(ISUB.EQ.26) THEN   
C...Angular weight for f + fb' -> W+/- + H0 -> 2 quarks/leptons + H0    
        WT=PKK(1,3)*PKK(2,4)    
        WTMAX=(PKK(1,3)+PKK(1,4))*(PKK(2,3)+PKK(2,4))   
    
      ELSEIF(ISUB.EQ.30) THEN   
C...Angular weight for f + g -> f + Z0 -> f + 2 quarks/leptons  
        IF(K(ILIN(1),2).GT.0) WT=((COUP(1,3)*COUP(3,3))**2+ 
     &  (COUP(1,4)*COUP(3,4))**2)*(PKK(1,4)**2+PKK(3,5)**2)+    
     &  ((COUP(1,3)*COUP(3,4))**2+(COUP(1,4)*COUP(3,3))**2)*    
     &  (PKK(1,3)**2+PKK(4,5)**2)   
        IF(K(ILIN(1),2).LT.0) WT=((COUP(1,3)*COUP(3,3))**2+ 
     &  (COUP(1,4)*COUP(3,4))**2)*(PKK(1,3)**2+PKK(4,5)**2)+    
     &  ((COUP(1,3)*COUP(3,4))**2+(COUP(1,4)*COUP(3,3))**2)*    
     &  (PKK(1,4)**2+PKK(3,5)**2)   
        WTMAX=(COUP(1,3)**2+COUP(1,4)**2)*(COUP(3,3)**2+COUP(3,4)**2)*  
     &  ((PKK(1,3)+PKK(1,4))**2+(PKK(3,5)+PKK(4,5))**2) 
    
      ELSEIF(ISUB.EQ.31) THEN   
C...Angular weight for f + g -> f' + W+/- -> f' + 2 quarks/leptons  
        IF(K(ILIN(1),2).GT.0) WT=PKK(1,4)**2+PKK(3,5)**2    
        IF(K(ILIN(1),2).LT.0) WT=PKK(1,3)**2+PKK(4,5)**2    
        WTMAX=(PKK(1,3)+PKK(1,4))**2+(PKK(3,5)+PKK(4,5))**2 
    
      ELSEIF(ISUB.EQ.141) THEN  
C...Angular weight for gamma*/Z0/Z'0 -> 2 quarks/leptons    
        EI=KCHG(IABS(MINT(15)),1)/3.    
        AI=SIGN(1.,EI+0.1)  
        VI=AI-4.*EI*XW  
        API=SIGN(1.,EI+0.1) 
        VPI=API-4.*EI*XW    
        EF=KCHG(KFA,1)/3.   
        AF=SIGN(1.,EF+0.1)  
        VF=AF-4.*EF*XW  
        APF=SIGN(1.,EF+0.1) 
        VPF=APF-4.*EF*XW    
        GG=1.   
        GZ=1./(8.*XW*(1.-XW))*SH*(SH-SQMZ)/((SH-SQMZ)**2+GZMZ**2)   
        GZP=1./(8.*XW*(1.-XW))*SH*(SH-SQMZP)/((SH-SQMZP)**2+GZMZP**2)   
        ZZ=1./(16.*XW*(1.-XW))**2*SH**2/((SH-SQMZ)**2+GZMZ**2)  
        ZZP=2./(16.*XW*(1.-XW))**2* 
     &  SH**2*((SH-SQMZ)*(SH-SQMZP)+GZMZ*GZMZP)/    
     &  (((SH-SQMZ)**2+GZMZ**2)*((SH-SQMZP)**2+GZMZP**2))   
        ZPZP=1./(16.*XW*(1.-XW))**2*SH**2/((SH-SQMZP)**2+GZMZP**2)  
        IF(MSTP(44).EQ.1) THEN  
C...Only gamma* production included 
          GZ=0. 
          GZP=0.    
          ZZ=0. 
          ZZP=0.    
          ZPZP=0.   
        ELSEIF(MSTP(44).EQ.2) THEN  
C...Only Z0 production included 
          GG=0. 
          GZ=0. 
          GZP=0.    
          ZZP=0.    
          ZPZP=0.   
        ELSEIF(MSTP(44).EQ.3) THEN  
C...Only Z'0 production included    
          GG=0. 
          GZ=0. 
          GZP=0.    
          ZZ=0. 
          ZZP=0.    
        ELSEIF(MSTP(44).EQ.4) THEN  
C...Only gamma*/Z0 production included  
          GZP=0.    
          ZZP=0.    
          ZPZP=0.   
        ELSEIF(MSTP(44).EQ.5) THEN  
C...Only gamma*/Z'0 production included 
          GZ=0. 
          ZZ=0. 
          ZZP=0.    
        ELSEIF(MSTP(44).EQ.6) THEN  
C...Only Z0/Z'0 production included 
          GG=0. 
          GZ=0. 
          GZP=0.    
        ENDIF   
        ASYM=2.*(EI*AI*GZ*EF*AF+EI*API*GZP*EF*APF+4.*VI*AI*ZZ*VF*AF+    
     &  (VI*API+VPI*AI)*ZZP*(VF*APF+VPF*AF)+4.*VPI*API*ZPZP*VPF*APF)/   
     &  (EI**2*GG*EF**2+EI*VI*GZ*EF*VF+EI*VPI*GZP*EF*VPF+   
     &  (VI**2+AI**2)*ZZ*(VF**2+AF**2)+(VI*VPI+AI*API)*ZZP* 
     &  (VF*VPF+AF*APF)+(VPI**2+API**2)*ZPZP*(VPF**2+APF**2))   
        WT=1.+ASYM*CTHE(JT)+CTHE(JT)**2 
        WTMAX=2.+ABS(ASYM)  
    
      ELSE  
        WT=1.   
        WTMAX=1.    
      ENDIF 
C...Obtain correct angular distribution by rejection techniques.    
      IF(WT.LT.RLU(0)*WTMAX) GOTO 420   
    
C...Construct massive four-vectors using angles chosen. Mark decayed    
C...resonances, add documentation lines. Shower evolution.  
  500 DO 520 JT=1,JTMAX 
      IF(KDCY(JT).EQ.0) GOTO 520    
      ID=IREF(IP,JT)    
      CALL LUDBRB(NSD(JT)+1,NSD(JT)+2,ACOS(CTHE(JT)),PHI(JT),   
     &DBLE(P(ID,1)/P(ID,4)),DBLE(P(ID,2)/P(ID,4)),DBLE(P(ID,3)/P(ID,4)))    
      K(ID,1)=K(ID,1)+10    
      K(ID,4)=NSD(JT)+1 
      K(ID,5)=NSD(JT)+2 
      IDOC=MINT(83)+MINT(4) 
      DO 510 I=NSD(JT)+1,NSD(JT)+2  
      MINT(4)=MINT(4)+1 
      I1=MINT(83)+MINT(4)   
      K(I,3)=I1 
      K(I1,1)=21    
      K(I1,2)=K(I,2)    
      K(I1,3)=IREF(IP,JT+2) 
      DO 510 J=1,5  
  510 P(I1,J)=P(I,J)    
      IF(JTMAX.EQ.1) THEN   
        MINT(7)=MINT(83)+6+2*ISET(ISUB) 
        MINT(8)=MINT(83)+7+2*ISET(ISUB) 
      ENDIF 
clin-8/19/02 avoid actual argument in common blocks of LUSHOW:
c      IF(MSTP(71).GE.1.AND.KDCY(JT).EQ.1) CALL LUSHOW(NSD(JT)+1,    
c     &NSD(JT)+2,P(ID,5))    
      pid5=P(ID,5)
      IF(MSTP(71).GE.1.AND.KDCY(JT).EQ.1) CALL LUSHOW(NSD(JT)+1,    
     &NSD(JT)+2,pid5)    
    
C...Check if new resonances were produced, loop back if needed. 
      IF(KDCY(JT).NE.3) GOTO 520    
      NP=NP+1   
      IREF(NP,1)=NSD(JT)+1  
      IREF(NP,2)=NSD(JT)+2  
      IREF(NP,3)=IDOC+1 
      IREF(NP,4)=IDOC+2 
      IREF(NP,5)=K(IREF(IP,JT),2)   
      IREF(NP,6)=IREF(IP,JT)    
  520 CONTINUE  
  530 IF(IP.LT.NP) GOTO 100 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYDIFF 
    
C...Handles diffractive and elastic scattering. 
      COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
      SAVE /LUJETS/ 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
    
C...Reset K, P and V vectors. Store incoming particles. 
      DO 100 JT=1,MSTP(126)+10  
      I=MINT(83)+JT 
      DO 100 J=1,5  
      K(I,J)=0  
      P(I,J)=0. 
  100 V(I,J)=0. 
      N=MINT(84)    
      MINT(3)=0 
      MINT(21)=0    
      MINT(22)=0    
      MINT(23)=0    
      MINT(24)=0    
      MINT(4)=4 
      DO 110 JT=1,2 
      I=MINT(83)+JT 
      K(I,1)=21 
      K(I,2)=MINT(10+JT)    
      P(I,5)=VINT(2+JT) 
      P(I,3)=VINT(5)*(-1)**(JT+1)   
  110 P(I,4)=SQRT(P(I,3)**2+P(I,5)**2)  
      MINT(6)=2 
    
C...Subprocess; kinematics. 
      ISUB=MINT(1)  
      SQLAM=(VINT(2)-VINT(63)-VINT(64))**2-4.*VINT(63)*VINT(64) 
      PZ=SQRT(SQLAM)/(2.*VINT(1))   
      DO 150 JT=1,2 
      I=MINT(83)+JT 
      PE=(VINT(2)+VINT(62+JT)-VINT(65-JT))/(2.*VINT(1)) 
    
C...Elastically scattered particle. 
      IF(MINT(16+JT).LE.0) THEN 
        N=N+1   
        K(N,1)=1    
        K(N,2)=K(I,2)   
        K(N,3)=I+2  
        P(N,3)=PZ*(-1)**(JT+1)  
        P(N,4)=PE   
        P(N,5)=P(I,5)   
    
C...Diffracted particle: valence quark kicked out.  
      ELSEIF(MSTP(101).EQ.1) THEN   
        N=N+2   
        K(N-1,1)=2  
        K(N,1)=1    
        K(N-1,3)=I+2    
        K(N,3)=I+2  
        CALL PYSPLI(K(I,2),21,K(N,2),K(N-1,2))  
        P(N-1,5)=ULMASS(K(N-1,2))   
        P(N,5)=ULMASS(K(N,2))   
        SQLAM=(VINT(62+JT)-P(N-1,5)**2-P(N,5)**2)**2-   
     &  4.*P(N-1,5)**2*P(N,5)**2    
        P(N-1,3)=(PE*SQRT(SQLAM)+PZ*(VINT(62+JT)+P(N-1,5)**2-   
     &  P(N,5)**2))/(2.*VINT(62+JT))*(-1)**(JT+1)   
        P(N-1,4)=SQRT(P(N-1,3)**2+P(N-1,5)**2)  
        P(N,3)=PZ*(-1)**(JT+1)-P(N-1,3) 
        P(N,4)=SQRT(P(N,3)**2+P(N,5)**2)    
    
C...Diffracted particle: gluon kicked out.  
      ELSE  
        N=N+3   
        K(N-2,1)=2  
        K(N-1,1)=2  
        K(N,1)=1    
        K(N-2,3)=I+2    
        K(N-1,3)=I+2    
        K(N,3)=I+2  
        CALL PYSPLI(K(I,2),21,K(N,2),K(N-2,2))  
        K(N-1,2)=21 
        P(N-2,5)=ULMASS(K(N-2,2))   
        P(N-1,5)=0. 
        P(N,5)=ULMASS(K(N,2))   
C...Energy distribution for particle into two jets. 
  120   IMB=1   
        IF(MOD(K(I,2)/1000,10).NE.0) IMB=2  
        CHIK=PARP(92+2*IMB) 
        IF(MSTP(92).LE.1) THEN  
          IF(IMB.EQ.1) CHI=RLU(0)   
          IF(IMB.EQ.2) CHI=1.-SQRT(RLU(0))  
        ELSEIF(MSTP(92).EQ.2) THEN  
          CHI=1.-RLU(0)**(1./(1.+CHIK)) 
        ELSEIF(MSTP(92).EQ.3) THEN  
          CUT=2.*0.3/VINT(1)    
  130     CHI=RLU(0)**2 
          IF((CHI**2/(CHI**2+CUT**2))**0.25*(1.-CHI)**CHIK.LT.  
     &    RLU(0)) GOTO 130  
        ELSE    
          CUT=2.*0.3/VINT(1)    
          CUTR=(1.+SQRT(1.+CUT**2))/CUT 
  140     CHIR=CUT*CUTR**RLU(0) 
          CHI=(CHIR**2-CUT**2)/(2.*CHIR)    
          IF((1.-CHI)**CHIK.LT.RLU(0)) GOTO 140 
        ENDIF   
        IF(CHI.LT.P(N,5)**2/VINT(62+JT).OR.CHI.GT.1.-P(N-2,5)**2/   
     &  VINT(62+JT)) GOTO 120   
        SQM=P(N-2,5)**2/(1.-CHI)+P(N,5)**2/CHI  
        IF((SQRT(SQM)+PARJ(32))**2.GE.VINT(62+JT)) GOTO 120 
        PZI=(PE*(VINT(62+JT)-SQM)+PZ*(VINT(62+JT)+SQM))/    
     &  (2.*VINT(62+JT))    
        PEI=SQRT(PZI**2+SQM)    
        PQQP=(1.-CHI)*(PEI+PZI) 
        P(N-2,3)=0.5*(PQQP-P(N-2,5)**2/PQQP)*(-1)**(JT+1)   
        P(N-2,4)=SQRT(P(N-2,3)**2+P(N-2,5)**2)  
        P(N-1,3)=(PZ-PZI)*(-1)**(JT+1)  
        P(N-1,4)=ABS(P(N-1,3))  
        P(N,3)=PZI*(-1)**(JT+1)-P(N-2,3)    
        P(N,4)=SQRT(P(N,3)**2+P(N,5)**2)    
      ENDIF 
    
C...Documentation lines.    
      K(I+2,1)=21   
      IF(MINT(16+JT).EQ.0) K(I+2,2)=MINT(10+JT) 
      IF(MINT(16+JT).NE.0) K(I+2,2)=10*(MINT(10+JT)/10) 
      K(I+2,3)=I    
      P(I+2,3)=PZ*(-1)**(JT+1)  
      P(I+2,4)=PE   
      P(I+2,5)=SQRT(VINT(62+JT))    
  150 CONTINUE  
    
C...Rotate outgoing partons/particles using cos(theta). 
      CALL LUDBRB(MINT(83)+3,N,ACOS(VINT(23)),VINT(24),0D0,0D0,0D0) 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYFRAM(IFRAME) 
    
C...Performs transformations between different coordinate frames.   
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
    
      IF(IFRAME.LT.1.OR.IFRAME.GT.2) THEN   
        WRITE(MSTU(11),1000) IFRAME,MINT(6) 
        RETURN  
      ENDIF 
      IF(IFRAME.EQ.MINT(6)) RETURN  
    
      IF(MINT(6).EQ.1) THEN 
C...Transform from fixed target or user specified frame to  
C...CM-frame of incoming particles. 
        CALL LUROBO(0.,0.,-VINT(8),-VINT(9),-VINT(10))  
        CALL LUROBO(0.,-VINT(7),0.,0.,0.)   
        CALL LUROBO(-VINT(6),0.,0.,0.,0.)   
        MINT(6)=2   
    
      ELSE  
C...Transform from particle CM-frame to fixed target or user specified  
C...frame.  
        CALL LUROBO(VINT(6),VINT(7),VINT(8),VINT(9),VINT(10))   
        MINT(6)=1   
      ENDIF 
      MSTI(6)=MINT(6)   
    
 1000 FORMAT(1X,'Error: illegal values in subroutine PYFRAM.',1X,   
     &'No transformation performed.'/1X,'IFRAME =',1X,I5,'; MINT(6) =', 
     &1X,I5)    
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYWIDT(KFLR,RMAS,WDTP,WDTE)    
    
C...Calculates full and partial widths of resonances.   
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT4/WIDP(21:40,0:40),WIDE(21:40,0:40),WIDS(21:40,3) 
      SAVE /PYINT4/ 
      DIMENSION WDTP(0:40),WDTE(0:40,0:5)   
    
C...Some common constants.  
      KFLA=IABS(KFLR)   
      SQM=RMAS**2   
      AS=ULALPS(SQM)    
      AEM=PARU(101) 
      XW=PARU(102)  
      RADC=1.+AS/PARU(1)    
    
C...Reset width information.    
      DO 100 I=0,40 
      WDTP(I)=0.    
      DO 100 J=0,5  
  100 WDTE(I,J)=0.  
    
      IF(KFLA.EQ.21) THEN   
C...QCD:    
        DO 110 I=1,MDCY(21,3)   
        IDC=I+MDCY(21,2)-1  
        RM1=(PMAS(IABS(KFDP(IDC,1)),1)/RMAS)**2 
        RM2=(PMAS(IABS(KFDP(IDC,2)),1)/RMAS)**2 
        IF(SQRT(RM1)+SQRT(RM2).GT.1..OR.MDME(IDC,1).LT.0) GOTO 110  
        IF(I.LE.8) THEN 
C...QCD -> q + qb   
          WDTP(I)=(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1))   
          WID2=1.   
        ENDIF   
        WDTP(0)=WDTP(0)+WDTP(I) 
        IF(MDME(IDC,1).GT.0) THEN   
          WDTE(I,MDME(IDC,1))=WDTP(I)*WID2  
          WDTE(0,MDME(IDC,1))=WDTE(0,MDME(IDC,1))+WDTE(I,MDME(IDC,1))   
          WDTE(I,0)=WDTE(I,MDME(IDC,1)) 
          WDTE(0,0)=WDTE(0,0)+WDTE(I,0) 
        ENDIF   
  110   CONTINUE    
    
      ELSEIF(KFLA.EQ.23) THEN   
C...Z0: 
        IF(MINT(61).EQ.1) THEN  
          EI=KCHG(IABS(MINT(15)),1)/3.  
          AI=SIGN(1.,EI)    
          VI=AI-4.*EI*XW    
          SQMZ=PMAS(23,1)**2    
          GZMZ=PMAS(23,2)*PMAS(23,1)    
          GGI=EI**2 
          GZI=EI*VI/(8.*XW*(1.-XW))*SQM*(SQM-SQMZ)/ 
     &    ((SQM-SQMZ)**2+GZMZ**2)   
          ZZI=(VI**2+AI**2)/(16.*XW*(1.-XW))**2*SQM**2/ 
     &    ((SQM-SQMZ)**2+GZMZ**2)   
          IF(MSTP(43).EQ.1) THEN    
C...Only gamma* production included 
            GZI=0.  
            ZZI=0.  
          ELSEIF(MSTP(43).EQ.2) THEN    
C...Only Z0 production included 
            GGI=0.  
            GZI=0.  
          ENDIF 
        ELSEIF(MINT(61).EQ.2) THEN  
          VINT(111)=0.  
          VINT(112)=0.  
          VINT(114)=0.  
        ENDIF   
        DO 120 I=1,MDCY(23,3)   
        IDC=I+MDCY(23,2)-1  
        RM1=(PMAS(IABS(KFDP(IDC,1)),1)/RMAS)**2 
        RM2=(PMAS(IABS(KFDP(IDC,2)),1)/RMAS)**2 
        IF(SQRT(RM1)+SQRT(RM2).GT.1..OR.MDME(IDC,1).LT.0) GOTO 120  
        IF(I.LE.8) THEN 
C...Z0 -> q + qb    
          EF=KCHG(I,1)/3.   
          AF=SIGN(1.,EF+0.1)    
          VF=AF-4.*EF*XW    
          IF(MINT(61).EQ.0) THEN    
            WDTP(I)=3.*(VF**2*(1.+2.*RM1)+AF**2*(1.-4.*RM1))*   
     &      SQRT(MAX(0.,1.-4.*RM1))*RADC    
          ELSEIF(MINT(61).EQ.1) THEN    
            WDTP(I)=3.*((GGI*EF**2+GZI*EF*VF+ZZI*VF**2)*    
     &      (1.+2.*RM1)+ZZI*AF**2*(1.-4.*RM1))* 
     &      SQRT(MAX(0.,1.-4.*RM1))*RADC    
          ELSEIF(MINT(61).EQ.2) THEN    
            GGF=3.*EF**2*(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1))*RADC   
            GZF=3.*EF*VF*(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1))*RADC   
            ZZF=3.*(VF**2*(1.+2.*RM1)+AF**2*(1.-4.*RM1))*   
     &      SQRT(MAX(0.,1.-4.*RM1))*RADC    
          ENDIF 
          WID2=1.   
        ELSEIF(I.LE.16) THEN    
C...Z0 -> l+ + l-, nu + nub 
          EF=KCHG(I+2,1)/3. 
          AF=SIGN(1.,EF+0.1)    
          VF=AF-4.*EF*XW    
          WDTP(I)=(VF**2*(1.+2.*RM1)+AF**2*(1.-4.*RM1))*    
     &    SQRT(MAX(0.,1.-4.*RM1))   
          IF(MINT(61).EQ.0) THEN    
            WDTP(I)=(VF**2*(1.+2.*RM1)+AF**2*(1.-4.*RM1))*  
     &      SQRT(MAX(0.,1.-4.*RM1)) 
          ELSEIF(MINT(61).EQ.1) THEN    
            WDTP(I)=((GGI*EF**2+GZI*EF*VF+ZZI*VF**2)*   
     &      (1.+2.*RM1)+ZZI*AF**2*(1.-4.*RM1))* 
     &      SQRT(MAX(0.,1.-4.*RM1)) 
          ELSEIF(MINT(61).EQ.2) THEN    
            GGF=EF**2*(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1))   
            GZF=EF*VF*(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1))   
            ZZF=(VF**2*(1.+2.*RM1)+AF**2*(1.-4.*RM1))*  
     &      SQRT(MAX(0.,1.-4.*RM1)) 
          ENDIF 
          WID2=1.   
        ELSE    
C...Z0 -> H+ + H-   
          CF=2.*(1.-2.*XW)  
          IF(MINT(61).EQ.0) THEN    
            WDTP(I)=0.25*CF**2*(1.-4.*RM1)*SQRT(MAX(0.,1.-4.*RM1))  
          ELSEIF(MINT(61).EQ.1) THEN    
            WDTP(I)=0.25*(GGI+GZI*CF+ZZI*CF**2)*(1.-4.*RM1)*    
     &      SQRT(MAX(0.,1.-4.*RM1)) 
          ELSEIF(MINT(61).EQ.2) THEN    
            GGF=0.25*(1.-4.*RM1)*SQRT(MAX(0.,1.-4.*RM1))    
            GZF=0.25*CF*(1.-4.*RM1)*SQRT(MAX(0.,1.-4.*RM1)) 
            ZZF=0.25*CF**2*(1.-4.*RM1)*SQRT(MAX(0.,1.-4.*RM1))  
          ENDIF 
          WID2=WIDS(37,1)   
        ENDIF   
        WDTP(0)=WDTP(0)+WDTP(I) 
        IF(MDME(IDC,1).GT.0) THEN   
          WDTE(I,MDME(IDC,1))=WDTP(I)*WID2  
          WDTE(0,MDME(IDC,1))=WDTE(0,MDME(IDC,1))+WDTE(I,MDME(IDC,1))   
          WDTE(I,0)=WDTE(I,MDME(IDC,1)) 
          WDTE(0,0)=WDTE(0,0)+WDTE(I,0) 
clin-4/2008 modified a la pythia6115.f to avoid undefined values (GGF,GZF,ZZF):
c          VINT(111)=VINT(111)+GGF*WID2  
c          VINT(112)=VINT(112)+GZF*WID2  
c          VINT(114)=VINT(114)+ZZF*WID2  
          IF(MINT(61).EQ.2) THEN    
             VINT(111)=VINT(111)+GGF*WID2  
             VINT(112)=VINT(112)+GZF*WID2  
             VINT(114)=VINT(114)+ZZF*WID2  
          ENDIF
clin-4/2008-end
        ENDIF   
  120   CONTINUE    
        IF(MSTP(43).EQ.1) THEN  
C...Only gamma* production included 
          VINT(112)=0.  
          VINT(114)=0.  
        ELSEIF(MSTP(43).EQ.2) THEN  
C...Only Z0 production included 
          VINT(111)=0.  
          VINT(112)=0.  
        ENDIF   
    
      ELSEIF(KFLA.EQ.24) THEN   
C...W+/-:   
        DO 130 I=1,MDCY(24,3)   
        IDC=I+MDCY(24,2)-1  
        RM1=(PMAS(IABS(KFDP(IDC,1)),1)/RMAS)**2 
        RM2=(PMAS(IABS(KFDP(IDC,2)),1)/RMAS)**2 
        IF(SQRT(RM1)+SQRT(RM2).GT.1..OR.MDME(IDC,1).LT.0) GOTO 130  
        IF(I.LE.16) THEN    
C...W+/- -> q + qb' 
          WDTP(I)=3.*(2.-RM1-RM2-(RM1-RM2)**2)* 
     &    SQRT(MAX(0.,(1.-RM1-RM2)**2-4.*RM1*RM2))* 
     &    VCKM((I-1)/4+1,MOD(I-1,4)+1)*RADC 
          WID2=1.   
        ELSE    
C...W+/- -> l+/- + nu   
          WDTP(I)=(2.-RM1-RM2-(RM1-RM2)**2)*    
     &    SQRT(MAX(0.,(1.-RM1-RM2)**2-4.*RM1*RM2))  
          WID2=1.   
        ENDIF   
        WDTP(0)=WDTP(0)+WDTP(I) 
        IF(MDME(IDC,1).GT.0) THEN   
          WDTE(I,MDME(IDC,1))=WDTP(I)*WID2  
          WDTE(0,MDME(IDC,1))=WDTE(0,MDME(IDC,1))+WDTE(I,MDME(IDC,1))   
          WDTE(I,0)=WDTE(I,MDME(IDC,1)) 
          WDTE(0,0)=WDTE(0,0)+WDTE(I,0) 
        ENDIF   
  130   CONTINUE    
    
      ELSEIF(KFLA.EQ.25) THEN   
C...H0: 
        DO 170 I=1,MDCY(25,3)   
        IDC=I+MDCY(25,2)-1  
        RM1=(PMAS(IABS(KFDP(IDC,1)),1)/RMAS)**2 
        RM2=(PMAS(IABS(KFDP(IDC,2)),1)/RMAS)**2 
        IF(SQRT(RM1)+SQRT(RM2).GT.1..OR.MDME(IDC,1).LT.0) GOTO 170  
        IF(I.LE.8) THEN 
C...H0 -> q + qb    
          WDTP(I)=3.*RM1*(1.-4.*RM1)*SQRT(MAX(0.,1.-4.*RM1))*RADC   
          WID2=1.   
        ELSEIF(I.LE.12) THEN    
C...H0 -> l+ + l-   
          WDTP(I)=RM1*(1.-4.*RM1)*SQRT(MAX(0.,1.-4.*RM1))   
          WID2=1.   
        ELSEIF(I.EQ.13) THEN    
C...H0 -> g + g; quark loop contribution only   
          ETARE=0.  
          ETAIM=0.  
          DO 140 J=1,2*MSTP(1)  
          EPS=(2.*PMAS(J,1)/RMAS)**2    
          IF(EPS.LE.1.) THEN    
            IF(EPS.GT.1.E-4) THEN   
              ROOT=SQRT(1.-EPS) 
              RLN=LOG((1.+ROOT)/(1.-ROOT))  
            ELSE    
              RLN=LOG(4./EPS-2.)    
            ENDIF   
            PHIRE=0.25*(RLN**2-PARU(1)**2)  
            PHIIM=0.5*PARU(1)*RLN   
          ELSE  
            PHIRE=-(ASIN(1./SQRT(EPS)))**2  
            PHIIM=0.    
          ENDIF 
          ETARE=ETARE+0.5*EPS*(1.+(EPS-1.)*PHIRE)   
          ETAIM=ETAIM+0.5*EPS*(EPS-1.)*PHIIM    
  140     CONTINUE  
          ETA2=ETARE**2+ETAIM**2    
          WDTP(I)=(AS/PARU(1))**2*ETA2  
          WID2=1.   
        ELSEIF(I.EQ.14) THEN    
C...H0 -> gamma + gamma; quark, charged lepton and W loop contributions 
          ETARE=0.  
          ETAIM=0.  
          DO 150 J=1,3*MSTP(1)+1    
          IF(J.LE.2*MSTP(1)) THEN   
            EJ=KCHG(J,1)/3. 
            EPS=(2.*PMAS(J,1)/RMAS)**2  
          ELSEIF(J.LE.3*MSTP(1)) THEN   
            JL=2*(J-2*MSTP(1))-1    
            EJ=KCHG(10+JL,1)/3. 
            EPS=(2.*PMAS(10+JL,1)/RMAS)**2  
          ELSE  
            EPS=(2.*PMAS(24,1)/RMAS)**2 
          ENDIF 
          IF(EPS.LE.1.) THEN    
            IF(EPS.GT.1.E-4) THEN   
              ROOT=SQRT(1.-EPS) 
              RLN=LOG((1.+ROOT)/(1.-ROOT))  
            ELSE    
              RLN=LOG(4./EPS-2.)    
            ENDIF   
            PHIRE=0.25*(RLN**2-PARU(1)**2)  
            PHIIM=0.5*PARU(1)*RLN   
          ELSE  
            PHIRE=-(ASIN(1./SQRT(EPS)))**2  
            PHIIM=0.    
          ENDIF 
          IF(J.LE.2*MSTP(1)) THEN   
            ETARE=ETARE+0.5*3.*EJ**2*EPS*(1.+(EPS-1.)*PHIRE)    
            ETAIM=ETAIM+0.5*3.*EJ**2*EPS*(EPS-1.)*PHIIM 
          ELSEIF(J.LE.3*MSTP(1)) THEN   
            ETARE=ETARE+0.5*EJ**2*EPS*(1.+(EPS-1.)*PHIRE)   
            ETAIM=ETAIM+0.5*EJ**2*EPS*(EPS-1.)*PHIIM    
          ELSE  
            ETARE=ETARE-0.5-0.75*EPS*(1.+(EPS-2.)*PHIRE)    
            ETAIM=ETAIM+0.75*EPS*(EPS-2.)*PHIIM 
          ENDIF 
  150     CONTINUE  
          ETA2=ETARE**2+ETAIM**2    
          WDTP(I)=(AEM/PARU(1))**2*0.5*ETA2 
          WID2=1.   
        ELSEIF(I.EQ.15) THEN    
C...H0 -> gamma + Z0; quark, charged lepton and W loop contributions    
          ETARE=0.  
          ETAIM=0.  
          DO 160 J=1,3*MSTP(1)+1    
          IF(J.LE.2*MSTP(1)) THEN   
            EJ=KCHG(J,1)/3. 
            AJ=SIGN(1.,EJ+0.1)  
            VJ=AJ-4.*EJ*XW  
            EPS=(2.*PMAS(J,1)/RMAS)**2  
            EPSP=(2.*PMAS(J,1)/PMAS(23,1))**2   
          ELSEIF(J.LE.3*MSTP(1)) THEN   
            JL=2*(J-2*MSTP(1))-1    
            EJ=KCHG(10+JL,1)/3. 
            AJ=SIGN(1.,EJ+0.1)  
            VJ=AI-4.*EJ*XW  
            EPS=(2.*PMAS(10+JL,1)/RMAS)**2  
            EPSP=(2.*PMAS(10+JL,1)/PMAS(23,1))**2   
          ELSE  
            EPS=(2.*PMAS(24,1)/RMAS)**2 
            EPSP=(2.*PMAS(24,1)/PMAS(23,1))**2  
          ENDIF 
          IF(EPS.LE.1.) THEN    
            ROOT=SQRT(1.-EPS)   
            IF(EPS.GT.1.E-4) THEN   
              RLN=LOG((1.+ROOT)/(1.-ROOT))  
            ELSE    
              RLN=LOG(4./EPS-2.)    
            ENDIF   
            PHIRE=0.25*(RLN**2-PARU(1)**2)  
            PHIIM=0.5*PARU(1)*RLN   
            PSIRE=-(1.+0.5*ROOT*RLN)    
            PSIIM=0.5*PARU(1)*ROOT  
          ELSE  
            PHIRE=-(ASIN(1./SQRT(EPS)))**2  
            PHIIM=0.    
            PSIRE=-(1.+SQRT(EPS-1.)*ASIN(1./SQRT(EPS))) 
            PSIIM=0.    
          ENDIF 
          IF(EPSP.LE.1.) THEN   
            ROOT=SQRT(1.-EPSP)  
            IF(EPSP.GT.1.E-4) THEN  
              RLN=LOG((1.+ROOT)/(1.-ROOT))  
            ELSE    
              RLN=LOG(4./EPSP-2.)   
            ENDIF   
            PHIREP=0.25*(RLN**2-PARU(1)**2) 
            PHIIMP=0.5*PARU(1)*RLN  
            PSIREP=-(1.+0.5*ROOT*RLN)   
            PSIIMP=0.5*PARU(1)*ROOT 
          ELSE  
            PHIREP=-(ASIN(1./SQRT(EPSP)))**2    
            PHIIMP=0.   
            PSIREP=-(1.+SQRT(EPSP-1.)*ASIN(1./SQRT(EPSP)))  
            PSIIMP=0.   
          ENDIF 
          FXYRE=EPS*EPSP/(8.*(EPS-EPSP))*(1.-EPS*EPSP/(EPS-EPSP)*(PHIRE-    
     &    PHIREP)+2.*EPS/(EPS-EPSP)*(PSIRE-PSIREP)) 
          FXYIM=EPS*EPSP/(8.*(EPS-EPSP))*(-EPS*EPSP/(EPS-EPSP)*(PHIIM-  
     &    PHIIMP)+2.*EPS/(EPS-EPSP)*(PSIIM-PSIIMP)) 
          F1RE=EPS*EPSP/(2.*(EPS-EPSP))*(PHIRE-PHIREP)  
          F1IM=EPS*EPSP/(2.*(EPS-EPSP))*(PHIIM-PHIIMP)  
          IF(J.LE.2*MSTP(1)) THEN   
            ETARE=ETARE-3.*EJ*VJ*(FXYRE-0.25*F1RE)  
            ETAIM=ETAIM-3.*EJ*VJ*(FXYIM-0.25*F1IM)  
          ELSEIF(J.LE.3*MSTP(1)) THEN   
            ETARE=ETARE-EJ*VJ*(FXYRE-0.25*F1RE) 
            ETAIM=ETAIM-EJ*VJ*(FXYIM-0.25*F1IM) 
          ELSE  
            ETARE=ETARE-SQRT(1.-XW)*(((1.+2./EPS)*XW/SQRT(1.-XW)-   
     &      (5.+2./EPS))*FXYRE+(3.-XW/SQRT(1.-XW))*F1RE)    
            ETAIM=ETAIM-SQRT(1.-XW)*(((1.+2./EPS)*XW/SQRT(1.-XW)-   
     &      (5.+2./EPS))*FXYIM+(3.-XW/SQRT(1.-XW))*F1IM)    
          ENDIF 
  160     CONTINUE  
          ETA2=ETARE**2+ETAIM**2    
          WDTP(I)=(AEM/PARU(1))**2*(1.-(PMAS(23,1)/RMAS)**2)**3/XW*ETA2 
          WID2=WIDS(23,2)   
        ELSE    
C...H0 -> Z0 + Z0, W+ + W-  
          WDTP(I)=(1.-4.*RM1+12.*RM1**2)*SQRT(MAX(0.,1.-4.*RM1))/   
     &    (2.*(18-I))   
          WID2=WIDS(7+I,1)  
        ENDIF   
        WDTP(0)=WDTP(0)+WDTP(I) 
        IF(MDME(IDC,1).GT.0) THEN   
          WDTE(I,MDME(IDC,1))=WDTP(I)*WID2  
          WDTE(0,MDME(IDC,1))=WDTE(0,MDME(IDC,1))+WDTE(I,MDME(IDC,1))   
          WDTE(I,0)=WDTE(I,MDME(IDC,1)) 
          WDTE(0,0)=WDTE(0,0)+WDTE(I,0) 
        ENDIF   
  170   CONTINUE    
    
      ELSEIF(KFLA.EQ.32) THEN   
C...Z'0:    
        IF(MINT(61).EQ.1) THEN  
          EI=KCHG(IABS(MINT(15)),1)/3.  
          AI=SIGN(1.,EI)    
          VI=AI-4.*EI*XW    
          SQMZ=PMAS(23,1)**2    
          GZMZ=PMAS(23,2)*PMAS(23,1)    
          API=SIGN(1.,EI)   
          VPI=API-4.*EI*XW  
          SQMZP=PMAS(32,1)**2   
          GZPMZP=PMAS(32,2)*PMAS(32,1)  
          GGI=EI**2 
          GZI=EI*VI/(8.*XW*(1.-XW))*SQM*(SQM-SQMZ)/ 
     &    ((SQM-SQMZ)**2+GZMZ**2)   
          GZPI=EI*VPI/(8.*XW*(1.-XW))*SQM*(SQM-SQMZP)/  
     &    ((SQM-SQMZP)**2+GZPMZP**2)    
          ZZI=(VI**2+AI**2)/(16.*XW*(1.-XW))**2*SQM**2/ 
     &    ((SQM-SQMZ)**2+GZMZ**2)   
          ZZPI=2.*(VI*VPI+AI*API)/(16.*XW*(1.-XW))**2*  
     &    SQM**2*((SQM-SQMZ)*(SQM-SQMZP)+GZMZ*GZPMZP)/  
     &    (((SQM-SQMZ)**2+GZMZ**2)*((SQM-SQMZP)**2+GZPMZP**2))  
          ZPZPI=(VPI**2+API**2)/(16.*XW*(1.-XW))**2*SQM**2/ 
     &    ((SQM-SQMZP)**2+GZPMZP**2)    
          IF(MSTP(44).EQ.1) THEN    
C...Only gamma* production included 
            GZI=0.  
            GZPI=0. 
            ZZI=0.  
            ZZPI=0. 
            ZPZPI=0.    
          ELSEIF(MSTP(44).EQ.2) THEN    
C...Only Z0 production included 
            GGI=0.  
            GZI=0.  
            GZPI=0. 
            ZZPI=0. 
            ZPZPI=0.    
          ELSEIF(MSTP(44).EQ.3) THEN    
C...Only Z'0 production included    
            GGI=0.  
            GZI=0.  
            GZPI=0. 
            ZZI=0.  
            ZZPI=0. 
          ELSEIF(MSTP(44).EQ.4) THEN    
C...Only gamma*/Z0 production included  
            GZPI=0. 
            ZZPI=0. 
            ZPZPI=0.    
          ELSEIF(MSTP(44).EQ.5) THEN    
C...Only gamma*/Z'0 production included 
            GZI=0.  
            ZZI=0.  
            ZZPI=0. 
          ELSEIF(MSTP(44).EQ.6) THEN    
C...Only Z0/Z'0 production included 
            GGI=0.  
            GZI=0.  
            GZPI=0. 
          ENDIF 
        ELSEIF(MINT(61).EQ.2) THEN  
          VINT(111)=0.  
          VINT(112)=0.  
          VINT(113)=0.  
          VINT(114)=0.  
          VINT(115)=0.  
          VINT(116)=0.  
        ENDIF   
        DO 180 I=1,MDCY(32,3)   
        IDC=I+MDCY(32,2)-1  
        RM1=(PMAS(IABS(KFDP(IDC,1)),1)/RMAS)**2 
        RM2=(PMAS(IABS(KFDP(IDC,2)),1)/RMAS)**2 
        IF(SQRT(RM1)+SQRT(RM2).GT.1..OR.MDME(IDC,1).LT.0) GOTO 180  
        IF(I.LE.8) THEN 
C...Z'0 -> q + qb   
          EF=KCHG(I,1)/3.   
          AF=SIGN(1.,EF+0.1)    
          VF=AF-4.*EF*XW    
          APF=SIGN(1.,EF+0.1)   
          VPF=APF-4.*EF*XW  
          IF(MINT(61).EQ.0) THEN    
            WDTP(I)=3.*(VPF**2*(1.+2.*RM1)+APF**2*(1.-4.*RM1))* 
     &      SQRT(MAX(0.,1.-4.*RM1))*RADC    
          ELSEIF(MINT(61).EQ.1) THEN    
            WDTP(I)=3.*((GGI*EF**2+GZI*EF*VF+GZPI*EF*VPF+ZZI*VF**2+ 
     &      ZZPI*VF*VPF+ZPZPI*VPF**2)*(1.+2.*RM1)+(ZZI*AF**2+   
     &      ZZPI*AF*APF+ZPZPI*APF**2)*(1.-4.*RM1))* 
     &      SQRT(MAX(0.,1.-4.*RM1))*RADC    
          ELSEIF(MINT(61).EQ.2) THEN    
            GGF=3.*EF**2*(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1))*RADC   
            GZF=3.*EF*VF*(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1))*RADC   
            GZPF=3.*EF*VPF*(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1))*RADC 
            ZZF=3.*(VF**2*(1.+2.*RM1)+AF**2*(1.-4.*RM1))*   
     &      SQRT(MAX(0.,1.-4.*RM1))*RADC    
            ZZPF=3.*(VF*VPF*(1.+2.*RM1)+AF*APF*(1.-4.*RM1))*    
     &      SQRT(MAX(0.,1.-4.*RM1))*RADC    
            ZPZPF=3.*(VPF**2*(1.+2.*RM1)+APF**2*(1.-4.*RM1))*   
     &      SQRT(MAX(0.,1.-4.*RM1))*RADC    
          ENDIF 
          WID2=1.   
        ELSE    
C...Z'0 -> l+ + l-, nu + nub    
          EF=KCHG(I+2,1)/3. 
          AF=SIGN(1.,EF+0.1)    
          VF=AF-4.*EF*XW    
clin-4/2008 modified above a la pythia6115.f to avoid undefined variable API:
c          APF=SIGN(1.,EF+0.1)   
c          VPF=API-4.*EF*XW  
          IF(I.LE.10) THEN
             VPF=PARU(127-2*MOD(I,2))
             APF=PARU(128-2*MOD(I,2))
          ELSEIF(I.LE.12) THEN
             VPF=PARJ(186-2*MOD(I,2))
             APF=PARJ(187-2*MOD(I,2))
          ELSE
             VPF=PARJ(194-2*MOD(I,2))
             APF=PARJ(195-2*MOD(I,2))
          ENDIF
clin-4/2008-end
          IF(MINT(61).EQ.0) THEN    
            WDTP(I)=(VPF**2*(1.+2.*RM1)+APF**2*(1.-4.*RM1))*    
     &      SQRT(MAX(0.,1.-4.*RM1)) 
          ELSEIF(MINT(61).EQ.1) THEN    
            WDTP(I)=((GGI*EF**2+GZI*EF*VF+GZPI*EF*VPF+ZZI*VF**2+    
     &      ZZPI*VF*VPF+ZPZPI*VPF**2)*(1.+2.*RM1)+(ZZI*AF**2+   
     &      ZZPI*AF*APF+ZPZPI*APF**2)*(1.-4.*RM1))* 
     &      SQRT(MAX(0.,1.-4.*RM1)) 
          ELSEIF(MINT(61).EQ.2) THEN    
            GGF=EF**2*(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1))   
            GZF=EF*VF*(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1))   
            GZPF=EF*VPF*(1.+2.*RM1)*SQRT(MAX(0.,1.-4.*RM1)) 
            ZZF=(VF**2*(1.+2.*RM1)+AF**2*(1.-4.*RM1))*  
     &      SQRT(MAX(0.,1.-4.*RM1)) 
            ZZPF=(VF*VPF*(1.+2.*RM1)+AF*APF*(1.-4.*RM1))*   
     &      SQRT(MAX(0.,1.-4.*RM1)) 
            ZPZPF=(VPF**2*(1.+2.*RM1)+APF**2*(1.-4.*RM1))*  
     &      SQRT(MAX(0.,1.-4.*RM1)) 
          ENDIF 
          WID2=1.   
        ENDIF   
        WDTP(0)=WDTP(0)+WDTP(I) 
        IF(MDME(IDC,1).GT.0) THEN   
          WDTE(I,MDME(IDC,1))=WDTP(I)*WID2  
          WDTE(0,MDME(IDC,1))=WDTE(0,MDME(IDC,1))+WDTE(I,MDME(IDC,1))   
          WDTE(I,0)=WDTE(I,MDME(IDC,1)) 
          WDTE(0,0)=WDTE(0,0)+WDTE(I,0) 
clin-4/2008:
c          VINT(111)=VINT(111)+GGF   
c          VINT(112)=VINT(112)+GZF   
c          VINT(113)=VINT(113)+GZPF  
c          VINT(114)=VINT(114)+ZZF   
c          VINT(115)=VINT(115)+ZZPF  
c          VINT(116)=VINT(116)+ZPZPF 
          IF(MINT(61).EQ.2) THEN    
             VINT(111)=VINT(111)+GGF   
             VINT(112)=VINT(112)+GZF   
             VINT(113)=VINT(113)+GZPF  
             VINT(114)=VINT(114)+ZZF   
             VINT(115)=VINT(115)+ZZPF  
             VINT(116)=VINT(116)+ZPZPF 
          ENDIF
clin-4/2008-end
        ENDIF   
  180   CONTINUE    
        IF(MSTP(44).EQ.1) THEN  
C...Only gamma* production included 
          VINT(112)=0.  
          VINT(113)=0.  
          VINT(114)=0.  
          VINT(115)=0.  
          VINT(116)=0.  
        ELSEIF(MSTP(44).EQ.2) THEN  
C...Only Z0 production included 
          VINT(111)=0.  
          VINT(112)=0.  
          VINT(113)=0.  
          VINT(115)=0.  
          VINT(116)=0.  
        ELSEIF(MSTP(44).EQ.3) THEN  
C...Only Z'0 production included    
          VINT(111)=0.  
          VINT(112)=0.  
          VINT(113)=0.  
          VINT(114)=0.  
          VINT(115)=0.  
        ELSEIF(MSTP(44).EQ.4) THEN  
C...Only gamma*/Z0 production included  
          VINT(113)=0.  
          VINT(115)=0.  
          VINT(116)=0.  
        ELSEIF(MSTP(44).EQ.5) THEN  
C...Only gamma*/Z'0 production included 
          VINT(112)=0.  
          VINT(114)=0.  
          VINT(115)=0.  
        ELSEIF(MSTP(44).EQ.6) THEN  
C...Only Z0/Z'0 production included 
          VINT(111)=0.  
          VINT(112)=0.  
          VINT(113)=0.  
        ENDIF   
    
      ELSEIF(KFLA.EQ.37) THEN   
C...H+/-:   
        DO 190 I=1,MDCY(37,3)   
        IDC=I+MDCY(37,2)-1  
        RM1=(PMAS(IABS(KFDP(IDC,1)),1)/RMAS)**2 
        RM2=(PMAS(IABS(KFDP(IDC,2)),1)/RMAS)**2 
        IF(SQRT(RM1)+SQRT(RM2).GT.1..OR.MDME(IDC,1).LT.0) GOTO 190  
        IF(I.LE.4) THEN 
C...H+/- -> q + qb' 
          WDTP(I)=3.*((RM1*PARU(121)+RM2/PARU(121))*    
     &    (1.-RM1-RM2)-4.*RM1*RM2)* 
     &    SQRT(MAX(0.,(1.-RM1-RM2)**2-4.*RM1*RM2))*RADC 
          WID2=1.   
        ELSE    
C...H+/- -> l+/- + nu   
          WDTP(I)=((RM1*PARU(121)+RM2/PARU(121))*   
     &    (1.-RM1-RM2)-4.*RM1*RM2)* 
     &    SQRT(MAX(0.,(1.-RM1-RM2)**2-4.*RM1*RM2))  
          WID2=1.   
        ENDIF   
        WDTP(0)=WDTP(0)+WDTP(I) 
        IF(MDME(IDC,1).GT.0) THEN   
          WDTE(I,MDME(IDC,1))=WDTP(I)*WID2  
          WDTE(0,MDME(IDC,1))=WDTE(0,MDME(IDC,1))+WDTE(I,MDME(IDC,1))   
          WDTE(I,0)=WDTE(I,MDME(IDC,1)) 
          WDTE(0,0)=WDTE(0,0)+WDTE(I,0) 
        ENDIF   
  190   CONTINUE    
    
      ELSEIF(KFLA.EQ.40) THEN   
C...R:  
        DO 200 I=1,MDCY(40,3)   
        IDC=I+MDCY(40,2)-1  
        RM1=(PMAS(IABS(KFDP(IDC,1)),1)/RMAS)**2 
        RM2=(PMAS(IABS(KFDP(IDC,2)),1)/RMAS)**2 
        IF(SQRT(RM1)+SQRT(RM2).GT.1..OR.MDME(IDC,1).LT.0) GOTO 200  
        IF(I.LE.4) THEN 
C...R -> q + qb'    
          WDTP(I)=3.*RADC   
          WID2=1.   
        ELSE    
C...R -> l+ + l'-   
          WDTP(I)=1.    
          WID2=1.   
        ENDIF   
        WDTP(0)=WDTP(0)+WDTP(I) 
        IF(MDME(IDC,1).GT.0) THEN   
          WDTE(I,MDME(IDC,1))=WDTP(I)*WID2  
          WDTE(0,MDME(IDC,1))=WDTE(0,MDME(IDC,1))+WDTE(I,MDME(IDC,1))   
          WDTE(I,0)=WDTE(I,MDME(IDC,1)) 
          WDTE(0,0)=WDTE(0,0)+WDTE(I,0) 
        ENDIF   
  200   CONTINUE    
    
      ENDIF 
      MINT(61)=0    
    
      RETURN    
      END   
    
C***********************************************************************    
    
      SUBROUTINE PYKLIM(ILIM)   
    
C...Checks generated variables against pre-set kinematical limits;  
C...also calculates limits on variables used in generation. 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
    
C...Common kinematical expressions. 
      ISUB=MINT(1)  
      IF(ISUB.EQ.96) GOTO 110   
      SQM3=VINT(63) 
      SQM4=VINT(64) 
      IF(ILIM.NE.1) THEN    
        TAU=VINT(21)    
        RM3=SQM3/(TAU*VINT(2))  
        RM4=SQM4/(TAU*VINT(2))  
        BE34=SQRT((1.-RM3-RM4)**2-4.*RM3*RM4)   
      ENDIF 
      PTHMIN=CKIN(3)    
      IF(MIN(SQM3,SQM4).LT.CKIN(6)**2) PTHMIN=MAX(CKIN(3),CKIN(5))  
      IF(ILIM.EQ.0) THEN    
C...Check generated values of tau, y*, cos(theta-hat), and tau' against 
C...pre-set kinematical limits. 
        YST=VINT(22)    
        CTH=VINT(23)    
        TAUP=VINT(26)   
        IF(ISET(ISUB).LE.2) THEN    
          X1=SQRT(TAU)*EXP(YST) 
          X2=SQRT(TAU)*EXP(-YST)    
        ELSE    
          X1=SQRT(TAUP)*EXP(YST)    
          X2=SQRT(TAUP)*EXP(-YST)   
        ENDIF   
        XF=X1-X2    
        IF(TAU*VINT(2).LT.CKIN(1)**2) MINT(51)=1    
        IF(CKIN(2).GE.0..AND.TAU*VINT(2).GT.CKIN(2)**2) MINT(51)=1  
        IF(X1.LT.CKIN(21).OR.X1.GT.CKIN(22)) MINT(51)=1 
        IF(X2.LT.CKIN(23).OR.X2.GT.CKIN(24)) MINT(51)=1 
        IF(XF.LT.CKIN(25).OR.XF.GT.CKIN(26)) MINT(51)=1 
        IF(YST.LT.CKIN(7).OR.YST.GT.CKIN(8)) MINT(51)=1 
        IF(ISET(ISUB).EQ.2.OR.ISET(ISUB).EQ.4) THEN 
          PTH=0.5*BE34*SQRT(TAU*VINT(2)*(1.-CTH**2))    
          Y3=YST+0.5*LOG((1.+RM3-RM4+BE34*CTH)/(1.+RM3-RM4-BE34*CTH))   
          Y4=YST+0.5*LOG((1.+RM4-RM3-BE34*CTH)/(1.+RM4-RM3+BE34*CTH))   
          YLARGE=MAX(Y3,Y4) 
          YSMALL=MIN(Y3,Y4) 
          ETALAR=10.    
          ETASMA=-10.   
          STH=SQRT(1.-CTH**2)   
          IF(STH.LT.1.E-6) GOTO 100 
          EXPET3=((1.+RM3-RM4)*SINH(YST)+BE34*COSH(YST)*CTH+    
     &    SQRT(((1.+RM3-RM4)*COSH(YST)+BE34*SINH(YST)*CTH)**2-4.*RM3))/ 
     &    (BE34*STH)    
          EXPET4=((1.-RM3+RM4)*SINH(YST)-BE34*COSH(YST)*CTH+    
     &    SQRT(((1.-RM3+RM4)*COSH(YST)-BE34*SINH(YST)*CTH)**2-4.*RM4))/ 
     &    (BE34*STH)    
          ETA3=LOG(MIN(1.E10,MAX(1.E-10,EXPET3)))   
          ETA4=LOG(MIN(1.E10,MAX(1.E-10,EXPET4)))   
          ETALAR=MAX(ETA3,ETA4) 
          ETASMA=MIN(ETA3,ETA4) 
  100     CTS3=((1.+RM3-RM4)*SINH(YST)+BE34*COSH(YST)*CTH)/ 
     &    SQRT(((1.+RM3-RM4)*COSH(YST)+BE34*SINH(YST)*CTH)**2-4.*RM3)   
          CTS4=((1.-RM3+RM4)*SINH(YST)-BE34*COSH(YST)*CTH)/ 
     &    SQRT(((1.-RM3+RM4)*COSH(YST)-BE34*SINH(YST)*CTH)**2-4.*RM4)   
          CTSLAR=MAX(CTS3,CTS4) 
          CTSSMA=MIN(CTS3,CTS4) 
          IF(PTH.LT.PTHMIN) MINT(51)=1  
          IF(CKIN(4).GE.0..AND.PTH.GT.CKIN(4)) MINT(51)=1   
          IF(YLARGE.LT.CKIN(9).OR.YLARGE.GT.CKIN(10)) MINT(51)=1    
          IF(YSMALL.LT.CKIN(11).OR.YSMALL.GT.CKIN(12)) MINT(51)=1   
          IF(ETALAR.LT.CKIN(13).OR.ETALAR.GT.CKIN(14)) MINT(51)=1   
          IF(ETASMA.LT.CKIN(15).OR.ETASMA.GT.CKIN(16)) MINT(51)=1   
          IF(CTSLAR.LT.CKIN(17).OR.CTSLAR.GT.CKIN(18)) MINT(51)=1   
          IF(CTSSMA.LT.CKIN(19).OR.CTSSMA.GT.CKIN(20)) MINT(51)=1   
          IF(CTH.LT.CKIN(27).OR.CTH.GT.CKIN(28)) MINT(51)=1 
        ENDIF   
        IF(ISET(ISUB).EQ.3.OR.ISET(ISUB).EQ.4) THEN 
          IF(TAUP*VINT(2).LT.CKIN(31)**2) MINT(51)=1    
          IF(CKIN(32).GE.0..AND.TAUP*VINT(2).GT.CKIN(32)**2) MINT(51)=1 
        ENDIF   
    
      ELSEIF(ILIM.EQ.1) THEN    
C...Calculate limits on tau 
C...0) due to definition    
        TAUMN0=0.   
        TAUMX0=1.   
C...1) due to limits on subsystem mass  
        TAUMN1=CKIN(1)**2/VINT(2)   
        TAUMX1=1.   
        IF(CKIN(2).GE.0.) TAUMX1=CKIN(2)**2/VINT(2) 
C...2) due to limits on pT-hat (and non-overlapping rapidity intervals) 
        TM3=SQRT(SQM3+PTHMIN**2)    
        TM4=SQRT(SQM4+PTHMIN**2)    
        YDCOSH=1.   
        IF(CKIN(9).GT.CKIN(12)) YDCOSH=COSH(CKIN(9)-CKIN(12))   
        TAUMN2=(TM3**2+2.*TM3*TM4*YDCOSH+TM4**2)/VINT(2)    
        TAUMX2=1.   
C...3) due to limits on pT-hat and cos(theta-hat)   
        CTH2MN=MIN(CKIN(27)**2,CKIN(28)**2) 
        CTH2MX=MAX(CKIN(27)**2,CKIN(28)**2) 
        TAUMN3=0.   
        IF(CKIN(27)*CKIN(28).GT.0.) TAUMN3= 
     &  (SQRT(SQM3+PTHMIN**2/(1.-CTH2MN))+  
     &  SQRT(SQM4+PTHMIN**2/(1.-CTH2MN)))**2/VINT(2)    
        TAUMX3=1.   
        IF(CKIN(4).GE.0..AND.CTH2MX.LT.1.) TAUMX3=  
     &  (SQRT(SQM3+CKIN(4)**2/(1.-CTH2MX))+ 
     &  SQRT(SQM4+CKIN(4)**2/(1.-CTH2MX)))**2/VINT(2)   
C...4) due to limits on x1 and x2   
        TAUMN4=CKIN(21)*CKIN(23)    
        TAUMX4=CKIN(22)*CKIN(24)    
C...5) due to limits on xF  
        TAUMN5=0.   
        TAUMX5=MAX(1.-CKIN(25),1.+CKIN(26)) 
        VINT(11)=MAX(TAUMN0,TAUMN1,TAUMN2,TAUMN3,TAUMN4,TAUMN5) 
        VINT(31)=MIN(TAUMX0,TAUMX1,TAUMX2,TAUMX3,TAUMX4,TAUMX5) 
        IF(MINT(43).EQ.1.AND.(ISET(ISUB).EQ.1.OR.ISET(ISUB).EQ.2)) THEN 
          VINT(11)=0.99999  
          VINT(31)=1.00001  
        ENDIF   
        IF(VINT(31).LE.VINT(11)) MINT(51)=1 
    
      ELSEIF(ILIM.EQ.2) THEN    
C...Calculate limits on y*  
        IF(ISET(ISUB).EQ.3.OR.ISET(ISUB).EQ.4) TAU=VINT(26) 
        TAURT=SQRT(TAU) 
C...0) due to kinematics    
        YSTMN0=LOG(TAURT)   
        YSTMX0=-YSTMN0  
C...1) due to explicit limits   
        YSTMN1=CKIN(7)  
        YSTMX1=CKIN(8)  
C...2) due to limits on x1  
        YSTMN2=LOG(MAX(TAU,CKIN(21))/TAURT) 
        YSTMX2=LOG(MAX(TAU,CKIN(22))/TAURT) 
C...3) due to limits on x2  
        YSTMN3=-LOG(MAX(TAU,CKIN(24))/TAURT)    
        YSTMX3=-LOG(MAX(TAU,CKIN(23))/TAURT)    
C...4) due to limits on xF  
        YEPMN4=0.5*ABS(CKIN(25))/TAURT  
        YSTMN4=SIGN(LOG(SQRT(1.+YEPMN4**2)+YEPMN4),CKIN(25))    
        YEPMX4=0.5*ABS(CKIN(26))/TAURT  
        YSTMX4=SIGN(LOG(SQRT(1.+YEPMX4**2)+YEPMX4),CKIN(26))    
C...5) due to simultaneous limits on y-large and y-small    
        YEPSMN=(RM3-RM4)*SINH(CKIN(9)-CKIN(11)) 
        YEPSMX=(RM3-RM4)*SINH(CKIN(10)-CKIN(12))    
        YDIFMN=ABS(LOG(SQRT(1.+YEPSMN**2)-YEPSMN))  
        YDIFMX=ABS(LOG(SQRT(1.+YEPSMX**2)-YEPSMX))  
        YSTMN5=0.5*(CKIN(9)+CKIN(11)-YDIFMN)    
        YSTMX5=0.5*(CKIN(10)+CKIN(12)+YDIFMX)   
C...6) due to simultaneous limits on cos(theta-hat) and y-large or  
C...   y-small  
        CTHLIM=SQRT(1.-4.*PTHMIN**2/(BE34*TAU*VINT(2))) 
        RZMN=BE34*MAX(CKIN(27),-CTHLIM) 
        RZMX=BE34*MIN(CKIN(28),CTHLIM)  
        YEX3MX=(1.+RM3-RM4+RZMX)/MAX(1E-10,1.+RM3-RM4-RZMX) 
        YEX4MX=(1.+RM4-RM3-RZMN)/MAX(1E-10,1.+RM4-RM3+RZMN) 
        YEX3MN=MAX(1E-10,1.+RM3-RM4+RZMN)/(1.+RM3-RM4-RZMN) 
        YEX4MN=MAX(1E-10,1.+RM4-RM3-RZMX)/(1.+RM4-RM3+RZMX) 
        YSTMN6=CKIN(9)-0.5*LOG(MAX(YEX3MX,YEX4MX))  
        YSTMX6=CKIN(12)-0.5*LOG(MIN(YEX3MN,YEX4MN)) 
        VINT(12)=MAX(YSTMN0,YSTMN1,YSTMN2,YSTMN3,YSTMN4,YSTMN5,YSTMN6)  
        VINT(32)=MIN(YSTMX0,YSTMX1,YSTMX2,YSTMX3,YSTMX4,YSTMX5,YSTMX6)  
        IF(MINT(43).EQ.1) THEN  
          VINT(12)=-0.00001 
          VINT(32)=0.00001  
        ELSEIF(MINT(43).EQ.2) THEN  
          VINT(12)=0.99999*YSTMX0   
          VINT(32)=1.00001*YSTMX0   
        ELSEIF(MINT(43).EQ.3) THEN  
          VINT(12)=-1.00001*YSTMX0  
          VINT(32)=-0.99999*YSTMX0  
        ENDIF   
        IF(VINT(32).LE.VINT(12)) MINT(51)=1 
    
      ELSEIF(ILIM.EQ.3) THEN    
C...Calculate limits on cos(theta-hat)  
        YST=VINT(22)    
C...0) due to definition    
        CTNMN0=-1.  
        CTNMX0=0.   
        CTPMN0=0.   
        CTPMX0=1.   
C...1) due to explicit limits   
        CTNMN1=MIN(0.,CKIN(27)) 
        CTNMX1=MIN(0.,CKIN(28)) 
        CTPMN1=MAX(0.,CKIN(27)) 
        CTPMX1=MAX(0.,CKIN(28)) 
C...2) due to limits on pT-hat  
        CTNMN2=-SQRT(1.-4.*PTHMIN**2/(BE34**2*TAU*VINT(2))) 
        CTPMX2=-CTNMN2  
        CTNMX2=0.   
        CTPMN2=0.   
        IF(CKIN(4).GE.0.) THEN  
          CTNMX2=-SQRT(MAX(0.,1.-4.*CKIN(4)**2/(BE34**2*TAU*VINT(2))))  
          CTPMN2=-CTNMX2    
        ENDIF   
C...3) due to limits on y-large and y-small 
        CTNMN3=MIN(0.,MAX((1.+RM3-RM4)/BE34*TANH(CKIN(11)-YST), 
     &  -(1.-RM3+RM4)/BE34*TANH(CKIN(10)-YST))) 
        CTNMX3=MIN(0.,(1.+RM3-RM4)/BE34*TANH(CKIN(12)-YST), 
     &  -(1.-RM3+RM4)/BE34*TANH(CKIN(9)-YST))   
        CTPMN3=MAX(0.,(1.+RM3-RM4)/BE34*TANH(CKIN(9)-YST),  
     &  -(1.-RM3+RM4)/BE34*TANH(CKIN(12)-YST))  
        CTPMX3=MAX(0.,MIN((1.+RM3-RM4)/BE34*TANH(CKIN(10)-YST), 
     &  -(1.-RM3+RM4)/BE34*TANH(CKIN(11)-YST))) 
        VINT(13)=MAX(CTNMN0,CTNMN1,CTNMN2,CTNMN3)   
        VINT(33)=MIN(CTNMX0,CTNMX1,CTNMX2,CTNMX3)   
        VINT(14)=MAX(CTPMN0,CTPMN1,CTPMN2,CTPMN3)   
        VINT(34)=MIN(CTPMX0,CTPMX1,CTPMX2,CTPMX3)   
        IF(VINT(33).LE.VINT(13).AND.VINT(34).LE.VINT(14)) MINT(51)=1    
    
      ELSEIF(ILIM.EQ.4) THEN    
C...Calculate limits on tau'    
C...0) due to kinematics    
        TAPMN0=TAU  
        TAPMX0=1.   
C...1) due to explicit limits   
        TAPMN1=CKIN(31)**2/VINT(2)  
        TAPMX1=1.   
        IF(CKIN(32).GE.0.) TAPMX1=CKIN(32)**2/VINT(2)   
        VINT(16)=MAX(TAPMN0,TAPMN1) 
        VINT(36)=MIN(TAPMX0,TAPMX1) 
        IF(MINT(43).EQ.1) THEN  
          VINT(16)=0.99999  
          VINT(36)=1.00001  
        ENDIF   
        IF(VINT(36).LE.VINT(16)) MINT(51)=1 
    
      ENDIF 
      RETURN    
    
C...Special case for low-pT and multiple interactions:  
C...effective kinematical limits for tau, y*, cos(theta-hat).   
  110 IF(ILIM.EQ.0) THEN    
      ELSEIF(ILIM.EQ.1) THEN    
        IF(MSTP(82).LE.1) VINT(11)=4.*PARP(81)**2/VINT(2)   
        IF(MSTP(82).GE.2) VINT(11)=PARP(82)**2/VINT(2)  
        VINT(31)=1. 
      ELSEIF(ILIM.EQ.2) THEN    
        VINT(12)=0.5*LOG(VINT(21))  
        VINT(32)=-VINT(12)  
      ELSEIF(ILIM.EQ.3) THEN    
        IF(MSTP(82).LE.1) ST2EFF=4.*PARP(81)**2/(VINT(21)*VINT(2))  
        IF(MSTP(82).GE.2) ST2EFF=0.01*PARP(82)**2/(VINT(21)*VINT(2))    
        VINT(13)=-SQRT(MAX(0.,1.-ST2EFF))   
        VINT(33)=0. 
        VINT(14)=0. 
        VINT(34)=-VINT(13)  
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYKMAP(IVAR,MVAR,VVAR) 
    
C...Maps a uniform distribution into a distribution of a kinematical    
C...variable according to one of the possibilities allowed. It is   
C...assumed that kinematical limits have been set by a PYKLIM call. 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
    
C...Convert VVAR to tau variable.   
      ISUB=MINT(1)  
      IF(IVAR.EQ.1) THEN    
        TAUMIN=VINT(11) 
        TAUMAX=VINT(31) 
        IF(MVAR.EQ.3.OR.MVAR.EQ.4) THEN 
          TAURE=VINT(73)    
          GAMRE=VINT(74)    
        ELSEIF(MVAR.EQ.5.OR.MVAR.EQ.6) THEN 
          TAURE=VINT(75)    
          GAMRE=VINT(76)    
        ENDIF   
        IF(MINT(43).EQ.1.AND.(ISET(ISUB).EQ.1.OR.ISET(ISUB).EQ.2)) THEN 
          TAU=1.    
        ELSEIF(MVAR.EQ.1) THEN  
          TAU=TAUMIN*(TAUMAX/TAUMIN)**VVAR  
        ELSEIF(MVAR.EQ.2) THEN  
          TAU=TAUMAX*TAUMIN/(TAUMIN+(TAUMAX-TAUMIN)*VVAR)   
        ELSEIF(MVAR.EQ.3.OR.MVAR.EQ.5) THEN 
          RATGEN=(TAURE+TAUMAX)/(TAURE+TAUMIN)*TAUMIN/TAUMAX    
          TAU=TAURE*TAUMIN/((TAURE+TAUMIN)*RATGEN**VVAR-TAUMIN) 
        ELSE    
          AUPP=ATAN((TAUMAX-TAURE)/GAMRE)   
          ALOW=ATAN((TAUMIN-TAURE)/GAMRE)   
          TAU=TAURE+GAMRE*TAN(ALOW+(AUPP-ALOW)*VVAR)    
        ENDIF   
        VINT(21)=MIN(TAUMAX,MAX(TAUMIN,TAU))    

C...Convert VVAR to y* variable.    
      ELSEIF(IVAR.EQ.2) THEN    
        YSTMIN=VINT(12) 
        YSTMAX=VINT(32) 
        IF(MINT(43).EQ.1) THEN  
          YST=0.    
        ELSEIF(MINT(43).EQ.2) THEN  
          IF(ISET(ISUB).LE.2) YST=-0.5*LOG(VINT(21))    
          IF(ISET(ISUB).GE.3) YST=-0.5*LOG(VINT(26))    
        ELSEIF(MINT(43).EQ.3) THEN  
          IF(ISET(ISUB).LE.2) YST=0.5*LOG(VINT(21)) 
          IF(ISET(ISUB).GE.3) YST=0.5*LOG(VINT(26)) 
        ELSEIF(MVAR.EQ.1) THEN  
          YST=YSTMIN+(YSTMAX-YSTMIN)*SQRT(VVAR) 
        ELSEIF(MVAR.EQ.2) THEN  
          YST=YSTMAX-(YSTMAX-YSTMIN)*SQRT(1.-VVAR)  
        ELSE    
          AUPP=ATAN(EXP(YSTMAX))    
          ALOW=ATAN(EXP(YSTMIN))    
          YST=LOG(TAN(ALOW+(AUPP-ALOW)*VVAR))   
        ENDIF   
        VINT(22)=MIN(YSTMAX,MAX(YSTMIN,YST))    
    
C...Convert VVAR to cos(theta-hat) variable.    
      ELSEIF(IVAR.EQ.3) THEN    
        RM34=2.*VINT(63)*VINT(64)/(VINT(21)*VINT(2))**2 
        RSQM=1.+RM34    
        IF(2.*VINT(71)**2/(VINT(21)*VINT(2)).LT.0.0001) RM34=MAX(RM34,  
     &  2.*VINT(71)**2/(VINT(21)*VINT(2)))  
        CTNMIN=VINT(13) 
        CTNMAX=VINT(33) 
        CTPMIN=VINT(14) 
        CTPMAX=VINT(34) 
        IF(MVAR.EQ.1) THEN  
          ANEG=CTNMAX-CTNMIN    
          APOS=CTPMAX-CTPMIN    
          IF(ANEG.GT.0..AND.VVAR*(ANEG+APOS).LE.ANEG) THEN  
            VCTN=VVAR*(ANEG+APOS)/ANEG  
            CTH=CTNMIN+(CTNMAX-CTNMIN)*VCTN 
          ELSE  
            VCTP=(VVAR*(ANEG+APOS)-ANEG)/APOS   
            CTH=CTPMIN+(CTPMAX-CTPMIN)*VCTP 
          ENDIF 
        ELSEIF(MVAR.EQ.2) THEN  
          RMNMIN=MAX(RM34,RSQM-CTNMIN)  
          RMNMAX=MAX(RM34,RSQM-CTNMAX)  
          RMPMIN=MAX(RM34,RSQM-CTPMIN)  
          RMPMAX=MAX(RM34,RSQM-CTPMAX)  
          ANEG=LOG(RMNMIN/RMNMAX)   
          APOS=LOG(RMPMIN/RMPMAX)   
          IF(ANEG.GT.0..AND.VVAR*(ANEG+APOS).LE.ANEG) THEN  
            VCTN=VVAR*(ANEG+APOS)/ANEG  
            CTH=RSQM-RMNMIN*(RMNMAX/RMNMIN)**VCTN   
          ELSE  
            VCTP=(VVAR*(ANEG+APOS)-ANEG)/APOS   
            CTH=RSQM-RMPMIN*(RMPMAX/RMPMIN)**VCTP   
          ENDIF 
        ELSEIF(MVAR.EQ.3) THEN  
          RMNMIN=MAX(RM34,RSQM+CTNMIN)  
          RMNMAX=MAX(RM34,RSQM+CTNMAX)  
          RMPMIN=MAX(RM34,RSQM+CTPMIN)  
          RMPMAX=MAX(RM34,RSQM+CTPMAX)  
          ANEG=LOG(RMNMAX/RMNMIN)   
          APOS=LOG(RMPMAX/RMPMIN)   
          IF(ANEG.GT.0..AND.VVAR*(ANEG+APOS).LE.ANEG) THEN  
            VCTN=VVAR*(ANEG+APOS)/ANEG  
            CTH=RMNMIN*(RMNMAX/RMNMIN)**VCTN-RSQM   
          ELSE  
            VCTP=(VVAR*(ANEG+APOS)-ANEG)/APOS   
            CTH=RMPMIN*(RMPMAX/RMPMIN)**VCTP-RSQM   
          ENDIF 
        ELSEIF(MVAR.EQ.4) THEN  
          RMNMIN=MAX(RM34,RSQM-CTNMIN)  
          RMNMAX=MAX(RM34,RSQM-CTNMAX)  
          RMPMIN=MAX(RM34,RSQM-CTPMIN)  
          RMPMAX=MAX(RM34,RSQM-CTPMAX)  
          ANEG=1./RMNMAX-1./RMNMIN  
          APOS=1./RMPMAX-1./RMPMIN  
          IF(ANEG.GT.0..AND.VVAR*(ANEG+APOS).LE.ANEG) THEN  
            VCTN=VVAR*(ANEG+APOS)/ANEG  
            CTH=RSQM-1./(1./RMNMIN+ANEG*VCTN)   
          ELSE  
            VCTP=(VVAR*(ANEG+APOS)-ANEG)/APOS   
            CTH=RSQM-1./(1./RMPMIN+APOS*VCTP)   
          ENDIF 
        ELSEIF(MVAR.EQ.5) THEN  
          RMNMIN=MAX(RM34,RSQM+CTNMIN)  
          RMNMAX=MAX(RM34,RSQM+CTNMAX)  
          RMPMIN=MAX(RM34,RSQM+CTPMIN)  
          RMPMAX=MAX(RM34,RSQM+CTPMAX)  
          ANEG=1./RMNMIN-1./RMNMAX  
          APOS=1./RMPMIN-1./RMPMAX  
          IF(ANEG.GT.0..AND.VVAR*(ANEG+APOS).LE.ANEG) THEN  
            VCTN=VVAR*(ANEG+APOS)/ANEG  
            CTH=1./(1./RMNMIN-ANEG*VCTN)-RSQM   
          ELSE  
            VCTP=(VVAR*(ANEG+APOS)-ANEG)/APOS   
            CTH=1./(1./RMPMIN-APOS*VCTP)-RSQM   
          ENDIF 
        ENDIF   
        IF(CTH.LT.0.) CTH=MIN(CTNMAX,MAX(CTNMIN,CTH))   
        IF(CTH.GT.0.) CTH=MIN(CTPMAX,MAX(CTPMIN,CTH))   
        VINT(23)=CTH    
    
C...Convert VVAR to tau' variable.  
      ELSEIF(IVAR.EQ.4) THEN    
        TAU=VINT(11)    
        TAUPMN=VINT(16) 
        TAUPMX=VINT(36) 
        IF(MINT(43).EQ.1) THEN  
          TAUP=1.   
        ELSEIF(MVAR.EQ.1) THEN  
          TAUP=TAUPMN*(TAUPMX/TAUPMN)**VVAR 
        ELSE    
          AUPP=(1.-TAU/TAUPMX)**4   
          ALOW=(1.-TAU/TAUPMN)**4   
          TAUP=TAU/(1.-(ALOW+(AUPP-ALOW)*VVAR)**0.25)   
        ENDIF   
        VINT(26)=MIN(TAUPMX,MAX(TAUPMN,TAUP))   
      ENDIF 
    
      RETURN    
      END   
    
C***********************************************************************    
    
      SUBROUTINE PYSIGH(NCHN,SIGS)  
    
C...Differential matrix elements for all included subprocesses. 
C...Note that what is coded is (disregarding the COMFAC factor) 
C...1) for 2 -> 1 processes: s-hat/pi*d(sigma-hat), where,  
C...when d(sigma-hat) is given in the zero-width limit, the delta   
C...function in tau is replaced by a Breit-Wigner:  
C...1/pi*(s*m_res*Gamma_res)/((s*tau-m_res^2)^2+(m_res*Gamma_res)^2);   
C...2) for 2 -> 2 processes: (s-hat)**2/pi*d(sigma-hat)/d(t-hat);   
C...i.e., dimensionless quantities. COMFAC contains the factor  
C...pi/s and the conversion factor from GeV^-2 to mb.   
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)    
      SAVE /LUDAT3/ 
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT3/XSFX(2,-40:40),ISIG(1000,3),SIGH(1000)  
      SAVE /PYINT3/ 
      COMMON/PYINT4/WIDP(21:40,0:40),WIDE(21:40,0:40),WIDS(21:40,3) 
      SAVE /PYINT4/ 
      COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3) 
      SAVE /PYINT5/ 
      DIMENSION X(2),XPQ(-6:6),KFAC(2,-40:40),WDTP(0:40),WDTE(0:40,0:5) 
    
C...Reset number of channels and cross-section. 
      NCHN=0    
      SIGS=0.   
    
C...Read kinematical variables and limits.  
      ISUB=MINT(1)  
      TAUMIN=VINT(11)   
      YSTMIN=VINT(12)   
      CTNMIN=VINT(13)   
      CTPMIN=VINT(14)   
      XT2MIN=VINT(15)   
      TAUPMN=VINT(16)   
      TAU=VINT(21)  
      YST=VINT(22)  
      CTH=VINT(23)  
      XT2=VINT(25)  
      TAUP=VINT(26) 
      TAUMAX=VINT(31)   
      YSTMAX=VINT(32)   
      CTNMAX=VINT(33)   
      CTPMAX=VINT(34)   
      XT2MAX=VINT(35)   
      TAUPMX=VINT(36)   
    
C...Derive kinematical quantities.  
      IF(ISET(ISUB).LE.2.OR.ISET(ISUB).EQ.5) THEN   
        X(1)=SQRT(TAU)*EXP(YST) 
        X(2)=SQRT(TAU)*EXP(-YST)    
      ELSE  
        X(1)=SQRT(TAUP)*EXP(YST)    
        X(2)=SQRT(TAUP)*EXP(-YST)   
      ENDIF 
      IF(MINT(43).EQ.4.AND.ISET(ISUB).GE.1.AND. 
     &(X(1).GT.0.999.OR.X(2).GT.0.999)) RETURN  
      SH=TAU*VINT(2)    
      SQM3=VINT(63) 
      SQM4=VINT(64) 
      RM3=SQM3/SH   
      RM4=SQM4/SH   
      BE34=SQRT((1.-RM3-RM4)**2-4.*RM3*RM4) 
      RPTS=4.*VINT(71)**2/SH    
      BE34L=SQRT(MAX(0.,(1.-RM3-RM4)**2-4.*RM3*RM4-RPTS))   
      RM34=2.*RM3*RM4   
      RSQM=1.+RM34  
      RTHM=(4.*RM3*RM4+RPTS)/(1.-RM3-RM4+BE34L) 
      TH=-0.5*SH*MAX(RTHM,1.-RM3-RM4-BE34*CTH)  
      UH=-0.5*SH*MAX(RTHM,1.-RM3-RM4+BE34*CTH)  
      SQPTH=0.25*SH*BE34**2*(1.-CTH**2) 
      SH2=SH**2 
      TH2=TH**2 
      UH2=UH**2 
    
C...Choice of Q2 scale. 
      IF(ISET(ISUB).EQ.1.OR.ISET(ISUB).EQ.3) THEN   
        Q2=SH   
      ELSEIF(MOD(ISET(ISUB),2).EQ.0.OR.ISET(ISUB).EQ.5) THEN    
        IF(MSTP(32).EQ.1) THEN  
          Q2=2.*SH*TH*UH/(SH**2+TH**2+UH**2)    
        ELSEIF(MSTP(32).EQ.2) THEN  
          Q2=SQPTH+0.5*(SQM3+SQM4)  
        ELSEIF(MSTP(32).EQ.3) THEN  
          Q2=MIN(-TH,-UH)   
        ELSEIF(MSTP(32).EQ.4) THEN  
          Q2=SH 
        ENDIF   
        IF(ISET(ISUB).EQ.5.AND.MSTP(82).GE.2) Q2=Q2+PARP(82)**2 
      ENDIF 
    
C...Store derived kinematical quantities.   
      VINT(41)=X(1) 
      VINT(42)=X(2) 
      VINT(44)=SH   
      VINT(43)=SQRT(SH) 
      VINT(45)=TH   
      VINT(46)=UH   
      VINT(48)=SQPTH    
      VINT(47)=SQRT(SQPTH)  
      VINT(50)=TAUP*VINT(2) 
      VINT(49)=SQRT(MAX(0.,VINT(50)))   
      VINT(52)=Q2   
      VINT(51)=SQRT(Q2) 
    
C...Calculate parton structure functions.   
      IF(ISET(ISUB).LE.0) GOTO 145  
      IF(MINT(43).GE.2) THEN    
        Q2SF=Q2 
        IF(ISET(ISUB).EQ.3.OR.ISET(ISUB).EQ.4) THEN 
          Q2SF=PMAS(23,1)**2    
          IF(ISUB.EQ.8.OR.ISUB.EQ.76.OR.ISUB.EQ.77) Q2SF=PMAS(24,1)**2  
        ENDIF   
        DO 100 I=3-MINT(41),MINT(42)    
        XSF=X(I)    
        IF(ISET(ISUB).EQ.5) XSF=X(I)/VINT(142+I)    
        CALL PYSTFU(MINT(10+I),XSF,Q2SF,XPQ,I)    
        DO 100 KFL=-6,6 
  100   XSFX(I,KFL)=XPQ(KFL)
      ENDIF 
    
C...Calculate alpha_strong and K-factor.    
      IF(MSTP(33).NE.3) AS=ULALPS(Q2)   
      FACK=1.   
      FACA=1.   
      IF(MSTP(33).EQ.1) THEN    
        FACK=PARP(31)   
      ELSEIF(MSTP(33).EQ.2) THEN    
        FACK=PARP(31)   
        FACA=PARP(32)/PARP(31)  
      ELSEIF(MSTP(33).EQ.3) THEN    
        Q2AS=PARP(33)*Q2    
        IF(ISET(ISUB).EQ.5.AND.MSTP(82).GE.2) Q2AS=Q2AS+    
     &  PARU(112)*PARP(82)  
        AS=ULALPS(Q2AS) 
      ENDIF 
      RADC=1.+AS/PARU(1)    
    
C...Set flags for allowed reacting partons/leptons. 
      DO 130 I=1,2  
      DO 110 J=-40,40   
  110 KFAC(I,J)=0   
      IF(MINT(40+I).EQ.1) THEN  
        KFAC(I,MINT(10+I))=1    
      ELSE  
        DO 120 J=-40,40 
        KFAC(I,J)=KFIN(I,J) 
        IF(ABS(J).GT.MSTP(54).AND.J.NE.21) KFAC(I,J)=0  
        IF(ABS(J).LE.6) THEN    
          IF(XSFX(I,J).LT.1.E-10) KFAC(I,J)=0   
        ELSEIF(J.EQ.21) THEN    
          IF(XSFX(I,0).LT.1.E-10) KFAC(I,21)=0  
        ENDIF   
  120   CONTINUE    
      ENDIF 
  130 CONTINUE  
    
C...Lower and upper limit for flavour loops.    
      MIN1=0    
      MAX1=0    
      MIN2=0    
      MAX2=0    
      DO 140 J=-20,20   
      IF(KFAC(1,-J).EQ.1) MIN1=-J   
      IF(KFAC(1,J).EQ.1) MAX1=J 
      IF(KFAC(2,-J).EQ.1) MIN2=-J   
      IF(KFAC(2,J).EQ.1) MAX2=J 
  140 CONTINUE  
      MINA=MIN(MIN1,MIN2)   
      MAXA=MAX(MAX1,MAX2)   
    
C...Common conversion factors (including Jacobian) for subprocesses.    
      SQMZ=PMAS(23,1)**2    
      GMMZ=PMAS(23,1)*PMAS(23,2)    
      SQMW=PMAS(24,1)**2    
      GMMW=PMAS(24,1)*PMAS(24,2)    
      SQMH=PMAS(25,1)**2    
      GMMH=PMAS(25,1)*PMAS(25,2)    
      SQMZP=PMAS(32,1)**2   
      GMMZP=PMAS(32,1)*PMAS(32,2)   
      SQMHC=PMAS(37,1)**2   
      GMMHC=PMAS(37,1)*PMAS(37,2)   
      SQMR=PMAS(40,1)**2    
      GMMR=PMAS(40,1)*PMAS(40,2)    
      AEM=PARU(101) 
      XW=PARU(102)  
    
C...Phase space integral in tau and y*. 
      COMFAC=PARU(1)*PARU(5)/VINT(2)    
      IF(MINT(43).EQ.4) COMFAC=COMFAC*FACK  
      IF((MINT(43).GE.2.OR.ISET(ISUB).EQ.3.OR.ISET(ISUB).EQ.4).AND. 
     &ISET(ISUB).NE.5) THEN 
        ATAU0=LOG(TAUMAX/TAUMIN)    
        ATAU1=(TAUMAX-TAUMIN)/(TAUMAX*TAUMIN)   
        H1=COEF(ISUB,1)+(ATAU0/ATAU1)*COEF(ISUB,2)/TAU  
        IF(MINT(72).GE.1) THEN  
          TAUR1=VINT(73)    
          GAMR1=VINT(74)    
          ATAU2=LOG(TAUMAX/TAUMIN*(TAUMIN+TAUR1)/(TAUMAX+TAUR1))/TAUR1  
          ATAU3=(ATAN((TAUMAX-TAUR1)/GAMR1)-ATAN((TAUMIN-TAUR1)/GAMR1))/    
     &    GAMR1 
          H1=H1+(ATAU0/ATAU2)*COEF(ISUB,3)/(TAU+TAUR1)+ 
     &    (ATAU0/ATAU3)*COEF(ISUB,4)*TAU/((TAU-TAUR1)**2+GAMR1**2)  
        ENDIF   
        IF(MINT(72).EQ.2) THEN  
          TAUR2=VINT(75)    
          GAMR2=VINT(76)    
          ATAU4=LOG(TAUMAX/TAUMIN*(TAUMIN+TAUR2)/(TAUMAX+TAUR2))/TAUR2  
          ATAU5=(ATAN((TAUMAX-TAUR2)/GAMR2)-ATAN((TAUMIN-TAUR2)/GAMR2))/    
     &    GAMR2 
          H1=H1+(ATAU0/ATAU4)*COEF(ISUB,5)/(TAU+TAUR2)+ 
     &    (ATAU0/ATAU5)*COEF(ISUB,6)*TAU/((TAU-TAUR2)**2+GAMR2**2)  
        ENDIF   
        COMFAC=COMFAC*ATAU0/(TAU*H1)    
      ENDIF 
      IF(MINT(43).EQ.4.AND.ISET(ISUB).NE.5) THEN    
        AYST0=YSTMAX-YSTMIN 
        AYST1=0.5*(YSTMAX-YSTMIN)**2    
        AYST2=AYST1 
        AYST3=2.*(ATAN(EXP(YSTMAX))-ATAN(EXP(YSTMIN)))  
        H2=(AYST0/AYST1)*COEF(ISUB,7)*(YST-YSTMIN)+(AYST0/AYST2)*   
     &  COEF(ISUB,8)*(YSTMAX-YST)+(AYST0/AYST3)*COEF(ISUB,9)/COSH(YST)  
        COMFAC=COMFAC*AYST0/H2  
      ENDIF 
    
C...2 -> 1 processes: reduction in angular part of phase space integral 
C...for case of decaying resonance. 
      ACTH0=CTNMAX-CTNMIN+CTPMAX-CTPMIN 
clin-4/2008 modified a la pythia6115.f to avoid invalid MDCY subcript#1,
c     also break up compound IF statements:
c      IF((ISET(ISUB).EQ.1.OR.ISET(ISUB).EQ.3).AND.  
c     &MDCY(KFPR(ISUB,1),1).EQ.1) THEN   
c        IF(KFPR(ISUB,1).EQ.25.OR.KFPR(ISUB,1).EQ.37) THEN   
c          COMFAC=COMFAC*0.5*ACTH0   
c        ELSE    
c          COMFAC=COMFAC*0.125*(3.*ACTH0+CTNMAX**3-CTNMIN**3+    
c     &    CTPMAX**3-CTPMIN**3)  
c        ENDIF   
      IF(ISET(ISUB).EQ.1.OR.ISET(ISUB).EQ.3) THEN
         if(MDCY(LUCOMP(KFPR(ISUB,1)),1).EQ.1) then
            IF(KFPR(ISUB,1).EQ.25.OR.KFPR(ISUB,1).EQ.37) THEN   
               COMFAC=COMFAC*0.5*ACTH0   
            ELSE    
               COMFAC=COMFAC*0.125*(3.*ACTH0+CTNMAX**3-CTNMIN**3+    
     &              CTPMAX**3-CTPMIN**3)  
            ENDIF
         endif
c
C...2 -> 2 processes: angular part of phase space integral. 
      ELSEIF(ISET(ISUB).EQ.2.OR.ISET(ISUB).EQ.4) THEN   
        ACTH1=LOG((MAX(RM34,RSQM-CTNMIN)*MAX(RM34,RSQM-CTPMIN))/    
     &  (MAX(RM34,RSQM-CTNMAX)*MAX(RM34,RSQM-CTPMAX)))  
        ACTH2=LOG((MAX(RM34,RSQM+CTNMAX)*MAX(RM34,RSQM+CTPMAX))/    
     &  (MAX(RM34,RSQM+CTNMIN)*MAX(RM34,RSQM+CTPMIN)))  
        ACTH3=1./MAX(RM34,RSQM-CTNMAX)-1./MAX(RM34,RSQM-CTNMIN)+    
     &  1./MAX(RM34,RSQM-CTPMAX)-1./MAX(RM34,RSQM-CTPMIN)   
        ACTH4=1./MAX(RM34,RSQM+CTNMIN)-1./MAX(RM34,RSQM+CTNMAX)+    
     &  1./MAX(RM34,RSQM+CTPMIN)-1./MAX(RM34,RSQM+CTPMAX)   
        H3=COEF(ISUB,10)+   
     &  (ACTH0/ACTH1)*COEF(ISUB,11)/MAX(RM34,RSQM-CTH)+ 
     &  (ACTH0/ACTH2)*COEF(ISUB,12)/MAX(RM34,RSQM+CTH)+ 
     &  (ACTH0/ACTH3)*COEF(ISUB,13)/MAX(RM34,RSQM-CTH)**2+  
     &  (ACTH0/ACTH4)*COEF(ISUB,14)/MAX(RM34,RSQM+CTH)**2   
        COMFAC=COMFAC*ACTH0*0.5*BE34/H3 
      ENDIF 
    
C...2 -> 3, 4 processes: phace space integral in tau'.  
      IF(MINT(43).GE.2.AND.(ISET(ISUB).EQ.3.OR.ISET(ISUB).EQ.4)) THEN   
        ATAUP0=LOG(TAUPMX/TAUPMN)   
        ATAUP1=((1.-TAU/TAUPMX)**4-(1.-TAU/TAUPMN)**4)/(4.*TAU) 
        H4=COEF(ISUB,15)+   
     &  ATAUP0/ATAUP1*COEF(ISUB,16)/TAUP*(1.-TAU/TAUP)**3   
        IF(1.-TAU/TAUP.GT.1.E-4) THEN   
          FZW=(1.+TAU/TAUP)*LOG(TAUP/TAU)-2.*(1.-TAU/TAUP)  
        ELSE    
          FZW=1./6.*(1.-TAU/TAUP)**3*TAU/TAUP   
        ENDIF   
        COMFAC=COMFAC*ATAUP0*FZW/H4 
      ENDIF 
    
C...Phase space integral for low-pT and multiple interactions.  
      IF(ISET(ISUB).EQ.5) THEN  
        COMFAC=PARU(1)*PARU(5)*FACK*0.5*VINT(2)/SH2 
        ATAU0=LOG(2.*(1.+SQRT(1.-XT2))/XT2-1.)  
        ATAU1=2.*ATAN(1./XT2-1.)/SQRT(XT2)  
        H1=COEF(ISUB,1)+(ATAU0/ATAU1)*COEF(ISUB,2)/SQRT(TAU)    
        COMFAC=COMFAC*ATAU0/H1  
        AYST0=YSTMAX-YSTMIN 
        AYST1=0.5*(YSTMAX-YSTMIN)**2    
        AYST3=2.*(ATAN(EXP(YSTMAX))-ATAN(EXP(YSTMIN)))  
        H2=(AYST0/AYST1)*COEF(ISUB,7)*(YST-YSTMIN)+(AYST0/AYST1)*   
     &  COEF(ISUB,8)*(YSTMAX-YST)+(AYST0/AYST3)*COEF(ISUB,9)/COSH(YST)  
        COMFAC=COMFAC*AYST0/H2  
        IF(MSTP(82).LE.1) COMFAC=COMFAC*XT2**2*(1./VINT(149)-1.)    
C...For MSTP(82)>=2 an additional factor (xT2/(xT2+VINT(149))**2 is 
C...introduced to make cross-section finite for xT2 -> 0.   
        IF(MSTP(82).GE.2) COMFAC=COMFAC*XT2**2/(VINT(149)*  
     &  (1.+VINT(149))) 
      ENDIF 
    
C...A: 2 -> 1, tree diagrams.   
    
  145 IF(ISUB.LE.10) THEN   
      IF(ISUB.EQ.1) THEN    
C...f + fb -> gamma*/Z0.    
        MINT(61)=2  
        CALL PYWIDT(23,SQRT(SH),WDTP,WDTE)  
        FACZ=COMFAC*AEM**2*4./3.    
        DO 150 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 150    
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        FACF=1. 
        IF(IABS(I).LE.10) FACF=FACA/3.  
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACF*FACZ*(EI**2*VINT(111)+EI*VI/(8.*XW*(1.-XW))*    
     &  SH*(SH-SQMZ)/((SH-SQMZ)**2+GMMZ**2)*VINT(112)+(VI**2+AI**2)/    
     &  (16.*XW*(1.-XW))**2*SH2/((SH-SQMZ)**2+GMMZ**2)*VINT(114))   
  150   CONTINUE    
    
      ELSEIF(ISUB.EQ.2) THEN    
C...f + fb' -> W+/-.    
        CALL PYWIDT(24,SQRT(SH),WDTP,WDTE)  
        FACW=COMFAC*(AEM/XW)**2*1./24*SH2/((SH-SQMW)**2+GMMW**2)    
        DO 170 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 170   
        IA=IABS(I)  
        DO 160 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 160   
        JA=IABS(J)  
        IF(I*J.GT.0.OR.MOD(IA+JA,2).EQ.0) GOTO 160  
        IF((IA.LE.10.AND.JA.GT.10).OR.(IA.GT.10.AND.JA.LE.10)) GOTO 160 
        KCHW=(KCHG(IA,1)*ISIGN(1,I)+KCHG(JA,1)*ISIGN(1,J))/3    
        FACF=1. 
        IF(IA.LE.10) FACF=VCKM((IA+1)/2,(JA+1)/2)*FACA/3.   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACF*FACW*(WDTE(0,1)+WDTE(0,(5-KCHW)/2)+WDTE(0,4))   
  160   CONTINUE    
  170   CONTINUE    
    
      ELSEIF(ISUB.EQ.3) THEN    
C...f + fb -> H0.   
        CALL PYWIDT(25,SQRT(SH),WDTP,WDTE)  
        FACH=COMFAC*(AEM/XW)**2*1./48.*(SH/SQMW)**2*    
     &  SH2/((SH-SQMH)**2+GMMH**2)*(WDTE(0,1)+WDTE(0,2)+WDTE(0,4))  
        DO 180 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 180    
        RMQ=PMAS(IABS(I),1)**2/SH   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACH*RMQ*SQRT(MAX(0.,1.-4.*RMQ)) 
  180   CONTINUE    
    
      ELSEIF(ISUB.EQ.4) THEN    
C...gamma + W+/- -> W+/-.   
    
      ELSEIF(ISUB.EQ.5) THEN    
C...Z0 + Z0 -> H0.  
        CALL PYWIDT(25,SQRT(SH),WDTP,WDTE)  
        FACH=COMFAC*1./(128.*PARU(1)**2*16.*(1.-XW)**3)*(AEM/XW)**4*    
     &  (SH/SQMW)**2*SH2/((SH-SQMH)**2+GMMH**2)*    
     &  (WDTE(0,1)+WDTE(0,2)+WDTE(0,4)) 
        DO 200 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 200   
        DO 190 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 190   
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        EJ=KCHG(IABS(J),1)/3.   
        AJ=SIGN(1.,EJ)  
        VJ=AJ-4.*EJ*XW  
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACH*(VI**2+AI**2)*(VJ**2+AJ**2) 
  190   CONTINUE    
  200   CONTINUE    
    
      ELSEIF(ISUB.EQ.6) THEN    
C...Z0 + W+/- -> W+/-.  
    
      ELSEIF(ISUB.EQ.7) THEN    
C...W+ + W- -> Z0.  
    
      ELSEIF(ISUB.EQ.8) THEN    
C...W+ + W- -> H0.  
        CALL PYWIDT(25,SQRT(SH),WDTP,WDTE)  
        FACH=COMFAC*1./(128*PARU(1)**2)*(AEM/XW)**4*(SH/SQMW)**2*   
     &  SH2/((SH-SQMH)**2+GMMH**2)*(WDTE(0,1)+WDTE(0,2)+WDTE(0,4))  
        DO 220 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 220   
        EI=SIGN(1.,FLOAT(I))*KCHG(IABS(I),1)    
        DO 210 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 210   
        EJ=SIGN(1.,FLOAT(J))*KCHG(IABS(J),1)    
        IF(EI*EJ.GT.0.) GOTO 210    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACH*VINT(180+I)*VINT(180+J) 
  210   CONTINUE    
  220   CONTINUE    
      ENDIF 
    
C...B: 2 -> 2, tree diagrams.   
    
      ELSEIF(ISUB.LE.20) THEN   
      IF(ISUB.EQ.11) THEN   
C...f + f' -> f + f'.   
        FACQQ1=COMFAC*AS**2*4./9.*(SH2+UH2)/TH2 
        FACQQB=COMFAC*AS**2*4./9.*((SH2+UH2)/TH2*FACA-  
     &  MSTP(34)*2./3.*UH2/(SH*TH)) 
        FACQQ2=COMFAC*AS**2*4./9.*((SH2+TH2)/UH2-   
     &  MSTP(34)*2./3.*SH2/(TH*UH)) 
        DO 240 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 240   
        DO 230 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 230   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACQQ1   
        IF(I.EQ.-J) SIGH(NCHN)=FACQQB   
        IF(I.EQ.J) THEN 
          SIGH(NCHN)=0.5*SIGH(NCHN) 
          NCHN=NCHN+1   
          ISIG(NCHN,1)=I    
          ISIG(NCHN,2)=J    
          ISIG(NCHN,3)=2    
          SIGH(NCHN)=0.5*FACQQ2 
        ENDIF   
  230   CONTINUE    
  240   CONTINUE    
    
      ELSEIF(ISUB.EQ.12) THEN   
C...f + fb -> f' + fb' (q + qb -> q' + qb' only).   
        CALL PYWIDT(21,SQRT(SH),WDTP,WDTE)  
        FACQQB=COMFAC*AS**2*4./9.*(TH2+UH2)/SH2*(WDTE(0,1)+WDTE(0,2)+   
     &  WDTE(0,3)+WDTE(0,4))    
        DO 250 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 250    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACQQB   
  250   CONTINUE    
    
      ELSEIF(ISUB.EQ.13) THEN   
C...f + fb -> g + g (q + qb -> g + g only). 
        FACGG1=COMFAC*AS**2*32./27.*(UH/TH-(2.+MSTP(34)*1./4.)*UH2/SH2) 
        FACGG2=COMFAC*AS**2*32./27.*(TH/UH-(2.+MSTP(34)*1./4.)*TH2/SH2) 
        DO 260 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 260    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=0.5*FACGG1   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=2  
        SIGH(NCHN)=0.5*FACGG2   
  260   CONTINUE    
    
      ELSEIF(ISUB.EQ.14) THEN   
C...f + fb -> g + gamma (q + qb -> g + gamma only). 
        FACGG=COMFAC*AS*AEM*8./9.*(TH2+UH2)/(TH*UH) 
        DO 270 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 270    
        EI=KCHG(IABS(I),1)/3.   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACGG*EI**2  
  270   CONTINUE    
    
      ELSEIF(ISUB.EQ.15) THEN   
C...f + fb -> g + Z0 (q + qb -> g + Z0 only).   
        FACZG=COMFAC*AS*AEM/(XW*(1.-XW))*1./18.*    
     &  (TH2+UH2+2.*SQM4*SH)/(TH*UH)    
        FACZG=FACZG*WIDS(23,2)  
        DO 280 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 280    
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACZG*(VI**2+AI**2)  
  280   CONTINUE    
    
      ELSEIF(ISUB.EQ.16) THEN   
C...f + fb' -> g + W+/- (q + qb' -> g + W+/- only). 
        FACWG=COMFAC*AS*AEM/XW*2./9.*(TH2+UH2+2.*SQM4*SH)/(TH*UH)   
        DO 300 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 300   
        IA=IABS(I)  
        DO 290 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 290   
        JA=IABS(J)  
        IF(I*J.GT.0.OR.MOD(IA+JA,2).EQ.0) GOTO 290  
        KCHW=(KCHG(IA,1)*ISIGN(1,I)+KCHG(JA,1)*ISIGN(1,J))/3    
        FCKM=1. 
        IF(MINT(43).EQ.4) FCKM=VCKM((IA+1)/2,(JA+1)/2)  
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACWG*FCKM*WIDS(24,(5-KCHW)/2)   
  290   CONTINUE    
  300   CONTINUE    
    
      ELSEIF(ISUB.EQ.17) THEN   
C...f + fb -> g + H0 (q + qb -> g + H0 only).   
    
      ELSEIF(ISUB.EQ.18) THEN   
C...f + fb -> gamma + gamma.    
        FACGG=COMFAC*FACA*AEM**2*1./3.*(TH2+UH2)/(TH*UH)    
        DO 310 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 310    
        EI=KCHG(IABS(I),1)/3.   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACGG*EI**4  
  310   CONTINUE    
    
      ELSEIF(ISUB.EQ.19) THEN   
C...f + fb -> gamma + Z0.   
        FACGZ=COMFAC*FACA*AEM**2/(XW*(1.-XW))*1./24.*   
     &  (TH2+UH2+2.*SQM4*SH)/(TH*UH)    
        FACGZ=FACGZ*WIDS(23,2)  
        DO 320 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 320    
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACGZ*EI**2*(VI**2+AI**2)    
  320   CONTINUE    
    
      ELSEIF(ISUB.EQ.20) THEN   
C...f + fb' -> gamma + W+/-.    
        FACGW=COMFAC*FACA*AEM**2/XW*1./6.*  
     &  ((2.*UH-TH)/(3.*(SH-SQM4)))**2*(TH2+UH2+2.*SQM4*SH)/(TH*UH) 
        DO 340 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 340   
        IA=IABS(I)  
        DO 330 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 330   
        JA=IABS(J)  
        IF(I*J.GT.0.OR.MOD(IA+JA,2).EQ.0) GOTO 330  
        KCHW=(KCHG(IA,1)*ISIGN(1,I)+KCHG(JA,1)*ISIGN(1,J))/3    
        FCKM=1. 
        IF(MINT(43).EQ.4) FCKM=VCKM((IA+1)/2,(JA+1)/2)  
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACGW*FCKM*WIDS(24,(5-KCHW)/2)   
  330   CONTINUE    
  340   CONTINUE    
      ENDIF 
    
      ELSEIF(ISUB.LE.30) THEN   
      IF(ISUB.EQ.21) THEN   
C...f + fb -> gamma + H0.   
    
      ELSEIF(ISUB.EQ.22) THEN   
C...f + fb -> Z0 + Z0.  
        FACZZ=COMFAC*FACA*(AEM/(XW*(1.-XW)))**2*1./768.*    
     &  (UH/TH+TH/UH+2.*(SQM3+SQM4)*SH/(TH*UH)- 
     &  SQM3*SQM4*(1./TH2+1./UH2))  
        FACZZ=FACZZ*WIDS(23,1)  
        DO 350 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 350    
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACZZ*(VI**4+6.*VI**2*AI**2+AI**4)   
  350   CONTINUE    
    
      ELSEIF(ISUB.EQ.23) THEN   
C...f + fb' -> Z0 + W+/-.   
        FACZW=COMFAC*FACA*(AEM/XW)**2*1./6. 
        FACZW=FACZW*WIDS(23,2)  
        THUH=MAX(TH*UH-SQM3*SQM4,SH*CKIN(3)**2) 
        DO 370 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 370   
        IA=IABS(I)  
        DO 360 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 360   
        JA=IABS(J)  
        IF(I*J.GT.0.OR.MOD(IA+JA,2).EQ.0) GOTO 360  
        KCHW=(KCHG(IA,1)*ISIGN(1,I)+KCHG(JA,1)*ISIGN(1,J))/3    
        EI=KCHG(IA,1)/3.    
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        EJ=KCHG(JA,1)/3.    
        AJ=SIGN(1.,EJ)  
        VJ=AJ-4.*EJ*XW  
        IF(VI+AI.GT.0) THEN 
          VISAV=VI  
          AISAV=AI  
          VI=VJ 
          AI=AJ 
          VJ=VISAV  
          AJ=AISAV  
        ENDIF   
        FCKM=1. 
        IF(MINT(43).EQ.4) FCKM=VCKM((IA+1)/2,(JA+1)/2)  
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACZW*FCKM*(1./(SH-SQMW)**2* 
     &  ((9.-8.*XW)/4.*THUH+(8.*XW-6.)/4.*SH*(SQM3+SQM4))+  
     &  (THUH-SH*(SQM3+SQM4))/(2.*(SH-SQMW))*((VJ+AJ)/TH-(VI+AI)/UH)+   
     &  THUH/(16.*(1.-XW))*((VJ+AJ)**2/TH2+(VI+AI)**2/UH2)+ 
     &  SH*(SQM3+SQM4)/(8.*(1.-XW))*(VI+AI)*(VJ+AJ)/(TH*UH))*   
     &  WIDS(24,(5-KCHW)/2) 
  360   CONTINUE    
  370   CONTINUE    
    
      ELSEIF(ISUB.EQ.24) THEN   
C...f + fb -> Z0 + H0.  
        THUH=MAX(TH*UH-SQM3*SQM4,SH*CKIN(3)**2) 
        FACHZ=COMFAC*FACA*(AEM/(XW*(1.-XW)))**2*1./96.* 
     &  (THUH+2.*SH*SQMZ)/(SH-SQMZ)**2  
        FACHZ=FACHZ*WIDS(23,2)*WIDS(25,2)   
        DO 380 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 380    
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACHZ*(VI**2+AI**2)  
  380   CONTINUE    
    
      ELSEIF(ISUB.EQ.25) THEN   
C...f + fb -> W+ + W-.  
        FACWW=COMFAC*FACA*(AEM/XW)**2*1./12.    
        FACWW=FACWW*WIDS(24,1)  
        THUH=MAX(TH*UH-SQM3*SQM4,SH*CKIN(3)**2) 
        DO 390 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 390    
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        DSIGWW=THUH/SH2*(3.-(SH-3.*(SQM3+SQM4))/(SH-SQMZ)*  
     &  (VI+AI)/(2.*AI*(1.-XW))+(SH/(SH-SQMZ))**2*  
     &  (1.-2.*(SQM3+SQM4)/SH+12.*SQM3*SQM4/SH2)*(VI**2+AI**2)/ 
     &  (8.*(1.-XW)**2))-2.*SQMZ/(SH-SQMZ)*(VI+AI)/AI+  
     &  SQMZ*SH/(SH-SQMZ)**2*(1.-2.*(SQM3+SQM4)/SH)*(VI**2+AI**2)/  
     &  (2.*(1.-XW))    
        IF(KCHG(IABS(I),1).LT.0) THEN   
          DSIGWW=DSIGWW+2.*(1.+SQMZ/(SH-SQMZ)*(VI+AI)/(2.*AI))* 
     &    (THUH/(SH*TH)-(SQM3+SQM4)/TH)+THUH/TH2    
        ELSE    
          DSIGWW=DSIGWW+2.*(1.+SQMZ/(SH-SQMZ)*(VI+AI)/(2.*AI))* 
     &    (THUH/(SH*UH)-(SQM3+SQM4)/UH)+THUH/UH2    
        ENDIF   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACWW*DSIGWW 
  390   CONTINUE    
    
      ELSEIF(ISUB.EQ.26) THEN   
C...f + fb' -> W+/- + H0.   
        THUH=MAX(TH*UH-SQM3*SQM4,SH*CKIN(3)**2) 
        FACHW=COMFAC*FACA*(AEM/XW)**2*1./24.*(THUH+2.*SH*SQMW)/ 
     &  (SH-SQMW)**2    
        FACHW=FACHW*WIDS(25,2)  
        DO 410 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 410   
        IA=IABS(I)  
        DO 400 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(1,J).EQ.0) GOTO 400   
        JA=IABS(J)  
        IF(I*J.GT.0.OR.MOD(IA+JA,2).EQ.0) GOTO 400  
        KCHW=(KCHG(IA,1)*ISIGN(1,I)+KCHG(JA,1)*ISIGN(1,J))/3    
        FCKM=1. 
        IF(MINT(43).EQ.4) FCKM=VCKM((IA+1)/2,(JA+1)/2)  
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACHW*FCKM*WIDS(24,(5-KCHW)/2)   
  400   CONTINUE    
  410   CONTINUE    
    
      ELSEIF(ISUB.EQ.27) THEN   
C...f + fb -> H0 + H0.  
    
      ELSEIF(ISUB.EQ.28) THEN   
C...f + g -> f + g (q + g -> q + g only).   
        FACQG1=COMFAC*AS**2*4./9.*((2.+MSTP(34)*1./4.)*UH2/TH2-UH/SH)*  
     &  FACA    
        FACQG2=COMFAC*AS**2*4./9.*((2.+MSTP(34)*1./4.)*SH2/TH2-SH/UH)   
        DO 430 I=MINA,MAXA  
        IF(I.EQ.0) GOTO 430 
        DO 420 ISDE=1,2 
        IF(ISDE.EQ.1.AND.KFAC(1,I)*KFAC(2,21).EQ.0) GOTO 420    
        IF(ISDE.EQ.2.AND.KFAC(1,21)*KFAC(2,I).EQ.0) GOTO 420    
        NCHN=NCHN+1 
        ISIG(NCHN,ISDE)=I   
        ISIG(NCHN,3-ISDE)=21    
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACQG1   
        NCHN=NCHN+1 
        ISIG(NCHN,ISDE)=I   
        ISIG(NCHN,3-ISDE)=21    
        ISIG(NCHN,3)=2  
        SIGH(NCHN)=FACQG2   
  420   CONTINUE    
  430   CONTINUE    
    
      ELSEIF(ISUB.EQ.29) THEN   
C...f + g -> f + gamma (q + g -> q + gamma only).   
        FGQ=COMFAC*FACA*AS*AEM*1./3.*(SH2+UH2)/(-SH*UH) 
        DO 450 I=MINA,MAXA  
        IF(I.EQ.0) GOTO 450 
        EI=KCHG(IABS(I),1)/3.   
        FACGQ=FGQ*EI**2 
        DO 440 ISDE=1,2 
        IF(ISDE.EQ.1.AND.KFAC(1,I)*KFAC(2,21).EQ.0) GOTO 440    
        IF(ISDE.EQ.2.AND.KFAC(1,21)*KFAC(2,I).EQ.0) GOTO 440    
        NCHN=NCHN+1 
        ISIG(NCHN,ISDE)=I   
        ISIG(NCHN,3-ISDE)=21    
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACGQ    
  440   CONTINUE    
  450   CONTINUE    
    
      ELSEIF(ISUB.EQ.30) THEN   
C...f + g -> f + Z0 (q + g -> q + Z0 only). 
        FZQ=COMFAC*FACA*AS*AEM/(XW*(1.-XW))*1./48.* 
     &  (SH2+UH2+2.*SQM4*TH)/(-SH*UH)   
        FZQ=FZQ*WIDS(23,2)  
        DO 470 I=MINA,MAXA  
        IF(I.EQ.0) GOTO 470 
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        FACZQ=FZQ*(VI**2+AI**2) 
        DO 460 ISDE=1,2 
        IF(ISDE.EQ.1.AND.KFAC(1,I)*KFAC(2,21).EQ.0) GOTO 460    
        IF(ISDE.EQ.2.AND.KFAC(1,21)*KFAC(2,I).EQ.0) GOTO 460    
        NCHN=NCHN+1 
        ISIG(NCHN,ISDE)=I   
        ISIG(NCHN,3-ISDE)=21    
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACZQ    
  460   CONTINUE    
  470   CONTINUE    
      ENDIF 
    
      ELSEIF(ISUB.LE.40) THEN   
      IF(ISUB.EQ.31) THEN   
C...f + g -> f' + W+/- (q + g -> q' + W+/- only).   
        FACWQ=COMFAC*FACA*AS*AEM/XW*1./12.* 
     &  (SH2+UH2+2.*SQM4*TH)/(-SH*UH)   
        DO 490 I=MINA,MAXA  
        IF(I.EQ.0) GOTO 490 
        IA=IABS(I)  
        KCHW=ISIGN(1,KCHG(IA,1)*ISIGN(1,I)) 
        DO 480 ISDE=1,2 
        IF(ISDE.EQ.1.AND.KFAC(1,I)*KFAC(2,21).EQ.0) GOTO 480    
        IF(ISDE.EQ.2.AND.KFAC(1,21)*KFAC(2,I).EQ.0) GOTO 480    
        NCHN=NCHN+1 
        ISIG(NCHN,ISDE)=I   
        ISIG(NCHN,3-ISDE)=21    
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACWQ*VINT(180+I)*WIDS(24,(5-KCHW)/2)    
  480   CONTINUE    
  490   CONTINUE    
    
      ELSEIF(ISUB.EQ.32) THEN   
C...f + g -> f + H0 (q + g -> q + H0 only). 
    
      ELSEIF(ISUB.EQ.33) THEN   
C...f + gamma -> f + g (q + gamma -> q + g only).   
    
      ELSEIF(ISUB.EQ.34) THEN   
C...f + gamma -> f + gamma. 
    
      ELSEIF(ISUB.EQ.35) THEN   
C...f + gamma -> f + Z0.    
    
      ELSEIF(ISUB.EQ.36) THEN   
C...f + gamma -> f' + W+/-. 
    
      ELSEIF(ISUB.EQ.37) THEN   
C...f + gamma -> f + H0.    
    
      ELSEIF(ISUB.EQ.38) THEN   
C...f + Z0 -> f + g (q + Z0 -> q + g only). 
    
      ELSEIF(ISUB.EQ.39) THEN   
C...f + Z0 -> f + gamma.    
    
      ELSEIF(ISUB.EQ.40) THEN   
C...f + Z0 -> f + Z0.   
      ENDIF 
    
      ELSEIF(ISUB.LE.50) THEN   
      IF(ISUB.EQ.41) THEN   
C...f + Z0 -> f' + W+/-.    
    
      ELSEIF(ISUB.EQ.42) THEN   
C...f + Z0 -> f + H0.   
    
      ELSEIF(ISUB.EQ.43) THEN   
C...f + W+/- -> f' + g (q + W+/- -> q' + g only).   
    
      ELSEIF(ISUB.EQ.44) THEN   
C...f + W+/- -> f' + gamma. 
    
      ELSEIF(ISUB.EQ.45) THEN   
C...f + W+/- -> f' + Z0.    
    
      ELSEIF(ISUB.EQ.46) THEN   
C...f + W+/- -> f' + W+/-.  
    
      ELSEIF(ISUB.EQ.47) THEN   
C...f + W+/- -> f' + H0.    
    
      ELSEIF(ISUB.EQ.48) THEN   
C...f + H0 -> f + g (q + H0 -> q + g only). 
    
      ELSEIF(ISUB.EQ.49) THEN   
C...f + H0 -> f + gamma.    
    
      ELSEIF(ISUB.EQ.50) THEN   
C...f + H0 -> f + Z0.   
      ENDIF 
    
      ELSEIF(ISUB.LE.60) THEN   
      IF(ISUB.EQ.51) THEN   
C...f + H0 -> f' + W+/-.    
    
      ELSEIF(ISUB.EQ.52) THEN   
C...f + H0 -> f + H0.   
    
      ELSEIF(ISUB.EQ.53) THEN   
C...g + g -> f + fb (g + g -> q + qb only). 
        CALL PYWIDT(21,SQRT(SH),WDTP,WDTE)  
        FACQQ1=COMFAC*AS**2*1./6.*(UH/TH-(2.+MSTP(34)*1./4.)*UH2/SH2)*  
     &  (WDTE(0,1)+WDTE(0,2)+WDTE(0,3)+WDTE(0,4))*FACA  
        FACQQ2=COMFAC*AS**2*1./6.*(TH/UH-(2.+MSTP(34)*1./4.)*TH2/SH2)*  
     &  (WDTE(0,1)+WDTE(0,2)+WDTE(0,3)+WDTE(0,4))*FACA  
        IF(KFAC(1,21)*KFAC(2,21).EQ.0) GOTO 500 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACQQ1   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=2  
        SIGH(NCHN)=FACQQ2   
  500   CONTINUE    
    
      ELSEIF(ISUB.EQ.54) THEN   
C...g + gamma -> f + fb (g + gamma -> q + qb only). 
    
      ELSEIF(ISUB.EQ.55) THEN   
C...g + gamma -> f + fb (g + gamma -> q + qb only). 
    
      ELSEIF(ISUB.EQ.56) THEN   
C...g + gamma -> f + fb (g + gamma -> q + qb only). 
    
      ELSEIF(ISUB.EQ.57) THEN   
C...g + gamma -> f + fb (g + gamma -> q + qb only). 
    
      ELSEIF(ISUB.EQ.58) THEN   
C...gamma + gamma -> f + fb.    
    
      ELSEIF(ISUB.EQ.59) THEN   
C...gamma + Z0 -> f + fb.   
    
      ELSEIF(ISUB.EQ.60) THEN   
C...gamma + W+/- -> f + fb'.    
      ENDIF 
    
      ELSEIF(ISUB.LE.70) THEN   
      IF(ISUB.EQ.61) THEN   
C...gamma + H0 -> f + fb.   
    
      ELSEIF(ISUB.EQ.62) THEN   
C...Z0 + Z0 -> f + fb.  
    
      ELSEIF(ISUB.EQ.63) THEN   
C...Z0 + W+/- -> f + fb'.   
    
      ELSEIF(ISUB.EQ.64) THEN   
C...Z0 + H0 -> f + fb.  
    
      ELSEIF(ISUB.EQ.65) THEN   
C...W+ + W- -> f + fb.  
    
      ELSEIF(ISUB.EQ.66) THEN   
C...W+/- + H0 -> f + fb'.   
    
      ELSEIF(ISUB.EQ.67) THEN   
C...H0 + H0 -> f + fb.  
    
      ELSEIF(ISUB.EQ.68) THEN   
C...g + g -> g + g. 
        FACGG1=COMFAC*AS**2*9./4.*(SH2/TH2+2.*SH/TH+3.+2.*TH/SH+    
     &  TH2/SH2)*FACA   
        FACGG2=COMFAC*AS**2*9./4.*(UH2/SH2+2.*UH/SH+3.+2.*SH/UH+    
     &  SH2/UH2)*FACA   
        FACGG3=COMFAC*AS**2*9./4.*(TH2/UH2+2.*TH/UH+3+2.*UH/TH+UH2/TH2) 
        IF(KFAC(1,21)*KFAC(2,21).EQ.0) GOTO 510 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=0.5*FACGG1   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=2  
        SIGH(NCHN)=0.5*FACGG2   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=3  
        SIGH(NCHN)=0.5*FACGG3   
  510   CONTINUE    
    
      ELSEIF(ISUB.EQ.69) THEN   
C...gamma + gamma -> W+ + W-.   
    
      ELSEIF(ISUB.EQ.70) THEN   
C...gamma + W+/- -> gamma + W+/-.   
      ENDIF 
    
      ELSEIF(ISUB.LE.80) THEN   
      IF(ISUB.EQ.71) THEN   
C...Z0 + Z0 -> Z0 + Z0. 
        BE2=1.-4.*SQMZ/SH   
        TH=-0.5*SH*BE2*(1.-CTH) 
        UH=-0.5*SH*BE2*(1.+CTH) 
        SHANG=1./(1.-XW)*SQMW/SQMZ*(1.+BE2)**2  
        ASHRE=(SH-SQMH)/((SH-SQMH)**2+GMMH**2)*SHANG    
        ASHIM=-GMMH/((SH-SQMH)**2+GMMH**2)*SHANG    
        THANG=1./(1.-XW)*SQMW/SQMZ*(BE2-CTH)**2 
        ATHRE=(TH-SQMH)/((TH-SQMH)**2+GMMH**2)*THANG    
        ATHIM=-GMMH/((TH-SQMH)**2+GMMH**2)*THANG    
        UHANG=1./(1.-XW)*SQMW/SQMZ*(BE2+CTH)**2 
        AUHRE=(UH-SQMH)/((UH-SQMH)**2+GMMH**2)*UHANG    
        AUHIM=-GMMH/((UH-SQMH)**2+GMMH**2)*UHANG    
        FACH=0.5*COMFAC*1./(4096.*PARU(1)**2*16.*(1.-XW)**2)*   
     &  (AEM/XW)**4*(SH/SQMW)**2*((ASHRE+ATHRE+AUHRE)**2+   
     &  (ASHIM+ATHIM+AUHIM)**2)*SQMZ/SQMW   
        DO 530 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 530   
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        AVI=AI**2+VI**2 
        DO 520 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 520   
        EJ=KCHG(IABS(J),1)/3.   
        AJ=SIGN(1.,EJ)  
        VJ=AJ-4.*EJ*XW  
        AVJ=AJ**2+VJ**2 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACH*AVI*AVJ 
  520   CONTINUE    
  530   CONTINUE    
    
      ELSEIF(ISUB.EQ.72) THEN   
C...Z0 + Z0 -> W+ + W-. 
        BE2=SQRT((1.-4.*SQMW/SH)*(1.-4.*SQMZ/SH))   
        CTH2=CTH**2 
        TH=-0.5*SH*(1.-2.*(SQMW+SQMZ)/SH-BE2*CTH)   
        UH=-0.5*SH*(1.-2.*(SQMW+SQMZ)/SH+BE2*CTH)   
        SHANG=4.*SQRT(SQMW/(SQMZ*(1.-XW)))*(1.-2.*SQMW/SH)* 
     &  (1.-2.*SQMZ/SH) 
        ASHRE=(SH-SQMH)/((SH-SQMH)**2+GMMH**2)*SHANG    
        ASHIM=-GMMH/((SH-SQMH)**2+GMMH**2)*SHANG    
        ATWRE=(1.-XW)/SQMZ*SH/(TH-SQMW)*((CTH-BE2)**2*(3./2.+BE2/2.*CTH-    
     &  (SQMW+SQMZ)/SH+(SQMW-SQMZ)**2/(SH*SQMW))+4.*((SQMW+SQMZ)/SH*    
     &  (1.-3.*CTH2)+8.*SQMW*SQMZ/SH2*(2.*CTH2-1.)+ 
     &  4.*(SQMW**2+SQMZ**2)/SH2*CTH2+2.*(SQMW+SQMZ)/SH*BE2*CTH))   
        ATWIM=0.    
        AUWRE=(1.-XW)/SQMZ*SH/(UH-SQMW)*((CTH+BE2)**2*(3./2.-BE2/2.*CTH-    
     &  (SQMW+SQMZ)/SH+(SQMW-SQMZ)**2/(SH*SQMW))+4.*((SQMW+SQMZ)/SH*    
     &  (1.-3.*CTH2)+8.*SQMW*SQMZ/SH2*(2.*CTH2-1.)+ 
     &  4.*(SQMW**2+SQMZ**2)/SH2*CTH2-2.*(SQMW+SQMZ)/SH*BE2*CTH))   
        AUWIM=0.    
        A4RE=2.*(1.-XW)/SQMZ*(3.-CTH2-4.*(SQMW+SQMZ)/SH)    
        A4IM=0. 
        FACH=COMFAC*1./(4096.*PARU(1)**2*16.*(1.-XW)**2)*(AEM/XW)**4*   
     &  (SH/SQMW)**2*((ASHRE+ATWRE+AUWRE+A4RE)**2+  
     &  (ASHIM+ATWIM+AUWIM+A4IM)**2)*SQMZ/SQMW  
        DO 550 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 550   
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        AVI=AI**2+VI**2 
        DO 540 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 540   
        EJ=KCHG(IABS(J),1)/3.   
        AJ=SIGN(1.,EJ)  
        VJ=AJ-4.*EJ*XW  
        AVJ=AJ**2+VJ**2 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACH*AVI*AVJ 
  540   CONTINUE    
  550   CONTINUE    
    
      ELSEIF(ISUB.EQ.73) THEN   
C...Z0 + W+/- -> Z0 + W+/-. 
        BE2=1.-2.*(SQMZ+SQMW)/SH+((SQMZ-SQMW)/SH)**2    
        EP1=1.+(SQMZ-SQMW)/SH   
        EP2=1.-(SQMZ-SQMW)/SH   
        TH=-0.5*SH*BE2*(1.-CTH) 
        UH=(SQMZ-SQMW)**2/SH-0.5*SH*BE2*(1.+CTH)    
        THANG=SQRT(SQMW/(SQMZ*(1.-XW)))*(BE2-EP1*CTH)*(BE2-EP2*CTH) 
        ATHRE=(TH-SQMH)/((TH-SQMH)**2+GMMH**2)*THANG    
        ATHIM=-GMMH/((TH-SQMH)**2+GMMH**2)*THANG    
        ASWRE=(1.-XW)/SQMZ*SH/(SH-SQMW)*(-BE2*(EP1+EP2)**4*CTH+ 
     &  1./4.*(BE2+EP1*EP2)**2*((EP1-EP2)**2-4.*BE2*CTH)+   
     &  2.*BE2*(BE2+EP1*EP2)*(EP1+EP2)**2*CTH-  
     &  1./16.*SH/SQMW*(EP1**2-EP2**2)**2*(BE2+EP1*EP2)**2) 
        ASWIM=0.    
        AUWRE=(1.-XW)/SQMZ*SH/(UH-SQMW)*(-BE2*(EP2+EP1*CTH)*    
     &  (EP1+EP2*CTH)*(BE2+EP1*EP2)+BE2*(EP2+EP1*CTH)*  
     &  (BE2+EP1*EP2*CTH)*(2.*EP2-EP2*CTH+EP1)-BE2*(EP2+EP1*CTH)**2*    
     &  (BE2-EP2**2*CTH)-1./8.*(BE2+EP1*EP2*CTH)**2*((EP1+EP2)**2+  
     &  2.*BE2*(1.-CTH))+1./32.*SH/SQMW*(BE2+EP1*EP2*CTH)**2*   
     &  (EP1**2-EP2**2)**2-BE2*(EP1+EP2*CTH)*(EP2+EP1*CTH)* 
     &  (BE2+EP1*EP2)+BE2*(EP1+EP2*CTH)*(BE2+EP1*EP2*CTH)*  
     &  (2.*EP1-EP1*CTH+EP2)-BE2*(EP1+EP2*CTH)**2*(BE2-EP1**2*CTH)- 
     &  1./8.*(BE2+EP1*EP2*CTH)**2*((EP1+EP2)**2+2.*BE2*(1.-CTH))+  
     &  1./32.*SH/SQMW*(BE2+EP1*EP2*CTH)**2*(EP1**2-EP2**2)**2) 
        AUWIM=0.    
        A4RE=(1.-XW)/SQMZ*(EP1**2*EP2**2*(CTH**2-1.)-   
     &  2.*BE2*(EP1**2+EP2**2+EP1*EP2)*CTH-2.*BE2*EP1*EP2)  
        A4IM=0. 
        FACH=COMFAC*1./(4096.*PARU(1)**2*4.*(1.-XW))*(AEM/XW)**4*   
     &  (SH/SQMW)**2*((ATHRE+ASWRE+AUWRE+A4RE)**2+  
     &  (ATHIM+ASWIM+AUWIM+A4IM)**2)*SQRT(SQMZ/SQMW)    
        DO 570 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 570   
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        AVI=AI**2+VI**2 
        DO 560 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 560   
        EJ=KCHG(IABS(J),1)/3.   
        AJ=SIGN(1.,EJ)  
        VJ=AI-4.*EJ*XW  
        AVJ=AJ**2+VJ**2 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACH*(AVI*VINT(180+J)+VINT(180+I)*AVJ)   
  560   CONTINUE    
  570   CONTINUE    
    
      ELSEIF(ISUB.EQ.75) THEN   
C...W+ + W- -> gamma + gamma.   
    
      ELSEIF(ISUB.EQ.76) THEN   
C...W+ + W- -> Z0 + Z0. 
        BE2=SQRT((1.-4.*SQMW/SH)*(1.-4.*SQMZ/SH))   
        CTH2=CTH**2 
        TH=-0.5*SH*(1.-2.*(SQMW+SQMZ)/SH-BE2*CTH)   
        UH=-0.5*SH*(1.-2.*(SQMW+SQMZ)/SH+BE2*CTH)   
        SHANG=4.*SQRT(SQMW/(SQMZ*(1.-XW)))*(1.-2.*SQMW/SH)* 
     &  (1.-2.*SQMZ/SH) 
        ASHRE=(SH-SQMH)/((SH-SQMH)**2+GMMH**2)*SHANG    
        ASHIM=-GMMH/((SH-SQMH)**2+GMMH**2)*SHANG    
        ATWRE=(1.-XW)/SQMZ*SH/(TH-SQMW)*((CTH-BE2)**2*(3./2.+BE2/2.*CTH-    
     &  (SQMW+SQMZ)/SH+(SQMW-SQMZ)**2/(SH*SQMW))+4.*((SQMW+SQMZ)/SH*    
     &  (1.-3.*CTH2)+8.*SQMW*SQMZ/SH2*(2.*CTH2-1.)+ 
     &  4.*(SQMW**2+SQMZ**2)/SH2*CTH2+2.*(SQMW+SQMZ)/SH*BE2*CTH))   
        ATWIM=0.    
        AUWRE=(1.-XW)/SQMZ*SH/(UH-SQMW)*((CTH+BE2)**2*(3./2.-BE2/2.*CTH-    
     &  (SQMW+SQMZ)/SH+(SQMW-SQMZ)**2/(SH*SQMW))+4.*((SQMW+SQMZ)/SH*    
     &  (1.-3.*CTH2)+8.*SQMW*SQMZ/SH2*(2.*CTH2-1.)+ 
     &  4.*(SQMW**2+SQMZ**2)/SH2*CTH2-2.*(SQMW+SQMZ)/SH*BE2*CTH))   
        AUWIM=0.    
        A4RE=2.*(1.-XW)/SQMZ*(3.-CTH2-4.*(SQMW+SQMZ)/SH)    
        A4IM=0. 
        FACH=0.5*COMFAC*1./(4096.*PARU(1)**2)*(AEM/XW)**4*(SH/SQMW)**2* 
     &  ((ASHRE+ATWRE+AUWRE+A4RE)**2+(ASHIM+ATWIM+AUWIM+A4IM)**2)   
        DO 590 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 590   
        EI=SIGN(1.,FLOAT(I))*KCHG(IABS(I),1)    
        DO 580 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 580   
        EJ=SIGN(1.,FLOAT(J))*KCHG(IABS(J),1)    
        IF(EI*EJ.GT.0.) GOTO 580    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACH*VINT(180+I)*VINT(180+J) 
  580   CONTINUE    
  590   CONTINUE    
    
      ELSEIF(ISUB.EQ.77) THEN   
C...W+/- + W+/- -> W+/- + W+/-. 
        BE2=1.-4.*SQMW/SH   
        BE4=BE2**2  
        CTH2=CTH**2 
        CTH3=CTH**3 
        TH=-0.5*SH*BE2*(1.-CTH) 
        UH=-0.5*SH*BE2*(1.+CTH) 
        SHANG=(1.+BE2)**2   
        ASHRE=(SH-SQMH)/((SH-SQMH)**2+GMMH**2)*SHANG    
        ASHIM=-GMMH/((SH-SQMH)**2+GMMH**2)*SHANG    
        THANG=(BE2-CTH)**2  
        ATHRE=(TH-SQMH)/((TH-SQMH)**2+GMMH**2)*THANG    
        ATHIM=-GMMH/((TH-SQMH)**2+GMMH**2)*THANG    
        SGZANG=1./SQMW*BE2*(3.-BE2)**2*CTH  
        ASGRE=XW*SGZANG 
        ASGIM=0.    
        ASZRE=(1.-XW)*SH/(SH-SQMZ)*SGZANG   
        ASZIM=0.    
        TGZANG=1./SQMW*(BE2*(4.-2.*BE2+BE4)+BE2*(4.-10.*BE2+BE4)*CTH+   
     &  (2.-11.*BE2+10.*BE4)*CTH2+BE2*CTH3) 
        ATGRE=0.5*XW*SH/TH*TGZANG   
        ATGIM=0.    
        ATZRE=0.5*(1.-XW)*SH/(TH-SQMZ)*TGZANG   
        ATZIM=0.    
        A4RE=1./SQMW*(1.+2.*BE2-6.*BE2*CTH-CTH2)    
        A4IM=0. 
        FACH=COMFAC*1./(4096.*PARU(1)**2)*(AEM/XW)**4*(SH/SQMW)**2* 
     &  ((ASHRE+ATHRE+ASGRE+ASZRE+ATGRE+ATZRE+A4RE)**2+ 
     &  (ASHIM+ATHIM+ASGIM+ASZIM+ATGIM+ATZIM+A4IM)**2)  
        DO 610 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 610   
        EI=SIGN(1.,FLOAT(I))*KCHG(IABS(I),1)    
        DO 600 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 600   
        EJ=SIGN(1.,FLOAT(J))*KCHG(IABS(J),1)    
        IF(EI*EJ.GT.0.) GOTO 600    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACH*VINT(180+I)*VINT(180+J) 
  600   CONTINUE    
  610   CONTINUE    
    
      ELSEIF(ISUB.EQ.78) THEN   
C...W+/- + H0 -> W+/- + H0. 
    
      ELSEIF(ISUB.EQ.79) THEN   
C...H0 + H0 -> H0 + H0. 
    
      ENDIF 
    
C...C: 2 -> 2, tree diagrams with masses.   
    
      ELSEIF(ISUB.LE.90) THEN   
      IF(ISUB.EQ.81) THEN   
C...q + qb -> Q + QB.   
        FACQQB=COMFAC*AS**2*4./9.*(((TH-SQM3)**2+   
     &  (UH-SQM3)**2)/SH2+2.*SQM3/SH)   
        IF(MSTP(35).GE.1) THEN  
          IF(MSTP(35).EQ.1) THEN    
            ALSSG=PARP(35)  
          ELSE  
            MST115=MSTU(115)    
            MSTU(115)=MSTP(36)  
            Q2BN=SQRT(SQM3*((SQRT(SH)-2.*SQRT(SQM3))**2+PARP(36)**2))   
            ALSSG=ULALPS(Q2BN)  
            MSTU(115)=MST115    
          ENDIF 
          XREPU=PARU(1)*ALSSG/(6.*SQRT(MAX(1E-20,1.-4.*SQM3/SH)))   
          FREPU=XREPU/(EXP(MIN(100.,XREPU))-1.) 
          PARI(81)=FREPU    
          FACQQB=FACQQB*FREPU   
        ENDIF   
        DO 620 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 620    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACQQB   
  620   CONTINUE    
    
      ELSEIF(ISUB.EQ.82) THEN   
C...g + g -> Q + QB.    
        FACQQ1=COMFAC*FACA*AS**2*1./6.*((UH-SQM3)/(TH-SQM3)-    
     &  2.*(UH-SQM3)**2/SH2+4.*SQM3/SH*(TH*UH-SQM3**2)/(TH-SQM3)**2)    
        FACQQ2=COMFAC*FACA*AS**2*1./6.*((TH-SQM3)/(UH-SQM3)-    
     &  2.*(TH-SQM3)**2/SH2+4.*SQM3/SH*(TH*UH-SQM3**2)/(UH-SQM3)**2)    
        IF(MSTP(35).GE.1) THEN  
          IF(MSTP(35).EQ.1) THEN    
            ALSSG=PARP(35)  
          ELSE  
            MST115=MSTU(115)    
            MSTU(115)=MSTP(36)  
            Q2BN=SQRT(SQM3*((SQRT(SH)-2.*SQRT(SQM3))**2+PARP(36)**2))   
            ALSSG=ULALPS(Q2BN)  
            MSTU(115)=MST115    
          ENDIF 
          XATTR=4.*PARU(1)*ALSSG/(3.*SQRT(MAX(1E-20,1.-4.*SQM3/SH)))    
          FATTR=XATTR/(1.-EXP(-MIN(100.,XATTR)))    
          XREPU=PARU(1)*ALSSG/(6.*SQRT(MAX(1E-20,1.-4.*SQM3/SH)))   
          FREPU=XREPU/(EXP(MIN(100.,XREPU))-1.) 
          FATRE=(2.*FATTR+5.*FREPU)/7.  
          PARI(81)=FATRE    
          FACQQ1=FACQQ1*FATRE   
          FACQQ2=FACQQ2*FATRE   
        ENDIF   
        IF(KFAC(1,21)*KFAC(2,21).EQ.0) GOTO 630 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACQQ1   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=2  
        SIGH(NCHN)=FACQQ2   
  630   CONTINUE    
    
      ENDIF 
    
C...D: Mimimum bias processes.  
    
      ELSEIF(ISUB.LE.100) THEN  
      IF(ISUB.EQ.91) THEN   
C...Elastic scattering. 
        SIGS=XSEC(ISUB,1)   
    
      ELSEIF(ISUB.EQ.92) THEN   
C...Single diffractive scattering.  
        SIGS=XSEC(ISUB,1)   
    
      ELSEIF(ISUB.EQ.93) THEN   
C...Double diffractive scattering.  
        SIGS=XSEC(ISUB,1)   
    
      ELSEIF(ISUB.EQ.94) THEN   
C...Central diffractive scattering. 
        SIGS=XSEC(ISUB,1)   
    
      ELSEIF(ISUB.EQ.95) THEN   
C...Low-pT scattering.  
        SIGS=XSEC(ISUB,1)   
    
      ELSEIF(ISUB.EQ.96) THEN   
C...Multiple interactions: sum of QCD processes.    
        CALL PYWIDT(21,SQRT(SH),WDTP,WDTE)  
    
C...q + q' -> q + q'.   
        FACQQ1=COMFAC*AS**2*4./9.*(SH2+UH2)/TH2 
        FACQQB=COMFAC*AS**2*4./9.*((SH2+UH2)/TH2*FACA-  
     &  MSTP(34)*2./3.*UH2/(SH*TH)) 
        FACQQ2=COMFAC*AS**2*4./9.*((SH2+TH2)/UH2-   
     &  MSTP(34)*2./3.*SH2/(TH*UH)) 
        DO 650 I=-3,3   
        IF(I.EQ.0) GOTO 650 
        DO 640 J=-3,3   
        IF(J.EQ.0) GOTO 640 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=111    
        SIGH(NCHN)=FACQQ1   
        IF(I.EQ.-J) SIGH(NCHN)=FACQQB   
        IF(I.EQ.J) THEN 
          SIGH(NCHN)=0.5*SIGH(NCHN) 
          NCHN=NCHN+1   
          ISIG(NCHN,1)=I    
          ISIG(NCHN,2)=J    
          ISIG(NCHN,3)=112  
          SIGH(NCHN)=0.5*FACQQ2 
        ENDIF   
  640   CONTINUE    
  650   CONTINUE    
    
C...q + qb -> q' + qb' or g + g.    
        FACQQB=COMFAC*AS**2*4./9.*(TH2+UH2)/SH2*(WDTE(0,1)+WDTE(0,2)+   
     &  WDTE(0,3)+WDTE(0,4))    
        FACGG1=COMFAC*AS**2*32./27.*(UH/TH-(2.+MSTP(34)*1./4.)*UH2/SH2) 
        FACGG2=COMFAC*AS**2*32./27.*(TH/UH-(2.+MSTP(34)*1./4.)*TH2/SH2) 
        DO 660 I=-3,3   
        IF(I.EQ.0) GOTO 660 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=121    
        SIGH(NCHN)=FACQQB   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=131    
        SIGH(NCHN)=0.5*FACGG1   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=132    
        SIGH(NCHN)=0.5*FACGG2   
  660   CONTINUE    
    
C...q + g -> q + g. 
        FACQG1=COMFAC*AS**2*4./9.*((2.+MSTP(34)*1./4.)*UH2/TH2-UH/SH)*  
     &  FACA    
        FACQG2=COMFAC*AS**2*4./9.*((2.+MSTP(34)*1./4.)*SH2/TH2-SH/UH)   
        DO 680 I=-3,3   
        IF(I.EQ.0) GOTO 680 
        DO 670 ISDE=1,2 
        NCHN=NCHN+1 
        ISIG(NCHN,ISDE)=I   
        ISIG(NCHN,3-ISDE)=21    
        ISIG(NCHN,3)=281    
        SIGH(NCHN)=FACQG1   
        NCHN=NCHN+1 
        ISIG(NCHN,ISDE)=I   
        ISIG(NCHN,3-ISDE)=21    
        ISIG(NCHN,3)=282    
        SIGH(NCHN)=FACQG2   
  670   CONTINUE    
  680   CONTINUE    
    
C...g + g -> q + qb or g + g.   
        FACQQ1=COMFAC*AS**2*1./6.*(UH/TH-(2.+MSTP(34)*1./4.)*UH2/SH2)*  
     &  (WDTE(0,1)+WDTE(0,2)+WDTE(0,3)+WDTE(0,4))*FACA  
        FACQQ2=COMFAC*AS**2*1./6.*(TH/UH-(2.+MSTP(34)*1./4.)*TH2/SH2)*  
     &  (WDTE(0,1)+WDTE(0,2)+WDTE(0,3)+WDTE(0,4))*FACA  
        FACGG1=COMFAC*AS**2*9./4.*(SH2/TH2+2.*SH/TH+3.+2.*TH/SH+    
     &  TH2/SH2)*FACA   
        FACGG2=COMFAC*AS**2*9./4.*(UH2/SH2+2.*UH/SH+3.+2.*SH/UH+    
     &  SH2/UH2)*FACA   
        FACGG3=COMFAC*AS**2*9./4.*(TH2/UH2+2.*TH/UH+3+2.*UH/TH+UH2/TH2) 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=531    
        SIGH(NCHN)=FACQQ1   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=532    
        SIGH(NCHN)=FACQQ2   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=681    
        SIGH(NCHN)=0.5*FACGG1   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=682    
        SIGH(NCHN)=0.5*FACGG2   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=683    
        SIGH(NCHN)=0.5*FACGG3   
      ENDIF 
    
C...E: 2 -> 1, loop diagrams.   
    
      ELSEIF(ISUB.LE.110) THEN  
      IF(ISUB.EQ.101) THEN  
C...g + g -> gamma*/Z0. 
    
      ELSEIF(ISUB.EQ.102) THEN  
C...g + g -> H0.    
        CALL PYWIDT(25,SQRT(SH),WDTP,WDTE)  
        ETARE=0.    
        ETAIM=0.    
        DO 690 I=1,2*MSTP(1)    
        EPS=4.*PMAS(I,1)**2/SH  
        IF(EPS.LE.1.) THEN  
          IF(EPS.GT.1.E-4) THEN 
            ROOT=SQRT(1.-EPS)   
            RLN=LOG((1.+ROOT)/(1.-ROOT))    
          ELSE  
            RLN=LOG(4./EPS-2.)  
          ENDIF 
          PHIRE=0.25*(RLN**2-PARU(1)**2)    
          PHIIM=0.5*PARU(1)*RLN 
        ELSE    
          PHIRE=-(ASIN(1./SQRT(EPS)))**2    
          PHIIM=0.  
        ENDIF   
        ETARE=ETARE+0.5*EPS*(1.+(EPS-1.)*PHIRE) 
        ETAIM=ETAIM+0.5*EPS*(EPS-1.)*PHIIM  
  690   CONTINUE    
        ETA2=ETARE**2+ETAIM**2  
        FACH=COMFAC*FACA*(AS/PARU(1)*AEM/XW)**2*1./512.*    
     &  (SH/SQMW)**2*ETA2*SH2/((SH-SQMH)**2+GMMH**2)*   
     &  (WDTE(0,1)+WDTE(0,2)+WDTE(0,4)) 
        IF(KFAC(1,21)*KFAC(2,21).EQ.0) GOTO 700 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACH 
  700   CONTINUE    
    
      ENDIF 
    
C...F: 2 -> 2, box diagrams.    
    
      ELSEIF(ISUB.LE.120) THEN  
      IF(ISUB.EQ.111) THEN  
C...f + fb -> g + H0 (q + qb -> g + H0 only).   
        A5STUR=0.   
        A5STUI=0.   
        DO 710 I=1,2*MSTP(1)    
        SQMQ=PMAS(I,1)**2   
        EPSS=4.*SQMQ/SH 
        EPSH=4.*SQMQ/SQMH   
        A5STUR=A5STUR+SQMQ/SQMH*(4.+4.*SH/(TH+UH)*(PYW1AU(EPSS,1)-  
     &  PYW1AU(EPSH,1))+(1.-4.*SQMQ/(TH+UH))*(PYW2AU(EPSS,1)-   
     &  PYW2AU(EPSH,1)))    
        A5STUI=A5STUI+SQMQ/SQMH*(4.*SH/(TH+UH)*(PYW1AU(EPSS,2)- 
     &  PYW1AU(EPSH,2))+(1.-4.*SQMQ/(TH+UH))*(PYW2AU(EPSS,2)-   
     &  PYW2AU(EPSH,2)))    
  710   CONTINUE    
        FACGH=COMFAC*FACA/(144.*PARU(1)**2)*AEM/XW*AS**3*SQMH/SQMW* 
     &  SQMH/SH*(UH**2+TH**2)/(UH+TH)**2*(A5STUR**2+A5STUI**2)  
        FACGH=FACGH*WIDS(25,2)  
        DO 720 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 720    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACGH    
  720   CONTINUE    
    
      ELSEIF(ISUB.EQ.112) THEN  
C...f + g -> f + H0 (q + g -> q + H0 only). 
        A5TSUR=0.   
        A5TSUI=0.   
        DO 730 I=1,2*MSTP(1)    
        SQMQ=PMAS(I,1)**2   
        EPST=4.*SQMQ/TH 
        EPSH=4.*SQMQ/SQMH   
        A5TSUR=A5TSUR+SQMQ/SQMH*(4.+4.*TH/(SH+UH)*(PYW1AU(EPST,1)-  
     &  PYW1AU(EPSH,1))+(1.-4.*SQMQ/(SH+UH))*(PYW2AU(EPST,1)-   
     &  PYW2AU(EPSH,1)))    
        A5TSUI=A5TSUI+SQMQ/SQMH*(4.*TH/(SH+UH)*(PYW1AU(EPST,2)- 
     &  PYW1AU(EPSH,2))+(1.-4.*SQMQ/(SH+UH))*(PYW2AU(EPST,2)-   
     &  PYW2AU(EPSH,2)))    
  730   CONTINUE    
        FACQH=COMFAC*FACA/(384.*PARU(1)**2)*AEM/XW*AS**3*SQMH/SQMW* 
     &  SQMH/(-TH)*(UH**2+SH**2)/(UH+SH)**2*(A5TSUR**2+A5TSUI**2)   
        FACQH=FACQH*WIDS(25,2)  
        DO 750 I=MINA,MAXA  
        IF(I.EQ.0) GOTO 750 
        DO 740 ISDE=1,2 
        IF(ISDE.EQ.1.AND.KFAC(1,I)*KFAC(2,21).EQ.0) GOTO 740    
        IF(ISDE.EQ.2.AND.KFAC(1,21)*KFAC(2,I).EQ.0) GOTO 740    
        NCHN=NCHN+1 
        ISIG(NCHN,ISDE)=I   
        ISIG(NCHN,3-ISDE)=21    
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACQH    
  740   CONTINUE    
  750   CONTINUE    
    
      ELSEIF(ISUB.EQ.113) THEN  
C...g + g -> g + H0.    
        A2STUR=0.   
        A2STUI=0.   
        A2USTR=0.   
        A2USTI=0.   
        A2TUSR=0.   
        A2TUSI=0.   
        A4STUR=0.   
        A4STUI=0.   
        DO 760 I=6,2*MSTP(1)    
C'''Only t-quarks yet included  
        SQMQ=PMAS(I,1)**2   
        EPSS=4.*SQMQ/SH 
        EPST=4.*SQMQ/TH 
        EPSU=4.*SQMQ/UH 
        EPSH=4.*SQMQ/SQMH   
        IF(EPSH.LT.1.E-6) GOTO 760  
        BESTU=0.5*(1.+SQRT(1.+EPSS*TH/UH))  
        BEUST=0.5*(1.+SQRT(1.+EPSU*SH/TH))  
        BETUS=0.5*(1.+SQRT(1.+EPST*UH/SH))  
        BEUTS=BESTU 
        BETSU=BEUST 
        BESUT=BETUS 
        W3STUR=PYI3AU(BESTU,EPSH,1)-PYI3AU(BESTU,EPSS,1)-   
     &  PYI3AU(BESTU,EPSU,1)    
        W3STUI=PYI3AU(BESTU,EPSH,2)-PYI3AU(BESTU,EPSS,2)-   
     &  PYI3AU(BESTU,EPSU,2)    
        W3SUTR=PYI3AU(BESUT,EPSH,1)-PYI3AU(BESUT,EPSS,1)-   
     &  PYI3AU(BESUT,EPST,1)    
        W3SUTI=PYI3AU(BESUT,EPSH,2)-PYI3AU(BESUT,EPSS,2)-   
     &  PYI3AU(BESUT,EPST,2)    
        W3TSUR=PYI3AU(BETSU,EPSH,1)-PYI3AU(BETSU,EPST,1)-   
     &  PYI3AU(BETSU,EPSU,1)    
        W3TSUI=PYI3AU(BETSU,EPSH,2)-PYI3AU(BETSU,EPST,2)-   
     &  PYI3AU(BETSU,EPSU,2)    
        W3TUSR=PYI3AU(BETUS,EPSH,1)-PYI3AU(BETUS,EPST,1)-   
     &  PYI3AU(BETUS,EPSS,1)    
        W3TUSI=PYI3AU(BETUS,EPSH,2)-PYI3AU(BETUS,EPST,2)-   
     &  PYI3AU(BETUS,EPSS,2)    
        W3USTR=PYI3AU(BEUST,EPSH,1)-PYI3AU(BEUST,EPSU,1)-   
     &  PYI3AU(BEUST,EPST,1)    
        W3USTI=PYI3AU(BEUST,EPSH,2)-PYI3AU(BEUST,EPSU,2)-   
     &  PYI3AU(BEUST,EPST,2)    
        W3UTSR=PYI3AU(BEUTS,EPSH,1)-PYI3AU(BEUTS,EPSU,1)-   
     &  PYI3AU(BEUTS,EPSS,1)    
        W3UTSI=PYI3AU(BEUTS,EPSH,2)-PYI3AU(BEUTS,EPSU,2)-   
     &  PYI3AU(BEUTS,EPSS,2)    
        B2STUR=SQMQ/SQMH**2*(SH*(UH-SH)/(SH+UH)+2.*TH*UH*(UH+2.*SH)/    
     &  (SH+UH)**2*(PYW1AU(EPST,1)-PYW1AU(EPSH,1))+(SQMQ-SH/4.)*    
     &  (0.5*PYW2AU(EPSS,1)+0.5*PYW2AU(EPSH,1)-PYW2AU(EPST,1)+W3STUR)+  
     &  SH**2*(2.*SQMQ/(SH+UH)**2-0.5/(SH+UH))*(PYW2AU(EPST,1)- 
     &  PYW2AU(EPSH,1))+0.5*TH*UH/SH*(PYW2AU(EPSH,1)-2.*PYW2AU(EPST,1))+    
     &  0.125*(SH-12.*SQMQ-4.*TH*UH/SH)*W3TSUR) 
        B2STUI=SQMQ/SQMH**2*(2.*TH*UH*(UH+2.*SH)/(SH+UH)**2*    
     &  (PYW1AU(EPST,2)-PYW1AU(EPSH,2))+(SQMQ-SH/4.)*   
     &  (0.5*PYW2AU(EPSS,2)+0.5*PYW2AU(EPSH,2)-PYW2AU(EPST,2)+W3STUI)+  
     &  SH**2*(2.*SQMQ/(SH+UH)**2-0.5/(SH+UH))*(PYW2AU(EPST,2)- 
     &  PYW2AU(EPSH,2))+0.5*TH*UH/SH*(PYW2AU(EPSH,2)-2.*PYW2AU(EPST,2))+    
     &  0.125*(SH-12.*SQMQ-4.*TH*UH/SH)*W3TSUI) 
        B2SUTR=SQMQ/SQMH**2*(SH*(TH-SH)/(SH+TH)+2.*UH*TH*(TH+2.*SH)/    
     &  (SH+TH)**2*(PYW1AU(EPSU,1)-PYW1AU(EPSH,1))+(SQMQ-SH/4.)*    
     &  (0.5*PYW2AU(EPSS,1)+0.5*PYW2AU(EPSH,1)-PYW2AU(EPSU,1)+W3SUTR)+  
     &  SH**2*(2.*SQMQ/(SH+TH)**2-0.5/(SH+TH))*(PYW2AU(EPSU,1)- 
     &  PYW2AU(EPSH,1))+0.5*UH*TH/SH*(PYW2AU(EPSH,1)-2.*PYW2AU(EPSU,1))+    
     &  0.125*(SH-12.*SQMQ-4.*UH*TH/SH)*W3USTR) 
        B2SUTI=SQMQ/SQMH**2*(2.*UH*TH*(TH+2.*SH)/(SH+TH)**2*    
     &  (PYW1AU(EPSU,2)-PYW1AU(EPSH,2))+(SQMQ-SH/4.)*   
     &  (0.5*PYW2AU(EPSS,2)+0.5*PYW2AU(EPSH,2)-PYW2AU(EPSU,2)+W3SUTI)+  
     &  SH**2*(2.*SQMQ/(SH+TH)**2-0.5/(SH+TH))*(PYW2AU(EPSU,2)- 
     &  PYW2AU(EPSH,2))+0.5*UH*TH/SH*(PYW2AU(EPSH,2)-2.*PYW2AU(EPSU,2))+    
     &  0.125*(SH-12.*SQMQ-4.*UH*TH/SH)*W3USTI) 
        B2TSUR=SQMQ/SQMH**2*(TH*(UH-TH)/(TH+UH)+2.*SH*UH*(UH+2.*TH)/    
     &  (TH+UH)**2*(PYW1AU(EPSS,1)-PYW1AU(EPSH,1))+(SQMQ-TH/4.)*    
     &  (0.5*PYW2AU(EPST,1)+0.5*PYW2AU(EPSH,1)-PYW2AU(EPSS,1)+W3TSUR)+  
     &  TH**2*(2.*SQMQ/(TH+UH)**2-0.5/(TH+UH))*(PYW2AU(EPSS,1)- 
     &  PYW2AU(EPSH,1))+0.5*SH*UH/TH*(PYW2AU(EPSH,1)-2.*PYW2AU(EPSS,1))+    
     &  0.125*(TH-12.*SQMQ-4.*SH*UH/TH)*W3STUR) 
        B2TSUI=SQMQ/SQMH**2*(2.*SH*UH*(UH+2.*TH)/(TH+UH)**2*    
     &  (PYW1AU(EPSS,2)-PYW1AU(EPSH,2))+(SQMQ-TH/4.)*   
     &  (0.5*PYW2AU(EPST,2)+0.5*PYW2AU(EPSH,2)-PYW2AU(EPSS,2)+W3TSUI)+  
     &  TH**2*(2.*SQMQ/(TH+UH)**2-0.5/(TH+UH))*(PYW2AU(EPSS,2)- 
     &  PYW2AU(EPSH,2))+0.5*SH*UH/TH*(PYW2AU(EPSH,2)-2.*PYW2AU(EPSS,2))+    
     &  0.125*(TH-12.*SQMQ-4.*SH*UH/TH)*W3STUI) 
        B2TUSR=SQMQ/SQMH**2*(TH*(SH-TH)/(TH+SH)+2.*UH*SH*(SH+2.*TH)/    
     &  (TH+SH)**2*(PYW1AU(EPSU,1)-PYW1AU(EPSH,1))+(SQMQ-TH/4.)*    
     &  (0.5*PYW2AU(EPST,1)+0.5*PYW2AU(EPSH,1)-PYW2AU(EPSU,1)+W3TUSR)+  
     &  TH**2*(2.*SQMQ/(TH+SH)**2-0.5/(TH+SH))*(PYW2AU(EPSU,1)- 
     &  PYW2AU(EPSH,1))+0.5*UH*SH/TH*(PYW2AU(EPSH,1)-2.*PYW2AU(EPSU,1))+    
     &  0.125*(TH-12.*SQMQ-4.*UH*SH/TH)*W3UTSR) 
        B2TUSI=SQMQ/SQMH**2*(2.*UH*SH*(SH+2.*TH)/(TH+SH)**2*    
     &  (PYW1AU(EPSU,2)-PYW1AU(EPSH,2))+(SQMQ-TH/4.)*   
     &  (0.5*PYW2AU(EPST,2)+0.5*PYW2AU(EPSH,2)-PYW2AU(EPSU,2)+W3TUSI)+  
     &  TH**2*(2.*SQMQ/(TH+SH)**2-0.5/(TH+SH))*(PYW2AU(EPSU,2)- 
     &  PYW2AU(EPSH,2))+0.5*UH*SH/TH*(PYW2AU(EPSH,2)-2.*PYW2AU(EPSU,2))+    
     &  0.125*(TH-12.*SQMQ-4.*UH*SH/TH)*W3UTSI) 
        B2USTR=SQMQ/SQMH**2*(UH*(TH-UH)/(UH+TH)+2.*SH*TH*(TH+2.*UH)/    
     &  (UH+TH)**2*(PYW1AU(EPSS,1)-PYW1AU(EPSH,1))+(SQMQ-UH/4.)*    
     &  (0.5*PYW2AU(EPSU,1)+0.5*PYW2AU(EPSH,1)-PYW2AU(EPSS,1)+W3USTR)+  
     &  UH**2*(2.*SQMQ/(UH+TH)**2-0.5/(UH+TH))*(PYW2AU(EPSS,1)- 
     &  PYW2AU(EPSH,1))+0.5*SH*TH/UH*(PYW2AU(EPSH,1)-2.*PYW2AU(EPSS,1))+    
     &  0.125*(UH-12.*SQMQ-4.*SH*TH/UH)*W3SUTR) 
        B2USTI=SQMQ/SQMH**2*(2.*SH*TH*(TH+2.*UH)/(UH+TH)**2*    
     &  (PYW1AU(EPSS,2)-PYW1AU(EPSH,2))+(SQMQ-UH/4.)*   
     &  (0.5*PYW2AU(EPSU,2)+0.5*PYW2AU(EPSH,2)-PYW2AU(EPSS,2)+W3USTI)+  
     &  UH**2*(2.*SQMQ/(UH+TH)**2-0.5/(UH+TH))*(PYW2AU(EPSS,2)- 
     &  PYW2AU(EPSH,2))+0.5*SH*TH/UH*(PYW2AU(EPSH,2)-2.*PYW2AU(EPSS,2))+    
     &  0.125*(UH-12.*SQMQ-4.*SH*TH/UH)*W3SUTI) 
        B2UTSR=SQMQ/SQMH**2*(UH*(SH-UH)/(UH+SH)+2.*TH*SH*(SH+2.*UH)/    
     &  (UH+SH)**2*(PYW1AU(EPST,1)-PYW1AU(EPSH,1))+(SQMQ-UH/4.)*    
     &  (0.5*PYW2AU(EPSU,1)+0.5*PYW2AU(EPSH,1)-PYW2AU(EPST,1)+W3UTSR)+  
     &  UH**2*(2.*SQMQ/(UH+SH)**2-0.5/(UH+SH))*(PYW2AU(EPST,1)- 
     &  PYW2AU(EPSH,1))+0.5*TH*SH/UH*(PYW2AU(EPSH,1)-2.*PYW2AU(EPST,1))+    
     &  0.125*(UH-12.*SQMQ-4.*TH*SH/UH)*W3TUSR) 
        B2UTSI=SQMQ/SQMH**2*(2.*TH*SH*(SH+2.*UH)/(UH+SH)**2*    
     &  (PYW1AU(EPST,2)-PYW1AU(EPSH,2))+(SQMQ-UH/4.)*   
     &  (0.5*PYW2AU(EPSU,2)+0.5*PYW2AU(EPSH,2)-PYW2AU(EPST,2)+W3UTSI)+  
     &  UH**2*(2.*SQMQ/(UH+SH)**2-0.5/(UH+SH))*(PYW2AU(EPST,2)- 
     &  PYW2AU(EPSH,2))+0.5*TH*SH/UH*(PYW2AU(EPSH,2)-2.*PYW2AU(EPST,2))+    
     &  0.125*(UH-12.*SQMQ-4.*TH*SH/UH)*W3TUSI) 
        B4STUR=SQMQ/SQMH*(-2./3.+(SQMQ/SQMH-1./4.)*(PYW2AU(EPSS,1)- 
     &  PYW2AU(EPSH,1)+W3STUR)) 
        B4STUI=SQMQ/SQMH*(SQMQ/SQMH-1./4.)*(PYW2AU(EPSS,2)- 
     &  PYW2AU(EPSH,2)+W3STUI)  
        B4TUSR=SQMQ/SQMH*(-2./3.+(SQMQ/SQMH-1./4.)*(PYW2AU(EPST,1)- 
     &  PYW2AU(EPSH,1)+W3TUSR)) 
        B4TUSI=SQMQ/SQMH*(SQMQ/SQMH-1./4.)*(PYW2AU(EPST,2)- 
     &  PYW2AU(EPSH,2)+W3TUSI)  
        B4USTR=SQMQ/SQMH*(-2./3.+(SQMQ/SQMH-1./4.)*(PYW2AU(EPSU,1)- 
     &  PYW2AU(EPSH,1)+W3USTR)) 
        B4USTI=SQMQ/SQMH*(SQMQ/SQMH-1./4.)*(PYW2AU(EPSU,2)- 
     &  PYW2AU(EPSH,2)+W3USTI)  
        A2STUR=A2STUR+B2STUR+B2SUTR 
        A2STUI=A2STUI+B2STUI+B2SUTI 
        A2USTR=A2USTR+B2USTR+B2UTSR 
        A2USTI=A2USTI+B2USTI+B2UTSI 
        A2TUSR=A2TUSR+B2TUSR+B2TSUR 
        A2TUSI=A2TUSI+B2TUSI+B2TSUI 
        A4STUR=A4STUR+B4STUR+B4USTR+B4TUSR  
        A4STUI=A4STUI+B4STUI+B4USTI+B4TUSI  
  760   CONTINUE    
        FACGH=COMFAC*FACA*3./(128.*PARU(1)**2)*AEM/XW*AS**3*    
     &  SQMH/SQMW*SQMH**3/(SH*TH*UH)*(A2STUR**2+A2STUI**2+A2USTR**2+    
     &  A2USTI**2+A2TUSR**2+A2TUSI**2+A4STUR**2+A4STUI**2)  
        FACGH=FACGH*WIDS(25,2)  
        IF(KFAC(1,21)*KFAC(2,21).EQ.0) GOTO 770 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACGH    
  770   CONTINUE    
    
      ELSEIF(ISUB.EQ.114) THEN  
C...g + g -> gamma + gamma. 
        ASRE=0. 
        ASIM=0. 
        DO 780 I=1,2*MSTP(1)    
        EI=KCHG(IABS(I),1)/3.   
        SQMQ=PMAS(I,1)**2   
        EPSS=4.*SQMQ/SH 
        EPST=4.*SQMQ/TH 
        EPSU=4.*SQMQ/UH 
        IF(EPSS+ABS(EPST)+ABS(EPSU).LT.3.E-6) THEN  
          A0STUR=1.+(TH-UH)/SH*LOG(TH/UH)+0.5*(TH2+UH2)/SH2*    
     &    (LOG(TH/UH)**2+PARU(1)**2)    
          A0STUI=0. 
          A0TSUR=1.+(SH-UH)/TH*LOG(-SH/UH)+0.5*(SH2+UH2)/TH2*   
     &    LOG(-SH/UH)**2    
          A0TSUI=-PARU(1)*((SH-UH)/TH+(SH2+UH2)/TH2*LOG(-SH/UH))    
          A0UTSR=1.+(TH-SH)/UH*LOG(-TH/SH)+0.5*(TH2+SH2)/UH2*   
     &    LOG(-TH/SH)**2    
          A0UTSI=PARU(1)*((TH-SH)/UH+(TH2+SH2)/UH2*LOG(-TH/SH)) 
          A1STUR=-1.    
          A1STUI=0. 
          A2STUR=-1.    
          A2STUI=0. 
        ELSE    
          BESTU=0.5*(1.+SQRT(1.+EPSS*TH/UH))    
          BEUST=0.5*(1.+SQRT(1.+EPSU*SH/TH))    
          BETUS=0.5*(1.+SQRT(1.+EPST*UH/SH))    
          BEUTS=BESTU   
          BETSU=BEUST   
          BESUT=BETUS   
          A0STUR=1.+(1.+2.*TH/SH)*PYW1AU(EPST,1)+(1.+2.*UH/SH)* 
     &    PYW1AU(EPSU,1)+0.5*((TH2+UH2)/SH2-EPSS)*(PYW2AU(EPST,1)+  
     &    PYW2AU(EPSU,1))-0.25*EPST*(1.-0.5*EPSS)*(PYI3AU(BESUT,EPSS,1)+    
     &    PYI3AU(BESUT,EPST,1))-0.25*EPSU*(1.-0.5*EPSS)*    
     &    (PYI3AU(BESTU,EPSS,1)+PYI3AU(BESTU,EPSU,1))+  
     &    0.25*(-2.*(TH2+UH2)/SH2+4.*EPSS+EPST+EPSU+0.5*EPST*EPSU)* 
     &    (PYI3AU(BETSU,EPST,1)+PYI3AU(BETSU,EPSU,1))   
          A0STUI=(1.+2.*TH/SH)*PYW1AU(EPST,2)+(1.+2.*UH/SH)*    
     &    PYW1AU(EPSU,2)+0.5*((TH2+UH2)/SH2-EPSS)*(PYW2AU(EPST,2)+  
     &    PYW2AU(EPSU,2))-0.25*EPST*(1.-0.5*EPSS)*(PYI3AU(BESUT,EPSS,2)+    
     &    PYI3AU(BESUT,EPST,2))-0.25*EPSU*(1.-0.5*EPSS)*    
     &    (PYI3AU(BESTU,EPSS,2)+PYI3AU(BESTU,EPSU,2))+  
     &    0.25*(-2.*(TH2+UH2)/SH2+4.*EPSS+EPST+EPSU+0.5*EPST*EPSU)* 
     &    (PYI3AU(BETSU,EPST,2)+PYI3AU(BETSU,EPSU,2))   
          A0TSUR=1.+(1.+2.*SH/TH)*PYW1AU(EPSS,1)+(1.+2.*UH/TH)* 
     &    PYW1AU(EPSU,1)+0.5*((SH2+UH2)/TH2-EPST)*(PYW2AU(EPSS,1)+  
     &    PYW2AU(EPSU,1))-0.25*EPSS*(1.-0.5*EPST)*(PYI3AU(BETUS,EPST,1)+    
     &    PYI3AU(BETUS,EPSS,1))-0.25*EPSU*(1.-0.5*EPST)*    
     &    (PYI3AU(BETSU,EPST,1)+PYI3AU(BETSU,EPSU,1))+  
     &    0.25*(-2.*(SH2+UH2)/TH2+4.*EPST+EPSS+EPSU+0.5*EPSS*EPSU)* 
     &    (PYI3AU(BESTU,EPSS,1)+PYI3AU(BESTU,EPSU,1))   
          A0TSUI=(1.+2.*SH/TH)*PYW1AU(EPSS,2)+(1.+2.*UH/TH)*    
     &    PYW1AU(EPSU,2)+0.5*((SH2+UH2)/TH2-EPST)*(PYW2AU(EPSS,2)+  
     &    PYW2AU(EPSU,2))-0.25*EPSS*(1.-0.5*EPST)*(PYI3AU(BETUS,EPST,2)+    
     &    PYI3AU(BETUS,EPSS,2))-0.25*EPSU*(1.-0.5*EPST)*    
     &    (PYI3AU(BETSU,EPST,2)+PYI3AU(BETSU,EPSU,2))+  
     &    0.25*(-2.*(SH2+UH2)/TH2+4.*EPST+EPSS+EPSU+0.5*EPSS*EPSU)* 
     &    (PYI3AU(BESTU,EPSS,2)+PYI3AU(BESTU,EPSU,2))   
          A0UTSR=1.+(1.+2.*TH/UH)*PYW1AU(EPST,1)+(1.+2.*SH/UH)* 
     &    PYW1AU(EPSS,1)+0.5*((TH2+SH2)/UH2-EPSU)*(PYW2AU(EPST,1)+  
     &    PYW2AU(EPSS,1))-0.25*EPST*(1.-0.5*EPSU)*(PYI3AU(BEUST,EPSU,1)+    
     &    PYI3AU(BEUST,EPST,1))-0.25*EPSS*(1.-0.5*EPSU)*    
     &    (PYI3AU(BEUTS,EPSU,1)+PYI3AU(BEUTS,EPSS,1))+  
     &    0.25*(-2.*(TH2+SH2)/UH2+4.*EPSU+EPST+EPSS+0.5*EPST*EPSS)* 
     &    (PYI3AU(BETUS,EPST,1)+PYI3AU(BETUS,EPSS,1))   
          A0UTSI=(1.+2.*TH/UH)*PYW1AU(EPST,2)+(1.+2.*SH/UH)*    
     &    PYW1AU(EPSS,2)+0.5*((TH2+SH2)/UH2-EPSU)*(PYW2AU(EPST,2)+  
     &    PYW2AU(EPSS,2))-0.25*EPST*(1.-0.5*EPSU)*(PYI3AU(BEUST,EPSU,2)+    
     &    PYI3AU(BEUST,EPST,2))-0.25*EPSS*(1.-0.5*EPSU)*    
     &    (PYI3AU(BEUTS,EPSU,2)+PYI3AU(BEUTS,EPSS,2))+  
     &    0.25*(-2.*(TH2+SH2)/UH2+4.*EPSU+EPST+EPSS+0.5*EPST*EPSS)* 
     &    (PYI3AU(BETUS,EPST,2)+PYI3AU(BETUS,EPSS,2))   
          A1STUR=-1.-0.25*(EPSS+EPST+EPSU)*(PYW2AU(EPSS,1)+ 
     &    PYW2AU(EPST,1)+PYW2AU(EPSU,1))+0.25*(EPSU+0.5*EPSS*EPST)* 
     &    (PYI3AU(BESUT,EPSS,1)+PYI3AU(BESUT,EPST,1))+  
     &    0.25*(EPST+0.5*EPSS*EPSU)*(PYI3AU(BESTU,EPSS,1)+  
     &    PYI3AU(BESTU,EPSU,1))+0.25*(EPSS+0.5*EPST*EPSU)*  
     &    (PYI3AU(BETSU,EPST,1)+PYI3AU(BETSU,EPSU,1))   
          A1STUI=-0.25*(EPSS+EPST+EPSU)*(PYW2AU(EPSS,2)+PYW2AU(EPST,2)+ 
     &    PYW2AU(EPSU,2))+0.25*(EPSU+0.5*EPSS*EPST)*    
     &    (PYI3AU(BESUT,EPSS,2)+PYI3AU(BESUT,EPST,2))+  
     &    0.25*(EPST+0.5*EPSS*EPSU)*(PYI3AU(BESTU,EPSS,2)+  
     &    PYI3AU(BESTU,EPSU,2))+0.25*(EPSS+0.5*EPST*EPSU)*  
     &    (PYI3AU(BETSU,EPST,2)+PYI3AU(BETSU,EPSU,2))   
          A2STUR=-1.+0.125*EPSS*EPST*(PYI3AU(BESUT,EPSS,1)+ 
     &    PYI3AU(BESUT,EPST,1))+0.125*EPSS*EPSU*(PYI3AU(BESTU,EPSS,1)+  
     &    PYI3AU(BESTU,EPSU,1))+0.125*EPST*EPSU*(PYI3AU(BETSU,EPST,1)+  
     &    PYI3AU(BETSU,EPSU,1)) 
          A2STUI=0.125*EPSS*EPST*(PYI3AU(BESUT,EPSS,2)+ 
     &    PYI3AU(BESUT,EPST,2))+0.125*EPSS*EPSU*(PYI3AU(BESTU,EPSS,2)+  
     &    PYI3AU(BESTU,EPSU,2))+0.125*EPST*EPSU*(PYI3AU(BETSU,EPST,2)+  
     &    PYI3AU(BETSU,EPSU,2)) 
        ENDIF   
        ASRE=ASRE+EI**2*(A0STUR+A0TSUR+A0UTSR+4.*A1STUR+A2STUR) 
        ASIM=ASIM+EI**2*(A0STUI+A0TSUI+A0UTSI+4.*A1STUI+A2STUI) 
  780   CONTINUE    
        FACGG=COMFAC*FACA/(8.*PARU(1)**2)*AS**2*AEM**2*(ASRE**2+ASIM**2)    
        IF(KFAC(1,21)*KFAC(2,21).EQ.0) GOTO 790 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACGG    
  790   CONTINUE    
    
      ELSEIF(ISUB.EQ.115) THEN  
C...g + g -> gamma + Z0.    
    
      ELSEIF(ISUB.EQ.116) THEN  
C...g + g -> Z0 + Z0.   
    
      ELSEIF(ISUB.EQ.117) THEN  
C...g + g -> W+ + W-.   
    
      ENDIF 
    
C...G: 2 -> 3, tree diagrams.   
    
      ELSEIF(ISUB.LE.140) THEN  
      IF(ISUB.EQ.121) THEN  
C...g + g -> f + fb + H0.   
    
      ENDIF 
    
C...H: 2 -> 1, tree diagrams, non-standard model processes. 
    
      ELSEIF(ISUB.LE.160) THEN  
      IF(ISUB.EQ.141) THEN  
C...f + fb -> gamma*/Z0/Z'0.    
        MINT(61)=2  
        CALL PYWIDT(32,SQRT(SH),WDTP,WDTE)  
        FACZP=COMFAC*AEM**2*4./9.   
        DO 800 I=MINA,MAXA  
        IF(I.EQ.0.OR.KFAC(1,I)*KFAC(2,-I).EQ.0) GOTO 800    
        EI=KCHG(IABS(I),1)/3.   
        AI=SIGN(1.,EI)  
        VI=AI-4.*EI*XW  
        API=SIGN(1.,EI) 
        VPI=API-4.*EI*XW    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACZP*(EI**2*VINT(111)+EI*VI/(8.*XW*(1.-XW))*    
     &  SH*(SH-SQMZ)/((SH-SQMZ)**2+GMMZ**2)*VINT(112)+EI*VPI/(8.*XW*    
     &  (1.-XW))*SH*(SH-SQMZP)/((SH-SQMZP)**2+GMMZP**2)*VINT(113)+  
     &  (VI**2+AI**2)/(16.*XW*(1.-XW))**2*SH2/((SH-SQMZ)**2+GMMZ**2)*   
     &  VINT(114)+2.*(VI*VPI+AI*API)/(16.*XW*(1.-XW))**2*SH2*   
     &  ((SH-SQMZ)*(SH-SQMZP)+GMMZ*GMMZP)/(((SH-SQMZ)**2+GMMZ**2)*  
     &  ((SH-SQMZP)**2+GMMZP**2))*VINT(115)+(VPI**2+API**2)/    
     &  (16.*XW*(1.-XW))**2*SH2/((SH-SQMZP)**2+GMMZP**2)*VINT(116)) 
  800   CONTINUE    
    
      ELSEIF(ISUB.EQ.142) THEN  
C...f + fb' -> H+/-.    
        CALL PYWIDT(37,SQRT(SH),WDTP,WDTE)  
        FHC=COMFAC*(AEM/XW)**2*1./48.*(SH/SQMW)**2*SH2/ 
     &  ((SH-SQMHC)**2+GMMHC**2)    
C'''No construction yet for leptons 
        DO 840 I=1,MSTP(54)/2   
        IL=2*I-1    
        IU=2*I  
        RMQL=PMAS(IL,1)**2/SH   
        RMQU=PMAS(IU,1)**2/SH   
        FACHC=FHC*((RMQL*PARU(121)+RMQU/PARU(121))*(1.-RMQL-RMQU)-  
     &  4.*RMQL*RMQU)/SQRT(MAX(0.,(1.-RMQL-RMQU)**2-4.*RMQL*RMQU))  
        IF(KFAC(1,IL)*KFAC(2,-IU).EQ.0) GOTO 810    
        KCHHC=(KCHG(IL,1)-KCHG(IU,1))/3 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=IL 
        ISIG(NCHN,2)=-IU    
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACHC*(WDTE(0,1)+WDTE(0,(5-KCHHC)/2)+WDTE(0,4))  
  810   IF(KFAC(1,-IL)*KFAC(2,IU).EQ.0) GOTO 820    
        KCHHC=(-KCHG(IL,1)+KCHG(IU,1))/3    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=-IL    
        ISIG(NCHN,2)=IU 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACHC*(WDTE(0,1)+WDTE(0,(5-KCHHC)/2)+WDTE(0,4))  
  820   IF(KFAC(1,IU)*KFAC(2,-IL).EQ.0) GOTO 830    
        KCHHC=(KCHG(IU,1)-KCHG(IL,1))/3 
        NCHN=NCHN+1 
        ISIG(NCHN,1)=IU 
        ISIG(NCHN,2)=-IL    
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACHC*(WDTE(0,1)+WDTE(0,(5-KCHHC)/2)+WDTE(0,4))  
  830   IF(KFAC(1,-IU)*KFAC(2,IL).EQ.0) GOTO 840    
        KCHHC=(-KCHG(IU,1)+KCHG(IL,1))/3    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=-IU    
        ISIG(NCHN,2)=IL 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACHC*(WDTE(0,1)+WDTE(0,(5-KCHHC)/2)+WDTE(0,4))  
  840   CONTINUE    
    
      ELSEIF(ISUB.EQ.143) THEN  
C...f + fb -> R.    
        CALL PYWIDT(40,SQRT(SH),WDTP,WDTE)  
        FACR=COMFAC*(AEM/XW)**2*1./9.*SH2/((SH-SQMR)**2+GMMR**2)    
        DO 860 I=MIN1,MAX1  
        IF(I.EQ.0.OR.KFAC(1,I).EQ.0) GOTO 860   
        IA=IABS(I)  
        DO 850 J=MIN2,MAX2  
        IF(J.EQ.0.OR.KFAC(2,J).EQ.0) GOTO 850   
        JA=IABS(J)  
        IF(I*J.GT.0.OR.IABS(IA-JA).NE.2) GOTO 850   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=J  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACR*(WDTE(0,1)+WDTE(0,(10-(I+J))/4)+WDTE(0,4))  
  850   CONTINUE    
  860   CONTINUE    
    
      ENDIF 
    
C...I: 2 -> 2, tree diagrams, non-standard model processes. 
    
      ELSE  
      IF(ISUB.EQ.161) THEN  
C...f + g -> f' + H+/- (q + g -> q' + H+/- only).   
        FHCQ=COMFAC*FACA*AS*AEM/XW*1./24    
        DO 900 I=1,MSTP(54) 
        IU=I+MOD(I,2)   
        SQMQ=PMAS(IU,1)**2  
        FACHCQ=FHCQ/PARU(121)*SQMQ/SQMW*(SH/(SQMQ-UH)+  
     &  2.*SQMQ*(SQMHC-UH)/(SQMQ-UH)**2+(SQMQ-UH)/SH+   
     &  2.*SQMQ/(SQMQ-UH)+2.*(SQMHC-UH)/(SQMQ-UH)*(SQMHC-SQMQ-SH)/SH)   
        IF(KFAC(1,-I)*KFAC(2,21).EQ.0) GOTO 870 
        KCHHC=ISIGN(1,-KCHG(I,1))   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=-I 
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACHCQ*(WDTE(0,1)+WDTE(0,(5-KCHHC)/2)+WDTE(0,4)) 
  870   IF(KFAC(1,I)*KFAC(2,21).EQ.0) GOTO 880  
        KCHHC=ISIGN(1,KCHG(I,1))    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=I  
        ISIG(NCHN,2)=21 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACHCQ*(WDTE(0,1)+WDTE(0,(5-KCHHC)/2)+WDTE(0,4)) 
  880   IF(KFAC(1,21)*KFAC(2,-I).EQ.0) GOTO 890 
        KCHHC=ISIGN(1,-KCHG(I,1))   
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=-I 
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACHCQ*(WDTE(0,1)+WDTE(0,(5-KCHHC)/2)+WDTE(0,4)) 
  890   IF(KFAC(1,21)*KFAC(2,I).EQ.0) GOTO 900  
        KCHHC=ISIGN(1,KCHG(I,1))    
        NCHN=NCHN+1 
        ISIG(NCHN,1)=21 
        ISIG(NCHN,2)=I  
        ISIG(NCHN,3)=1  
        SIGH(NCHN)=FACHCQ*(WDTE(0,1)+WDTE(0,(5-KCHHC)/2)+WDTE(0,4)) 
  900   CONTINUE    
    
      ENDIF 
      ENDIF 
    
C...Multiply with structure functions.  
      IF(ISUB.LE.90.OR.ISUB.GE.96) THEN 
        DO 910 ICHN=1,NCHN  
        IF(MINT(41).EQ.2) THEN  
          KFL1=ISIG(ICHN,1) 
          IF(KFL1.EQ.21) KFL1=0 
          SIGH(ICHN)=SIGH(ICHN)*XSFX(1,KFL1)    
        ENDIF   
        IF(MINT(42).EQ.2) THEN  
          KFL2=ISIG(ICHN,2) 
          IF(KFL2.EQ.21) KFL2=0 
          SIGH(ICHN)=SIGH(ICHN)*XSFX(2,KFL2)    
        ENDIF   
  910   SIGS=SIGS+SIGH(ICHN)    
      ENDIF 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYSTFU(KF,X,Q2,XPQ,JBT)    

C                        *******JBT specifies beam or target of the particle
C...Gives proton and pi+ parton structure functions according to a few  
C...different parametrizations. Note that what is coded is x times the  
C...probability distribution, i.e. xq(x,Q2) etc.    
      COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
      SAVE /HPARNT/
      COMMON/hjcrdn/YP(3,300),YT(3,300)
      SAVE /hjcrdn/
C                        ********COMMON BLOCK FROM HIJING
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      DIMENSION XPQ(-6:6),XQ(6),TX(6),TT(6),TS(6),NEHLQ(8,2),   
     &CEHLQ(6,6,2,8,2),CDO(3,6,5,2),COW(3,5,4,2)    
    
C...The following data lines are coefficients needed in the 
C...Eichten, Hinchliffe, Lane, Quigg proton structure function  
C...parametrizations, see below.    
C...Powers of 1-x in different cases.   
      DATA NEHLQ/3,4,7,5,7,7,7,7,3,4,7,6,7,7,7,7/   
C...Expansion coefficients for up valence quark distribution.   
      DATA (((CEHLQ(IX,IT,NX,1,1),IX=1,6),IT=1,6),NX=1,2)/  
     1 7.677E-01,-2.087E-01,-3.303E-01,-2.517E-02,-1.570E-02,-1.000E-04,    
     2-5.326E-01,-2.661E-01, 3.201E-01, 1.192E-01, 2.434E-02, 7.620E-03,    
     3 2.162E-01, 1.881E-01,-8.375E-02,-6.515E-02,-1.743E-02,-5.040E-03,    
     4-9.211E-02,-9.952E-02, 1.373E-02, 2.506E-02, 8.770E-03, 2.550E-03,    
     5 3.670E-02, 4.409E-02, 9.600E-04,-7.960E-03,-3.420E-03,-1.050E-03,    
     6-1.549E-02,-2.026E-02,-3.060E-03, 2.220E-03, 1.240E-03, 4.100E-04,    
     1 2.395E-01, 2.905E-01, 9.778E-02, 2.149E-02, 3.440E-03, 5.000E-04,    
     2 1.751E-02,-6.090E-03,-2.687E-02,-1.916E-02,-7.970E-03,-2.750E-03,    
     3-5.760E-03,-5.040E-03, 1.080E-03, 2.490E-03, 1.530E-03, 7.500E-04,    
     4 1.740E-03, 1.960E-03, 3.000E-04,-3.400E-04,-2.900E-04,-1.800E-04,    
     5-5.300E-04,-6.400E-04,-1.700E-04, 4.000E-05, 6.000E-05, 4.000E-05,    
     6 1.700E-04, 2.200E-04, 8.000E-05, 1.000E-05,-1.000E-05,-1.000E-05/    
      DATA (((CEHLQ(IX,IT,NX,1,2),IX=1,6),IT=1,6),NX=1,2)/  
     1 7.237E-01,-2.189E-01,-2.995E-01,-1.909E-02,-1.477E-02, 2.500E-04,    
     2-5.314E-01,-2.425E-01, 3.283E-01, 1.119E-01, 2.223E-02, 7.070E-03,    
     3 2.289E-01, 1.890E-01,-9.859E-02,-6.900E-02,-1.747E-02,-5.080E-03,    
     4-1.041E-01,-1.084E-01, 2.108E-02, 2.975E-02, 9.830E-03, 2.830E-03,    
     5 4.394E-02, 5.116E-02,-1.410E-03,-1.055E-02,-4.230E-03,-1.270E-03,    
     6-1.991E-02,-2.539E-02,-2.780E-03, 3.430E-03, 1.720E-03, 5.500E-04,    
     1 2.410E-01, 2.884E-01, 9.369E-02, 1.900E-02, 2.530E-03, 2.400E-04,    
     2 1.765E-02,-9.220E-03,-3.037E-02,-2.085E-02,-8.440E-03,-2.810E-03,    
     3-6.450E-03,-5.260E-03, 1.720E-03, 3.110E-03, 1.830E-03, 8.700E-04,    
     4 2.120E-03, 2.320E-03, 2.600E-04,-4.900E-04,-3.900E-04,-2.300E-04,    
     5-6.900E-04,-8.200E-04,-2.000E-04, 7.000E-05, 9.000E-05, 6.000E-05,    
     6 2.400E-04, 3.100E-04, 1.100E-04, 0.000E+00,-2.000E-05,-2.000E-05/    
C...Expansion coefficients for down valence quark distribution. 
      DATA (((CEHLQ(IX,IT,NX,2,1),IX=1,6),IT=1,6),NX=1,2)/  
     1 3.813E-01,-8.090E-02,-1.634E-01,-2.185E-02,-8.430E-03,-6.200E-04,    
     2-2.948E-01,-1.435E-01, 1.665E-01, 6.638E-02, 1.473E-02, 4.080E-03,    
     3 1.252E-01, 1.042E-01,-4.722E-02,-3.683E-02,-1.038E-02,-2.860E-03,    
     4-5.478E-02,-5.678E-02, 8.900E-03, 1.484E-02, 5.340E-03, 1.520E-03,    
     5 2.220E-02, 2.567E-02,-3.000E-05,-4.970E-03,-2.160E-03,-6.500E-04,    
     6-9.530E-03,-1.204E-02,-1.510E-03, 1.510E-03, 8.300E-04, 2.700E-04,    
     1 1.261E-01, 1.354E-01, 3.958E-02, 8.240E-03, 1.660E-03, 4.500E-04,    
     2 3.890E-03,-1.159E-02,-1.625E-02,-9.610E-03,-3.710E-03,-1.260E-03,    
     3-1.910E-03,-5.600E-04, 1.590E-03, 1.590E-03, 8.400E-04, 3.900E-04,    
     4 6.400E-04, 4.900E-04,-1.500E-04,-2.900E-04,-1.800E-04,-1.000E-04,    
     5-2.000E-04,-1.900E-04, 0.000E+00, 6.000E-05, 4.000E-05, 3.000E-05,    
     6 7.000E-05, 8.000E-05, 2.000E-05,-1.000E-05,-1.000E-05,-1.000E-05/    
      DATA (((CEHLQ(IX,IT,NX,2,2),IX=1,6),IT=1,6),NX=1,2)/  
     1 3.578E-01,-8.622E-02,-1.480E-01,-1.840E-02,-7.820E-03,-4.500E-04,    
     2-2.925E-01,-1.304E-01, 1.696E-01, 6.243E-02, 1.353E-02, 3.750E-03,    
     3 1.318E-01, 1.041E-01,-5.486E-02,-3.872E-02,-1.038E-02,-2.850E-03,    
     4-6.162E-02,-6.143E-02, 1.303E-02, 1.740E-02, 5.940E-03, 1.670E-03,    
     5 2.643E-02, 2.957E-02,-1.490E-03,-6.450E-03,-2.630E-03,-7.700E-04,    
     6-1.218E-02,-1.497E-02,-1.260E-03, 2.240E-03, 1.120E-03, 3.500E-04,    
     1 1.263E-01, 1.334E-01, 3.732E-02, 7.070E-03, 1.260E-03, 3.400E-04,    
     2 3.660E-03,-1.357E-02,-1.795E-02,-1.031E-02,-3.880E-03,-1.280E-03,    
     3-2.100E-03,-3.600E-04, 2.050E-03, 1.920E-03, 9.800E-04, 4.400E-04,    
     4 7.700E-04, 5.400E-04,-2.400E-04,-3.900E-04,-2.400E-04,-1.300E-04,    
     5-2.600E-04,-2.300E-04, 2.000E-05, 9.000E-05, 6.000E-05, 4.000E-05,    
     6 9.000E-05, 1.000E-04, 2.000E-05,-2.000E-05,-2.000E-05,-1.000E-05/    
C...Expansion coefficients for up and down sea quark distributions. 
      DATA (((CEHLQ(IX,IT,NX,3,1),IX=1,6),IT=1,6),NX=1,2)/  
     1 6.870E-02,-6.861E-02, 2.973E-02,-5.400E-03, 3.780E-03,-9.700E-04,    
     2-1.802E-02, 1.400E-04, 6.490E-03,-8.540E-03, 1.220E-03,-1.750E-03,    
     3-4.650E-03, 1.480E-03,-5.930E-03, 6.000E-04,-1.030E-03,-8.000E-05,    
     4 6.440E-03, 2.570E-03, 2.830E-03, 1.150E-03, 7.100E-04, 3.300E-04,    
     5-3.930E-03,-2.540E-03,-1.160E-03,-7.700E-04,-3.600E-04,-1.900E-04,    
     6 2.340E-03, 1.930E-03, 5.300E-04, 3.700E-04, 1.600E-04, 9.000E-05,    
     1 1.014E+00,-1.106E+00, 3.374E-01,-7.444E-02, 8.850E-03,-8.700E-04,    
     2 9.233E-01,-1.285E+00, 4.475E-01,-9.786E-02, 1.419E-02,-1.120E-03,    
     3 4.888E-02,-1.271E-01, 8.606E-02,-2.608E-02, 4.780E-03,-6.000E-04,    
     4-2.691E-02, 4.887E-02,-1.771E-02, 1.620E-03, 2.500E-04,-6.000E-05,    
     5 7.040E-03,-1.113E-02, 1.590E-03, 7.000E-04,-2.000E-04, 0.000E+00,    
     6-1.710E-03, 2.290E-03, 3.800E-04,-3.500E-04, 4.000E-05, 1.000E-05/    
      DATA (((CEHLQ(IX,IT,NX,3,2),IX=1,6),IT=1,6),NX=1,2)/  
     1 1.008E-01,-7.100E-02, 1.973E-02,-5.710E-03, 2.930E-03,-9.900E-04,    
     2-5.271E-02,-1.823E-02, 1.792E-02,-6.580E-03, 1.750E-03,-1.550E-03,    
     3 1.220E-02, 1.763E-02,-8.690E-03,-8.800E-04,-1.160E-03,-2.100E-04,    
     4-1.190E-03,-7.180E-03, 2.360E-03, 1.890E-03, 7.700E-04, 4.100E-04,    
     5-9.100E-04, 2.040E-03,-3.100E-04,-1.050E-03,-4.000E-04,-2.400E-04,    
     6 1.190E-03,-1.700E-04,-2.000E-04, 4.200E-04, 1.700E-04, 1.000E-04,    
     1 1.081E+00,-1.189E+00, 3.868E-01,-8.617E-02, 1.115E-02,-1.180E-03,    
     2 9.917E-01,-1.396E+00, 4.998E-01,-1.159E-01, 1.674E-02,-1.720E-03,    
     3 5.099E-02,-1.338E-01, 9.173E-02,-2.885E-02, 5.890E-03,-6.500E-04,    
     4-3.178E-02, 5.703E-02,-2.070E-02, 2.440E-03, 1.100E-04,-9.000E-05,    
     5 8.970E-03,-1.392E-02, 2.050E-03, 6.500E-04,-2.300E-04, 2.000E-05,    
     6-2.340E-03, 3.010E-03, 5.000E-04,-3.900E-04, 6.000E-05, 1.000E-05/    
C...Expansion coefficients for gluon distribution.  
      DATA (((CEHLQ(IX,IT,NX,4,1),IX=1,6),IT=1,6),NX=1,2)/  
     1 9.482E-01,-9.578E-01, 1.009E-01,-1.051E-01, 3.456E-02,-3.054E-02,    
     2-9.627E-01, 5.379E-01, 3.368E-01,-9.525E-02, 1.488E-02,-2.051E-02,    
     3 4.300E-01,-8.306E-02,-3.372E-01, 4.902E-02,-9.160E-03, 1.041E-02,    
     4-1.925E-01,-1.790E-02, 2.183E-01, 7.490E-03, 4.140E-03,-1.860E-03,    
     5 8.183E-02, 1.926E-02,-1.072E-01,-1.944E-02,-2.770E-03,-5.200E-04,    
     6-3.884E-02,-1.234E-02, 5.410E-02, 1.879E-02, 3.350E-03, 1.040E-03,    
     1 2.948E+01,-3.902E+01, 1.464E+01,-3.335E+00, 5.054E-01,-5.915E-02,    
     2 2.559E+01,-3.955E+01, 1.661E+01,-4.299E+00, 6.904E-01,-8.243E-02,    
     3-1.663E+00, 1.176E+00, 1.118E+00,-7.099E-01, 1.948E-01,-2.404E-02,    
     4-2.168E-01, 8.170E-01,-7.169E-01, 1.851E-01,-1.924E-02,-3.250E-03,    
     5 2.088E-01,-4.355E-01, 2.239E-01,-2.446E-02,-3.620E-03, 1.910E-03,    
     6-9.097E-02, 1.601E-01,-5.681E-02,-2.500E-03, 2.580E-03,-4.700E-04/    
      DATA (((CEHLQ(IX,IT,NX,4,2),IX=1,6),IT=1,6),NX=1,2)/  
     1 2.367E+00, 4.453E-01, 3.660E-01, 9.467E-02, 1.341E-01, 1.661E-02,    
     2-3.170E+00,-1.795E+00, 3.313E-02,-2.874E-01,-9.827E-02,-7.119E-02,    
     3 1.823E+00, 1.457E+00,-2.465E-01, 3.739E-02, 6.090E-03, 1.814E-02,    
     4-1.033E+00,-9.827E-01, 2.136E-01, 1.169E-01, 5.001E-02, 1.684E-02,    
     5 5.133E-01, 5.259E-01,-1.173E-01,-1.139E-01,-4.988E-02,-2.021E-02,    
     6-2.881E-01,-3.145E-01, 5.667E-02, 9.161E-02, 4.568E-02, 1.951E-02,    
     1 3.036E+01,-4.062E+01, 1.578E+01,-3.699E+00, 6.020E-01,-7.031E-02,    
     2 2.700E+01,-4.167E+01, 1.770E+01,-4.804E+00, 7.862E-01,-1.060E-01,    
     3-1.909E+00, 1.357E+00, 1.127E+00,-7.181E-01, 2.232E-01,-2.481E-02,    
     4-2.488E-01, 9.781E-01,-8.127E-01, 2.094E-01,-2.997E-02,-4.710E-03,    
     5 2.506E-01,-5.427E-01, 2.672E-01,-3.103E-02,-1.800E-03, 2.870E-03,    
     6-1.128E-01, 2.087E-01,-6.972E-02,-2.480E-03, 2.630E-03,-8.400E-04/    
C...Expansion coefficients for strange sea quark distribution.  
      DATA (((CEHLQ(IX,IT,NX,5,1),IX=1,6),IT=1,6),NX=1,2)/  
     1 4.968E-02,-4.173E-02, 2.102E-02,-3.270E-03, 3.240E-03,-6.700E-04,    
     2-6.150E-03,-1.294E-02, 6.740E-03,-6.890E-03, 9.000E-04,-1.510E-03,    
     3-8.580E-03, 5.050E-03,-4.900E-03,-1.600E-04,-9.400E-04,-1.500E-04,    
     4 7.840E-03, 1.510E-03, 2.220E-03, 1.400E-03, 7.000E-04, 3.500E-04,    
     5-4.410E-03,-2.220E-03,-8.900E-04,-8.500E-04,-3.600E-04,-2.000E-04,    
     6 2.520E-03, 1.840E-03, 4.100E-04, 3.900E-04, 1.600E-04, 9.000E-05,    
     1 9.235E-01,-1.085E+00, 3.464E-01,-7.210E-02, 9.140E-03,-9.100E-04,    
     2 9.315E-01,-1.274E+00, 4.512E-01,-9.775E-02, 1.380E-02,-1.310E-03,    
     3 4.739E-02,-1.296E-01, 8.482E-02,-2.642E-02, 4.760E-03,-5.700E-04,    
     4-2.653E-02, 4.953E-02,-1.735E-02, 1.750E-03, 2.800E-04,-6.000E-05,    
     5 6.940E-03,-1.132E-02, 1.480E-03, 6.500E-04,-2.100E-04, 0.000E+00,    
     6-1.680E-03, 2.340E-03, 4.200E-04,-3.400E-04, 5.000E-05, 1.000E-05/    
      DATA (((CEHLQ(IX,IT,NX,5,2),IX=1,6),IT=1,6),NX=1,2)/  
     1 6.478E-02,-4.537E-02, 1.643E-02,-3.490E-03, 2.710E-03,-6.700E-04,    
     2-2.223E-02,-2.126E-02, 1.247E-02,-6.290E-03, 1.120E-03,-1.440E-03,    
     3-1.340E-03, 1.362E-02,-6.130E-03,-7.900E-04,-9.000E-04,-2.000E-04,    
     4 5.080E-03,-3.610E-03, 1.700E-03, 1.830E-03, 6.800E-04, 4.000E-04,    
     5-3.580E-03, 6.000E-05,-2.600E-04,-1.050E-03,-3.800E-04,-2.300E-04,    
     6 2.420E-03, 9.300E-04,-1.000E-04, 4.500E-04, 1.700E-04, 1.100E-04,    
     1 9.868E-01,-1.171E+00, 3.940E-01,-8.459E-02, 1.124E-02,-1.250E-03,    
     2 1.001E+00,-1.383E+00, 5.044E-01,-1.152E-01, 1.658E-02,-1.830E-03,    
     3 4.928E-02,-1.368E-01, 9.021E-02,-2.935E-02, 5.800E-03,-6.600E-04,    
     4-3.133E-02, 5.785E-02,-2.023E-02, 2.630E-03, 1.600E-04,-8.000E-05,    
     5 8.840E-03,-1.416E-02, 1.900E-03, 5.800E-04,-2.500E-04, 1.000E-05,    
     6-2.300E-03, 3.080E-03, 5.500E-04,-3.700E-04, 7.000E-05, 1.000E-05/    
C...Expansion coefficients for charm sea quark distribution.    
      DATA (((CEHLQ(IX,IT,NX,6,1),IX=1,6),IT=1,6),NX=1,2)/  
     1 9.270E-03,-1.817E-02, 9.590E-03,-6.390E-03, 1.690E-03,-1.540E-03,    
     2 5.710E-03,-1.188E-02, 6.090E-03,-4.650E-03, 1.240E-03,-1.310E-03,    
     3-3.960E-03, 7.100E-03,-3.590E-03, 1.840E-03,-3.900E-04, 3.400E-04,    
     4 1.120E-03,-1.960E-03, 1.120E-03,-4.800E-04, 1.000E-04,-4.000E-05,    
     5 4.000E-05,-3.000E-05,-1.800E-04, 9.000E-05,-5.000E-05,-2.000E-05,    
     6-4.200E-04, 7.300E-04,-1.600E-04, 5.000E-05, 5.000E-05, 5.000E-05,    
     1 8.098E-01,-1.042E+00, 3.398E-01,-6.824E-02, 8.760E-03,-9.000E-04,    
     2 8.961E-01,-1.217E+00, 4.339E-01,-9.287E-02, 1.304E-02,-1.290E-03,    
     3 3.058E-02,-1.040E-01, 7.604E-02,-2.415E-02, 4.600E-03,-5.000E-04,    
     4-2.451E-02, 4.432E-02,-1.651E-02, 1.430E-03, 1.200E-04,-1.000E-04,    
     5 1.122E-02,-1.457E-02, 2.680E-03, 5.800E-04,-1.200E-04, 3.000E-05,    
     6-7.730E-03, 7.330E-03,-7.600E-04,-2.400E-04, 1.000E-05, 0.000E+00/    
      DATA (((CEHLQ(IX,IT,NX,6,2),IX=1,6),IT=1,6),NX=1,2)/  
     1 9.980E-03,-1.945E-02, 1.055E-02,-6.870E-03, 1.860E-03,-1.560E-03,    
     2 5.700E-03,-1.203E-02, 6.250E-03,-4.860E-03, 1.310E-03,-1.370E-03,    
     3-4.490E-03, 7.990E-03,-4.170E-03, 2.050E-03,-4.400E-04, 3.300E-04,    
     4 1.470E-03,-2.480E-03, 1.460E-03,-5.700E-04, 1.200E-04,-1.000E-05,    
     5-9.000E-05, 1.500E-04,-3.200E-04, 1.200E-04,-6.000E-05,-4.000E-05,    
     6-4.200E-04, 7.600E-04,-1.400E-04, 4.000E-05, 7.000E-05, 5.000E-05,    
     1 8.698E-01,-1.131E+00, 3.836E-01,-8.111E-02, 1.048E-02,-1.300E-03,    
     2 9.626E-01,-1.321E+00, 4.854E-01,-1.091E-01, 1.583E-02,-1.700E-03,    
     3 3.057E-02,-1.088E-01, 8.022E-02,-2.676E-02, 5.590E-03,-5.600E-04,    
     4-2.845E-02, 5.164E-02,-1.918E-02, 2.210E-03,-4.000E-05,-1.500E-04,    
     5 1.311E-02,-1.751E-02, 3.310E-03, 5.100E-04,-1.200E-04, 5.000E-05,    
     6-8.590E-03, 8.380E-03,-9.200E-04,-2.600E-04, 1.000E-05,-1.000E-05/    
C...Expansion coefficients for bottom sea quark distribution.   
      DATA (((CEHLQ(IX,IT,NX,7,1),IX=1,6),IT=1,6),NX=1,2)/  
     1 9.010E-03,-1.401E-02, 7.150E-03,-4.130E-03, 1.260E-03,-1.040E-03,    
     2 6.280E-03,-9.320E-03, 4.780E-03,-2.890E-03, 9.100E-04,-8.200E-04,    
     3-2.930E-03, 4.090E-03,-1.890E-03, 7.600E-04,-2.300E-04, 1.400E-04,    
     4 3.900E-04,-1.200E-03, 4.400E-04,-2.500E-04, 2.000E-05,-2.000E-05,    
     5 2.600E-04, 1.400E-04,-8.000E-05, 1.000E-04, 1.000E-05, 1.000E-05,    
     6-2.600E-04, 3.200E-04, 1.000E-05,-1.000E-05, 1.000E-05,-1.000E-05,    
     1 8.029E-01,-1.075E+00, 3.792E-01,-7.843E-02, 1.007E-02,-1.090E-03,    
     2 7.903E-01,-1.099E+00, 4.153E-01,-9.301E-02, 1.317E-02,-1.410E-03,    
     3-1.704E-02,-1.130E-02, 2.882E-02,-1.341E-02, 3.040E-03,-3.600E-04,    
     4-7.200E-04, 7.230E-03,-5.160E-03, 1.080E-03,-5.000E-05,-4.000E-05,    
     5 3.050E-03,-4.610E-03, 1.660E-03,-1.300E-04,-1.000E-05, 1.000E-05,    
     6-4.360E-03, 5.230E-03,-1.610E-03, 2.000E-04,-2.000E-05, 0.000E+00/    
      DATA (((CEHLQ(IX,IT,NX,7,2),IX=1,6),IT=1,6),NX=1,2)/  
     1 8.980E-03,-1.459E-02, 7.510E-03,-4.410E-03, 1.310E-03,-1.070E-03,    
     2 5.970E-03,-9.440E-03, 4.800E-03,-3.020E-03, 9.100E-04,-8.500E-04,    
     3-3.050E-03, 4.440E-03,-2.100E-03, 8.500E-04,-2.400E-04, 1.400E-04,    
     4 5.300E-04,-1.300E-03, 5.600E-04,-2.700E-04, 3.000E-05,-2.000E-05,    
     5 2.000E-04, 1.400E-04,-1.100E-04, 1.000E-04, 0.000E+00, 0.000E+00,    
     6-2.600E-04, 3.200E-04, 0.000E+00,-3.000E-05, 1.000E-05,-1.000E-05,    
     1 8.672E-01,-1.174E+00, 4.265E-01,-9.252E-02, 1.244E-02,-1.460E-03,    
     2 8.500E-01,-1.194E+00, 4.630E-01,-1.083E-01, 1.614E-02,-1.830E-03,    
     3-2.241E-02,-5.630E-03, 2.815E-02,-1.425E-02, 3.520E-03,-4.300E-04,    
     4-7.300E-04, 8.030E-03,-5.780E-03, 1.380E-03,-1.300E-04,-4.000E-05,    
     5 3.460E-03,-5.380E-03, 1.960E-03,-2.100E-04, 1.000E-05, 1.000E-05,    
     6-4.850E-03, 5.950E-03,-1.890E-03, 2.600E-04,-3.000E-05, 0.000E+00/    
C...Expansion coefficients for top sea quark distribution.  
      DATA (((CEHLQ(IX,IT,NX,8,1),IX=1,6),IT=1,6),NX=1,2)/  
     1 4.410E-03,-7.480E-03, 3.770E-03,-2.580E-03, 7.300E-04,-7.100E-04,    
     2 3.840E-03,-6.050E-03, 3.030E-03,-2.030E-03, 5.800E-04,-5.900E-04,    
     3-8.800E-04, 1.660E-03,-7.500E-04, 4.700E-04,-1.000E-04, 1.000E-04,    
     4-8.000E-05,-1.500E-04, 1.200E-04,-9.000E-05, 3.000E-05, 0.000E+00,    
     5 1.300E-04,-2.200E-04,-2.000E-05,-2.000E-05,-2.000E-05,-2.000E-05,    
     6-7.000E-05, 1.900E-04,-4.000E-05, 2.000E-05, 0.000E+00, 0.000E+00,    
     1 6.623E-01,-9.248E-01, 3.519E-01,-7.930E-02, 1.110E-02,-1.180E-03,    
     2 6.380E-01,-9.062E-01, 3.582E-01,-8.479E-02, 1.265E-02,-1.390E-03,    
     3-2.581E-02, 2.125E-02, 4.190E-03,-4.980E-03, 1.490E-03,-2.100E-04,    
     4 7.100E-04, 5.300E-04,-1.270E-03, 3.900E-04,-5.000E-05,-1.000E-05,    
     5 3.850E-03,-5.060E-03, 1.860E-03,-3.500E-04, 4.000E-05, 0.000E+00,    
     6-3.530E-03, 4.460E-03,-1.500E-03, 2.700E-04,-3.000E-05, 0.000E+00/    
      DATA (((CEHLQ(IX,IT,NX,8,2),IX=1,6),IT=1,6),NX=1,2)/  
     1 4.260E-03,-7.530E-03, 3.830E-03,-2.680E-03, 7.600E-04,-7.300E-04,    
     2 3.640E-03,-6.050E-03, 3.030E-03,-2.090E-03, 5.900E-04,-6.000E-04,    
     3-9.200E-04, 1.710E-03,-8.200E-04, 5.000E-04,-1.200E-04, 1.000E-04,    
     4-5.000E-05,-1.600E-04, 1.300E-04,-9.000E-05, 3.000E-05, 0.000E+00,    
     5 1.300E-04,-2.100E-04,-1.000E-05,-2.000E-05,-2.000E-05,-1.000E-05,    
     6-8.000E-05, 1.800E-04,-5.000E-05, 2.000E-05, 0.000E+00, 0.000E+00,    
     1 7.146E-01,-1.007E+00, 3.932E-01,-9.246E-02, 1.366E-02,-1.540E-03,    
     2 6.856E-01,-9.828E-01, 3.977E-01,-9.795E-02, 1.540E-02,-1.790E-03,    
     3-3.053E-02, 2.758E-02, 2.150E-03,-4.880E-03, 1.640E-03,-2.500E-04,    
     4 9.200E-04, 4.200E-04,-1.340E-03, 4.600E-04,-8.000E-05,-1.000E-05,    
     5 4.230E-03,-5.660E-03, 2.140E-03,-4.300E-04, 6.000E-05, 0.000E+00,    
     6-3.890E-03, 5.000E-03,-1.740E-03, 3.300E-04,-4.000E-05, 0.000E+00/    
    
C...The following data lines are coefficients needed in the 
C...Duke, Owens proton structure function parametrizations, see below.  
C...Expansion coefficients for (up+down) valence quark distribution.    
      DATA ((CDO(IP,IS,1,1),IS=1,6),IP=1,3)/    
     1 4.190E-01, 3.460E+00, 4.400E+00, 0.000E+00, 0.000E+00, 0.000E+00,    
     2 4.000E-03, 7.240E-01,-4.860E+00, 0.000E+00, 0.000E+00, 0.000E+00,    
     3-7.000E-03,-6.600E-02, 1.330E+00, 0.000E+00, 0.000E+00, 0.000E+00/    
      DATA ((CDO(IP,IS,1,2),IS=1,6),IP=1,3)/    
     1 3.740E-01, 3.330E+00, 6.030E+00, 0.000E+00, 0.000E+00, 0.000E+00,    
     2 1.400E-02, 7.530E-01,-6.220E+00, 0.000E+00, 0.000E+00, 0.000E+00,    
     3 0.000E+00,-7.600E-02, 1.560E+00, 0.000E+00, 0.000E+00, 0.000E+00/    
C...Expansion coefficients for down valence quark distribution. 
      DATA ((CDO(IP,IS,2,1),IS=1,6),IP=1,3)/    
     1 7.630E-01, 4.000E+00, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00,    
     2-2.370E-01, 6.270E-01,-4.210E-01, 0.000E+00, 0.000E+00, 0.000E+00,    
     3 2.600E-02,-1.900E-02, 3.300E-02, 0.000E+00, 0.000E+00, 0.000E+00/    
      DATA ((CDO(IP,IS,2,2),IS=1,6),IP=1,3)/    
     1 7.610E-01, 3.830E+00, 0.000E+00, 0.000E+00, 0.000E+00, 0.000E+00,    
     2-2.320E-01, 6.270E-01,-4.180E-01, 0.000E+00, 0.000E+00, 0.000E+00,    
     3 2.300E-02,-1.900E-02, 3.600E-02, 0.000E+00, 0.000E+00, 0.000E+00/    
C...Expansion coefficients for (up+down+strange) sea quark distribution.    
      DATA ((CDO(IP,IS,3,1),IS=1,6),IP=1,3)/    
     1 1.265E+00, 0.000E+00, 8.050E+00, 0.000E+00, 0.000E+00, 0.000E+00,    
     2-1.132E+00,-3.720E-01, 1.590E+00, 6.310E+00,-1.050E+01, 1.470E+01,    
     3 2.930E-01,-2.900E-02,-1.530E-01,-2.730E-01,-3.170E+00, 9.800E+00/    
      DATA ((CDO(IP,IS,3,2),IS=1,6),IP=1,3)/    
     1 1.670E+00, 0.000E+00, 9.150E+00, 0.000E+00, 0.000E+00, 0.000E+00,    
     2-1.920E+00,-2.730E-01, 5.300E-01, 1.570E+01,-1.010E+02, 2.230E+02,    
     3 5.820E-01,-1.640E-01,-7.630E-01,-2.830E+00, 4.470E+01,-1.170E+02/    
C...Expansion coefficients for charm sea quark distribution.    
      DATA ((CDO(IP,IS,4,1),IS=1,6),IP=1,3)/    
     1 0.000E+00,-3.600E-02, 6.350E+00, 0.000E+00, 0.000E+00, 0.000E+00,    
     2 1.350E-01,-2.220E-01, 3.260E+00,-3.030E+00, 1.740E+01,-1.790E+01,    
     3-7.500E-02,-5.800E-02,-9.090E-01, 1.500E+00,-1.130E+01, 1.560E+01/    
       DATA ((CDO(IP,IS,4,2),IS=1,6),IP=1,3)/   
     1 0.000E+00,-1.200E-01, 3.510E+00, 0.000E+00, 0.000E+00, 0.000E+00,    
     2 6.700E-02,-2.330E-01, 3.660E+00,-4.740E-01, 9.500E+00,-1.660E+01,    
     3-3.100E-02,-2.300E-02,-4.530E-01, 3.580E-01,-5.430E+00, 1.550E+01/    
C...Expansion coefficients for gluon distribution.  
      DATA ((CDO(IP,IS,5,1),IS=1,6),IP=1,3)/    
     1 1.560E+00, 0.000E+00, 6.000E+00, 9.000E+00, 0.000E+00, 0.000E+00,    
     2-1.710E+00,-9.490E-01, 1.440E+00,-7.190E+00,-1.650E+01, 1.530E+01,    
     3 6.380E-01, 3.250E-01,-1.050E+00, 2.550E-01, 1.090E+01,-1.010E+01/    
      DATA ((CDO(IP,IS,5,2),IS=1,6),IP=1,3)/    
     1 8.790E-01, 0.000E+00, 4.000E+00, 9.000E+00, 0.000E+00, 0.000E+00,    
     2-9.710E-01,-1.160E+00, 1.230E+00,-5.640E+00,-7.540E+00,-5.960E-01,    
     3 4.340E-01, 4.760E-01,-2.540E-01,-8.170E-01, 5.500E+00, 1.260E-01/    
    
C...The following data lines are coefficients needed in the 
C...Owens pion structure function parametrizations, see below.  
C...Expansion coefficients for up and down valence quark distributions. 
      DATA ((COW(IP,IS,1,1),IS=1,5),IP=1,3)/    
     1  4.0000E-01,  7.0000E-01,  0.0000E+00,  0.0000E+00,  0.0000E+00, 
     2 -6.2120E-02,  6.4780E-01,  0.0000E+00,  0.0000E+00,  0.0000E+00, 
     3 -7.1090E-03,  1.3350E-02,  0.0000E+00,  0.0000E+00,  0.0000E+00/ 
      DATA ((COW(IP,IS,1,2),IS=1,5),IP=1,3)/    
     1  4.0000E-01,  6.2800E-01,  0.0000E+00,  0.0000E+00,  0.0000E+00, 
     2 -5.9090E-02,  6.4360E-01,  0.0000E+00,  0.0000E+00,  0.0000E+00, 
     3 -6.5240E-03,  1.4510E-02,  0.0000E+00,  0.0000E+00,  0.0000E+00/ 
C...Expansion coefficients for gluon distribution.  
      DATA ((COW(IP,IS,2,1),IS=1,5),IP=1,3)/    
     1  8.8800E-01,  0.0000E+00,  3.1100E+00,  6.0000E+00,  0.0000E+00, 
     2 -1.8020E+00, -1.5760E+00, -1.3170E-01,  2.8010E+00, -1.7280E+01, 
     3  1.8120E+00,  1.2000E+00,  5.0680E-01, -1.2160E+01,  2.0490E+01/ 
      DATA ((COW(IP,IS,2,2),IS=1,5),IP=1,3)/    
     1  7.9400E-01,  0.0000E+00,  2.8900E+00,  6.0000E+00,  0.0000E+00, 
     2 -9.1440E-01, -1.2370E+00,  5.9660E-01, -3.6710E+00, -8.1910E+00, 
     3  5.9660E-01,  6.5820E-01, -2.5500E-01, -2.3040E+00,  7.7580E+00/ 
C...Expansion coefficients for (up+down+strange) quark sea distribution.    
      DATA ((COW(IP,IS,3,1),IS=1,5),IP=1,3)/    
     1  9.0000E-01,  0.0000E+00,  5.0000E+00,  0.0000E+00,  0.0000E+00, 
     2 -2.4280E-01, -2.1200E-01,  8.6730E-01,  1.2660E+00,  2.3820E+00, 
     3  1.3860E-01,  3.6710E-03,  4.7470E-02, -2.2150E+00,  3.4820E-01/ 
      DATA ((COW(IP,IS,3,2),IS=1,5),IP=1,3)/    
     1  9.0000E-01,  0.0000E+00,  5.0000E+00,  0.0000E+00,  0.0000E+00, 
     2 -1.4170E-01, -1.6970E-01, -2.4740E+00, -2.5340E+00,  5.6210E-01, 
     3 -1.7400E-01, -9.6230E-02,  1.5750E+00,  1.3780E+00, -2.7010E-01/ 
C...Expansion coefficients for charm quark sea distribution.    
      DATA ((COW(IP,IS,4,1),IS=1,5),IP=1,3)/    
     1  0.0000E+00, -2.2120E-02,  2.8940E+00,  0.0000E+00,  0.0000E+00, 
     2  7.9280E-02, -3.7850E-01,  9.4330E+00,  5.2480E+00,  8.3880E+00, 
     3 -6.1340E-02, -1.0880E-01, -1.0852E+01, -7.1870E+00, -1.1610E+01/ 
      DATA ((COW(IP,IS,4,2),IS=1,5),IP=1,3)/    
     1  0.0000E+00, -8.8200E-02,  1.9240E+00,  0.0000E+00,  0.0000E+00, 
     2  6.2290E-02, -2.8920E-01,  2.4240E-01, -4.4630E+00, -8.3670E-01, 
     3 -4.0990E-02, -1.0820E-01,  2.0360E+00,  5.2090E+00, -4.8400E-02/ 

C...Euler's beta function, requires ordinary Gamma function 
clin-10/25/02 get rid of argument usage mismatch in PYGAMM():
c      EULBT(X,Y)=PYGAMM(X)*PYGAMM(Y)/PYGAMM(X+Y)
    
C...Reset structure functions, check x and hadron flavour.  
      ALAM=0.   
      DO 100 KFL=-6,6   
  100 XPQ(KFL)=0.   
      IF(X.LT.0..OR.X.GT.1.) THEN   
        WRITE(MSTU(11),1000) X  
        RETURN  
      ENDIF 
      KFA=IABS(KF)  
      IF(KFA.NE.211.AND.KFA.NE.2212.AND.KFA.NE.2112) THEN   
        WRITE(MSTU(11),1100) KF 
        RETURN  
      ENDIF 
    
C...Call user-supplied structure function. Select proton/neutron/pion.  
      IF(MSTP(51).EQ.0.OR.MSTP(52).GE.2) THEN   
        KFE=KFA 
        IF(KFA.EQ.2112) KFE=2212    
        CALL PYSTFE(KFE,X,Q2,XPQ)   
        GOTO 230    
      ENDIF 
      IF(KFA.EQ.211) GOTO 200   
    
      IF(MSTP(51).EQ.1.OR.MSTP(51).EQ.2) THEN   
C...Proton structure functions from Eichten, Hinchliffe, Lane, Quigg.   
C...Allowed variable range: 5 GeV2 < Q2 < 1E8 GeV2; 1E-4 < x < 1    
    
C...Determine set, Lamdba and x and t expansion variables.  
        NSET=MSTP(51)   
        IF(NSET.EQ.1) ALAM=0.2  
        IF(NSET.EQ.2) ALAM=0.29 
        TMIN=LOG(5./ALAM**2)    
        TMAX=LOG(1E8/ALAM**2)   
        IF(MSTP(52).EQ.0) THEN  
          T=TMIN    
        ELSE    
          T=LOG(Q2/ALAM**2) 
        ENDIF   
        VT=MAX(-1.,MIN(1.,(2.*T-TMAX-TMIN)/(TMAX-TMIN)))    
        NX=1    
        IF(X.LE.0.1) NX=2   
        IF(NX.EQ.1) VX=(2.*X-1.1)/0.9   
        IF(NX.EQ.2) VX=MAX(-1.,(2.*LOG(X)+11.51293)/6.90776)    
        CXS=1.  
        IF(X.LT.1E-4.AND.ABS(PARP(51)-1.).GT.0.01) CXS= 
     &  (1E-4/X)**(PARP(51)-1.) 
    
C...Chebyshev polynomials for x and t expansion.    
        TX(1)=1.    
        TX(2)=VX    
        TX(3)=2.*VX**2-1.   
        TX(4)=4.*VX**3-3.*VX    
        TX(5)=8.*VX**4-8.*VX**2+1.  
        TX(6)=16.*VX**5-20.*VX**3+5.*VX 
        TT(1)=1.    
        TT(2)=VT    
        TT(3)=2.*VT**2-1.   
        TT(4)=4.*VT**3-3.*VT    
        TT(5)=8.*VT**4-8.*VT**2+1.  
        TT(6)=16.*VT**5-20.*VT**3+5.*VT 
    
C...Calculate structure functions.  
        DO 120 KFL=1,6  
        XQSUM=0.    
        DO 110 IT=1,6   
        DO 110 IX=1,6   
  110   XQSUM=XQSUM+CEHLQ(IX,IT,NX,KFL,NSET)*TX(IX)*TT(IT)  
  120   XQ(KFL)=XQSUM*(1.-X)**NEHLQ(KFL,NSET)*CXS   
    
C...Put into output array.  
        XPQ(0)=XQ(4)    
        XPQ(1)=XQ(2)+XQ(3)  
        XPQ(2)=XQ(1)+XQ(3)  
        XPQ(3)=XQ(5)    
        XPQ(4)=XQ(6)    
        XPQ(-1)=XQ(3)   
        XPQ(-2)=XQ(3)   
        XPQ(-3)=XQ(5)   
        XPQ(-4)=XQ(6)   
    
C...Special expansion for bottom (thresh effects).   
        IF(MSTP(54).GE.5) THEN  
          IF(NSET.EQ.1) TMIN=8.1905 
          IF(NSET.EQ.2) TMIN=7.4474 
          IF(T.LE.TMIN) GOTO 140    
          VT=MAX(-1.,MIN(1.,(2.*T-TMAX-TMIN)/(TMAX-TMIN)))  
          TT(1)=1.  
          TT(2)=VT  
          TT(3)=2.*VT**2-1. 
          TT(4)=4.*VT**3-3.*VT  
          TT(5)=8.*VT**4-8.*VT**2+1.    
          TT(6)=16.*VT**5-20.*VT**3+5.*VT   
          XQSUM=0.  
          DO 130 IT=1,6 
          DO 130 IX=1,6 
  130     XQSUM=XQSUM+CEHLQ(IX,IT,NX,7,NSET)*TX(IX)*TT(IT)  
          XPQ(5)=XQSUM*(1.-X)**NEHLQ(7,NSET)    
          XPQ(-5)=XPQ(5)    
  140     CONTINUE  
        ENDIF   
    
C...Special expansion for top (thresh effects).  
        IF(MSTP(54).GE.6) THEN  
          IF(NSET.EQ.1) TMIN=11.5528    
          IF(NSET.EQ.2) TMIN=10.8097    
          TMIN=TMIN+2.*LOG(PMAS(6,1)/30.)   
          TMAX=TMAX+2.*LOG(PMAS(6,1)/30.)   
          IF(T.LE.TMIN) GOTO 160    
          VT=MAX(-1.,MIN(1.,(2.*T-TMAX-TMIN)/(TMAX-TMIN)))  
          TT(1)=1.  
          TT(2)=VT  
          TT(3)=2.*VT**2-1. 
          TT(4)=4.*VT**3-3.*VT  
          TT(5)=8.*VT**4-8.*VT**2+1.    
          TT(6)=16.*VT**5-20.*VT**3+5.*VT   
          XQSUM=0.  
          DO 150 IT=1,6 
          DO 150 IX=1,6 
  150     XQSUM=XQSUM+CEHLQ(IX,IT,NX,8,NSET)*TX(IX)*TT(IT)  
          XPQ(6)=XQSUM*(1.-X)**NEHLQ(8,NSET)    
          XPQ(-6)=XPQ(6)    
  160     CONTINUE  
        ENDIF   
    
      ELSEIF(MSTP(51).EQ.3.OR.MSTP(51).EQ.4) THEN   
C...Proton structure functions from Duke, Owens.    
C...Allowed variable range: 4 GeV2 < Q2 < approx 1E6 GeV2.  
    
C...Determine set, Lambda and s expansion parameter.    
        NSET=MSTP(51)-2 
        IF(NSET.EQ.1) ALAM=0.2  
        IF(NSET.EQ.2) ALAM=0.4  
        IF(MSTP(52).LE.0) THEN  
          SD=0. 
        ELSE    
          SD=LOG(LOG(MAX(Q2,4.)/ALAM**2)/LOG(4./ALAM**2))   
        ENDIF   
    
C...Calculate structure functions.  
        DO 180 KFL=1,5  
        DO 170 IS=1,6   
  170   TS(IS)=CDO(1,IS,KFL,NSET)+CDO(2,IS,KFL,NSET)*SD+    
     &  CDO(3,IS,KFL,NSET)*SD**2    
        IF(KFL.LE.2) THEN   

clin-10/25/02 evaluate EULBT(TS(1),TS(2)+1.):
c          XQ(KFL)=X**TS(1)*(1.-X)**TS(2)*(1.+TS(3)*X)/(EULBT(TS(1),    
c     &    TS(2)+1.)*(1.+TS(3)*TS(1)/(TS(1)+TS(2)+1.)))  
           eulbt1=PYGAMM(TS(1))*PYGAMM(TS(2)+1.)/PYGAMM(TS(1)+TS(2)+1.)
           XQ(KFL)=X**TS(1)*(1.-X)**TS(2)*(1.+TS(3)*X)/(EULBT1
     &          *(1.+TS(3)*TS(1)/(TS(1)+TS(2)+1.)))  
        ELSE    
           XQ(KFL)=TS(1)*X**TS(2)*(1.-X)**TS(3)*(1.+TS(4)*X+TS(5)*X**2+  
     &    TS(6)*X**3)   
        ENDIF   


  180   CONTINUE    
    
C...Put into output arrays. 
        XPQ(0)=XQ(5)    
        XPQ(1)=XQ(2)+XQ(3)/6.   
        XPQ(2)=3.*XQ(1)-XQ(2)+XQ(3)/6.  
        XPQ(3)=XQ(3)/6. 
        XPQ(4)=XQ(4)    
        XPQ(-1)=XQ(3)/6.    
        XPQ(-2)=XQ(3)/6.    
        XPQ(-3)=XQ(3)/6.    
        XPQ(-4)=XQ(4)   
    
C...Proton structure functions from Diemoz, Ferroni, Longo, Martinelli. 
C...These are accessed via PYSTFE since the files needed may not always 
C...available.  
      ELSEIF(MSTP(51).GE.11.AND.MSTP(51).LE.13) THEN    
        CALL PYSTFE(2212,X,Q2,XPQ)  
    
C...Unknown proton parametrization. 
      ELSE  
        WRITE(MSTU(11),1200) MSTP(51)   
      ENDIF 
      GOTO 230  
    
  200 IF((MSTP(51).GE.1.AND.MSTP(51).LE.4).OR.  
     &(MSTP(51).GE.11.AND.MSTP(51).LE.13)) THEN 
C...Pion structure functions from Owens.    
C...Allowed variable range: 4 GeV2 < Q2 < approx 2000 GeV2. 
    
C...Determine set, Lambda and s expansion variable. 
        NSET=1  
        IF(MSTP(51).EQ.2.OR.MSTP(51).EQ.4.OR.MSTP(51).EQ.13) NSET=2 
        IF(NSET.EQ.1) ALAM=0.2  
        IF(NSET.EQ.2) ALAM=0.4  
        IF(MSTP(52).LE.0) THEN  
          SD=0. 
        ELSE    
          SD=LOG(LOG(MAX(Q2,4.)/ALAM**2)/LOG(4./ALAM**2))   
        ENDIF   
    
C...Calculate structure functions.  
        DO 220 KFL=1,4  
        DO 210 IS=1,5   
  210   TS(IS)=COW(1,IS,KFL,NSET)+COW(2,IS,KFL,NSET)*SD+    
     &  COW(3,IS,KFL,NSET)*SD**2    
        IF(KFL.EQ.1) THEN   

clin-10/25/02 get rid of argument usage mismatch in PYGAMM():
c          XQ(KFL)=X**TS(1)*(1.-X)**TS(2)/EULBT(TS(1),TS(2)+1.) 
           eulbt2=PYGAMM(TS(1))*PYGAMM(TS(2)+1.)/PYGAMM(TS(1)+TS(2)+1.)
           XQ(KFL)=X**TS(1)*(1.-X)**TS(2)/EULBT2
        ELSE    
          XQ(KFL)=TS(1)*X**TS(2)*(1.-X)**TS(3)*(1.+TS(4)*X+TS(5)*X**2)  
        ENDIF   
  220   CONTINUE    
    
C...Put into output arrays. 
        XPQ(0)=XQ(2)    
        XPQ(1)=XQ(3)/6. 
        XPQ(2)=XQ(1)+XQ(3)/6.   
        XPQ(3)=XQ(3)/6. 
        XPQ(4)=XQ(4)    
        XPQ(-1)=XQ(1)+XQ(3)/6.  
        XPQ(-2)=XQ(3)/6.    
        XPQ(-3)=XQ(3)/6.    
        XPQ(-4)=XQ(4)   
    
C...Unknown pion parametrization.   
      ELSE  
        WRITE(MSTU(11),1200) MSTP(51)   
      ENDIF 
    
C...Isospin conjugation for neutron, charge conjugation for antipart.   
  230 IF(KFA.EQ.2112) THEN  
        XPS=XPQ(1)  
        XPQ(1)=XPQ(2)   
        XPQ(2)=XPS  
        XPS=XPQ(-1) 
        XPQ(-1)=XPQ(-2) 
        XPQ(-2)=XPS 
      ENDIF 
      IF(KF.LT.0) THEN  
        DO 240 KFL=1,4  
        XPS=XPQ(KFL)    
        XPQ(KFL)=XPQ(-KFL)  
  240   XPQ(-KFL)=XPS   
      ENDIF 
    
C...Check positivity and reset above maximum allowed flavour.   
      DO 250 KFL=-6,6   
      XPQ(KFL)=MAX(0.,XPQ(KFL)) 
  250 IF(IABS(KFL).GT.MSTP(54)) XPQ(KFL)=0. 

C...consider nuclear effect on the structure function
              IF((JBT.NE.1.AND.JBT.NE.2).OR.IHPR2(6).EQ.0
     &                  .OR.IHNT2(16).EQ.1) GO TO 400
              ATNM=IHNT2(2*JBT-1)
              IF(ATNM.LE.1.0) GO TO 400
              IF(JBT.EQ.1) THEN
               BBR2=(YP(1,IHNT2(11))**2+YP(2,IHNT2(11))**2)/1.44/
     1              ATNM**0.66666
              ELSEIF(JBT.EQ.2) THEN
               BBR2=(YT(1,IHNT2(12))**2+YT(2,IHNT2(12))**2)/1.44/
     1              ATNM**0.66666
              ENDIF
              BBR2=MIN(1.0,BBR2)
        ABX=(ATNM**0.33333333-1.0)
              APX=HIPR1(6)*4.0/3.0*ABX*SQRT(1.0-BBR2)
              AAX=1.192*ALOG(ATNM)**0.1666666
              RRX=AAX*(X**3-1.2*X**2+0.21*X)+1.0
     &           -(APX-1.079*ABX*SQRT(X)/ALOG(ATNM+1.0))
     1           *EXP(-X**2.0/0.01)
              DO 300 KFL=-6,6
                XPQ(KFL)=XPQ(KFL)*RRX
300           CONTINUE
C                        ********consider the nuclear effect on the structure
C                                function which also depends on the impact
C                                parameter of the nuclear reaction

 400          CONTINUE    
C...Formats for error printouts.    
 1000 FORMAT(' Error: x value outside physical range, x =',1P,E12.3)    
 1100 FORMAT(' Error: illegal particle code for structure function,',   
     &' KF =',I5)   
 1200 FORMAT(' Error: bad value of parameter MSTP(51) in PYSTFU,',  
     &' MSTP(51) =',I5) 
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYSPLI(KF,KFLIN,KFLCH,KFLSP)   
    
C...In case of a hadron remnant which is more complicated than just a   
C...quark or a diquark, split it into two (partons or hadron + parton). 
      DIMENSION KFL(3)  
    
C...Preliminaries. Parton composition.  
      KFA=IABS(KF)  
      KFS=ISIGN(1,KF)   
      KFL(1)=MOD(KFA/1000,10)   
      KFL(2)=MOD(KFA/100,10)    
      KFL(3)=MOD(KFA/10,10) 
      KFLR=KFLIN*KFS    
      KFLCH=0   
    
C...Subdivide meson.    
      IF(KFL(1).EQ.0) THEN  
        KFL(2)=KFL(2)*(-1)**KFL(2)  
        KFL(3)=-KFL(3)*(-1)**IABS(KFL(2))   
        IF(KFLR.EQ.KFL(2)) THEN 
          KFLSP=KFL(3)  
        ELSEIF(KFLR.EQ.KFL(3)) THEN 
          KFLSP=KFL(2)  
        ELSEIF(IABS(KFLR).EQ.21.AND.RLU(0).GT.0.5) THEN 
          KFLSP=KFL(2)  
          KFLCH=KFL(3)  
        ELSEIF(IABS(KFLR).EQ.21) THEN   
          KFLSP=KFL(3)  
          KFLCH=KFL(2)  
        ELSEIF(KFLR*KFL(2).GT.0) THEN   
          CALL LUKFDI(-KFLR,KFL(2),KFDUMP,KFLCH)    
          KFLSP=KFL(3)  
        ELSE    
          CALL LUKFDI(-KFLR,KFL(3),KFDUMP,KFLCH)    
          KFLSP=KFL(2)  
        ENDIF   
    
C...Subdivide baryon.   
      ELSE  
        NAGR=0  
        DO 100 J=1,3    
  100   IF(KFLR.EQ.KFL(J)) NAGR=NAGR+1  
        IF(NAGR.GE.1) THEN  
          RAGR=0.00001+(NAGR-0.00002)*RLU(0)    
          IAGR=0    
          DO 110 J=1,3  
          IF(KFLR.EQ.KFL(J)) RAGR=RAGR-1.   
  110     IF(IAGR.EQ.0.AND.RAGR.LE.0.) IAGR=J   
        ELSE    
          IAGR=int(1.00001+2.99998*RLU(0))
        ENDIF   
        ID1=1   
        IF(IAGR.EQ.1) ID1=2 
        IF(IAGR.EQ.1.AND.KFL(3).GT.KFL(2)) ID1=3    
        ID2=6-IAGR-ID1  
        KSP=3   
        IF(MOD(KFA,10).EQ.2.AND.KFL(1).EQ.KFL(2)) THEN  
          IF(IAGR.NE.3.AND.RLU(0).GT.0.25) KSP=1    
        ELSEIF(MOD(KFA,10).EQ.2.AND.KFL(2).GE.KFL(3)) THEN  
          IF(IAGR.NE.1.AND.RLU(0).GT.0.25) KSP=1    
        ELSEIF(MOD(KFA,10).EQ.2) THEN   
          IF(IAGR.EQ.1) KSP=1   
          IF(IAGR.NE.1.AND.RLU(0).GT.0.75) KSP=1    
        ENDIF   
        KFLSP=1000*KFL(ID1)+100*KFL(ID2)+KSP    
        IF(KFLIN.EQ.21) THEN    
          KFLCH=KFL(IAGR)   
        ELSEIF(NAGR.EQ.0.AND.KFLR.GT.0) THEN    
          CALL LUKFDI(-KFLR,KFL(IAGR),KFDUMP,KFLCH) 
        ELSEIF(NAGR.EQ.0) THEN  
          CALL LUKFDI(10000+KFLSP,-KFLR,KFDUMP,KFLCH)   
          KFLSP=KFL(IAGR)   
        ENDIF   
      ENDIF 
    
C...Add on correct sign for result. 
      KFLCH=KFLCH*KFS   
      KFLSP=KFLSP*KFS   
    
      RETURN    
      END   
    
C*********************************************************************  
    
      FUNCTION PYGAMM(X)    
    
C...Gives ordinary Gamma function Gamma(x) for positive, real arguments;    
C...see M. Abramowitz, I. A. Stegun: Handbook of Mathematical Functions 
C...(Dover, 1965) 6.1.36.   
      DIMENSION B(8)    
clin      DATA B/-0.577191652,0.988205891,-0.897056937,0.918206857, 
clin     &-0.756704078,0.482199394,-0.193527818,0.035868343/    
      DATA B/-0.57719165,0.98820589,-0.89705694,0.91820686, 
     &-0.75670408,0.48219939,-0.19352782,0.03586834/    
    
      NX=INT(X) 
      DX=X-NX   
    
      PYGAMM=1. 
      DO 100 I=1,8  
  100 PYGAMM=PYGAMM+B(I)*DX**I  
      IF(X.LT.1.) THEN  
        PYGAMM=PYGAMM/X 
      ELSE  
        DO 110 IX=1,NX-1    
  110   PYGAMM=(X-IX)*PYGAMM    
      ENDIF 
    
      RETURN    
      END   
    
C***********************************************************************    
    
      FUNCTION PYW1AU(EPS,IREIM)    
    
C...Calculates real and imaginary parts of the auxiliary function W1;   
C...see R. K. Ellis, I. Hinchliffe, M. Soldate and J. J. van der Bij,   
C...FERMILAB-Pub-87/100-T, LBL-23504, June, 1987    
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
    
clin-8/2014:
c      ASINH(X)=LOG(X+SQRT(X**2+1.)) 
      ACOSH(X)=LOG(X+SQRT(X**2-1.)) 
    
      IF(EPS.LT.0.) THEN    
        W1RE=2.*SQRT(1.-EPS)*ASINH(SQRT(-1./EPS))   
        W1IM=0. 
      ELSEIF(EPS.LT.1.) THEN    
        W1RE=2.*SQRT(1.-EPS)*ACOSH(SQRT(1./EPS))    
        W1IM=-PARU(1)*SQRT(1.-EPS)  
      ELSE  
        W1RE=2.*SQRT(EPS-1.)*ASIN(SQRT(1./EPS)) 
        W1IM=0. 
      ENDIF 
    
      IF(IREIM.EQ.1) PYW1AU=W1RE    
      IF(IREIM.EQ.2) PYW1AU=W1IM    
    
      RETURN    
      END   
    
C***********************************************************************    
    
      FUNCTION PYW2AU(EPS,IREIM)    
    
C...Calculates real and imaginary parts of the auxiliary function W2;   
C...see R. K. Ellis, I. Hinchliffe, M. Soldate and J. J. van der Bij,   
C...FERMILAB-Pub-87/100-T, LBL-23504, June, 1987    
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
    
clin-8/2014:
c      ASINH(X)=LOG(X+SQRT(X**2+1.)) 
      ACOSH(X)=LOG(X+SQRT(X**2-1.)) 
    
      IF(EPS.LT.0.) THEN    
        W2RE=4.*(ASINH(SQRT(-1./EPS)))**2   
        W2IM=0. 
      ELSEIF(EPS.LT.1.) THEN    
        W2RE=4.*(ACOSH(SQRT(1./EPS)))**2-PARU(1)**2 
        W2IM=-4.*PARU(1)*ACOSH(SQRT(1./EPS))    
      ELSE  
        W2RE=-4.*(ASIN(SQRT(1./EPS)))**2    
        W2IM=0. 
      ENDIF 
    
      IF(IREIM.EQ.1) PYW2AU=W2RE    
      IF(IREIM.EQ.2) PYW2AU=W2IM    
    
      RETURN    
      END   
    
C***********************************************************************    
    
      FUNCTION PYI3AU(BE,EPS,IREIM) 
    
C...Calculates real and imaginary parts of the auxiliary function I3;   
C...see R. K. Ellis, I. Hinchliffe, M. Soldate and J. J. van der Bij,   
C...FERMILAB-Pub-87/100-T, LBL-23504, June, 1987    
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
    
      IF(EPS.LT.1.) GA=0.5*(1.+SQRT(1.-EPS))    
    
      IF(EPS.LT.0.) THEN    
        F3RE=PYSPEN((GA-1.)/(GA+BE-1.),0.,1)-PYSPEN(GA/(GA+BE-1.),0.,1)+    
     &  PYSPEN((BE-GA)/BE,0.,1)-PYSPEN((BE-GA)/(BE-1.),0.,1)+   
     &  (LOG(BE)**2-LOG(BE-1.)**2)/2.+LOG(GA)*LOG((GA+BE-1.)/BE)+   
     &  LOG(GA-1.)*LOG((BE-1.)/(GA+BE-1.))  
        F3IM=0. 
      ELSEIF(EPS.LT.1.) THEN    
        F3RE=PYSPEN((GA-1.)/(GA+BE-1.),0.,1)-PYSPEN(GA/(GA+BE-1.),0.,1)+    
     &  PYSPEN(GA/(GA-BE),0.,1)-PYSPEN((GA-1.)/(GA-BE),0.,1)+   
     &  LOG(GA/(1.-GA))*LOG((GA+BE-1.)/(BE-GA)) 
        F3IM=-PARU(1)*LOG((GA+BE-1.)/(BE-GA))   
      ELSE  
        RSQ=EPS/(EPS-1.+(2.*BE-1.)**2)  
        RCTHE=RSQ*(1.-2.*BE/EPS)    
        RSTHE=SQRT(RSQ-RCTHE**2)    
        RCPHI=RSQ*(1.+2.*(BE-1.)/EPS)   
        RSPHI=SQRT(RSQ-RCPHI**2)    
        R=SQRT(RSQ) 
        THE=ACOS(RCTHE/R)   
        PHI=ACOS(RCPHI/R)   
        F3RE=PYSPEN(RCTHE,RSTHE,1)+PYSPEN(RCTHE,-RSTHE,1)-  
     &  PYSPEN(RCPHI,RSPHI,1)-PYSPEN(RCPHI,-RSPHI,1)+   
     &  (PHI-THE)*(PHI+THE-PARU(1)) 
        F3IM=PYSPEN(RCTHE,RSTHE,2)+PYSPEN(RCTHE,-RSTHE,2)-  
     &  PYSPEN(RCPHI,RSPHI,2)-PYSPEN(RCPHI,-RSPHI,2)    
      ENDIF 
    
      IF(IREIM.EQ.1) PYI3AU=2./(2.*BE-1.)*F3RE  
      IF(IREIM.EQ.2) PYI3AU=2./(2.*BE-1.)*F3IM  
    
      RETURN    
      END   
    
C***********************************************************************    
    
      FUNCTION PYSPEN(XREIN,XIMIN,IREIM)    
    
C...Calculates real and imaginary part of Spence function; see  
C...G. 't Hooft and M. Veltman, Nucl. Phys. B153 (1979) 365.    
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      DIMENSION B(0:14) 
    
      DATA B/   
     & 1.000000E+00,        -5.000000E-01,         1.666667E-01,    
     & 0.000000E+00,        -3.333333E-02,         0.000000E+00,    
     & 2.380952E-02,         0.000000E+00,        -3.333333E-02,    
     & 0.000000E+00,         7.575757E-02,         0.000000E+00,    
     &-2.531135E-01,         0.000000E+00,         1.166667E+00/    
    
      XRE=XREIN 
      XIM=XIMIN 
      IF(ABS(1.-XRE).LT.1.E-6.AND.ABS(XIM).LT.1.E-6) THEN   
        IF(IREIM.EQ.1) PYSPEN=PARU(1)**2/6. 
        IF(IREIM.EQ.2) PYSPEN=0.    
        RETURN  
      ENDIF 
    
      XMOD=SQRT(XRE**2+XIM**2)  
      IF(XMOD.LT.1.E-6) THEN    
        IF(IREIM.EQ.1) PYSPEN=0.    
        IF(IREIM.EQ.2) PYSPEN=0.    
        RETURN  
      ENDIF 
    
      XARG=SIGN(ACOS(XRE/XMOD),XIM) 
      SP0RE=0.  
      SP0IM=0.  
      SGN=1.    
      IF(XMOD.GT.1.) THEN   
        ALGXRE=LOG(XMOD)    
        ALGXIM=XARG-SIGN(PARU(1),XARG)  
        SP0RE=-PARU(1)**2/6.-(ALGXRE**2-ALGXIM**2)/2.   
        SP0IM=-ALGXRE*ALGXIM    
        SGN=-1. 
        XMOD=1./XMOD    
        XARG=-XARG  
        XRE=XMOD*COS(XARG)  
        XIM=XMOD*SIN(XARG)  
      ENDIF 
      IF(XRE.GT.0.5) THEN   
        ALGXRE=LOG(XMOD)    
        ALGXIM=XARG 
        XRE=1.-XRE  
        XIM=-XIM    
        XMOD=SQRT(XRE**2+XIM**2)    
        XARG=SIGN(ACOS(XRE/XMOD),XIM)   
        ALGYRE=LOG(XMOD)    
        ALGYIM=XARG 
        SP0RE=SP0RE+SGN*(PARU(1)**2/6.-(ALGXRE*ALGYRE-ALGXIM*ALGYIM))   
        SP0IM=SP0IM-SGN*(ALGXRE*ALGYIM+ALGXIM*ALGYRE)   
        SGN=-SGN    
      ENDIF 
    
      XRE=1.-XRE    
      XIM=-XIM  
      XMOD=SQRT(XRE**2+XIM**2)  
      XARG=SIGN(ACOS(XRE/XMOD),XIM) 
      ZRE=-LOG(XMOD)    
      ZIM=-XARG 
    
      SPRE=0.   
      SPIM=0.   
      SAVERE=1. 
      SAVEIM=0. 
      DO 100 I=0,14 
      TERMRE=(SAVERE*ZRE-SAVEIM*ZIM)/FLOAT(I+1) 
      TERMIM=(SAVERE*ZIM+SAVEIM*ZRE)/FLOAT(I+1) 
      SAVERE=TERMRE 
      SAVEIM=TERMIM 
      SPRE=SPRE+B(I)*TERMRE 
  100 SPIM=SPIM+B(I)*TERMIM 
    
      IF(IREIM.EQ.1) PYSPEN=SP0RE+SGN*SPRE  
      IF(IREIM.EQ.2) PYSPEN=SP0IM+SGN*SPIM  
    
      RETURN    
      END   
    
C*********************************************************************  
    
      BLOCK DATA PYDATA 
    
C...Give sensible default values to all status codes and parameters.    
      COMMON/PYSUBS/MSEL,MSUB(200),KFIN(2,-40:40),CKIN(200) 
      SAVE /PYSUBS/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      COMMON/PYINT1/MINT(400),VINT(400) 
      SAVE /PYINT1/ 
      COMMON/PYINT2/ISET(200),KFPR(200,2),COEF(200,20),ICOL(40,4,2) 
      SAVE /PYINT2/ 
      COMMON/PYINT3/XSFX(2,-40:40),ISIG(1000,3),SIGH(1000)  
      SAVE /PYINT3/ 
      COMMON/PYINT4/WIDP(21:40,0:40),WIDE(21:40,0:40),WIDS(21:40,3) 
      SAVE /PYINT4/ 
      COMMON/PYINT5/NGEN(0:200,3),XSEC(0:200,3) 
      SAVE /PYINT5/ 
      COMMON/PYINT6/PROC(0:200) 
      CHARACTER PROC*28 
      SAVE /PYINT6/ 
    
C...Default values for allowed processes and kinematics constraints.    
      DATA MSEL/1/  
      DATA MSUB/200*0/  
      DATA ((KFIN(I,J),J=-40,40),I=1,2)/40*1,0,80*1,0,40*1/ 
      DATA CKIN/    
     &   2.0, -1.0,  0.0, -1.0,  1.0,  1.0, -10.,  10., -10.,  10., 
     1  -10.,  10., -10.,  10., -10.,  10., -1.0,  1.0, -1.0,  1.0, 
     2   0.0,  1.0,  0.0,  1.0, -1.0,  1.0, -1.0,  1.0,   0.,   0., 
     3   2.0, -1.0,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     4   160*0./    
    
C...Default values for main switches and parameters. Reset information. 
      DATA (MSTP(I),I=1,100)/   
     &     3,    1,    2,    0,    0,    0,    0,    0,    0,    0, 
     1     0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
     2     0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
     3     1,    2,    0,    0,    0,    2,    0,    0,    0,    0, 
     4     1,    0,    3,    7,    1,    0,    0,    0,    0,    0, 
     5     1,    1,   20,    6,    0,    0,    0,    0,    0,    0, 
     6     1,    2,    2,    2,    1,    0,    0,    0,    0,    0, 
     7     1,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
     8     1,    1,  100,    0,    0,    0,    0,    0,    0,    0, 
     9     1,    4,    0,    0,    0,    0,    0,    0,    0,    0/ 
      DATA (MSTP(I),I=101,200)/ 
     &     1,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
     1     1,    1,    1,    0,    0,    0,    0,    0,    0,    0, 
     2     0,    1,    2,    1,    1,   20,    0,    0,    0,    0, 
     3     0,    4,    0,    1,    0,    0,    0,    0,    0,    0, 
     4     0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
     5     0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
     6     0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
     7     0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
     8     5,    3, 1989,   11,   24,    0,    0,    0,    0,    0, 
     9     0,    0,    0,    0,    0,    0,    0,    0,    0,    0/ 
      DATA (PARP(I),I=1,100)/   
     &  0.25,  10.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     1    0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     2    0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     3   1.5,  2.0, 0.075,  0.,  0.2,   0.,   0.,   0.,   0.,   0., 
     4    0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     5   1.0, 2.26, 1.E4, 1.E-4,  0.,   0.,   0.,   0.,   0.,   0., 
     6  0.25,  1.0, 0.25,  1.0,  2.0, 1.E-3, 4.0,   0.,   0.,   0., 
     7   4.0,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     8   1.6, 1.85,  0.5,  0.2, 0.33, 0.66,  0.7,  0.5,   0.,   0., 
     9  0.44, 0.44,  2.0,  1.0,   0.,  3.0,  1.0, 0.75,   0.,   0./ 
      DATA (PARP(I),I=101,200)/ 
     & -0.02,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     1   2.0,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     2   0.4,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     3  0.01,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     4    0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     5    0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     6    0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     7    0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     8    0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 
     9    0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0./ 
      DATA MSTI/200*0/  
      DATA PARI/200*0./ 
      DATA MINT/400*0/  
      DATA VINT/400*0./ 
    
C...Constants for the generation of the various processes.  
      DATA (ISET(I),I=1,100)/   
     &    1,    1,    1,   -1,    3,   -1,   -1,    3,   -2,   -2,  
     1    2,    2,    2,    2,    2,    2,   -1,    2,    2,    2,  
     2   -1,    2,    2,    2,    2,    2,   -1,    2,    2,    2,  
     3    2,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  
     4   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  
     5   -1,   -1,    2,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  
     6   -1,   -1,   -1,   -1,   -1,   -1,   -1,    2,   -1,   -1,  
     7    4,    4,    4,   -1,   -1,    4,    4,   -1,   -1,   -2,  
     8    2,    2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,  
     9    0,    0,    0,   -1,    0,    5,   -2,   -2,   -2,   -2/  
      DATA (ISET(I),I=101,200)/ 
     &   -1,    1,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,  
     1    2,    2,    2,    2,   -1,   -1,   -1,   -2,   -2,   -2,  
     2   -1,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,  
     3   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,  
     4    1,    1,    1,   -2,   -2,   -2,   -2,   -2,   -2,   -2,  
     5   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,  
     6    2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,  
     7   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,  
     8   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,  
     9   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2/  
      DATA ((KFPR(I,J),J=1,2),I=1,50)/  
     &   23,    0,   24,    0,   25,    0,   24,    0,   25,    0,  
     &   24,    0,   23,    0,   25,    0,    0,    0,    0,    0,  
     1    0,    0,    0,    0,   21,   21,   21,   22,   21,   23,  
     1   21,   24,   21,   25,   22,   22,   22,   23,   22,   24,  
     2   22,   25,   23,   23,   23,   24,   23,   25,   24,   24,  
     2   24,   25,   25,   25,    0,   21,    0,   22,    0,   23,  
     3    0,   24,    0,   25,    0,   21,    0,   22,    0,   23,  
     3    0,   24,    0,   25,    0,   21,    0,   22,    0,   23,  
     4    0,   24,    0,   25,    0,   21,    0,   22,    0,   23,  
     4    0,   24,    0,   25,    0,   21,    0,   22,    0,   23/  
      DATA ((KFPR(I,J),J=1,2),I=51,100)/    
     5    0,   24,    0,   25,    0,    0,    0,    0,    0,    0,  
     5    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     6    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     6    0,    0,    0,    0,   21,   21,   24,   24,   22,   24,  
     7   23,   23,   24,   24,   23,   24,   23,   25,   22,   22,  
     7   23,   23,   24,   24,   24,   25,   25,   25,    0,    0,  
     8    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     8    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     9    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     9    0,    0,    0,    0,    0,    0,    0,    0,    0,    0/  
      DATA ((KFPR(I,J),J=1,2),I=101,150)/   
     &   23,    0,   25,    0,    0,    0,    0,    0,    0,    0,  
     &    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     1   21,   25,    0,   25,   21,   25,   22,   22,   22,   23,  
     1   23,   23,   24,   24,    0,    0,    0,    0,    0,    0,  
     2    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     2    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     3    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     3    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     4   32,    0,   37,    0,   40,    0,    0,    0,    0,    0,  
     4    0,    0,    0,    0,    0,    0,    0,    0,    0,    0/  
      DATA ((KFPR(I,J),J=1,2),I=151,200)/   
     5    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     5    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     6    0,   37,    0,    0,    0,    0,    0,    0,    0,    0,  
     6    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     7    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     7    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     8    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     8    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     9    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,  
     9    0,    0,    0,    0,    0,    0,    0,    0,    0,    0/  
      DATA COEF/4000*0./    
      DATA (((ICOL(I,J,K),K=1,2),J=1,4),I=1,40)/    
     1 4,0,3,0,2,0,1,0,3,0,4,0,1,0,2,0,2,0,0,1,4,0,0,3,3,0,0,4,1,0,0,2, 
     2 3,0,0,4,1,4,3,2,4,0,0,3,4,2,1,3,2,0,4,1,4,0,2,3,4,0,3,4,2,0,1,2, 
     3 3,2,1,0,1,4,3,0,4,3,3,0,2,1,1,0,3,2,1,4,1,0,0,2,2,4,3,1,2,0,0,1, 
     4 3,2,1,4,1,4,3,2,4,2,1,3,4,2,1,3,3,4,4,3,1,2,2,1,2,0,3,1,2,0,0,0, 
     5 4,2,1,0,0,0,1,0,3,0,0,3,1,2,0,0,4,0,0,4,0,0,1,2,2,0,0,1,4,4,3,3, 
     6 2,2,1,1,4,4,3,3,3,3,4,4,1,1,2,2,3,2,1,3,1,2,0,0,4,2,1,4,0,0,1,2, 
     7 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 
     8 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 
     9 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 
     & 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0/ 
    
C...Character constants: name of processes. 
      DATA PROC(0)/                    'All included subprocesses   '/  
      DATA (PROC(I),I=1,20)/    
     1'f + fb -> gamma*/Z0         ',  'f + fb'' -> W+/-             ', 
     2'f + fb -> H0                ',  'gamma + W+/- -> W+/-        ',  
     3'Z0 + Z0 -> H0               ',  'Z0 + W+/- -> W+/-           ',  
     4'                            ',  'W+ + W- -> H0               ',  
     5'                            ',  '                            ',  
     6'f + f'' -> f + f''            ','f + fb -> f'' + fb''          ',    
     7'f + fb -> g + g             ',  'f + fb -> g + gamma         ',  
     8'f + fb -> g + Z0            ',  'f + fb'' -> g + W+/-         ', 
     9'f + fb -> g + H0            ',  'f + fb -> gamma + gamma     ',  
     &'f + fb -> gamma + Z0        ',  'f + fb'' -> gamma + W+/-     '/ 
      DATA (PROC(I),I=21,40)/   
     1'f + fb -> gamma + H0        ',  'f + fb -> Z0 + Z0           ',  
     2'f + fb'' -> Z0 + W+/-        ', 'f + fb -> Z0 + H0           ',  
     3'f + fb -> W+ + W-           ',  'f + fb'' -> W+/- + H0        ', 
     4'f + fb -> H0 + H0           ',  'f + g -> f + g              ',  
     5'f + g -> f + gamma          ',  'f + g -> f + Z0             ',  
     6'f + g -> f'' + W+/-          ', 'f + g -> f + H0             ',  
     7'f + gamma -> f + g          ',  'f + gamma -> f + gamma      ',  
     8'f + gamma -> f + Z0         ',  'f + gamma -> f'' + W+/-      ', 
     9'f + gamma -> f + H0         ',  'f + Z0 -> f + g             ',  
     &'f + Z0 -> f + gamma         ',  'f + Z0 -> f + Z0            '/  
      DATA (PROC(I),I=41,60)/   
     1'f + Z0 -> f'' + W+/-         ', 'f + Z0 -> f + H0            ',  
     2'f + W+/- -> f'' + g          ', 'f + W+/- -> f'' + gamma      ', 
     3'f + W+/- -> f'' + Z0         ', 'f + W+/- -> f'' + W+/-       ', 
     4'f + W+/- -> f'' + H0         ', 'f + H0 -> f + g             ',  
     5'f + H0 -> f + gamma         ',  'f + H0 -> f + Z0            ',  
     6'f + H0 -> f'' + W+/-         ', 'f + H0 -> f + H0            ',  
     7'g + g -> f + fb             ',  'g + gamma -> f + fb         ',  
     8'g + Z0 -> f + fb            ',  'g + W+/- -> f + fb''         ', 
     9'g + H0 -> f + fb            ',  'gamma + gamma -> f + fb     ',  
     &'gamma + Z0 -> f + fb        ',  'gamma + W+/- -> f + fb''     '/ 
      DATA (PROC(I),I=61,80)/   
     1'gamma + H0 -> f + fb        ',  'Z0 + Z0 -> f + fb           ',  
     2'Z0 + W+/- -> f + fb''        ', 'Z0 + H0 -> f + fb           ',  
     3'W+ + W- -> f + fb           ',  'W+/- + H0 -> f + fb''        ', 
     4'H0 + H0 -> f + fb           ',  'g + g -> g + g              ',  
     5'gamma + gamma -> W+ + W-    ',  'gamma + W+/- -> gamma + W+/-',  
     6'Z0 + Z0 -> Z0 + Z0          ',  'Z0 + Z0 -> W+ + W-          ',  
     7'Z0 + W+/- -> Z0 + W+/-      ',  'Z0 + Z0 -> Z0 + H0          ',  
     8'W+ + W- -> gamma + gamma    ',  'W+ + W- -> Z0 + Z0          ',  
     9'W+/- + W+/- -> W+/- + W+/-  ',  'W+/- + H0 -> W+/- + H0      ',  
     &'H0 + H0 -> H0 + H0          ',  '                            '/  
      DATA (PROC(I),I=81,100)/  
     1'q + qb -> Q + QB, massive   ',  'g + g -> Q + QB, massive    ',  
     2'                            ',  '                            ',  
     3'                            ',  '                            ',  
     4'                            ',  '                            ',  
     5'                            ',  '                            ',  
     6'Elastic scattering          ',  'Single diffractive          ',  
     7'Double diffractive          ',  'Central diffractive         ',  
     8'Low-pT scattering           ',  'Semihard QCD 2 -> 2         ',  
     9'                            ',  '                            ',  
     &'                            ',  '                            '/  
      DATA (PROC(I),I=101,120)/ 
     1'g + g -> gamma*/Z0          ',  'g + g -> H0                 ',  
     2'                            ',  '                            ',  
     3'                            ',  '                            ',  
     4'                            ',  '                            ',  
     5'                            ',  '                            ',  
     6'f + fb -> g + H0            ',  'q + g -> q + H0             ',  
     7'g + g -> g + H0             ',  'g + g -> gamma + gamma      ',  
     8'g + g -> gamma + Z0         ',  'g + g -> Z0 + Z0            ',  
     9'g + g -> W+ + W-            ',  '                            ',  
     &'                            ',  '                            '/  
      DATA (PROC(I),I=121,140)/ 
     1'g + g -> f + fb + H0        ',  '                            ',  
     2'                            ',  '                            ',  
     3'                            ',  '                            ',  
     4'                            ',  '                            ',  
     5'                            ',  '                            ',  
     6'                            ',  '                            ',  
     7'                            ',  '                            ',  
     8'                            ',  '                            ',  
     9'                            ',  '                            ',  
     &'                            ',  '                            '/  
      DATA (PROC(I),I=141,160)/ 
     1'f + fb -> gamma*/Z0/Z''0     ', 'f + fb'' -> H+/-             ', 
     2'f + fb -> R                 ',  '                            ',  
     3'                            ',  '                            ',  
     4'                            ',  '                            ',  
     5'                            ',  '                            ',  
     6'                            ',  '                            ',  
     7'                            ',  '                            ',  
     8'                            ',  '                            ',  
     9'                            ',  '                            ',  
     &'                            ',  '                            '/  
      DATA (PROC(I),I=161,180)/ 
     1'f + g -> f'' + H+/-          ', '                            ',  
     2'                            ',  '                            ',  
     3'                            ',  '                            ',  
     4'                            ',  '                            ',  
     5'                            ',  '                            ',  
     6'                            ',  '                            ',  
     7'                            ',  '                            ',  
     8'                            ',  '                            ',  
     9'                            ',  '                            ',  
     &'                            ',  '                            '/  
      DATA (PROC(I),I=181,200)/     20*'                            '/  
    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYKCUT(MCUT)   
    
C...Dummy routine, which the user can replace in order to make cuts on  
C...the kinematics on the parton level before the matrix elements are   
C...evaluated and the event is generated. The cross-section estimates   
C...will automatically take these cuts into account, so the given   
C...values are for the allowed phase space region only. MCUT=0 means    
C...that the event has passed the cuts, MCUT=1 that it has failed.  
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
    
      MCUT=0    
    
      RETURN    
      END   
    
C*********************************************************************  
    
      SUBROUTINE PYSTFE(KF,X,Q2,XPQ)    
    
C...This is a dummy routine, where the user can introduce an interface  
C...to his own external structure function parametrization. 
C...Arguments in:   
C...KF : 2212 for p, 211 for pi+; isospin conjugation for n and charge  
C...    conjugation for pbar, nbar or pi- is performed by PYSTFU.   
C...X : x value.    
C...Q2 : Q^2 value. 
C...Arguments out:  
C...XPQ(-6:6) : x * f(x,Q2), with index according to KF code,   
C...    except that gluon is placed in 0. Thus XPQ(0) = xg, 
C...    XPQ(1) = xd, XPQ(-1) = xdbar, XPQ(2) = xu, XPQ(-2) = xubar, 
C...    XPQ(3) = xs, XPQ(-3) = xsbar, XPQ(4) = xc, XPQ(-4) = xcbar, 
C...    XPQ(5) = xb, XPQ(-5) = xbbar, XPQ(6) = xt, XPQ(-6) = xtbar. 
C...    
C...One such interface, to the Diemos, Ferroni, Longo, Martinelli   
C...proton structure functions, already comes with the package. What    
C...the user needs here is external files with the three routines   
C...FXG160, FXG260 and FXG360 of the authors above, plus the    
C...interpolation routine FINT, which is part of the CERN library   
C...KERNLIB package. To avoid problems with unresolved external 
C...references, the external calls are commented in the current 
C...version. To enable this option, remove the C* at the beginning  
C...of the relevant lines.  
C...    
C...Alternatively, the routine can be used as an interface to the   
C...structure function evolution program of Tung. This can be achieved  
C...by removing C* at the beginning of some of the lines below. 
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
      SAVE /LUDAT1/ 
      COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)    
      SAVE /LUDAT2/ 
      COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200) 
      SAVE /PYPARS/ 
      DIMENSION XPQ(-6:6),XFDFLM(9) 
      CHARACTER CHDFLM(9)*5,HEADER*40   
      DATA CHDFLM/'UPVAL','DOVAL','GLUON','QBAR ','UBAR ','SBAR ',  
     &'CBAR ','BBAR ','TBAR '/  
      DATA HEADER/'Tung evolution package has been invoked'/    
      DATA INIT/0/  
    
C...Proton structure functions from Diemoz, Ferroni, Longo, Martinelli. 
C...Allowed variable range 10 GeV2 < Q2 < 1E8 GeV2, 5E-5 < x < .95. 
      IF(MSTP(51).GE.11.AND.MSTP(51).LE.13.AND.MSTP(52).LE.1) THEN  
        XDFLM=MAX(0.51E-4,X)    
        Q2DFLM=MAX(10.,MIN(1E8,Q2)) 
        IF(MSTP(52).EQ.0) Q2DFLM=10.    
        DO 100 J=1,9    
        IF(MSTP(52).EQ.1.AND.J.EQ.9) THEN   
          Q2DFLM=Q2DFLM*(40./PMAS(6,1))**2  
          Q2DFLM=MAX(10.,MIN(1E8,Q2))   
        ENDIF   
        XFDFLM(J)=0.    
C...Remove C* on following three lines to enable the DFLM options.  
C*      IF(MSTP(51).EQ.11) CALL FXG160(XDFLM,Q2DFLM,CHDFLM(J),XFDFLM(J))    
C*      IF(MSTP(51).EQ.12) CALL FXG260(XDFLM,Q2DFLM,CHDFLM(J),XFDFLM(J))    
C*      IF(MSTP(51).EQ.13) CALL FXG360(XDFLM,Q2DFLM,CHDFLM(J),XFDFLM(J))    
  100   CONTINUE    
        IF(X.LT.0.51E-4.AND.ABS(PARP(51)-1.).GT.0.01) THEN  
          CXS=(0.51E-4/X)**(PARP(51)-1.)    
          DO 110 J=1,7  
  110     XFDFLM(J)=XFDFLM(J)*CXS   
        ENDIF   
        XPQ(0)=XFDFLM(3)    
        XPQ(1)=XFDFLM(2)+XFDFLM(5)  
        XPQ(2)=XFDFLM(1)+XFDFLM(5)  
        XPQ(3)=XFDFLM(6)    
        XPQ(4)=XFDFLM(7)    
        XPQ(5)=XFDFLM(8)    
        XPQ(6)=XFDFLM(9)    
        XPQ(-1)=XFDFLM(5)   
        XPQ(-2)=XFDFLM(5)   
        XPQ(-3)=XFDFLM(6)   
        XPQ(-4)=XFDFLM(7)   
        XPQ(-5)=XFDFLM(8)   
        XPQ(-6)=XFDFLM(9)   
    
C...Proton structure function evolution from Wu-Ki Tung: parton 
C...distribution functions incorporating heavy quark mass effects.  
C...Allowed variable range: PARP(52) < Q < PARP(53); PARP(54) < x < 1.  
      ELSE  
        IF(INIT.EQ.0) THEN  
          I1=0  
          IF(MSTP(52).EQ.4) I1=1    
          IHDRN=1   
          NU=MSTP(53)   
          I2=MSTP(51)   
          IF(MSTP(51).GE.11) I2=MSTP(51)-3  
          I3=0  
          IF(MSTP(52).EQ.3) I3=1    
    
C...Convert to Lambda in CWZ scheme (approximately linear relation).    
          ALAM=0.75*PARP(1) 
          TPMS=PMAS(6,1)    
          QINI=PARP(52) 
          QMAX=PARP(53) 
          XMIN=PARP(54) 
    
C...Initialize evolution (perform calculation or read results from  
C...file).  
C...Remove C* on following two lines to enable Tung initialization. 
C*        CALL PDFSET(I1,IHDRN,ALAM,TPMS,QINI,QMAX,XMIN,NU,HEADER,  
C*   &    I2,I3,IRET,IRR)   
          INIT=1    
        ENDIF   
    
C...Put into output array.  
        Q=SQRT(Q2)  
        DO 200 I=-6,6   
        FIXQ=0. 
C...Remove C* on following line to enable structure function call.  
C*      FIXQ=MAX(0.,PDF(10,1,I,X,Q,IR)) 
  200   XPQ(I)=X*FIXQ   
    
C...Change order of u and d quarks from Tung to PYTHIA convention.  
        XPS=XPQ(1)  
        XPQ(1)=XPQ(2)   
        XPQ(2)=XPS  
        XPS=XPQ(-1) 
        XPQ(-1)=XPQ(-2) 
        XPQ(-2)=XPS 
      ENDIF 
    
      RETURN    
      END   

c.................... linana.f
c=======================================================================
c     10/26/01 update freezeout positions in case of interactions:
clin-3/2009 Note: freezeout spacetime values cannot be trusted for K0S & K0L 
c     as K0S/K0L are converted from K+/K- by hand at the end of hadron cascade.
      subroutine hbtout(nnew,nt,ntmax)
c
      PARAMETER  (MAXSTR=150001,MAXR=1)
clin-5/2008 give tolerance to regular particles (perturbative probability 1):
      PARAMETER  (oneminus=0.99999,oneplus=1.00001)
      dimension lastkp(MAXSTR), newkp(MAXSTR),xnew(3)
      common /para7/ ioscar,nsmbbbar,nsmmeson
cc      SAVE /para7/
      COMMON/hbt/lblast(MAXSTR),xlast(4,MAXSTR),plast(4,MAXSTR),nlast
cc      SAVE /hbt/
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
      COMMON   /AA/  R(3,MAXSTR)
cc      SAVE /AA/
      COMMON   /BB/  P(3,MAXSTR)
cc      SAVE /BB/
      COMMON   /CC/  E(MAXSTR)
cc      SAVE /CC/
      COMMON   /EE/  ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
      common /lastt/itimeh,bimp
cc      SAVE /lastt/
      COMMON/tdecay/tfdcy(MAXSTR),tfdpi(MAXSTR,MAXR),tft(MAXSTR)
cc      SAVE /tdecay/
      COMMON /AREVT/ IAEVT, IARUN, MISS
cc      SAVE /AREVT/
      common/snn/efrm,npart1,npart2,epsiPz,epsiPt,PZPROJ,PZTARG
cc      SAVE /snn/
      COMMON/HJGLBR/NELT,NINTHJ,NELP,NINP
cc      SAVE /HJGLBR/
      COMMON/FTMAX/ftsv(MAXSTR),ftsvt(MAXSTR, MAXR)
      COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1     dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2     dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
clin-12/14/03:
      COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
      EXTERNAL IARFLV, INVFLV
      common /para8/ idpert,npertd,idxsec
clin-2/2012:
      common /phiHJ/iphirp,phiRP
      SAVE   
c
      do 1001 i=1,max0(nlast,nnew)
         lastkp(i)=0
 1001 continue
      do 1002 i=1,nnew
         newkp(i)=0
 1002 continue
c     for each of the particles, search the freezeout record (common /hbt/) 
c     to find & keep those which do not have interactions during this timestep:
      do 100 ip=1,nnew
         do 1004 iplast=1,nlast
            if(p(1,ip).eq.plast(1,iplast).and.
     1           p(2,ip).eq.plast(2,iplast).and.
     2           p(3,ip).eq.plast(3,iplast).and.
     3           e(ip).eq.plast(4,iplast).and.
     4           lb(ip).eq.lblast(iplast).and.
     5      dpertp(ip).eq.dplast(iplast).and.lastkp(iplast).eq.0) then
clin-5/2008 modified below to the above in case we have perturbative particles:
c     5           lastkp(iplast).eq.0) then
               deltat=nt*dt-xlast(4,iplast)
               ene=sqrt(plast(1,iplast)**2+plast(2,iplast)**2
     1              +plast(3,iplast)**2+plast(4,iplast)**2)
c     xnew gives the coordinate if a particle free-streams to current time:
               do 1003 ii=1,3
                  xnew(ii)=xlast(ii,iplast)+plast(ii,iplast)/ene*deltat
 1003          continue
                  dr=sqrt((r(1,ip)-xnew(1))**2+(r(2,ip)-xnew(2))**2
     1              +(r(3,ip)-xnew(3))**2)
c     find particles with dp=0 and dr<0.01, considered to be those 
c     without any interactions during this timestep, 
c     thus keep their last positions and time:
               if(dr.le.0.01) then
                  lastkp(iplast)=1
                  newkp(ip)=1
c                  if(lb(ip).eq.41) then
c                write(95,*) 'nt,ip,px,x=',nt,ip,p(1,ip),r(1,ip),ftsv(ip)
c                write(95,*) 'xnew=',xnew(1),xnew(2),xnew(3),xlast(4,ip)
c                  endif
clin-5/2009 Take care of formation time of particles read in at nt=ntmax-1:
                  if(nt.eq.ntmax.and.ftsv(ip).gt.((ntmax-1)*dt)) 
     1                 xlast(4,iplast)=ftsv(ip)
                  goto 100
               endif
            endif
 1004    continue
 100  continue
c     for current particles with interactions, fill their current info in 
c     the freezeout record (if that record entry needs not to be kept):
      do 150 ip=1,nnew
         if(newkp(ip).eq.0) then
            do 1005 iplast=1,nnew
               if(lastkp(iplast).eq.0) then
ctest off: write collision info
c                  if(lb(ip).eq.41) then
c                     write(95,*) 'nt,lb(ip)=',nt,lb(ip)
c                  write(95,*) '  last p=',plast(1,iplast),
c     1 plast(2,iplast),plast(3,iplast),plast(4,iplast)
c                  write(95,*) '  after p=',p(1,ip),p(2,ip),p(3,ip),e(ip)
c                  write(95,*) 'after x=',r(1,ip),r(2,ip),r(3,ip),ftsv(ip)
c                  endif
c
                  xlast(1,iplast)=r(1,ip)
                  xlast(2,iplast)=r(2,ip)
                  xlast(3,iplast)=r(3,ip)
                  xlast(4,iplast)=nt*dt
c
                  if(nt.eq.ntmax) then
c     freezeout time for decay daughters at the last timestep 
c     needs to include the decay time of the parent:
                     if(tfdcy(ip).gt.(ntmax*dt+0.001)) then
                        xlast(4,iplast)=tfdcy(ip)
c     freezeout time for particles unformed at the next-to-last timestep 
c     needs to be their formation time instead of (ntmax*dt):
                     elseif(ftsv(ip).gt.((ntmax-1)*dt)) then
                        xlast(4,iplast)=ftsv(ip)
                     endif
                  endif
                  plast(1,iplast)=p(1,ip)
                  plast(2,iplast)=p(2,ip)
                  plast(3,iplast)=p(3,ip)
                  plast(4,iplast)=e(ip)
                  lblast(iplast)=lb(ip)
                  lastkp(iplast)=1
clin-5/2008:
                  dplast(iplast)=dpertp(ip)
                  goto 150
               endif
 1005       continue
         endif
 150  continue
c     if the current particle list is shorter than the freezeout record,
c     condense the last-collision record by filling new record from 1 to nnew, 
c     and label these entries as keep:
      if(nnew.lt.nlast) then
         do 170 iplast=1,nlast
            if(lastkp(iplast).eq.0) then
               do 1006 ip2=iplast+1,nlast
                  if(lastkp(ip2).eq.1) then
                     xlast(1,iplast)=xlast(1,ip2)
                     xlast(2,iplast)=xlast(2,ip2)
                     xlast(3,iplast)=xlast(3,ip2)
                     xlast(4,iplast)=xlast(4,ip2)
                     plast(1,iplast)=plast(1,ip2)
                     plast(2,iplast)=plast(2,ip2)
                     plast(3,iplast)=plast(3,ip2)
                     plast(4,iplast)=plast(4,ip2)
                     lblast(iplast)=lblast(ip2)
                     lastkp(iplast)=1
clin-5/2008:
                     dplast(iplast)=dplast(ip2)
                     goto 170
                  endif
 1006          continue
            endif
 170     continue
      endif
      nlast=nnew
ctest off look inside each NT timestep (for debugging purpose):
c      do ip=1,nlast
c         write(99,*) ' p ',nt,ip,lblast(ip),plast(1,ip),
c     1        plast(2,ip),plast(3,ip),plast(4,ip),dplast(ip)
c         write(99,*) '  x ',nt,ip,lblast(ip),xlast(1,ip),
c     1        xlast(2,ip),xlast(3,ip),xlast(4,ip),dplast(ip)
c      enddo
c
      if(nt.eq.ntmax) then
clin-5/2008 find final number of perturbative particles (deuterons only):
         ndpert=0
         do ip=1,nlast
            if(dplast(ip).gt.oneminus.and.dplast(ip).lt.oneplus) then
            else
               ndpert=ndpert+1
            endif
         enddo
c
c         write(16,190) IAEVT,IARUN,nlast,bimp,npart1,npart2,
c     1 NELP,NINP,NELT,NINTHJ
clin-2/2012:
c         write(16,190) IAEVT,IARUN,nlast-ndpert,bimp,npart1,npart2,
c     1 NELP,NINP,NELT,NINTHJ
         write(16,191) IAEVT,IARUN,nlast-ndpert,bimp,npart1,npart2,
     1 NELP,NINP,NELT,NINTHJ,phiRP
clin-5/2008 write out perturbatively-produced particles (deuterons only):
         if(idpert.eq.1.or.idpert.eq.2)
     1        write(90,190) IAEVT,IARUN,ndpert,bimp,npart1,npart2,
     2        NELP,NINP,NELT,NINTHJ
         do 1007 ip=1,nlast
clin-12/14/03   No formation time for spectator projectile or target nucleons,
c     see ARINI1 in 'amptsub.f':
clin-3/2009 To be consistent with new particles produced in hadron cascade
c     that are limited by the time-resolution (DT) of the hadron cascade, 
c     freezeout time of spectator projectile or target nucleons is written as 
c     DT as they are read at the 1st timestep and then propagated to time DT: 
c
clin-9/2011 determine spectator nucleons consistently
c            if(plast(1,ip).eq.0.and.plast(2,ip).eq.0
c     1           .and.(sqrt(plast(3,ip)**2+plast(4,ip)**2)*2/HINT1(1))
c     2           .gt.0.99.and.(lblast(ip).eq.1.or.lblast(ip).eq.2)) then
            if(abs(plast(1,ip)).le.epsiPt.and.abs(plast(2,ip)).le.epsiPt
     1           .and.(plast(3,ip).gt.amax1(0.,PZPROJ-epsiPz)
     2                .or.plast(3,ip).lt.(-PZTARG+epsiPz))
     3           .and.(lblast(ip).eq.1.or.lblast(ip).eq.2)) then
clin-5/2008 perturbatively-produced particles (currently only deuterons) 
c     are written to ana/ampt_pert.dat (without the column for the mass); 
c     ana/ampt.dat has regularly-produced particles (including deuterons);
c     these two sets of deuteron data are close to each other(but not the same 
c     because of the bias from triggering the perturbative production); 
c     ONLY use one data set for analysis to avoid double-counting:
               if(dplast(ip).gt.oneminus.and.dplast(ip).lt.oneplus) then
                  write(16,200) INVFLV(lblast(ip)), plast(1,ip),
     1                 plast(2,ip),plast(3,ip),plast(4,ip),
     2                 xlast(1,ip),xlast(2,ip),xlast(3,ip),
     3                 xlast(4,ip)
clin-12/14/03-end
               else
                  if(idpert.eq.1.or.idpert.eq.2) then
                     write(90,250) INVFLV(lblast(ip)), plast(1,ip),
     1                 plast(2,ip),plast(3,ip),
     2                 xlast(1,ip),xlast(2,ip),xlast(3,ip),
     3                 xlast(4,ip)
                  else
                     write(99,*) 'Unexpected perturbative particles'
                  endif
               endif
            elseif(amax1(abs(xlast(1,ip)),abs(xlast(2,ip)),
     1              abs(xlast(3,ip)),abs(xlast(4,ip))).lt.9999) then
               if(dplast(ip).gt.oneminus.and.dplast(ip).lt.oneplus) then
            write(16,200) INVFLV(lblast(ip)), plast(1,ip),
     1           plast(2,ip),plast(3,ip),plast(4,ip),
     2           xlast(1,ip),xlast(2,ip),xlast(3,ip),xlast(4,ip)
               else
                  if(idpert.eq.1.or.idpert.eq.2) then
            write(90,250) INVFLV(lblast(ip)),plast(1,ip),
     1           plast(2,ip),plast(3,ip),
     2           xlast(1,ip),xlast(2,ip),xlast(3,ip),xlast(4,ip),
     3           dplast(ip)
                  else
                     write(99,*) 'Unexpected perturbative particles'
                  endif
               endif
            else
c     change format for large numbers:
               if(dplast(ip).gt.oneminus.and.dplast(ip).lt.oneplus) then
            write(16,201) INVFLV(lblast(ip)), plast(1,ip),
     1           plast(2,ip),plast(3,ip),plast(4,ip),
     2           xlast(1,ip),xlast(2,ip),xlast(3,ip),xlast(4,ip)
               else
                  if(idpert.eq.1.or.idpert.eq.2) then
                     write(90,251) INVFLV(lblast(ip)), plast(1,ip),
     1           plast(2,ip),plast(3,ip),
     2           xlast(1,ip),xlast(2,ip),xlast(3,ip),xlast(4,ip),
     3           dplast(ip)
                  else
                     write(99,*) 'Unexpected perturbative particles'
                  endif
               endif
            endif
 1007    continue
         if(ioscar.eq.1) call hoscar
      endif
 190  format(3(i7),f10.4,5x,6(i4))
 191  format(3(i7),f10.4,5x,6(i4),5x,f7.4)
clin-3/2009 improve the output accuracy of Pz
 200  format(I6,2(1x,f8.3),1x,f11.4,1x,f6.3,4(1x,f8.2))
 201  format(I6,2(1x,f8.3),1x,f11.4,1x,f6.3,4(1x,e8.2))
 250  format(I5,2(1x,f8.3),1x,f10.3,2(1x,f7.1),1x,f8.2,1x,f7.2,1x,e10.4)
 251  format(I5,2(1x,f8.3),1x,f10.3,4(1x,e8.2),1x,e10.4)
c     
        return
        end

c=======================================================================
        SUBROUTINE decomp(px0,py0,pz0,xm0,i,itq1)
c
        IMPLICIT DOUBLE PRECISION(D)  
        DOUBLE PRECISION  enenew, pxnew, pynew, pznew
clin-8/2015 changed ptwo(2,5) and related variables to double precision
c     to avoid IEEE_DIVIDE_BY_ZERO or IEEE_INVALID or IEEE_OVERFLOW_FLAG:
        DOUBLE PRECISION  de0, beta2, gam, ptwo, px0, py0, pz0, xm0
        common /lor/ enenew, pxnew, pynew, pznew
cc      SAVE /lor/
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
        common /decom/ptwo(2,5)
cc      SAVE /decom/
        COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
        COMMON/HMAIN1/EATT,JATT,NATT,NT,NP,N0,N01,N10,N11
        common/embed/iembed,nsembd,pxqembd,pyqembd,xembd,yembd,
     1       psembd,tmaxembd,phidecomp
        SAVE   
c
        dcth=dble(RANART(NSEED))*2.d0-1.d0
        dPHI=dble(RANART(NSEED)*HIPR1(40))*2.d0
clin-6/2009 Added if embedding a high-Pt quark pair after string melting:
        if(iembed.ge.1.and.iembed.le.4) then
c     Decompose the parent high-Pt pion to q and qbar with an internal momentum
c     parallel to the pion direction so that one parton has ~the same hight Pt
c     and the other parton has a very soft Pt:
c     Note: htop() decomposes a meson to q as it(1) followed by qbar as it(2):
           if(i.eq.(natt-2*nsembd).or.i.eq.(natt-2*nsembd-1)) then
              dcth=0.d0
              dphi=dble(phidecomp)
           endif
        endif
c
        ds=xm0**2
        dpcm=dsqrt((ds-(ptwo(1,5)+ptwo(2,5))**2)
     1 *(ds-(ptwo(1,5)-ptwo(2,5))**2)/ds/4d0)
        dpz=dpcm*dcth
        dpx=dpcm*dsqrt(1.d0-dcth**2)*dcos(dphi)
        dpy=dpcm*dsqrt(1.d0-dcth**2)*dsin(dphi)
        de1=dsqrt(ptwo(1,5)**2+dpcm**2)
        de2=dsqrt(ptwo(2,5)**2+dpcm**2)
c
      de0=dsqrt(px0**2+py0**2+pz0**2+xm0**2)
        dbex=px0/de0
        dbey=py0/de0
        dbez=pz0/de0
c     boost the reference frame up by beta (pznew=gam(pz+beta e)):
      beta2 = dbex ** 2 + dbey ** 2 + dbez ** 2
      gam = 1.d0 / dsqrt(1.d0 - beta2)
      if(beta2.ge.0.9999999999999d0) then
         write(6,*) '1',dbex,dbey,dbez,beta2,gam
      endif
c
      call lorenz(de1,dpx,dpy,dpz,-dbex,-dbey,-dbez)
        ptwo(1,1)=pxnew
        ptwo(1,2)=pynew
        ptwo(1,3)=pznew
        ptwo(1,4)=enenew
      call lorenz(de2,-dpx,-dpy,-dpz,-dbex,-dbey,-dbez)
        ptwo(2,1)=pxnew
        ptwo(2,2)=pynew
        ptwo(2,3)=pznew
        ptwo(2,4)=enenew
c
      RETURN
      END

c=======================================================================
      SUBROUTINE HTOP
c
      PARAMETER (MAXSTR=150001)
      PARAMETER (MAXPTN=400001)
      PARAMETER (MAXIDL=4001)
      DOUBLE PRECISION  GX0, GY0, GZ0, FT0, PX0, PY0, PZ0, E0, XMASS0
      DOUBLE PRECISION  PXSGS,PYSGS,PZSGS,PESGS,PMSGS,
     1     GXSGS,GYSGS,GZSGS,FTSGS, ptwo, xmdq, ptwox, ptwoy, ptwoz
      dimension it(4)
      COMMON/HMAIN2/KATT(MAXSTR,4),PATT(MAXSTR,4)
cc      SAVE /HMAIN2/
      COMMON/HMAIN1/EATT,JATT,NATT,NT,NP,N0,N01,N10,N11
cc      SAVE /HMAIN1/
      COMMON /PARA1/ MUL
cc      SAVE /PARA1/
      COMMON /prec1/GX0(MAXPTN),GY0(MAXPTN),GZ0(MAXPTN),FT0(MAXPTN),
     &     PX0(MAXPTN), PY0(MAXPTN), PZ0(MAXPTN), E0(MAXPTN),
     &     XMASS0(MAXPTN), ITYP0(MAXPTN)
cc      SAVE /prec1/
      COMMON /ilist7/ LSTRG0(MAXPTN), LPART0(MAXPTN)
cc      SAVE /ilist7/
      COMMON /ARPRC/ ITYPAR(MAXSTR),
     &     GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
     &     PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
     &     XMAR(MAXSTR)
cc      SAVE /ARPRC/
      common /decom/ptwo(2,5)
cc      SAVE /decom/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      COMMON /NOPREC/ NNOZPC, ITYPN(MAXIDL),
     &     GXN(MAXIDL), GYN(MAXIDL), GZN(MAXIDL), FTN(MAXIDL),
     &     PXN(MAXIDL), PYN(MAXIDL), PZN(MAXIDL), EEN(MAXIDL),
     &     XMN(MAXIDL)
cc      SAVE /NOPREC/
      COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
cc      SAVE /HPARNT/
c     7/20/01: use double precision
c     otherwise sometimes beta>1 and gamma diverge in lorenz():
      COMMON/SOFT/PXSGS(MAXSTR,3),PYSGS(MAXSTR,3),PZSGS(MAXSTR,3),
     &     PESGS(MAXSTR,3),PMSGS(MAXSTR,3),GXSGS(MAXSTR,3),
     &     GYSGS(MAXSTR,3),GZSGS(MAXSTR,3),FTSGS(MAXSTR,3),
     &     K1SGS(MAXSTR,3),K2SGS(MAXSTR,3),NJSGS(MAXSTR)
cc      SAVE /SOFT/
      common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
clin-8/2015:
      DOUBLE PRECISION vxp0,vyp0,vzp0,xstrg0,ystrg0,xstrg,ystrg
      common /precpa/vxp0(MAXPTN),vyp0(MAXPTN),vzp0(MAXPTN),
     1     xstrg0(MAXPTN),ystrg0(MAXPTN),
     2     xstrg(MAXPTN),ystrg(MAXPTN),istrg0(MAXPTN),istrg(MAXPTN)
c      DOUBLE PRECISION  vxp0,vyp0,vzp0
c      common /precpa/ vxp0(MAXPTN), vyp0(MAXPTN), vzp0(MAXPTN)
cc      SAVE /precpa/
      common /para7/ ioscar,nsmbbbar,nsmmeson
      COMMON /AREVT/ IAEVT, IARUN, MISS
      common/snn/efrm,npart1,npart2,epsiPz,epsiPt,PZPROJ,PZTARG
      SAVE   
c
        npar=0
        nnozpc=0
clin-5b/2008 calculate the number of hadrons to be converted to q/qbar:
        if((isoft.eq.4.or.isoft.eq.5).and.(ioscar.eq.2.or.ioscar.eq.3)) 
     1       then
           nsmbbbar=0
           nsmmeson=0
           do i=1,natt
              id=ITYPAR(i)
              idabs=iabs(id)
              i2=MOD(idabs/10,10)
clin-9/2011 determine spectator nucleons consistently
c              if(PXAR(i).eq.0.and.PYAR(i).eq.0.and.PEAR(i)
c     1             .ge.(HINT1(1)/2*0.99).and.
c     2             .and.(id.eq.2112.or.id.eq.2212)) then
              if(abs(PXAR(i)).le.epsiPt.and.abs(PYAR(i)).le.epsiPt
     1             .and.(PZAR(i).gt.amax1(0.,PZPROJ-epsiPz)
     2                .or.PZAR(i).lt.(-PZTARG+epsiPz))
     3             .and.(id.eq.2112.or.id.eq.2212)) then
c     spectator proj or targ nucleons without interactions, do not enter ZPC:
              elseif(idabs.gt.1000.and.i2.ne.0) then
c     baryons to be converted to q/qbar:
                 nsmbbbar=nsmbbbar+1
              elseif((idabs.gt.100.and.idabs.lt.1000)
     1                .or.idabs.gt.10000) then
c     mesons to be converted to q/qbar:
                 nsmmeson=nsmmeson+1
              endif
           enddo

clin-6/2009:
           if(ioscar.eq.2.or.ioscar.eq.3) then
              write(92,*) iaevt,miss,3*nsmbbbar+2*nsmmeson,
     1             nsmbbbar,nsmmeson,natt,natt-nsmbbbar-nsmmeson
           endif
c           write(92,*) iaevt, 3*nsmbbbar+2*nsmmeson
c           write(92,*) ' event#, total # of initial partons after string 
c     1 melting'
c           write(92,*) 'String melting converts ',nsmbbbar, ' baryons &'
c     1, nsmmeson, ' mesons'
c           write(92,*) 'Total # of initial particles= ',natt
c           write(92,*) 'Total # of initial particles (gamma,e,muon,...) 
c     1 not entering ZPC= ',natt-nsmbbbar-nsmmeson
        endif
clin-5b/2008-over
        do 100 i=1,natt
           id=ITYPAR(i)
           idabs=iabs(id)
           i4=MOD(idabs/1000,10)
           i3=MOD(idabs/100,10)
           i2=MOD(idabs/10,10)
           i1=MOD(idabs,10)
           rnum=RANART(NSEED)
           ftime=0.197*PEAR(i)/(PXAR(i)**2+PYAR(i)**2+XMAR(i)**2)
           inozpc=0
           it(1)=0
           it(2)=0
           it(3)=0
           it(4)=0
c
clin-9/2011 determine spectator nucleons consistently
c           if(PXAR(i).eq.0.and.PYAR(i).eq.0.and.PEAR(i)
c     1 .ge.(HINT1(1)/2*0.99).and.((id.eq.2112).or.(id.eq.2212))) then
              if(abs(PXAR(i)).le.epsiPt.and.abs(PYAR(i)).le.epsiPt
     1             .and.(PZAR(i).gt.amax1(0.,PZPROJ-epsiPz)
     2                .or.PZAR(i).lt.(-PZTARG+epsiPz))
     3             .and.(id.eq.2112.or.id.eq.2212)) then
c     spectator proj or targ nucleons without interactions, do not enter ZPC:
              inozpc=1
           elseif(idabs.gt.1000.and.i2.ne.0) then
c     baryons:
              if(((i4.eq.1.or.i4.eq.2).and.i4.eq.i3)
     1 .or.(i4.eq.3.and.i3.eq.3)) then
                 if(i1.eq.2) then
                    if(rnum.le.(1./2.)) then
                       it(1)=i4
                       it(2)=i3*1000+i2*100+1
                    elseif(rnum.le.(2./3.)) then
                       it(1)=i4
                       it(2)=i3*1000+i2*100+3
                    else
                       it(1)=i2
                       it(2)=i4*1000+i3*100+3
                    endif
                 elseif(i1.eq.4) then
                    if(rnum.le.(2./3.)) then
                       it(1)=i4
                       it(2)=i3*1000+i2*100+3
                    else
                       it(1)=i2
                       it(2)=i4*1000+i3*100+3
                    endif
                 endif
              elseif(i4.eq.1.or.i4.eq.2) then
                 if(i1.eq.2) then
                    if(rnum.le.(1./2.)) then
                       it(1)=i2
                       it(2)=i4*1000+i3*100+1
                    elseif(rnum.le.(2./3.)) then
                       it(1)=i2
                       it(2)=i4*1000+i3*100+3
                    else
                       it(1)=i4
                       it(2)=i3*1000+i2*100+3
                    endif
                 elseif(i1.eq.4) then
                    if(rnum.le.(2./3.)) then
                       it(1)=i2
                       it(2)=i4*1000+i3*100+3
                    else
                       it(1)=i4
                       it(2)=i3*1000+i2*100+3
                    endif
                 endif
              elseif(i4.ge.3) then
                 it(1)=i4
                 if(i3.lt.i2) then
                    it(2)=i2*1000+i3*100+1
                 else
                    it(2)=i3*1000+i2*100+3
                 endif
              endif
c       antibaryons:
              if(id.lt.0) then
                 it(1)=-it(1)
                 it(2)=-it(2)
              endif
c     isoft=4or5 decompose diquark flavor it(2) to two quarks it(3)&(4):
              if(isoft.eq.4.or.isoft.eq.5) then
                 it(3)=MOD(it(2)/1000,10)
                 it(4)=MOD(it(2)/100,10)
              endif

           elseif((idabs.gt.100.and.idabs.lt.1000)
     1 .or.idabs.gt.10000) then
c     mesons:
              if(i3.eq.i2) then
                 if(i3.eq.1.or.i3.eq.2) then
                    if(rnum.le.0.5) then
                       it(1)=1
                       it(2)=-1
                    else
                       it(1)=2
                       it(2)=-2
                    endif
                 else
                    it(1)=i3
                    it(2)=-i3
                 endif
              else
                 if((isign(1,id)*(-1)**i3).eq.1) then
                    it(1)=i3
                    it(2)=-i2
                 else
                    it(1)=i2
                    it(2)=-i3
                 endif
              endif
           else
c     save other particles (leptons and photons) outside of ZPC:
              inozpc=1
           endif
c
           if(inozpc.eq.1) then
              NJSGS(i)=0
              nnozpc=nnozpc+1
              itypn(nnozpc)=ITYPAR(i)
              pxn(nnozpc)=PXAR(i)
              pyn(nnozpc)=PYAR(i)
              pzn(nnozpc)=PZAR(i)
              een(nnozpc)=PEAR(i)
              xmn(nnozpc)=XMAR(i)
              gxn(nnozpc)=GXAR(i)
              gyn(nnozpc)=GYAR(i)
              gzn(nnozpc)=GZAR(i)
              ftn(nnozpc)=FTAR(i)
           else
              NJSGS(i)=2
              ptwo(1,5)=dble(ulmass(it(1)))
              ptwo(2,5)=dble(ulmass(it(2)))
              call decomp(dble(patt(i,1)),dble(patt(i,2)),
     1             dble(patt(i,3)),dble(XMAR(i)),i,it(1))
              ipamax=2
              if((isoft.eq.4.or.isoft.eq.5)
     1 .and.iabs(it(2)).gt.1000) ipamax=1
              do 1001 ipar=1,ipamax
                 npar=npar+1
                 ityp0(npar)=it(ipar)
                 px0(npar)=ptwo(ipar,1)
                 py0(npar)=ptwo(ipar,2)
                 pz0(npar)=ptwo(ipar,3)
                 e0(npar)=ptwo(ipar,4)
                 xmass0(npar)=ptwo(ipar,5)
                 gx0(npar)=dble(GXAR(i))
                 gy0(npar)=dble(GYAR(i))
                 gz0(npar)=dble(GZAR(i))
                 ft0(npar)=dble(ftime)
                 lstrg0(npar)=i
                 lpart0(npar)=ipar
                 vxp0(npar)=dble(patt(i,1)/patt(i,4))
                 vyp0(npar)=dble(patt(i,2)/patt(i,4))
                 vzp0(npar)=dble(patt(i,3)/patt(i,4))
clin-8/2015: set parent string information for this parton:
                 xstrg(npar)=xstrg0(i)
                 ystrg(npar)=ystrg0(i)
                 istrg(npar)=istrg0(i)
 1001     continue
 200      format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,f8.2))
 201      format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,e8.2))
c
              if((isoft.eq.4.or.isoft.eq.5)
     1 .and.iabs(it(2)).gt.1000) then
                 NJSGS(i)=3
                 xmdq=ptwo(2,5)
                 ptwo(1,5)=dble(ulmass(it(3)))
                 ptwo(2,5)=dble(ulmass(it(4)))
c     8/19/02 avoid actual argument in common blocks of DECOMP:
c                 call decomp(ptwo(2,1),ptwo(2,2),ptwo(2,3),xmdq)
                 ptwox=ptwo(2,1)
                 ptwoy=ptwo(2,2)
                 ptwoz=ptwo(2,3)
                 call decomp(ptwox,ptwoy,ptwoz,xmdq,i,it(1))
c
                 do 1002 ipar=1,2
                    npar=npar+1
                    ityp0(npar)=it(ipar+2)
                    px0(npar)=ptwo(ipar,1)
                    py0(npar)=ptwo(ipar,2)
                    pz0(npar)=ptwo(ipar,3)
                    e0(npar)=ptwo(ipar,4)
                    xmass0(npar)=ptwo(ipar,5)
                    gx0(npar)=dble(GXAR(i))
                    gy0(npar)=dble(GYAR(i))
                    gz0(npar)=dble(GZAR(i))
                    ft0(npar)=dble(ftime)
                    lstrg0(npar)=i
                    lpart0(npar)=ipar+1
                    vxp0(npar)=dble(patt(i,1)/patt(i,4))
                    vyp0(npar)=dble(patt(i,2)/patt(i,4))
                    vzp0(npar)=dble(patt(i,3)/patt(i,4))
clin-8/2015: set parent string information for this parton:
                    xstrg(npar)=xstrg0(i)
                    ystrg(npar)=ystrg0(i)
                    istrg(npar)=istrg0(i)
 1002        continue
              endif
c
           endif
 100        continue
      MUL=NPAR
c      
clin-5b/2008:
      if((isoft.eq.4.or.isoft.eq.5).and.(ioscar.eq.2.or.ioscar.eq.3)) 
     1     then
         if((natt-nsmbbbar-nsmmeson).ne.nnozpc) 
     1        write(92,*) 'Problem with the total # of initial particles
     2 (gamma,e,muon,...) not entering ZPC'
         if((3*nsmbbbar+2*nsmmeson).ne.npar) 
     1        write(92,*) 'Problem with the total # of initial partons
     2 after string melting'
      endif
c
      RETURN
      END

c=======================================================================
      SUBROUTINE PTOH
c
      PARAMETER (MAXSTR=150001)
      DOUBLE PRECISION  gxp,gyp,gzp,ftp,pxp,pyp,pzp,pep,pmp
      DOUBLE PRECISION  gxp0,gyp0,gzp0,ft0fom,drlocl
      DOUBLE PRECISION  enenew, pxnew, pynew, pznew, beta2, gam
      DOUBLE PRECISION  ftavg0,gxavg0,gyavg0,gzavg0,bex,bey,bez
      DOUBLE PRECISION  PXSGS,PYSGS,PZSGS,PESGS,PMSGS,
     1     GXSGS,GYSGS,GZSGS,FTSGS
      DOUBLE PRECISION  xmdiag,px1,py1,pz1,e1,px2,py2,pz2,e2,
     1     px3,py3,pz3,e3,xmpair,etot
clin-9/2012: improve precision for argument in sqrt():
      DOUBLE PRECISION  p1,p2,p3
      common /loclco/gxp(3),gyp(3),gzp(3),ftp(3),
     1     pxp(3),pyp(3),pzp(3),pep(3),pmp(3)
cc      SAVE /loclco/
      COMMON/HMAIN1/EATT,JATT,NATT,NT,NP,N0,N01,N10,N11
cc      SAVE /HMAIN1/
      COMMON/HMAIN2/KATT(MAXSTR,4),PATT(MAXSTR,4)
cc      SAVE /HMAIN2/
      COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &     K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &     PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
      COMMON /ARPRNT/ ARPAR1(100), IAPAR2(50), ARINT1(100), IAINT2(50)
cc      SAVE /ARPRNT/
      COMMON /ARPRC/ ITYPAR(MAXSTR),
     &     GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
     &     PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
     &     XMAR(MAXSTR)
cc      SAVE /ARPRC/
      COMMON/SOFT/PXSGS(MAXSTR,3),PYSGS(MAXSTR,3),PZSGS(MAXSTR,3),
     &     PESGS(MAXSTR,3),PMSGS(MAXSTR,3),GXSGS(MAXSTR,3),
     &     GYSGS(MAXSTR,3),GZSGS(MAXSTR,3),FTSGS(MAXSTR,3),
     &     K1SGS(MAXSTR,3),K2SGS(MAXSTR,3),NJSGS(MAXSTR)
cc      SAVE /SOFT/
      COMMON/RNDF77/NSEED
cc      SAVE /RNDF77/
      common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
      common /prtn23/ gxp0(3),gyp0(3),gzp0(3),ft0fom
cc      SAVE /prtn23/
      common /nzpc/nattzp
cc      SAVE /nzpc/
      common /lor/ enenew, pxnew, pynew, pznew
cc      SAVE /lor/
      COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200) 
cc      SAVE /LUDAT1/ 
clin 4/19/2006
      common /lastt/itimeh,bimp
      COMMON/HJGLBR/NELT,NINTHJ,NELP,NINP
      COMMON /AREVT/ IAEVT, IARUN, MISS
      common /para7/ ioscar,nsmbbbar,nsmmeson
clin-5/2011
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
c
      dimension xmdiag(MAXSTR),indx(MAXSTR),ndiag(MAXSTR)
      SAVE   
c
      call coales
c     obtain particle mass here without broadening by Breit-Wigner width:
      mstj24=MSTJ(24)
      MSTJ(24)=0
        nuudd=0
        npich=0
        nrhoch=0
      ppi0=1.
      prho0=0.
c     determine hadron flavor except (pi0,rho0,eta,omega):
      DO 1001 ISG = 1, NSG
           if(NJSGS(ISG).ne.0) then
              NATT=NATT+1
              K1=K2SGS(ISG,1)
              k1abs=iabs(k1)
              PX1=PXSGS(ISG,1)
              PY1=PYSGS(ISG,1)
              PZ1=PZSGS(ISG,1)
              K2=K2SGS(ISG,2)
              k2abs=iabs(k2)
              PX2=PXSGS(ISG,2)
              PY2=PYSGS(ISG,2)
              PZ2=PZSGS(ISG,2)
c     5/02/01 try lowest spin states as first choices, 
c     i.e. octet baryons and pseudoscalar mesons (ibs=2*baryonspin+1):
              e1=PESGS(ISG,1)
              e2=PESGS(ISG,2)
              xmpair=dsqrt((e1+e2)**2-(px1+px2)**2-(py1+py2)**2
     1 -(pz1+pz2)**2)
              ibs=2
              imspin=0
              if(k1.eq.-k2.and.iabs(k1).le.2.
     1           and.NJSGS(ISG).eq.2) then
               nuudd=nuudd+1
               xmdiag(nuudd)=xmpair
               ndiag(nuudd)=natt
            endif
              K3=0
              if((isoft.eq.4.or.isoft.eq.5).and.NJSGS(ISG).eq.3) then
               K3=K2SGS(ISG,3)
               k3abs=iabs(k3)
               PX3=PXSGS(ISG,3)
               PY3=PYSGS(ISG,3)
               PZ3=PZSGS(ISG,3)
               e3=PESGS(ISG,3)
               xmpair=dsqrt((e1+e2+e3)**2-(px1+px2+px3)**2
     1              -(py1+py2+py3)**2-(pz1+pz2+pz3)**2)
              endif
c*****     isoft=3 baryon decomposition is different:
              if(isoft.eq.3.and.
     1           (k1abs.gt.1000.or.k2abs.gt.1000)) then
               if(k1abs.gt.1000) then
                  kdq=k1abs
                  kk=k2abs
               else
                  kdq=k2abs
                  kk=k1abs
               endif
               ki=MOD(kdq/1000,10)
               kj=MOD(kdq/100,10)
               if(MOD(kdq,10).eq.1) then
                  idqspn=0
               else
                  idqspn=1
               endif
c
               if(kk.gt.ki) then
                  ktemp=kk
                  kk=kj
                  kj=ki
                  ki=ktemp
               elseif(kk.gt.kj) then
                  ktemp=kk
                  kk=kj
                  kj=ktemp
               endif
c     
               if(ki.ne.kj.and.ki.ne.kk.and.kj.ne.kk) then
                  if(idqspn.eq.0) then
                     kf=1000*ki+100*kk+10*kj+ibs
                  else
                     kf=1000*ki+100*kj+10*kk+ibs
                  endif
               elseif(ki.eq.kj.and.ki.eq.kk) then
c     can only be decuplet baryons:
                  kf=1000*ki+100*kj+10*kk+4
               else
                  kf=1000*ki+100*kj+10*kk+ibs
               endif
c     form a decuplet baryon if the q+diquark mass is closer to its mass 
c     (and if the diquark has spin 1):
cc     for now only include Delta, which is present in ART:
cc                 if(idqspn.eq.1.and.MOD(kf,10).eq.2) then
               if(kf.eq.2112.or.kf.eq.2212) then
                  if(abs(sngl(xmpair)-ULMASS(kf)).gt.
     1                 abs(sngl(xmpair)-ULMASS(kf+2))) kf=kf+2
               endif
               if(k1.lt.0) kf=-kf
clin-6/22/01 isoft=4or5 baryons:
              elseif((isoft.eq.4.or.isoft.eq.5).and.NJSGS(ISG).eq.3) 
     1              then
               if(k1abs.gt.k2abs) then
                  ki=k1abs
                  kk=k2abs
               else
                  ki=k2abs
                  kk=k1abs
               endif
               if(k3abs.gt.ki) then
                  kj=ki
                  ki=k3abs
               elseif(k3abs.lt.kk) then
                  kj=kk
                  kk=k3abs
               else
                  kj=k3abs
               endif
c     
               if(ki.eq.kj.and.ki.eq.kk) then
c     can only be decuplet baryons (Delta-,++, Omega):
                  ibs=4
                  kf=1000*ki+100*kj+10*kk+ibs
               elseif(ki.ne.kj.and.ki.ne.kk.and.kj.ne.kk) then
c     form Lambda or Sigma according to 3-quark mass, 
c     for now neglect decuplet (Sigma*0 etc) which is absent in ART:
                  ibs=2
                  kf1=1000*ki+100*kj+10*kk+ibs
                  kf2=1000*ki+100*kk+10*kj+ibs
                  kf=kf1
                  if(abs(sngl(xmpair)-ULMASS(kf1)).gt.
     1                 abs(sngl(xmpair)-ULMASS(kf2))) kf=kf2
               else
                  ibs=2
                  kf=1000*ki+100*kj+10*kk+ibs
cc     for now only include Delta0,+ as decuplets, which are present in ART:
                  if(kf.eq.2112.or.kf.eq.2212) then
                     if(abs(sngl(xmpair)-ULMASS(kf)).gt.
     1                    abs(sngl(xmpair)-ULMASS(kf+2))) kf=kf+2
                  endif
               endif
               if(k1.lt.0) kf=-kf
c*****     mesons:
              else
               if(k1abs.eq.k2abs) then
                  if(k1abs.le.2) then
c     treat diagonal mesons later in the subroutine:
                     kf=0
                  elseif(k1abs.le.3) then
c     do not form eta', only form phi from s-sbar, since no eta' in ART:
                     kf=333
                  else
                     kf=100*k1abs+10*k1abs+2*imspin+1
                  endif
               else
                  if(k1abs.gt.k2abs) then
                     kmax=k1abs
                     kmin=k2abs
                  elseif(k1abs.lt.k2abs) then
                     kmax=k2abs
                     kmin=k1abs
                  endif
                  kf=(100*kmax+10*kmin+2*imspin+1)
     1                 *isign(1,k1+k2)*(-1)**kmax
c     form a vector meson if the q+qbar mass is closer to its mass:
                  if(MOD(iabs(kf),10).eq.1) then
                     if(abs(sngl(xmpair)-ULMASS(iabs(kf))).gt.
     1                    abs(sngl(xmpair)-ULMASS(iabs(kf)+2))) 
     2                    kf=(iabs(kf)+2)*isign(1,kf)
                  endif
               endif
              endif
              ITYPAR(NATT)=kf
              KATT(NATT,1)=kf
            if(iabs(kf).eq.211) then
               npich=npich+1
            elseif(iabs(kf).eq.213) then
               nrhoch=nrhoch+1
            endif
           endif
clin-7/2011-check charm hadron flavors:
c           if(k1abs.eq.4.or.k2abs.eq.4) then
c              if(k3.eq.0) then
c                 write(99,*) iaevt,k1,k2,kf,xmpair,
c     1                ULMASS(iabs(kf)),ULMASS(iabs(kf)+2),isg
c              else
c                 write(99,*) iaevt,k1,k2,k3,kf,xmpair,
c     1                ULMASS(iabs(kf)),ULMASS(iabs(kf)+2),isg
c              endif
c           endif
clin-7/2011-end
 1001   CONTINUE
c     assume Npi0=(Npi+ + Npi-)/2, Nrho0=(Nrho+ + Nrho-)/2 on the average:
        if(nuudd.ne.0) then
         ppi0=float(npich/2)/float(nuudd)
         prho0=float(nrhoch/2)/float(nuudd)
      endif      
c     determine diagonal mesons (pi0,rho0,eta and omega) from uubar/ddbar:
      npi0=0
      DO 1002 ISG = 1, NSG
         if(K2SGS(ISG,1).eq.-K2SGS(ISG,2)
     1        .and.iabs(K2SGS(ISG,1)).le.2.and.NJSGS(ISG).eq.2) then
            if(RANART(NSEED).le.ppi0) npi0=npi0+1
         endif
 1002 CONTINUE
c
      if(nuudd.gt.1) then
         call index1(MAXSTR,nuudd,xmdiag,indx)
      else
         indx(1)=1
      end if
c
      DO 1003 ix=1,nuudd
         iuudd=indx(ix)
         inatt=ndiag(iuudd)            
         if(ix.le.npi0) then
            kf=111
         elseif(RANART(NSEED).le.(prho0/(1-ppi0+0.00001))) then
            kf=113
         else
c     at T=150MeV, thermal weights for eta and omega(spin1) are about the same:
            if(RANART(NSEED).le.0.5) then
               kf=221
            else
               kf=223
            endif
         endif
         ITYPAR(inatt)=kf
         KATT(inatt,1)=kf
 1003 CONTINUE
c  determine hadron formation time, position and momentum:
      inatt=0
clin-6/2009 write out parton info after coalescence:
      if(ioscar.eq.3) then
         WRITE (85, 395) IAEVT, 3*nsmbbbar+2*nsmmeson,nsmbbbar,nsmmeson, 
     1     bimp, NELP,NINP,NELT,NINTHJ,MISS
      endif
 395  format(4I8,f10.4,5I5)
c
      DO 1006 ISG = 1, NSG
           if(NJSGS(ISG).ne.0) then
            inatt=inatt+1
              K1=K2SGS(ISG,1)
              k1abs=iabs(k1)
              PX1=PXSGS(ISG,1)
              PY1=PYSGS(ISG,1)
              PZ1=PZSGS(ISG,1)
              K2=K2SGS(ISG,2)
              k2abs=iabs(k2)
              PX2=PXSGS(ISG,2)
              PY2=PYSGS(ISG,2)
              PZ2=PZSGS(ISG,2)
              e1=PESGS(ISG,1)
              e2=PESGS(ISG,2)
c
              if(NJSGS(ISG).eq.2) then
               PXAR(inatt)=sngl(px1+px2)
               PYAR(inatt)=sngl(py1+py2)
               PZAR(inatt)=sngl(pz1+pz2)
               PATT(inatt,1)=PXAR(inatt)
               PATT(inatt,2)=PYAR(inatt)
               PATT(inatt,3)=PZAR(inatt)
               etot=e1+e2
clin-9/2012: improve precision for argument in sqrt():
               p1=px1+px2
               p2=py1+py2
               p3=pz1+pz2
c
              elseif((isoft.eq.4.or.isoft.eq.5).and.NJSGS(ISG).eq.3) 
     1              then
               PX3=PXSGS(ISG,3)
               PY3=PYSGS(ISG,3)
               PZ3=PZSGS(ISG,3)
               e3=PESGS(ISG,3)
               PXAR(inatt)=sngl(px1+px2+px3)
               PYAR(inatt)=sngl(py1+py2+py3)
               PZAR(inatt)=sngl(pz1+pz2+pz3)
               PATT(inatt,1)=PXAR(inatt)
               PATT(inatt,2)=PYAR(inatt)
               PATT(inatt,3)=PZAR(inatt)
               etot=e1+e2+e3
clin-9/2012: improve precision for argument in sqrt():
               p1=px1+px2+px3
               p2=py1+py2+py3
               p3=pz1+pz2+pz3
c
              endif
              XMAR(inatt)=ULMASS(ITYPAR(inatt))
clin-5/2011-add finite width to resonances (rho,omega,eta,K*,phi,Delta) after formation:
              kf=KATT(inatt,1)
              if(kf.eq.113.or.abs(kf).eq.213.or.kf.eq.221.or.kf.eq.223
     1             .or.abs(kf).eq.313.or.abs(kf).eq.323.or.kf.eq.333
     2             .or.abs(kf).eq.1114.or.abs(kf).eq.2114
     3             .or.abs(kf).eq.2214.or.abs(kf).eq.2224) then
                 XMAR(inatt)=resmass(kf)
              endif
c
              PEAR(inatt)=sqrt(PXAR(inatt)**2+PYAR(inatt)**2
     1           +PZAR(inatt)**2+XMAR(inatt)**2)
              PATT(inatt,4)=PEAR(inatt)
              EATT=EATT+PEAR(inatt)
            ipartn=NJSGS(ISG)
            DO 1004 i=1,ipartn
               ftp(i)=ftsgs(isg,i)
               gxp(i)=gxsgs(isg,i)
               gyp(i)=gysgs(isg,i)
               gzp(i)=gzsgs(isg,i)
               pxp(i)=pxsgs(isg,i)
               pyp(i)=pysgs(isg,i)
               pzp(i)=pzsgs(isg,i)
               pmp(i)=pmsgs(isg,i)
               pep(i)=pesgs(isg,i)
 1004       CONTINUE
            call locldr(ipartn,drlocl)
c
            tau0=ARPAR1(1)
            ftavg0=ft0fom+dble(tau0)
            gxavg0=0d0
            gyavg0=0d0
            gzavg0=0d0
            DO 1005 i=1,ipartn
               gxavg0=gxavg0+gxp0(i)/ipartn
               gyavg0=gyavg0+gyp0(i)/ipartn
               gzavg0=gzavg0+gzp0(i)/ipartn
 1005       CONTINUE
clin-9/2012: improve precision for argument in sqrt():
c            bex=dble(PXAR(inatt))/etot
c            bey=dble(PYAR(inatt))/etot
c            bez=dble(PZAR(inatt))/etot
            bex=p1/etot
            bey=p2/etot
            bez=p3/etot
c
            beta2 = bex ** 2 + bey ** 2 + bez ** 2
            gam = 1.d0 / dsqrt(1.d0 - beta2)
            if(beta2.ge.0.9999999999999d0) then
               write(6,*) '2',bex,bey,bez,beta2,gam
            endif
c
            call lorenz(ftavg0,gxavg0,gyavg0,gzavg0,-bex,-bey,-bez)
              GXAR(inatt)=sngl(pxnew)
              GYAR(inatt)=sngl(pynew)
              GZAR(inatt)=sngl(pznew)
              FTAR(inatt)=sngl(enenew)
clin 4/19/2006 write out parton info after coalescence:
              if(ioscar.eq.3) then
                 WRITE (85, 313) K2SGS(ISG,1),px1,py1,pz1,PMSGS(ISG,1),
     1                inatt,katt(inatt,1),xmar(inatt)
                 WRITE (85, 312) K2SGS(ISG,2),px2,py2,pz2,PMSGS(ISG,2),
     1                inatt,katt(inatt,1)
                 if(NJSGS(ISG).eq.3) WRITE (85, 312) K2SGS(ISG,3),
     1                px3,py3,pz3,PMSGS(ISG,3),inatt,katt(inatt,1)
              endif
 312       FORMAT(I6,4(1X,F10.3),1X,I6,1X,I6)
clin-5/02/2011
 313          FORMAT(I6,4(1X,F10.3),1X,I6,1X,I6,1X,F10.3)
c
           endif
 1006   CONTINUE
c     number of hadrons formed from partons inside ZPC:
      nattzp=natt
      MSTJ(24)=mstj24
c      
      RETURN
      END

c=======================================================================
clin-5/2011-add finite width to resonances (rho,omega,eta,K*,phi,Delta) after formation:
      FUNCTION resmass(kf)

      PARAMETER  (arho=0.775,aomega=0.783,aeta=0.548,aks=0.894,
     1     aphi=1.019,adelta=1.232)
      PARAMETER  (wrho=0.149,womega=0.00849,weta=1.30E-6,wks=0.0498,
     1     wphi=0.00426,wdelta=0.118)
      common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
      COMMON/RNDF77/NSEED
      SAVE   

      if(kf.eq.113.or.abs(kf).eq.213) then
         amass=arho
         wid=wrho
      elseif(kf.eq.221) then
         amass=aeta
         wid=weta
      elseif(kf.eq.223) then
         amass=aomega
         wid=womega
      elseif(abs(kf).eq.313.or.abs(kf).eq.323) then
         amass=aks
         wid=wks
      elseif(kf.eq.333) then
         amass=aphi
         wid=wphi
      elseif(abs(kf).eq.1114.or.abs(kf).eq.2114
     1        .or.abs(kf).eq.2214.or.abs(kf).eq.2224) then
         amass=adelta
         wid=wdelta
      endif
      dmin=amass-2*wid
      dmax=amass+2*wid
c     Delta mass needs to be big enough to decay to N+pi:
      if(amass.eq.adelta) dmin=1.078
c      
      FM=1.
      NTRY1=0
 10   DM = RANART(NSEED) * (DMAX-DMIN) + DMIN
      NTRY1=NTRY1+1
      fmass=(amass*wid)**2/((DM**2-amass**2)**2+(amass*wid)**2)
check      write (99,*) ntry1,kf,amass,wid,fmass,DM
      IF((RANART(NSEED) .GT. FMASS/FM).AND. (NTRY1.LE.10)) GOTO 10
c     
      resmass=DM
      
      RETURN
      END

c=======================================================================
      SUBROUTINE coales

      PARAMETER (MAXSTR=150001)
      IMPLICIT DOUBLE PRECISION(D)
      DOUBLE PRECISION  gxp,gyp,gzp,ftp,pxp,pyp,pzp,pep,pmp
      DIMENSION IOVER(MAXSTR),dp1(2:3),dr1(2:3)
      DOUBLE PRECISION  PXSGS,PYSGS,PZSGS,PESGS,PMSGS,
     1     GXSGS,GYSGS,GZSGS,FTSGS
      double precision  dpcoal,drcoal,ecritl
      COMMON/SOFT/PXSGS(MAXSTR,3),PYSGS(MAXSTR,3),PZSGS(MAXSTR,3),
     &     PESGS(MAXSTR,3),PMSGS(MAXSTR,3),GXSGS(MAXSTR,3),
     &     GYSGS(MAXSTR,3),GZSGS(MAXSTR,3),FTSGS(MAXSTR,3),
     &     K1SGS(MAXSTR,3),K2SGS(MAXSTR,3),NJSGS(MAXSTR)
cc      SAVE /SOFT/
      common /coal/dpcoal,drcoal,ecritl
cc      SAVE /coal/
      common /loclco/gxp(3),gyp(3),gzp(3),ftp(3),
     1     pxp(3),pyp(3),pzp(3),pep(3),pmp(3)
cc      SAVE /loclco/
      COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &     K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &     PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
cc      SAVE /HJJET2/
      SAVE   
c      
      do 1001 ISG=1, NSG
         IOVER(ISG)=0
 1001 continue
C1     meson q coalesce with all available qbar:
      do 150 ISG=1,NSG
         if(NJSGS(ISG).ne.2.or.IOVER(ISG).eq.1) goto 150
C     DETERMINE CURRENT RELATIVE DISTANCE AND MOMENTUM:
         if(K2SGS(ISG,1).lt.0) then
            write(6,*) 'Antiquark appears in quark loop; stop'
            stop
         endif
c         
         do 1002 j=1,2
            ftp(j)=ftsgs(isg,j)
            gxp(j)=gxsgs(isg,j)
            gyp(j)=gysgs(isg,j)
            gzp(j)=gzsgs(isg,j)
            pxp(j)=pxsgs(isg,j)
            pyp(j)=pysgs(isg,j)
            pzp(j)=pzsgs(isg,j)
            pmp(j)=pmsgs(isg,j)
            pep(j)=pesgs(isg,j)
 1002    continue
         call locldr(2,drlocl)
         dr0=drlocl
c     dp0^2 defined as (p1+p2)^2-(m1+m2)^2:
         dp0=dsqrt(2*(pep(1)*pep(2)-pxp(1)*pxp(2)
     &        -pyp(1)*pyp(2)-pzp(1)*pzp(2)-pmp(1)*pmp(2)))
c
         do 120 JSG=1,NSG
c     skip default or unavailable antiquarks:
            if(JSG.eq.ISG.or.IOVER(JSG).eq.1) goto 120
            if(NJSGS(JSG).eq.2) then
               ipmin=2
               ipmax=2
            elseif(NJSGS(JSG).eq.3.and.K2SGS(JSG,1).lt.0) then
               ipmin=1
               ipmax=3
            else
               goto 120
            endif
            do 100 ip=ipmin,ipmax
               dplocl=dsqrt(2*(pep(1)*pesgs(jsg,ip)
     1              -pxp(1)*pxsgs(jsg,ip)
     2              -pyp(1)*pysgs(jsg,ip)
     3              -pzp(1)*pzsgs(jsg,ip)
     4              -pmp(1)*pmsgs(jsg,ip)))
c     skip if outside of momentum radius:
               if(dplocl.gt.dpcoal) goto 120
               ftp(2)=ftsgs(jsg,ip)
               gxp(2)=gxsgs(jsg,ip)
               gyp(2)=gysgs(jsg,ip)
               gzp(2)=gzsgs(jsg,ip)
               pxp(2)=pxsgs(jsg,ip)
               pyp(2)=pysgs(jsg,ip)
               pzp(2)=pzsgs(jsg,ip)
               pmp(2)=pmsgs(jsg,ip)
               pep(2)=pesgs(jsg,ip)
               call locldr(2,drlocl)
c     skip if outside of spatial radius:
               if(drlocl.gt.drcoal) goto 120
c     q_isg coalesces with qbar_jsg:
               if((dp0.gt.dpcoal.or.dr0.gt.drcoal)
     1              .or.(drlocl.lt.dr0)) then
                  dp0=dplocl
                  dr0=drlocl
                  call exchge(isg,2,jsg,ip)
               endif
 100        continue
 120     continue
         if(dp0.le.dpcoal.and.dr0.le.drcoal) IOVER(ISG)=1
 150  continue
c
C2     meson qbar coalesce with all available q:
      do 250 ISG=1,NSG
         if(NJSGS(ISG).ne.2.or.IOVER(ISG).eq.1) goto 250
C     DETERMINE CURRENT RELATIVE DISTANCE AND MOMENTUM:
         do 1003 j=1,2
            ftp(j)=ftsgs(isg,j)
            gxp(j)=gxsgs(isg,j)
            gyp(j)=gysgs(isg,j)
            gzp(j)=gzsgs(isg,j)
            pxp(j)=pxsgs(isg,j)
            pyp(j)=pysgs(isg,j)
            pzp(j)=pzsgs(isg,j)
            pmp(j)=pmsgs(isg,j)
            pep(j)=pesgs(isg,j)
 1003    continue
         call locldr(2,drlocl)
         dr0=drlocl
         dp0=dsqrt(2*(pep(1)*pep(2)-pxp(1)*pxp(2)
     &        -pyp(1)*pyp(2)-pzp(1)*pzp(2)-pmp(1)*pmp(2)))
c
         do 220 JSG=1,NSG
            if(JSG.eq.ISG.or.IOVER(JSG).eq.1) goto 220
            if(NJSGS(JSG).eq.2) then
               ipmin=1
               ipmax=1
            elseif(NJSGS(JSG).eq.3.and.K2SGS(JSG,1).gt.0) then
               ipmin=1
               ipmax=3
            else
               goto 220
            endif
            do 200 ip=ipmin,ipmax
               dplocl=dsqrt(2*(pep(2)*pesgs(jsg,ip)
     1              -pxp(2)*pxsgs(jsg,ip)
     2              -pyp(2)*pysgs(jsg,ip)
     3              -pzp(2)*pzsgs(jsg,ip)
     4              -pmp(2)*pmsgs(jsg,ip)))
c     skip if outside of momentum radius:
               if(dplocl.gt.dpcoal) goto 220
               ftp(1)=ftsgs(jsg,ip)
               gxp(1)=gxsgs(jsg,ip)
               gyp(1)=gysgs(jsg,ip)
               gzp(1)=gzsgs(jsg,ip)
               pxp(1)=pxsgs(jsg,ip)
               pyp(1)=pysgs(jsg,ip)
               pzp(1)=pzsgs(jsg,ip)
               pmp(1)=pmsgs(jsg,ip)
               pep(1)=pesgs(jsg,ip)
               call locldr(2,drlocl)
c     skip if outside of spatial radius:
               if(drlocl.gt.drcoal) goto 220
c     qbar_isg coalesces with q_jsg:
               if((dp0.gt.dpcoal.or.dr0.gt.drcoal)
     1              .or.(drlocl.lt.dr0)) then
                  dp0=dplocl
                  dr0=drlocl
                  call exchge(isg,1,jsg,ip)
               endif
 200        continue
 220     continue
         if(dp0.le.dpcoal.and.dr0.le.drcoal) IOVER(ISG)=1
 250  continue
c
C3     baryon q (antibaryon qbar) coalesce with all available q (qbar):
      do 350 ISG=1,NSG
         if(NJSGS(ISG).ne.3.or.IOVER(ISG).eq.1) goto 350
         ibaryn=K2SGS(ISG,1)
C     DETERMINE CURRENT RELATIVE DISTANCE AND MOMENTUM:
         do 1004 j=1,2
            ftp(j)=ftsgs(isg,j)
            gxp(j)=gxsgs(isg,j)
            gyp(j)=gysgs(isg,j)
            gzp(j)=gzsgs(isg,j)
            pxp(j)=pxsgs(isg,j)
            pyp(j)=pysgs(isg,j)
            pzp(j)=pzsgs(isg,j)
            pmp(j)=pmsgs(isg,j)
            pep(j)=pesgs(isg,j)
 1004    continue
         call locldr(2,drlocl)
         dr1(2)=drlocl
         dp1(2)=dsqrt(2*(pep(1)*pep(2)-pxp(1)*pxp(2)
     &        -pyp(1)*pyp(2)-pzp(1)*pzp(2)-pmp(1)*pmp(2)))
c
         ftp(2)=ftsgs(isg,3)
         gxp(2)=gxsgs(isg,3)
         gyp(2)=gysgs(isg,3)
         gzp(2)=gzsgs(isg,3)
         pxp(2)=pxsgs(isg,3)
         pyp(2)=pysgs(isg,3)
         pzp(2)=pzsgs(isg,3)
         pmp(2)=pmsgs(isg,3)
         pep(2)=pesgs(isg,3)
         call locldr(2,drlocl)
         dr1(3)=drlocl
         dp1(3)=dsqrt(2*(pep(1)*pep(2)-pxp(1)*pxp(2)
     &        -pyp(1)*pyp(2)-pzp(1)*pzp(2)-pmp(1)*pmp(2)))
c
         do 320 JSG=1,NSG
            if(JSG.eq.ISG.or.IOVER(JSG).eq.1) goto 320
            if(NJSGS(JSG).eq.2) then
               if(ibaryn.gt.0) then
                  ipmin=1
               else
                  ipmin=2
               endif
               ipmax=ipmin
            elseif(NJSGS(JSG).eq.3.and.
     1              (ibaryn*K2SGS(JSG,1)).gt.0) then
               ipmin=1
               ipmax=3
            else
               goto 320
            endif
            do 300 ip=ipmin,ipmax
               dplocl=dsqrt(2*(pep(1)*pesgs(jsg,ip)
     1              -pxp(1)*pxsgs(jsg,ip)
     2              -pyp(1)*pysgs(jsg,ip)
     3              -pzp(1)*pzsgs(jsg,ip)
     4              -pmp(1)*pmsgs(jsg,ip)))
c     skip if outside of momentum radius:
               if(dplocl.gt.dpcoal) goto 320
               ftp(2)=ftsgs(jsg,ip)
               gxp(2)=gxsgs(jsg,ip)
               gyp(2)=gysgs(jsg,ip)
               gzp(2)=gzsgs(jsg,ip)
               pxp(2)=pxsgs(jsg,ip)
               pyp(2)=pysgs(jsg,ip)
               pzp(2)=pzsgs(jsg,ip)
               pmp(2)=pmsgs(jsg,ip)
               pep(2)=pesgs(jsg,ip)
               call locldr(2,drlocl)
c     skip if outside of spatial radius:
               if(drlocl.gt.drcoal) goto 320
c     q_isg may coalesce with q_jsg for a baryon:
               ipi=0
               if(dp1(2).gt.dpcoal.or.dr1(2).gt.drcoal) then
                  ipi=2
                  if((dp1(3).gt.dpcoal.or.dr1(3).gt.drcoal)
     1                 .and.dr1(3).gt.dr1(2)) ipi=3
               elseif(dp1(3).gt.dpcoal.or.dr1(3).gt.drcoal) then
                  ipi=3
               elseif(dr1(2).lt.dr1(3)) then
                  if(drlocl.lt.dr1(3)) ipi=3
               elseif(dr1(3).le.dr1(2)) then
                  if(drlocl.lt.dr1(2)) ipi=2
               endif
               if(ipi.ne.0) then
                  dp1(ipi)=dplocl
                  dr1(ipi)=drlocl
                  call exchge(isg,ipi,jsg,ip)
               endif
 300        continue
 320     continue
         if(dp1(2).le.dpcoal.and.dr1(2).le.drcoal
     1        .and.dp1(3).le.dpcoal.and.dr1(3).le.drcoal)
     2        IOVER(ISG)=1
 350  continue
c      
      RETURN
      END

c=======================================================================
      SUBROUTINE exchge(isg,ipi,jsg,ipj)
c
      implicit double precision  (a-h, o-z)
      PARAMETER (MAXSTR=150001)
      COMMON/SOFT/PXSGS(MAXSTR,3),PYSGS(MAXSTR,3),PZSGS(MAXSTR,3),
     &     PESGS(MAXSTR,3),PMSGS(MAXSTR,3),GXSGS(MAXSTR,3),
     &     GYSGS(MAXSTR,3),GZSGS(MAXSTR,3),FTSGS(MAXSTR,3),
     &     K1SGS(MAXSTR,3),K2SGS(MAXSTR,3),NJSGS(MAXSTR)
cc      SAVE /SOFT/
      SAVE   
c
      k1=K1SGS(isg,ipi)
      k2=K2SGS(isg,ipi)
      px=PXSGS(isg,ipi)
      py=PYSGS(isg,ipi)
      pz=PZSGS(isg,ipi)
      pe=PESGS(isg,ipi)
      pm=PMSGS(isg,ipi)
      gx=GXSGS(isg,ipi)
      gy=GYSGS(isg,ipi)
      gz=GZSGS(isg,ipi)
      ft=FTSGS(isg,ipi)
      K1SGS(isg,ipi)=K1SGS(jsg,ipj)
      K2SGS(isg,ipi)=K2SGS(jsg,ipj)
      PXSGS(isg,ipi)=PXSGS(jsg,ipj)
      PYSGS(isg,ipi)=PYSGS(jsg,ipj)
      PZSGS(isg,ipi)=PZSGS(jsg,ipj)
      PESGS(isg,ipi)=PESGS(jsg,ipj)
      PMSGS(isg,ipi)=PMSGS(jsg,ipj)
      GXSGS(isg,ipi)=GXSGS(jsg,ipj)
      GYSGS(isg,ipi)=GYSGS(jsg,ipj)
      GZSGS(isg,ipi)=GZSGS(jsg,ipj)
      FTSGS(isg,ipi)=FTSGS(jsg,ipj)
      K1SGS(jsg,ipj)=k1
      K2SGS(jsg,ipj)=k2
      PXSGS(jsg,ipj)=px
      PYSGS(jsg,ipj)=py
      PZSGS(jsg,ipj)=pz
      PESGS(jsg,ipj)=pe
      PMSGS(jsg,ipj)=pm
      GXSGS(jsg,ipj)=gx
      GYSGS(jsg,ipj)=gy
      GZSGS(jsg,ipj)=gz
      FTSGS(jsg,ipj)=ft
c
      RETURN
      END

c=======================================================================
      SUBROUTINE locldr(icall,drlocl)
c
      implicit double precision (a-h, o-z)
      dimension ftp0(3),pxp0(3),pyp0(3),pzp0(3),pep0(3)
      common /loclco/gxp(3),gyp(3),gzp(3),ftp(3),
     1     pxp(3),pyp(3),pzp(3),pep(3),pmp(3)
cc      SAVE /loclco/
      common /prtn23/ gxp0(3),gyp0(3),gzp0(3),ft0fom
cc      SAVE /prtn23/
      common /lor/ enenew, pxnew, pynew, pznew
cc      SAVE /lor/
      SAVE   
c     for 2-body kinematics:
      if(icall.eq.2) then
         etot=pep(1)+pep(2)
         bex=(pxp(1)+pxp(2))/etot
         bey=(pyp(1)+pyp(2))/etot
         bez=(pzp(1)+pzp(2))/etot
c     boost the reference frame down by beta to get to the pair rest frame:
         do 1001 j=1,2
            beta2 = bex ** 2 + bey ** 2 + bez ** 2
            gam = 1.d0 / dsqrt(1.d0 - beta2)
            if(beta2.ge.0.9999999999999d0) then
               write(6,*) '4',pxp(1),pxp(2),pyp(1),pyp(2),
     1              pzp(1),pzp(2),pep(1),pep(2),pmp(1),pmp(2),
     2          dsqrt(pxp(1)**2+pyp(1)**2+pzp(1)**2+pmp(1)**2)/pep(1),
     3          dsqrt(pxp(1)**2+pyp(1)**2+pzp(1)**2)/pep(1)
               write(6,*) '4a',pxp(1)+pxp(2),pyp(1)+pyp(2),
     1              pzp(1)+pzp(2),etot
               write(6,*) '4b',bex,bey,bez,beta2,gam
            endif
c
            call lorenz(ftp(j),gxp(j),gyp(j),gzp(j),bex,bey,bez)
            gxp0(j)=pxnew
            gyp0(j)=pynew
            gzp0(j)=pznew
            ftp0(j)=enenew
            call lorenz(pep(j),pxp(j),pyp(j),pzp(j),bex,bey,bez)
            pxp0(j)=pxnew
            pyp0(j)=pynew
            pzp0(j)=pznew
            pep0(j)=enenew
 1001    continue
c     
         if(ftp0(1).ge.ftp0(2)) then
            ilate=1
            iearly=2
         else
            ilate=2
            iearly=1
         endif
         ft0fom=ftp0(ilate)
c     
         dt0=ftp0(ilate)-ftp0(iearly)
         gxp0(iearly)=gxp0(iearly)+pxp0(iearly)/pep0(iearly)*dt0
         gyp0(iearly)=gyp0(iearly)+pyp0(iearly)/pep0(iearly)*dt0
         gzp0(iearly)=gzp0(iearly)+pzp0(iearly)/pep0(iearly)*dt0
         drlocl=dsqrt((gxp0(ilate)-gxp0(iearly))**2
     1        +(gyp0(ilate)-gyp0(iearly))**2
     2        +(gzp0(ilate)-gzp0(iearly))**2)
c     for 3-body kinematics, used for baryons formation:
      elseif(icall.eq.3) then
         etot=pep(1)+pep(2)+pep(3)
         bex=(pxp(1)+pxp(2)+pxp(3))/etot
         bey=(pyp(1)+pyp(2)+pyp(3))/etot
         bez=(pzp(1)+pzp(2)+pzp(3))/etot
         beta2 = bex ** 2 + bey ** 2 + bez ** 2
         gam = 1.d0 / dsqrt(1.d0 - beta2)
         if(beta2.ge.0.9999999999999d0) then
            write(6,*) '5',bex,bey,bez,beta2,gam
         endif
c     boost the reference frame down by beta to get to the 3-parton rest frame:
         do 1002 j=1,3
            call lorenz(ftp(j),gxp(j),gyp(j),gzp(j),bex,bey,bez)
            gxp0(j)=pxnew
            gyp0(j)=pynew
            gzp0(j)=pznew
            ftp0(j)=enenew
            call lorenz(pep(j),pxp(j),pyp(j),pzp(j),bex,bey,bez)
            pxp0(j)=pxnew
            pyp0(j)=pynew
            pzp0(j)=pznew
            pep0(j)=enenew
 1002    continue
c     
         if(ftp0(1).gt.ftp0(2)) then
            ilate=1
            if(ftp0(3).gt.ftp0(1)) ilate=3
         else
            ilate=2
            if(ftp0(3).ge.ftp0(2)) ilate=3
         endif
         ft0fom=ftp0(ilate)
c     
         if(ilate.eq.1) then
            imin=2
            imax=3
            istep=1
         elseif(ilate.eq.2) then
            imin=1
            imax=3
            istep=2
         elseif(ilate.eq.3) then
            imin=1
            imax=2
            istep=1
         endif
c     
         do 1003 iearly=imin,imax,istep
            dt0=ftp0(ilate)-ftp0(iearly)
            gxp0(iearly)=gxp0(iearly)+pxp0(iearly)/pep0(iearly)*dt0
            gyp0(iearly)=gyp0(iearly)+pyp0(iearly)/pep0(iearly)*dt0
            gzp0(iearly)=gzp0(iearly)+pzp0(iearly)/pep0(iearly)*dt0
 1003    continue
      endif
c
      RETURN
      END

c=======================================================================
        subroutine hoscar
c
        parameter (MAXSTR=150001,AMN=0.939457,AMP=0.93828)
        character*8 code, reffra, FRAME
        character*25 amptvn
        common/snn/efrm,npart1,npart2,epsiPz,epsiPt,PZPROJ,PZTARG
cc      SAVE /snn/
        common /lastt/itimeh,bimp 
cc      SAVE /lastt/
        COMMON/hbt/lblast(MAXSTR),xlast(4,MAXSTR),plast(4,MAXSTR),nlast
cc      SAVE /hbt/
        common/oscar1/iap,izp,iat,izt
cc      SAVE /oscar1/
        common/oscar2/FRAME,amptvn
cc      SAVE /oscar2/
        SAVE   
        data nff/0/
c
c       file header
        if(nff.eq.0) then
           write (19, 101) 'OSCAR1997A'
           write (19, 111) 'final_id_p_x'
           code = 'AMPT'
           if(FRAME.eq.'CMS') then
              reffra = 'nncm'
              xmp=(amp*izp+amn*(iap-izp))/iap
              xmt=(amp*izt+amn*(iat-izt))/iat
              ebeam=(efrm**2-xmp**2-xmt**2)/2./xmt
           elseif(FRAME.eq.'LAB') then
              reffra = 'lab'
              ebeam=efrm
           else
              reffra = 'unknown'
              ebeam=0.
           endif
           ntestp = 1
           write (19, 102) code, amptvn, iap, izp, iat, izt,
     &        reffra, ebeam, ntestp
           nff = 1
           ievent = 1
           phi = 0.
           if(FRAME.eq.'CMS') write(19,112) efrm
        endif
c       comment
c       event header
        write (19, 103) ievent, nlast, bimp, phi
c       particles
        do 99 i = 1, nlast
           ene=sqrt(plast(1,i)**2+plast(2,i)**2+plast(3,i)**2
     1          +plast(4,i)**2)
           write (19, 104) i, INVFLV(lblast(i)), plast(1,i),
     1          plast(2,i),plast(3,i),ene,plast(4,i),
     2          xlast(1,i),xlast(2,i),xlast(3,i),xlast(4,i)
 99     continue
        ievent = ievent + 1
 101        format (a10)
 111        format (a12)
 102        format (a4,1x,a20,1x,'(', i3, ',', i3, ')+(', i3, ',', 
     &           i3, ')', 2x, a4, 2x, e10.4, 2x, i8)
 103        format (i10, 2x, i10, 2x, f8.3, 2x, f8.3)
 104        format (i10, 2x, i10, 2x, 9(e12.6, 2x))
 112        format ('# Center-of-mass energy/nucleon-pair is',
     & f12.3,'GeV')
c
        return
        end

c=======================================================================
        subroutine getnp

        PARAMETER (MAXSTR=150001)
        COMMON/HMAIN1/EATT,JATT,NATT,NT,NP,N0,N01,N10,N11
cc      SAVE /HMAIN1/
        COMMON/HMAIN2/KATT(MAXSTR,4),PATT(MAXSTR,4)
cc      SAVE /HMAIN2/
        COMMON /HPARNT/HIPR1(100), IHPR2(50), HINT1(100), IHNT2(50)
cc      SAVE /HPARNT/
        common/snn/efrm,npart1,npart2,epsiPz,epsiPt,PZPROJ,PZTARG
cc      SAVE /snn/
        SAVE   

        if(NATT.eq.0) then
           npart1=0
           npart2=0
           return
        endif
c
        PZPROJ=SQRT(HINT1(6)**2-HINT1(8)**2)
        PZTARG=SQRT(HINT1(7)**2-HINT1(9)**2)
        epsiPz=0.01
clin-9/2011-add Pt tolerance in determining spectator nucleons
c     (affect string melting runs when LAB frame is used):
        epsiPt=1e-6
c
        nspec1=0
        nspec2=0
        DO 1000 I = 1, NATT
clin-9/2011 determine spectator nucleons consistently
c           if((KATT(I,1).eq.2112.or.KATT(I,1).eq.2212)
c     1          .and.PATT(I, 1).eq.0.and.PATT(I, 2).eq.0) then
           if((KATT(I,1).eq.2112.or.KATT(I,1).eq.2212)
     1          .and.abs(PATT(I, 1)).le.epsiPt
     2          .and.abs(PATT(I, 2)).le.epsiPt) then
              if(PATT(I, 3).gt.amax1(0.,PZPROJ-epsiPz)) then
                 nspec1=nspec1+1
              elseif(PATT(I, 3).lt.(-PZTARG+epsiPz)) then
                 nspec2=nspec2+1
              endif
           endif
 1000   CONTINUE
        npart1=IHNT2(1)-nspec1
        npart2=IHNT2(3)-nspec2

        return
        end

c=======================================================================
c     2/18/03 use PYTHIA to decay eta,rho,omega,k*,phi and Delta
c     4/2012 added pi0 decay flag: 
c       ipion=0: resonance or pi0 in lb(i1); >0: pi0 in lpion(ipion).
        subroutine resdec(i1,nt,nnn,wid,idecay,ipion)

        PARAMETER (hbarc=0.19733)
        PARAMETER (AK0=0.498,APICH=0.140,API0=0.135,AN=0.940,ADDM=0.02)
        PARAMETER (MAXSTR=150001, MAXR=1)
        COMMON /INPUT2/ ILAB, MANYB, NTMAX, ICOLL, INSYS, IPOT, MODE, 
     &       IMOMEN, NFREQ, ICFLOW, ICRHO, ICOU, KPOTEN, KMUL
cc      SAVE /INPUT2/
        COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
cc      SAVE /LUJETS/
        COMMON/LUDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
cc      SAVE /LUDAT1/
        COMMON/LUDAT2/KCHG(500,3),PMAS(500,4),PARF(2000),VCKM(4,4)
cc      SAVE /LUDAT2/
        COMMON/LUDAT3/MDCY(500,3),MDME(2000,2),BRAT(2000),KFDP(2000,5)
cc      SAVE /LUDAT3/
        COMMON /CC/ E(MAXSTR)
cc      SAVE /CC/
        COMMON /EE/ ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON   /PA/RPION(3,MAXSTR,MAXR)
cc      SAVE /PA/
        COMMON   /PB/PPION(3,MAXSTR,MAXR)
cc      SAVE /PB/
        COMMON   /PC/EPION(MAXSTR,MAXR)
cc      SAVE /PC/
        COMMON   /PD/LPION(MAXSTR,MAXR)
cc      SAVE /PD/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
        common/resdcy/NSAV,iksdcy
cc      SAVE /resdcy/
        common/leadng/lb1,px1,py1,pz1,em1,e1,xfnl,yfnl,zfnl,tfnl,
     1       px1n,py1n,pz1n,dp1n
cc      SAVE /leadng/
        EXTERNAL IARFLV, INVFLV
        COMMON/tdecay/tfdcy(MAXSTR),tfdpi(MAXSTR,MAXR),tft(MAXSTR)
cc      SAVE /tdecay/
        COMMON/RNDF77/NSEED
        COMMON /dpert/dpertt(MAXSTR,MAXR),dpertp(MAXSTR),dplast(MAXSTR),
     1       dpdcy(MAXSTR),dpdpi(MAXSTR,MAXR),dpt(MAXSTR, MAXR),
     2       dpp1(MAXSTR,MAXR),dppion(MAXSTR,MAXR)
cc      SAVE /RNDF77/
        common/phidcy/iphidcy,pttrig,ntrig,maxmiss,ipi0dcy
        SAVE   
        irun=idecay
clin-4/2012 for option of pi0 decay:
        if(nt.eq.ntmax.and.ipi0dcy.eq.1
     &       .and.((lb1.eq.4.and.ipion.eq.0).or.ipion.ge.1)) then
           kf=111
c        if(lb1.eq.0.or.lb1.eq.25.or.lb1.eq.26.or.lb1.eq.27
        elseif(lb1.eq.0.or.lb1.eq.25.or.lb1.eq.26.or.lb1.eq.27
     &       .or.lb1.eq.28.or.lb1.eq.29.or.iabs(lb1).eq.30
     &       .or.lb1.eq.24.or.(iabs(lb1).ge.6.and.iabs(lb1).le.9) 
     &       .or.iabs(lb1).eq.16) then
           kf=INVFLV(lb1)
        else
           return
        endif
c
        IP=1
c     label as undecayed and the only particle in the record:
        N=1
        K(IP,1)=1
        K(IP,3)=0
        K(IP,4)=0
        K(IP,5)=0
c
        K(IP,2)=kf
clin-4/2012 for option of pi0 decay:
        if(ipion.eq.0) then
c
        P(IP,1)=px1
        P(IP,2)=py1
        P(IP,3)=pz1
c        em1a=em1
c     eta or omega in ART may be below or too close to (pi+pi-pi0) mass, 
c     causing LUDECY error,thus increase their mass ADDM above this thresh,
c     noting that rho (m=0.281) too close to 2pi thrshold fails to decay:
        if((lb1.eq.0.or.lb1.eq.28).and.em1.lt.(2*APICH+API0+ADDM)) then
           em1=2*APICH+API0+ADDM
c     rho
        elseif(lb1.ge.25.and.lb1.le.27.and.em1.lt.(2*APICH+ADDM)) then
           em1=2*APICH+ADDM
c     K*
        elseif(iabs(lb1).eq.30.and.em1.lt.(APICH+AK0+ADDM)) then
           em1=APICH+AK0+ADDM
c     Delta created in ART may be below (n+pich) mass, causing LUDECY error:
        elseif(iabs(lb1).ge.6.and.iabs(lb1).le.9
     1          .and.em1.lt.(APICH+AN+ADDM)) then
           em1=APICH+AN+ADDM
        endif
c        if(em1.ge.(em1a+0.01)) write (6,*) 
c     1       'Mass increase in resdec():',nt,em1-em1a,lb1
        e1=SQRT(EM1**2+PX1**2+PY1**2+PZ1**2)
        P(IP,4)=e1
        P(IP,5)=em1
clin-5/2008:
        dpdecp=dpertp(i1)
clin-4/2012 for option of pi0 decay:
        elseif(nt.eq.ntmax.and.ipi0dcy.eq.1.and.ipion.ge.1) then        
           P(IP,1)=PPION(1,ipion,IRUN)
           P(IP,2)=PPION(2,ipion,IRUN)
           P(IP,3)=PPION(3,ipion,IRUN)
           P(IP,5)=EPION(ipion,IRUN)
           P(IP,4)=SQRT(P(IP,5)**2+P(IP,1)**2+P(IP,2)**2+P(IP,3)**2)
           dpdecp=dppion(ipion,IRUN)
ctest off
c           write(99,*) P(IP,4), P(IP,5), dpdecp, ipion, wid
        else
           print *, 'stopped in resdec() a'
           stop
        endif
c
        call ludecy(IP)
c     add decay time to daughter's formation time at the last timestep:
        if(nt.eq.ntmax) then
           tau0=hbarc/wid
           taudcy=tau0*(-1.)*alog(1.-RANART(NSEED))
           ndaut=n-nsav
           if(ndaut.le.1) then
              write(10,*) 'note: ndaut(<1)=',ndaut
              call lulist(2)
              stop
            endif
c     lorentz boost:
clin-4/2012 for option of pi0 decay:
            if(ipion.eq.0) then
               taudcy=taudcy*e1/em1
               tfnl=tfnl+taudcy
               xfnl=xfnl+px1/e1*taudcy
               yfnl=yfnl+py1/e1*taudcy
               zfnl=zfnl+pz1/e1*taudcy
            elseif(ipion.ge.1) then
               taudcy=taudcy*P(IP,4)/P(IP,5)
               tfnl=tfdpi(ipion,IRUN)+taudcy
               xfnl=RPION(1,ipion,IRUN)+P(IP,1)/P(IP,4)*taudcy
               yfnl=RPION(2,ipion,IRUN)+P(IP,2)/P(IP,4)*taudcy
               zfnl=RPION(3,ipion,IRUN)+P(IP,3)/P(IP,4)*taudcy
            else
               print *, 'stopped in resdec() b',ipion,wid,P(ip,4)
               stop
            endif
c     at the last timestep, assign rho, K0S or eta (decay daughter)
c     to lb(i1) only (not to lpion) in order to decay them again:
clin-4/2012 for option of pi0 decay:
c           if(n.ge.(nsav+2)) then
           if(n.ge.(nsav+2).and.ipion.eq.0) then
              do 1001 idau=nsav+2,n
                 kdaut=K(idau,2)
                 if(kdaut.eq.221.or.kdaut.eq.113
     1                .or.kdaut.eq.213.or.kdaut.eq.-213
     2                .or.kdaut.eq.310) then
c     switch idau and i1(nsav+1):
                    ksave=kdaut
                    pxsave=p(idau,1)
                    pysave=p(idau,2)
                    pzsave=p(idau,3)
                    esave=p(idau,4)
                    xmsave=p(idau,5)
                    K(idau,2)=K(nsav+1,2)
                    p(idau,1)=p(nsav+1,1)
                    p(idau,2)=p(nsav+1,2)
                    p(idau,3)=p(nsav+1,3)
                    p(idau,4)=p(nsav+1,4)
                    p(idau,5)=p(nsav+1,5)
                    K(nsav+1,2)=ksave
                    p(nsav+1,1)=pxsave
                    p(nsav+1,2)=pysave
                    p(nsav+1,3)=pzsave
                    p(nsav+1,4)=esave
                    p(nsav+1,5)=xmsave
c     note: phi decay may produce rho, K0s or eta, N*(1535) decay may produce 
c     eta, but only one daughter may be rho, K0s or eta:
                    goto 111
                 endif
 1001         continue
           endif
 111       continue
c     
           enet=0.
           do 1002 idau=nsav+1,n
              enet=enet+p(idau,4)
 1002      continue
c           if(abs(enet-e1).gt.0.02) 
c     1          write(93,*) 'resdec(): nt=',nt,enet-e1,lb1
        endif

        do 1003 idau=nsav+1,n
           kdaut=K(idau,2)
           lbdaut=IARFLV(kdaut)
c     K0S and K0L are named K+/K- during hadron cascade, and only 
c     at the last timestep they keep their real LB # before output;
c     K0/K0bar (from K* decay) converted to K0S and K0L at the last timestep:
           if(nt.eq.ntmax.and.(kdaut.eq.130.or.kdaut.eq.310
     1          .or.iabs(kdaut).eq.311)) then
              if(kdaut.eq.130) then
                 lbdaut=22
              elseif(kdaut.eq.310) then
                 lbdaut=24
              elseif(iabs(kdaut).eq.311) then
                 if(RANART(NSEED).lt.0.5) then
                    lbdaut=22
                 else
                    lbdaut=24
                 endif
              endif
           endif
c
           if(idau.eq.(nsav+1)) then
clin-4/2012 for option of pi0 decay:
              if(ipion.eq.0) then
                 LB(i1)=lbdaut
                 E(i1)=p(idau,5)
                 px1n=p(idau,1)
                 py1n=p(idau,2)
                 pz1n=p(idau,3)
clin-5/2008:
                 dp1n=dpdecp
              elseif(ipion.ge.1) then
                 LPION(ipion,IRUN)=lbdaut
                 EPION(ipion,IRUN)=p(idau,5)
                 PPION(1,ipion,IRUN)=p(idau,1)
                 PPION(2,ipion,IRUN)=p(idau,2)
                 PPION(3,ipion,IRUN)=p(idau,3)
                 RPION(1,ipion,IRUN)=xfnl
                 RPION(2,ipion,IRUN)=yfnl
                 RPION(3,ipion,IRUN)=zfnl
                 tfdpi(ipion,IRUN)=tfnl
                 dppion(ipion,IRUN)=dpdecp
              endif
c
           else
              nnn=nnn+1
              LPION(NNN,IRUN)=lbdaut
              EPION(NNN,IRUN)=p(idau,5)
              PPION(1,NNN,IRUN)=p(idau,1)
              PPION(2,NNN,IRUN)=p(idau,2)
              PPION(3,NNN,IRUN)=p(idau,3)
              RPION(1,NNN,IRUN)=xfnl
              RPION(2,NNN,IRUN)=yfnl
              RPION(3,NNN,IRUN)=zfnl
              tfdpi(NNN,IRUN)=tfnl
clin-5/2008:
              dppion(NNN,IRUN)=dpdecp
           endif
 1003   continue
        return
        end

c=======================================================================
        subroutine inidcy

        COMMON/LUJETS/N,K(9000,5),P(9000,5),V(9000,5)
cc      SAVE /LUJETS/
        common/resdcy/NSAV,iksdcy
cc      SAVE /resdcy/
        SAVE   
        N=1
        NSAV=N
        return
        end

c=======================================================================
clin-6/06/02 local parton freezeout motivated from critical density:
        subroutine local(t)
c
        implicit double precision  (a-h, o-z)
        PARAMETER (MAXPTN=400001)
        PARAMETER (r0=1d0)
        COMMON /para1/ mul
cc      SAVE /para1/
        COMMON /prec2/GX5(MAXPTN),GY5(MAXPTN),GZ5(MAXPTN),FT5(MAXPTN),
     &       PX5(MAXPTN), PY5(MAXPTN), PZ5(MAXPTN), E5(MAXPTN),
     &       XMASS5(MAXPTN), ITYP5(MAXPTN)
cc      SAVE /prec2/
        common /frzprc/ 
     &       gxfrz(MAXPTN), gyfrz(MAXPTN), gzfrz(MAXPTN), ftfrz(MAXPTN),
     &       pxfrz(MAXPTN), pyfrz(MAXPTN), pzfrz(MAXPTN), efrz(MAXPTN),
     &       xmfrz(MAXPTN), 
     &       tfrz(302), ifrz(MAXPTN), idfrz(MAXPTN), itlast
cc      SAVE /frzprc/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /prec5/ eta(MAXPTN), rap(MAXPTN), tau(MAXPTN)
cc      SAVE /prec5/
        common /coal/dpcoal,drcoal,ecritl
cc      SAVE /coal/
        SAVE   
c
      do 1001 it=1,301
         if(t.ge.tfrz(it).and.t.lt.tfrz(it+1)) then
            if(it.eq.itlast) then
               return
            else
               itlast=it
               goto 50
            endif
         endif
 1001 continue
      write(1,*) 'local time out of range in LOCAL, stop',t,it
      stop
 50   continue
c
      do 200 ip=1,mul
c     skip partons which have frozen out:
         if(ifrz(ip).eq.1) goto 200
         if(it.eq.301) then
c     freezeout all the left partons beyond the time of 3000 fm:
            etcrit=1d6
            goto 150
         else
c     freezeout when transverse energy density < etcrit:
            etcrit=(ecritl*2d0/3d0)
         endif
c     skip partons which have not yet formed:
         if(t.lt.FT5(ip)) goto 200
         rap0=rap(ip)
         eta0=eta(ip)
         x0=GX5(ip)+vx(ip)*(t-FT5(ip))
         y0=GY5(ip)+vy(ip)*(t-FT5(ip))
         detdy=0d0
         do 100 itest=1,mul
c     skip self and partons which have not yet formed:
            if(itest.eq.ip.or.t.lt.FT5(itest)) goto 100
            ettest=eta(itest)
            xtest=GX5(itest)+vx(itest)*(t-FT5(itest))
            ytest=GY5(itest)+vy(itest)*(t-FT5(itest))
            drt=sqrt((xtest-x0)**2+(ytest-y0)**2)
c     count partons within drt<1 and -1<(eta-eta0)<1:
            if(dabs(ettest-eta0).le.1d0.and.drt.le.r0) 
     1           detdy=detdy+dsqrt(PX5(itest)**2+PY5(itest)**2
     2           +XMASS5(itest)**2)*0.5d0
 100     continue
         detdy=detdy*(dcosh(eta0)**2)/(t*3.1416d0*r0**2*dcosh(rap0))
c     when density is below critical density for phase transition, freeze out:
 150     if(detdy.le.etcrit) then
            ifrz(ip)=1
            idfrz(ip)=ITYP5(ip)
            pxfrz(ip)=PX5(ip)
            pyfrz(ip)=PY5(ip)
            pzfrz(ip)=PZ5(ip)
            efrz(ip)=E5(ip)
            xmfrz(ip)=XMASS5(ip)
            if(t.gt.FT5(ip)) then
               gxfrz(ip)=x0
               gyfrz(ip)=y0
               gzfrz(ip)=GZ5(ip)+vz(ip)*(t-FT5(ip))
               ftfrz(ip)=t
            else
c     if this freezeout time < formation time, use formation time & positions.
c     This ensures the recovery of default hadron when e_crit=infty:
               gxfrz(ip)=GX5(ip)
               gyfrz(ip)=GY5(ip)
               gzfrz(ip)=GZ5(ip)
               ftfrz(ip)=FT5(ip)
            endif
         endif
 200  continue
c
        return
        end

c=======================================================================
clin-6/06/02 initialization for local parton freezeout
        subroutine inifrz
c
        implicit double precision  (a-h, o-z)
        PARAMETER (MAXPTN=400001)
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        common /frzprc/ 
     &       gxfrz(MAXPTN), gyfrz(MAXPTN), gzfrz(MAXPTN), ftfrz(MAXPTN),
     &       pxfrz(MAXPTN), pyfrz(MAXPTN), pzfrz(MAXPTN), efrz(MAXPTN),
     &       xmfrz(MAXPTN), 
     &       tfrz(302), ifrz(MAXPTN), idfrz(MAXPTN), itlast
cc      SAVE /frzprc/
        SAVE   
c
c     for freezeout time 0-10fm, use interval of 0.1fm; 
c     for 10-100fm, use interval of 1fm; 
c     for 100-1000fm, use interval of 10fm; 
c     for 1000-3000fm, use interval of 100fm: 
        step1=0.1d0
        step2=1d0
        step3=10d0
        step4=100d0
c     
        do 1001 it=1,101
           tfrz(it)=0d0+dble(it-1)*step1
 1001 continue
        do 1002 it=102,191
           tfrz(it)=10d0+dble(it-101)*step2
 1002   continue
        do 1003 it=192,281
           tfrz(it)=100d0+dble(it-191)*step3
 1003   continue
        do 1004 it=282,301
           tfrz(it)=1000d0+dble(it-281)*step4
 1004   continue
        tfrz(302)=tlarge
c
        return
        end

clin-5/2009 v2 analysis
c=======================================================================
c     idd=0,1,2,3 specifies different subroutines for partonic flow analysis.
        subroutine flowp(idd)
c
        implicit double precision  (a-h, o-z)
        real dt
        parameter (MAXPTN=400001)
csp
        parameter (bmt=0.05d0)
        dimension nlfile(3),nsfile(3),nmfile(3)
c
        dimension v2pp(3),xnpp(3),v2psum(3),v2p2sm(3),nfile(3)
        dimension tsp(31),v2pevt(3),v2pavg(3),varv2p(3)
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        COMMON /para1/ mul
cc      SAVE /para1/
        COMMON /prec2/GX5(MAXPTN),GY5(MAXPTN),GZ5(MAXPTN),FT5(MAXPTN),
     &       PX5(MAXPTN), PY5(MAXPTN), PZ5(MAXPTN), E5(MAXPTN),
     &       XMASS5(MAXPTN), ITYP5(MAXPTN)
cc      SAVE /prec2/
        COMMON /pflow/ v2p(30,3),xnpart(30,3),etp(30,3),
     1       s2p(30,3),v2p2(30,3),nevt(30)
cc      SAVE /pflow/
        COMMON /pflowf/ v2pf(30,3),xnpf(30,3),etpf(30,3),
     1                 xncoll(30),s2pf(30,3),v2pf2(30,3)
cc      SAVE /pflowf/
        COMMON /pfrz/ v2pfrz(30,3),xnpfrz(30,3),etpfrz(30,3),
     1       s2pfrz(30,3),v2p2fz(30,3),tscatt(31),
     2       nevtfz(30),iscatt(30)
cc      SAVE /pfrz/
        COMMON /hflow/ v2h(30,3),xnhadr(30,3),eth(30,3),
     1 v2h2(30,3),s2h(30,3)
cc      SAVE /hflow/
        COMMON /AREVT/ IAEVT, IARUN, MISS
cc      SAVE /AREVT/
        common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
        COMMON /INPUT2/ ILAB, MANYB, NTMAX, ICOLL, INSYS, IPOT, MODE, 
     &   IMOMEN, NFREQ, ICFLOW, ICRHO, ICOU, KPOTEN, KMUL
cc      SAVE /INPUT2/
cc      SAVE itimep,iaevtp,v2pp,xnpp,v2psum,v2p2sm
cc      SAVE nfile,itanim,nlfile,nsfile,nmfile
        common /precpb/vxp(MAXPTN),vyp(MAXPTN),vzp(MAXPTN)
        SAVE   
csp
        dimension etpl(30,3),etps(30,3),etplf(30,3),etpsf(30,3),
     &       etlfrz(30,3),etsfrz(30,3),
     &       xnpl(30,3),xnps(30,3),xnplf(30,3),xnpsf(30,3),
     &       xnlfrz(30,3),xnsfrz(30,3),
     &       v2pl(30,3),v2ps(30,3),v2plf(30,3),v2psf(30,3),
     &       s2pl(30,3),s2ps(30,3),s2plf(30,3),s2psf(30,3),
     &       DMYil(50,3),DMYfl(50,3),
     &       DMYis(50,3),DMYfs(50,3)
        data tsp/0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 
     &       1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 
     &       2  , 3,   4,   5,   6,   7,   8,   9,   10,  20,  30/
c     idd=0: initialization for flow analysis, called by artdri.f:
        if(idd.eq.0) then        
           nfile(1)=60
           nfile(2)=64
           nfile(3)=20
           OPEN (nfile(1),FILE='ana1/v2p.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(1)+1, 
     1 FILE = 'ana1/v2p-formed.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(1)+2, 
     1 FILE = 'ana1/v2p-active.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(1)+3, 
     1 FILE = 'ana1/v2ph.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(2),FILE='ana1/v2p-y2.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(2)+1, 
     1 FILE = 'ana1/v2p-formed2.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(2)+2, 
     1 FILE = 'ana1/v2p-active2.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(2)+3, 
     1 FILE = 'ana1/v2ph-y2.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(3),FILE='ana1/v2p-y1.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(3)+1, 
     1 FILE = 'ana1/v2p-formed1.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(3)+2, 
     1 FILE = 'ana1/v2p-active1.dat', STATUS = 'UNKNOWN')
           OPEN (nfile(3)+3, 
     1 FILE = 'ana1/v2ph-y1.dat', STATUS = 'UNKNOWN')
           OPEN (49, FILE = 'ana1/v2p-ebe.dat', STATUS = 'UNKNOWN')
           write(49, *) '    ievt,  v2p,  v2p_y2,   v2p_y1'
c
           OPEN (59, FILE = 'ana1/v2h.dat', STATUS = 'UNKNOWN')
           OPEN (68, FILE = 'ana1/v2h-y2.dat', STATUS = 'UNKNOWN')
           OPEN (69, FILE = 'ana1/v2h-y1.dat', STATUS = 'UNKNOWN')
           OPEN (88, FILE = 'ana1/v2h-ebe.dat', STATUS = 'UNKNOWN')
           write(88, *) '    ievt,  v2h,  v2h_y2,   v2h_y1'
csp07/05
           nlfile(1)=70
           nlfile(2)=72
           nlfile(3)=74
           OPEN (nlfile(1),FILE='ana1/mtl.dat', STATUS = 'UNKNOWN')
           OPEN (nlfile(1)+1, 
     1 FILE = 'ana1/mtl-formed.dat', STATUS = 'UNKNOWN')
           OPEN (nlfile(2),FILE='ana1/mtl-y2.dat', STATUS = 'UNKNOWN')
           OPEN (nlfile(2)+1, 
     1 FILE = 'ana1/mtl-formed2.dat', STATUS = 'UNKNOWN')
           OPEN (nlfile(3),FILE='ana1/mtl-y1.dat', STATUS = 'UNKNOWN')
           OPEN (nlfile(3)+1, 
     1 FILE = 'ana1/mtl-formed1.dat', STATUS = 'UNKNOWN')
           nsfile(1)=76
           nsfile(2)=78
           nsfile(3)=80
           OPEN (nsfile(1),FILE='ana1/mts.dat', STATUS = 'UNKNOWN')
           OPEN (nsfile(1)+1, 
     1 FILE = 'ana1/mts-formed.dat', STATUS = 'UNKNOWN')
           OPEN (nsfile(2),FILE='ana1/mts-y2.dat', STATUS = 'UNKNOWN')
           OPEN (nsfile(2)+1, 
     1 FILE = 'ana1/mts-formed2.dat', STATUS = 'UNKNOWN')
           OPEN (nsfile(3),FILE='ana1/mts-y1.dat', STATUS = 'UNKNOWN')
           OPEN (nsfile(3)+1, 
     1 FILE = 'ana1/mts-formed1.dat', STATUS = 'UNKNOWN')
           nmfile(1)=82
           nmfile(2)=83
           nmfile(3)=84
           OPEN (nmfile(1),FILE='ana1/Nmt.dat', STATUS = 'UNKNOWN')
           OPEN (nmfile(2),FILE='ana1/Nmt-y2.dat', STATUS = 'UNKNOWN')
           OPEN (nmfile(3),FILE='ana1/Nmt-y1.dat', STATUS = 'UNKNOWN')
clin-8/2015: changed unit number of animation files,
ctest off     turn off animation output (0 to turn off and 1 to turn on):
           ifanim=0
clin-11/27/00 for animation:
           if(ifanim.eq.1) then
              OPEN (10, FILE = 'ana1/h-animate.dat', STATUS = 'UNKNOWN')
              write(10,*) ntmax, dt
              OPEN (11, FILE = 'ana1/p-animate.dat', STATUS = 'UNKNOWN')
              OPEN (15, FILE = 'ana1/p-finalft.dat', STATUS = 'UNKNOWN')
           endif
clin-10/2014: write out partons at all eta, turn off now:
c           if(nevent.ge.1) 
           if(nevent.lt.1) 
     1          OPEN (93, FILE = 'ana1/parton-t.dat', STATUS='UNKNOWN')
c
           itimep=0
           itanim=0
           iaevtp=0
csp
           do 1002 ii=1,50
              do 1001 iy=1,3
                 DMYil(ii,iy) = 0d0
                 DMYfl(ii,iy) = 0d0
                 DMYis(ii,iy) = 0d0
                 DMYfs(ii,iy) = 0d0
 1001         continue
 1002      continue
c
           do 1003 ii=1,31
              tscatt(ii)=0d0
 1003      continue
           do 1005 ii=1,30
              nevt(ii)=0
              xncoll(ii)=0d0
              nevtfz(ii)=0
              iscatt(ii)=0
              do 1004 iy=1,3
                 v2p(ii,iy)=0d0
                 v2p2(ii,iy)=0d0
                 s2p(ii,iy)=0d0
                 etp(ii,iy)=0d0
                 xnpart(ii,iy)=0d0
                 v2pf(ii,iy)=0d0
                 v2pf2(ii,iy)=0d0
                 s2pf(ii,iy)=0d0
                 etpf(ii,iy)=0d0
                 xnpf(ii,iy)=0d0
                 v2pfrz(ii,iy)=0d0
                 v2p2fz(ii,iy)=0d0
                 s2pfrz(ii,iy)=0d0
                 etpfrz(ii,iy)=0d0
                 xnpfrz(ii,iy)=0d0
csp07/05
                 etpl(ii,iy)=0d0
                 etps(ii,iy)=0d0
                 etplf(ii,iy)=0d0
                 etpsf(ii,iy)=0d0
                 etlfrz(ii,iy)=0d0
                 etsfrz(ii,iy)=0d0
              xnpl(ii,iy)=0d0
              xnps(ii,iy)=0d0
              xnplf(ii,iy)=0d0
              xnpsf(ii,iy)=0d0
              xnlfrz(ii,iy)=0d0
              xnsfrz(ii,iy)=0d0
              v2pl(ii,iy)=0d0
              v2ps(ii,iy)=0d0
              v2plf(ii,iy)=0d0
              v2psf(ii,iy)=0d0
              s2pl(ii,iy)=0d0
              s2ps(ii,iy)=0d0
              s2plf(ii,iy)=0d0
              s2psf(ii,iy)=0d0
 1004      continue
 1005   continue
           do 1006 iy=1,3
              v2pevt(iy)=0d0
              v2pavg(iy)=0d0
              varv2p(iy)=0d0
              v2pp(iy)=0.d0
              xnpp(iy)=0d0
              v2psum(iy)=0.d0
              v2p2sm(iy)=0.d0
 1006      continue
c     idd=1: calculate parton elliptic flow, called by zpc.f:
        else if(idd.eq.1) then        
           if(iaevt.ne.iaevtp.and.ianp.eq.31) itanim=0
c
           t2time = FT5(iscat)
           do 1008 ianp = 1, 30
              if (t2time.lt.tsp(ianp+1).and.t2time.ge.tsp(ianp)) then
c     write flow info only once at each fixed time:
                 xncoll(ianp)=xncoll(ianp)+1d0
c     to prevent an earlier t2time comes later in the same event 
c     and mess up nevt:
                 if(ianp.le.itimep.and.iaevt.eq.iaevtp) goto 101
                 nevt(ianp)=nevt(ianp)+1
                 tscatt(ianp+1)=t2time
                 iscatt(ianp)=1
                 nevtfz(ianp)=nevtfz(ianp)+1
                 do 100 I=1,mul
clin-8/2015 to avoid IEEE_DIVIDE_BY_ZERO or IEEE_INVALID:
c                    ypartn=0.5d0*dlog((E5(i)+PZ5(i))
c     1                   /(E5(i)-PZ5(i)+1.d-8))
                    delta=1d-8
                    if((E5(i)-dabs(PZ5(i))+delta).le.0) then
                       ypartn=1000000.d0*sign(1.d0,PZ5(i))
                       write(6,*) 'ypartn error',E5(i)-dabs(PZ5(i))
                    else
                       ypartn=0.5d0*dlog((E5(i)+PZ5(i)+delta)
     1                      /(E5(i)-PZ5(i)+delta))
                    endif
                    pt2=PX5(I)**2+PY5(I)**2
ctest off: initial (pt,y) and (x,y) distribution:
c                    idtime=1
c                    if(ianp.eq.idtime) then
c                       iityp=iabs(ITYP5(I))
c                       if(iityp.eq.1.or.iityp.eq.2) then
c                          write(651,*) dsqrt(pt2),ypartn
c                          write(654,*) GX5(I),GY5(I)
c                       elseif(iityp.eq.1103.or.iityp.eq.2101
c     1 .or.iityp.eq.2103.or.iityp.eq.2203.
c     2 .or.iityp.eq.3101.or.iityp.eq.3103.
c     3 .or.iityp.eq.3201.or.iityp.eq.3203.or.iityp.eq.3303) 
c     4 then
c                          write(652,*) dsqrt(pt2),ypartn
c                          write(655,*) GX5(I),GY5(I)
c                       elseif(iityp.eq.21) then
c                          write(653,*) dsqrt(pt2),ypartn
c                          write(656,*) GX5(I),GY5(I)
c                       endif
c                    endif
ctest-end
ctest off density with 2fm radius and z:(-0.1*t,0.1*t):
c                    gx_now=GX5(i)+(t2time-FT5(i))*PX5(i)/E5(i)
c                    gy_now=GY5(i)+(t2time-FT5(i))*PY5(i)/E5(i)
c                    gz_now=GZ5(i)+(t2time-FT5(i))*PZ5(i)/E5(i)
c                    rt_now=dsqrt(gx_now**2+gy_now**2)
c                    zmax=0.1d0*t2time
c                    volume=3.1416d0*(2d0**2)*(2*zmax)
c                    if(rt_now.gt.2d0.or.dabs(gz_now).gt.zmax)
c     1                   goto 100
ctest-end
                    iloop=1
                    if(dabs(ypartn).le.1d0) then
                       iloop=2
                       if(dabs(ypartn).le.0.5d0) then
                          iloop=3
                       endif
                    endif
                    do 50 iy=1,iloop
clin-5/2012:
c                       if(pt2.gt.0.) then
                       if(pt2.gt.0d0) then
                          v2prtn=(PX5(I)**2-PY5(I)**2)/pt2
clin-5/2012:
c                          if(abs(v2prtn).gt.1.) 
                          if(dabs(v2prtn).gt.1d0) 
     1 write(nfile(iy),*) 'v2prtn>1',v2prtn
                          v2p(ianp,iy)=v2p(ianp,iy)+v2prtn
                          v2p2(ianp,iy)=v2p2(ianp,iy)+v2prtn**2
                       endif
                       xperp2=GX5(I)**2+GY5(I)**2
clin-5/2012:
c                       if(xperp2.gt.0.) 
                       if(xperp2.gt.0d0) 
     1        s2p(ianp,iy)=s2p(ianp,iy)+(GX5(I)**2-GY5(I)**2)/xperp2
                       xnpart(ianp,iy)=xnpart(ianp,iy)+1d0
                       etp(ianp,iy)=etp(ianp,iy)+dsqrt(pt2+XMASS5(I)**2)
ctest off density:
c                       etp(ianp,iy)=etp(ianp,iy)
c     1                  +dsqrt(pt2+XMASS5(I)**2+PZ5(i)**2)/volume
clin-2/22/00 to write out parton info only for formed ones:
                       if(FT5(I).le.t2time) then
                          v2pf(ianp,iy)=v2pf(ianp,iy)+v2prtn
                          v2pf2(ianp,iy)=v2pf2(ianp,iy)+v2prtn**2
clin-5/2012:
c                          if(xperp2.gt.0.) 
                          if(xperp2.gt.0d0) 
     1        s2pf(ianp,iy)=s2pf(ianp,iy)+(GX5(I)**2-GY5(I)**2)/xperp2
                          xnpf(ianp,iy)=xnpf(ianp,iy)+1d0
                  etpf(ianp,iy)=etpf(ianp,iy)+dsqrt(pt2+XMASS5(I)**2)
ctest off density:
c                  etpf(ianp,iy)=etpf(ianp,iy)
c     1                   +dsqrt(pt2+XMASS5(I)**2+PZ5(i)**2)/volume
                       endif
 50                    continue
 100                 continue
                 itimep=ianp
                 iaevtp=iaevt
clin-3/30/00 ebe v2 variables:
                 if(ianp.eq.30) then
                    do 1007 iy=1,3
                       npartn=IDINT(xnpart(ianp,iy)-xnpp(iy))
                       if(npartn.ne.0) then
                          v2pevt(iy)=(v2p(ianp,iy)-v2pp(iy))/npartn
                          v2psum(iy)=v2psum(iy)+v2pevt(iy)
                          v2p2sm(iy)=v2p2sm(iy)+v2pevt(iy)**2
                          v2pp(iy)=v2p(ianp,iy)
                          xnpp(iy)=xnpart(ianp,iy)
                       endif
 1007               continue
                    write(49, 160) iaevt,v2pevt
                 endif
                 goto 101
              endif
 1008      continue
clin-11/28/00 for animation:
clin-8/2015 ctest off turn off parton-t.dat:
c 101       if(nevent.ge.1) then
 101       if(nevent.lt.1) then
              do 110 nt = 1, ntmax
                 time1=dble(nt*dt)
                 time2=dble((nt+1)*dt)
                 if (t2time.lt.time2.and.t2time.ge.time1) then
                    if(nt.le.itanim) return
                    if(ifanim.eq.1) write(11,*) t2time
                    iform=0
                    ne1all=0
                    ne1form=0
                    do 1009 I=1,mul
c     Calculate parton coordinates after propagation to current time:
                       gz_now=GZ5(i)+(t2time-FT5(i))*PZ5(i)/E5(i)
                       If(dabs(gz_now).lt.t2time) then
                       etap=0.5d0*dlog((t2time+gz_now)/(t2time-gz_now))
                       else
                          etap=1000000.d0*sign(1.d0,gz_now)
                       endif
                       ne1all=ne1all+1
                       if(FT5(I).le.t2time) ne1form=ne1form+1
c     write out parton info only for formed ones for animation:
                       if(FT5(I).le.t2time) iform=iform+1
 1009               continue
clin-8/2015 for animation:
                    if(ifanim.eq.1) write(11,*) iform
                    write(93,184) 'evt#,t,np,npformed=',
     1                   iaevt,t2time,ne1all,ne1form
 184                format(a20,i7,f8.4,2(1x,i6))
c
                    do 120 I=1,mul
                       if(FT5(I).le.t2time) then
c     propagate formed partons to current time t2time using parton v:
                          gz_now=GZ5(i)+(t2time-FT5(i))*PZ5(i)/E5(i)
                       else
c     back-propagate unformed partons using parent hadron v:
                          gz_now=GZ5(i)+(t2time-FT5(i))*vzp(i)
                       endif
c
                       If(dabs(gz_now).lt.t2time) then
                       etap=0.5d0*dlog((t2time+gz_now)/(t2time-gz_now))
                       else
                          etap=1000000.d0*sign(1.d0,gz_now)
                       endif
c     calculate other coordinates of the parton:
                       if(FT5(I).le.t2time) then
                          gx_now=GX5(i)+(t2time-FT5(i))*PX5(i)/E5(i)
                          gy_now=GY5(i)+(t2time-FT5(i))*PY5(i)/E5(i)
                       else
                          gx_now=GX5(i)+(t2time-FT5(i))*vxp(i)
                          gy_now=GY5(i)+(t2time-FT5(i))*vyp(i)
                       endif
                       write(93,185) ITYP5(i),PX5(i),PY5(i),PZ5(i),
     1                      XMASS5(i),gx_now,gy_now,ft5(i),etap
clin-8/2015 for animation:
                       if(ifanim.eq.1.and.FT5(I).le.t2time) then
                          write(11,180) ITYP5(i),GX5(i),GY5(i),GZ5(i),
     1                         FT5(i),PX5(i),PY5(i),PZ5(i),E5(i)
                       endif
 185           format(i3,3(1x,f8.3),1x,f8.4,1x,2(f8.3,1x),f11.4,1x,f8.3)
 120                continue
                    itanim=nt
                 endif
 110          continue
           endif
c
 160       format(i10,3(2x,f9.5))
 180       format(i6,8(1x,f7.2))
clin-5/17/01 calculate v2 for active partons (which have not frozen out):
c     idd=3, called at end of zpc.f:
        else if(idd.eq.3) then        
           do 1010 ianp=1,30
              if(iscatt(ianp).eq.0) tscatt(ianp+1)=tscatt(ianp)
 1010      continue
           do 350 I=1,mul
clin-8/2015 to avoid IEEE_DIVIDE_BY_ZERO or IEEE_INVALID:
c              ypartn=0.5d0*dlog((E5(i)+PZ5(i))
c     1             /(E5(i)-PZ5(i)+1.d-8))
              delta=1d-8
              if((E5(i)-dabs(PZ5(i))+delta).le.0) then
                 write(6,*) 'ypartn error',E5(i)-dabs(PZ5(i))
                 ypartn=1000000.d0*sign(1.d0,PZ5(i))
              else
                 ypartn=0.5d0*dlog((E5(i)+PZ5(i)+delta)
     1                /(E5(i)-PZ5(i)+delta))
              endif
              pt2=PX5(I)**2+PY5(I)**2
              iloop=1
              if(dabs(ypartn).le.1d0) then
                 iloop=2
                 if(dabs(ypartn).le.0.5d0) then
                    iloop=3
                 endif
              endif
c
              do 325 ianp=1,30
                 if(iscatt(ianp).ne.0) then
                    if(FT5(I).lt.tscatt(ianp+1)
     1 .and.FT5(I).ge.tscatt(ianp)) then
                       do 1011 iy=1,iloop
clin-5/2012:
c                          if(pt2.gt.0.) then
                          if(pt2.gt.0d0) then
                             v2prtn=(PX5(I)**2-PY5(I)**2)/pt2
                             v2pfrz(ianp,iy)=v2pfrz(ianp,iy)+v2prtn
                     v2p2fz(ianp,iy)=v2p2fz(ianp,iy)+v2prtn**2
                          endif
                          xperp2=GX5(I)**2+GY5(I)**2
clin-5/2012:
c                          if(xperp2.gt.0.) s2pfrz(ianp,iy)=
                          if(xperp2.gt.0d0) s2pfrz(ianp,iy)=
     1 s2pfrz(ianp,iy)+(GX5(I)**2-GY5(I)**2)/xperp2
        etpfrz(ianp,iy)=etpfrz(ianp,iy)+dsqrt(pt2+XMASS5(I)**2)
                          xnpfrz(ianp,iy)=xnpfrz(ianp,iy)+1d0
ctest off density:
c                    etpfrz(ianp,iy)=etpfrz(ianp,iy)
c     1                   +dsqrt(pt2+XMASS5(I)**2+PZ5(i)**2)/volume
csp07/05
            if(ITYP5(I).eq.1.or.ITYP5(I).eq.2)then
              etlfrz(ianp,iy)=etlfrz(ianp,iy)+dsqrt(pt2+XMASS5(I)**2)
              xnlfrz(ianp,iy)=xnlfrz(ianp,iy)+1d0
            elseif(ITYP5(I).eq.3)then
              etsfrz(ianp,iy)=etsfrz(ianp,iy)+dsqrt(pt2+XMASS5(I)**2)
              xnsfrz(ianp,iy)=xnsfrz(ianp,iy)+1d0
            endif
csp07/05 end
 1011    continue
c     parton freezeout info taken, proceed to next parton:
                       goto 350
                    endif
                 endif
 325          continue
 350       continue
c     idd=2: calculate average partonic elliptic flow, called from artdri.f,
        else if(idd.eq.2) then
           do 1012 i=1,3
              write(nfile(i),*) '   tsp,   v2p,     v2p2, '//
     1 '   s2p,  etp,   xmult,    nevt,  xnctot'
              write ((nfile(i)+1),*) '  tsp,   v2pf,   v2pf2, '//
     1 '   s2pf, etpf,  xnform,  xcrate'
              write ((nfile(i)+2),*) '  tsp,   v2pa,   v2pa2, '//
     1 '   s2pa, etpa,  xmult_ap,  xnform,   nevt'
              write ((nfile(i)+3),*) '  tsph,  v2ph,   v2ph2, '//
     1 '   s2ph, etph,  xmult_(ap/2+h),xmult_ap/2,nevt'
csp
           write(nlfile(i),*) '   tsp,    v2,     s2,    etp,    xmul'
           write(nsfile(i),*) '   tsp,    v2,     s2,    etp,    xmul'
           write(nlfile(i)+1,*) '   tsp,    v2,     s2,    etp,    xmul'
           write(nsfile(i)+1,*) '   tsp,    v2,     s2,    etp,    xmul'
c
 1012   continue
clin-3/30/00 ensemble average & variance of v2 (over particles in all events):
           do 150 ii=1, 30
              if(nevt(ii).eq.0) goto 150
              do 1014 iy=1,3
clin-5/2012:
c                 if(xnpart(ii,iy).gt.1) then
                 if(xnpart(ii,iy).gt.1d0) then
                    v2p(ii,iy)=v2p(ii,iy)/xnpart(ii,iy)
                    v2p2(ii,iy)=dsqrt((v2p2(ii,iy)/xnpart(ii,iy)
     1                    -v2p(ii,iy)**2)/(xnpart(ii,iy)-1))
                    s2p(ii,iy)=s2p(ii,iy)/xnpart(ii,iy)
c xmult and etp are multiplicity and et for an averaged event:
                    xmult=dble(xnpart(ii,iy)/dble(nevt(ii)))
                    etp(ii,iy)=etp(ii,iy)/dble(nevt(ii))
csp
                    etpl(ii,iy)=etpl(ii,iy)/dble(nevt(ii))
                    etps(ii,iy)=etps(ii,iy)/dble(nevt(ii))
c
                    xnctot=0d0
                    do 1013 inum=1,ii
                       xnctot=xnctot+xncoll(inum)
 1013               continue
                    if(nevt(1).ne.0) xnctot=xnctot/nevt(1)
                    write (nfile(iy),200) tsp(ii),v2p(ii,iy),
     1      v2p2(ii,iy),s2p(ii,iy),etp(ii,iy),xmult,nevt(ii),xnctot
                 endif
                 if(nevt(ii).ne.0) 
     1                xcrate=xncoll(ii)/(tsp(ii+1)-tsp(ii))/nevt(ii)
c
clin-5/2012:
c                 if(xnpf(ii,iy).gt.1) then
                 if(xnpf(ii,iy).gt.1d0) then
                    v2pf(ii,iy)=v2pf(ii,iy)/xnpf(ii,iy)
                    v2pf2(ii,iy)=dsqrt((v2pf2(ii,iy)/xnpf(ii,iy)
     1                    -v2pf(ii,iy)**2)/(xnpf(ii,iy)-1))
                    s2pf(ii,iy)=s2pf(ii,iy)/xnpf(ii,iy)
                    xnform=dble(xnpf(ii,iy)/dble(nevt(ii)))
                    etpf(ii,iy)=etpf(ii,iy)/dble(nevt(ii))
csp
                    etplf(ii,iy)=etplf(ii,iy)/dble(nevt(ii))
                    etpsf(ii,iy)=etpsf(ii,iy)/dble(nevt(ii))
c
                    write (nfile(iy)+1, 210) tsp(ii),v2pf(ii,iy),
     1      v2pf2(ii,iy),s2pf(ii,iy),etpf(ii,iy),xnform,xcrate
                 endif
csp
clin-5/2012:
c                 if(xnpl(ii,iy).gt.1) then
                 if(xnpl(ii,iy).gt.1d0) then
                    v2pl(ii,iy)=v2pl(ii,iy)/xnpl(ii,iy)
                    s2pl(ii,iy)=s2pl(ii,iy)/xnpl(ii,iy)
                    xmult=dble(xnpl(ii,iy)/dble(nevt(ii)))
                    etpl(ii,iy)=etpl(ii,iy)/dble(nevt(ii))
                    write (nlfile(iy),201) tsp(ii),v2pl(ii,iy),
     1        s2pl(ii,iy),etpl(ii,iy),xmult
                 endif
clin-5/2012:
c                 if(xnps(ii,iy).gt.1) then
                 if(xnps(ii,iy).gt.1d0) then
                    v2ps(ii,iy)=v2ps(ii,iy)/xnps(ii,iy)
                    s2ps(ii,iy)=s2ps(ii,iy)/xnps(ii,iy)
                    xmult=dble(xnps(ii,iy)/dble(nevt(ii)))
                    etps(ii,iy)=etps(ii,iy)/dble(nevt(ii))
                    write (nsfile(iy),201) tsp(ii),v2ps(ii,iy),
     1        s2ps(ii,iy),etps(ii,iy),xmult
                 endif
clin-5/2012:
c                 if(xnplf(ii,iy).gt.1) then
                 if(xnplf(ii,iy).gt.1d0) then
                    v2plf(ii,iy)=v2plf(ii,iy)/xnplf(ii,iy)
                    s2plf(ii,iy)=s2plf(ii,iy)/xnplf(ii,iy)
                    xmult=dble(xnplf(ii,iy)/dble(nevt(ii)))
                    etplf(ii,iy)=etplf(ii,iy)/dble(nevt(ii))
                    write (nlfile(iy)+1,201) tsp(ii),v2plf(ii,iy),
     1        s2plf(ii,iy),etplf(ii,iy),xmult
                 endif
clin-5/2012:
c                 if(xnpsf(ii,iy).gt.1) then
                 if(xnpsf(ii,iy).gt.1d0) then
                    v2psf(ii,iy)=v2psf(ii,iy)/xnpsf(ii,iy)
                    s2psf(ii,iy)=s2psf(ii,iy)/xnpsf(ii,iy)
                    xmult=dble(xnpsf(ii,iy)/dble(nevt(ii)))
                    etpsf(ii,iy)=etpsf(ii,iy)/dble(nevt(ii))
                    write (nsfile(iy)+1,201) tsp(ii),v2psf(ii,iy),
     1        s2psf(ii,iy),etpsf(ii,iy),xmult
                 endif
csp-end
 1014         continue
 150           continue
csp07/05 initial & final mt distrb 
               scalei=0d0
               scalef=0d0               
               if(nevt(1).ne.0) SCALEi = 1d0 / dble(nevt(1)) / BMT
               if(nevt(30).ne.0) SCALEf = 1d0 / dble(nevt(30)) / BMT
         do 1016 iy=2,3
           yra = 1d0
           if(iy .eq. 2)yra = 2d0
         do 1015 i=1,50
           WRITE(nmfile(iy),251) BMT*dble(I - 0.5), 
     &     SCALEi*DMYil(I,iy)/yra, SCALEf*DMYfl(I,iy)/yra,
     &     SCALEi*DMYis(I,iy)/yra, SCALEf*DMYfs(I,iy)/yra
 1015   continue
 1016 continue
csp07/05 end
clin-3/30/00 event-by-event average & variance of v2:
           if(nevt(30).ge.1) then
              do 1017 iy=1,3
                 v2pavg(iy)=v2psum(iy)/nevt(30)
                 v2var0=v2p2sm(iy)/nevt(30)-v2pavg(iy)**2
clin-5/2012:
c                 if(v2var0.gt.0) varv2p(iy)=dsqrt(v2var0)
                 if(v2var0.gt.0d0) varv2p(iy)=dsqrt(v2var0)
 1017 continue
              write(49, 240) 'EBE v2p,v2p(y2),v2p(y1): avg=', v2pavg
              write(49, 240) 'EBE v2p,v2p(y2),v2p(y1): var=', varv2p
           endif
clin-8/2015:
clin-11/28/00 for animation:
           if(ifanim.eq.1) then
              do 1018 I=1,mul
                 if(FT5(I).le.t2time) then
                    write(15,140) ITYP5(i),GX5(i),GY5(i),GZ5(i),FT5(i)
                 endif
 1018         continue
 140          format(i10,4(2x,f7.2))
clin-11/29/00 signal the end of animation file:
              write(10,*) -10.
              write(10,*) 0
              write(11,*) -10.
              write(11,*) 0
              close(10)
              close(11)
              close(15)
           endif

clin-5/18/01 calculate v2 for active partons:
           do 450 ianp=1,30
              do 400 iy=1,3
                 v2pact=0d0
                 v2p2ac=0d0
                 s2pact=0d0
                 etpact=0d0
                 xnacti=0d0
clin-5/2012:
c                 if(xnpf(ianp,iy).gt.1) then
                 if(xnpf(ianp,iy).gt.1d0) then
c     reconstruct the sum of v2p, v2p2, s2p, etp, and xnp for formed partons:
                    v2pact=v2pf(ianp,iy)*xnpf(ianp,iy)
                    v2p2ac=(v2pf2(ianp,iy)**2*(xnpf(ianp,iy)-1)
     1 +v2pf(ianp,iy)**2)*xnpf(ianp,iy)
                    s2pact=s2pf(ianp,iy)*xnpf(ianp,iy)
                    etpact=etpf(ianp,iy)*dble(nevt(ianp))
                    xnpact=xnpf(ianp,iy)
c
                    do 1019 kanp=1,ianp
                       v2pact=v2pact-v2pfrz(kanp,iy)
                       v2p2ac=v2p2ac-v2p2fz(kanp,iy)
                       s2pact=s2pact-s2pfrz(kanp,iy)
                       etpact=etpact-etpfrz(kanp,iy)
                       xnpact=xnpact-xnpfrz(kanp,iy)
 1019               continue
c     save the sum of v2p, v2p2, s2p, etp, and xnp for formed partons:
                    v2ph=v2pact
                    v2ph2=v2p2ac
                    s2ph=s2pact
                    etph=etpact
                    xnp2=xnpact/2d0
c
clin-5/2012:
c                    if(xnpact.gt.1.and.nevt(ianp).ne.0) then
                    if(xnpact.gt.1d0.and.nevt(ianp).ne.0) then
                       v2pact=v2pact/xnpact
                       v2p2ac=dsqrt((v2p2ac/xnpact
     1                    -v2pact**2)/(xnpact-1))
                       s2pact=s2pact/xnpact
                       xnacti=dble(xnpact/dble(nevt(ianp)))
                       etpact=etpact/dble(nevt(ianp))
                       write (nfile(iy)+2, 250) tsp(ianp),v2pact,
     1 v2p2ac,s2pact,etpact,xnacti,
     2 xnpf(ianp,iy)/dble(nevt(ianp)),nevt(ianp)
                    endif
                 endif
c     To calculate combined v2 for active partons plus formed hadrons, 
c     add the sum of v2h, v2h2, s2h, eth, and xnh for formed hadrons:
c     scale the hadron part in case nevt(ianp) != nevent:
                 shadr=dble(nevt(ianp))/dble(nevent)
                 ianh=ianp
                 v2ph=v2ph+v2h(ianh,iy)*xnhadr(ianh,iy)*shadr
                 v2ph2=v2ph2+(v2h2(ianh,iy)**2*(xnhadr(ianh,iy)-1)
     1 +v2h(ianh,iy)**2)*xnhadr(ianh,iy)*shadr
                 s2ph=s2ph+s2h(ianh,iy)*xnhadr(ianh,iy)*shadr
                 etph=etph+eth(ianh,iy)*dble(nevent)*shadr
                 xnph=xnpact+xnhadr(ianh,iy)*shadr
                 xnp2h=xnp2+xnhadr(ianh,iy)*shadr
clin-8/2015 to avoid IEEE_DIVIDE_BY_ZERO:
cclin-5/2012:
cc                 if(xnph.gt.1) then
c                 if(xnph.gt.1d0) then
                 if(xnph.gt.1d0.and.nevt(ianp).ne.0) then
                    v2ph=v2ph/xnph
                    v2ph2=dsqrt((v2ph2/xnph-v2ph**2)/(xnph-1))
                    s2ph=s2ph/xnph
                    etph=etph/dble(nevt(ianp))
                    xnp2=xnp2/dble(nevt(ianp))
                    xnp2h=xnp2h/dble(nevent)
clin-8/2015
c                    if(tsp(ianp).le.(ntmax*dt)) 
                    if(tsp(ianp).le.dble(ntmax*dt)) 
     1                    write (nfile(iy)+3, 250) tsp(ianp),v2ph,
     2 v2ph2,s2ph,etph,xnp2h,xnp2,nevt(ianp)
                 endif
c
 400              continue
 450       continue
           do 550 ianp=1,30
              do 500 iy=1,3
                 v2pact=0d0
                 v2p2ac=0d0
                 s2pact=0d0
                 etpact=0d0
                 xnacti=0d0
c     reconstruct the sum of v2p, v2p2, s2p, etp, and xnp for formed partons:
                    v2pact=v2pf(ianp,iy)*xnpf(ianp,iy)
                    v2p2ac=(v2pf2(ianp,iy)**2*(xnpf(ianp,iy)-1)
     1 +v2pf(ianp,iy)**2)*xnpf(ianp,iy)
                    s2pact=s2pf(ianp,iy)*xnpf(ianp,iy)
                    etpact=etpf(ianp,iy)*dble(nevt(ianp))
                    xnpact=xnpf(ianp,iy)
 500              continue
 550           continue
           close (620)
           close (630)
           do 1021 nf=1,3
              do 1020 ifile=0,3
                 close(nfile(nf)+ifile)
 1020        continue
 1021     continue
           do 1022 nf=1,3
              close(740+nf)
 1022      continue
        endif
 200        format(2x,f5.2,3(2x,f7.4),2(2x,f9.2),i6,2x,f9.2)
 210        format(2x,f5.2,3(2x,f7.4),3(2x,f9.2))
 240        format(a30,3(2x,f9.5))
 250        format(2x,f5.2,3(2x,f7.4),3(2x,f9.2),i6)
csp
 201        format(2x,f5.2,4(2x,f9.2))
 251        format(5e15.5)
c
        return
        end

c=======================================================================
c     Calculate flow from formed hadrons, called by art1e.f:
c     Note: numbers in art not in double precision!
        subroutine flowh(ct)
        PARAMETER (MAXSTR=150001, MAXR=1)
        dimension tsh(31)
        DOUBLE PRECISION  v2h,xnhadr,eth,v2h2,s2h
        DOUBLE PRECISION  v2hp,xnhadp,v2hsum,v2h2sm,v2hevt(3)
        DOUBLE PRECISION  pt2, v2hadr
        COMMON /hflow/ v2h(30,3),xnhadr(30,3),eth(30,3),
     1 v2h2(30,3),s2h(30,3)
cc      SAVE /hflow/
        common/ebe/v2hp(3),xnhadp(3),v2hsum(3),v2h2sm(3)
cc      SAVE /ebe/
        common /lastt/itimeh,bimp
cc      SAVE /lastt/
        COMMON /RUN/ NUM
cc      SAVE /RUN/
        COMMON  /AA/      R(3,MAXSTR)
cc      SAVE /AA/
        COMMON  /BB/      P(3,MAXSTR)
cc      SAVE /BB/
        COMMON  /CC/      E(MAXSTR)
cc      SAVE /CC/
        COMMON  /EE/      ID(MAXSTR),LB(MAXSTR)
cc      SAVE /EE/
        COMMON  /RR/      MASSR(0:MAXR)
cc      SAVE /RR/
        common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
        COMMON /AREVT/ IAEVT, IARUN, MISS
cc      SAVE /AREVT/
        SAVE   
c
        do 1001 ii = 1, 31
           tsh(ii)=float(ii-1)
 1001   continue
c
        do 1004 ianh = 1, 30
           if ((ct+0.0001).lt.tsh(ianh+1)
     1 .and.(ct+0.0001).ge.tsh(ianh)) then
              if(ianh.eq.itimeh) goto 101
              IA = 0
              DO 1002 J = 1, NUM
                 mult=MASSR(J)
                 IA = IA + MASSR(J - 1)
                 DO 100 IC = 1, mult
                    I = IA + IC
c     5/04/01 exclude leptons and photons:
                    if(iabs(LB(I)-10000).lt.100) goto 100
                    px=p(1,i)
                    py=p(2,i)
                    pt2=dble(px)**2+dble(py)**2
c     2/18/00 Note: e(i) gives the mass in ART:
                    ene=sqrt(e(i)**2+sngl(pt2)+p(3,i)**2)
                    RAP=0.5*alog((ene+p(3,i))/(ene-p(3,i)))
ctest off density with 2fm radius and z:(-0.1*t,0.1*t):
c                rt_now=sqrt(r(1,i)**2+r(2,i)**2)
c                gz_now=r(3,i)
c                zmax=0.1*ct
c                volume=3.1416*(2.**2)*2*zmax
c                if(rt_now.gt.2.or.abs(gz_now).gt.zmax)
c     1               goto 100
                    iloop=1
                    if(abs(rap).le.1) then
                       iloop=2
                       if(abs(rap).le.0.5) then
                          iloop=3
                       endif
                    endif
                    do 50 iy=1,iloop
                       if(pt2.gt.0d0) then
                          v2hadr=(dble(px)**2-dble(py)**2)/pt2
                          v2h(ianh,iy)=v2h(ianh,iy)+v2hadr
                          v2h2(ianh,iy)=v2h2(ianh,iy)+v2hadr**2
                          if(dabs(v2hadr).gt.1d0) 
     1 write(1,*) 'v2hadr>1',v2hadr,px,py
                       endif
                       xperp2=r(1,I)**2+r(2,I)**2
                       if(xperp2.gt.0.) 
     1 s2h(ianh,iy)=s2h(ianh,iy)+dble((r(1,I)**2-r(2,I)**2)/xperp2)
               eth(ianh,iy)=eth(ianh,iy)+dble(SQRT(e(i)**2+sngl(pt2)))
ctest off density:
c               eth(ianh,iy)=eth(ianh,iy)
c     1                  +dble(SQRT(e(i)**2+sngl(pt2)+p(3,i)**2))/volume
                       xnhadr(ianh,iy)=xnhadr(ianh,iy)+1d0
 50                    continue
 100                 continue
 1002         CONTINUE
              itimeh=ianh
clin-5/04/01 ebe v2 variables:
              if(ianh.eq.30) then
                 do 1003 iy=1,3
                    nhadrn=IDINT(xnhadr(ianh,iy)-xnhadp(iy))
                    if(nhadrn.ne.0) then
               v2hevt(iy)=(v2h(ianh,iy)-v2hp(iy))/dble(nhadrn)
                       v2hsum(iy)=v2hsum(iy)+v2hevt(iy)
                       v2h2sm(iy)=v2h2sm(iy)+v2hevt(iy)**2
                       v2hp(iy)=v2h(ianh,iy)
                       xnhadp(iy)=xnhadr(ianh,iy)
                    endif
 1003            continue
                 write(88, 160) iaevt,v2hevt
              endif
              goto 101
           endif
 1004   continue
 160    format(i10,3(2x,f9.5))
clin-8/2015:
clin-11/27/00 for animation:
ctest off     turn off animation output (0 to turn off and 1 to turn on):
 101    ifanim=0
        if(ifanim.eq.1) then
           IA = 0
           do 1005 J = 1, NUM
              mult=MASSR(J)
              IA = IA + MASSR(J - 1)
              write(10,*) ct
              write(10,*) mult
              DO 150 IC = 1, mult
                 I = IA + IC
clin-6/2013 for animation:                                                                  
                 if(amax1(abs(r(1,i)),abs(r(2,i)),
     1                abs(r(3,i))).lt.9999) then
                    write(10,210) LB(i),r(1,i),r(2,i),r(3,i),
     1                   p(1,i),p(2,i),p(3,i),e(i)
                 else
                    write(10,220) LB(i),r(1,i),r(2,i),r(3,i),
     1                   p(1,i),p(2,i),p(3,i),e(i)
                 endif
 150          continue
 1005      continue
           return
        endif
 210    format(i6,7(1x,f9.3))
 220    format(i6,3(1x,e9.3),4(1x,f9.3))
        return
        end

c=======================================================================
        subroutine flowh0(NEVNT,idd)
c
        dimension tsh(31)
        DOUBLE PRECISION  v2h,xnhadr,eth,v2h2,s2h
        DOUBLE PRECISION  v2hp,xnhadp,v2hsum,v2h2sm,
     1 v2havg(3),varv2h(3)
        COMMON /hflow/ v2h(30,3),xnhadr(30,3),eth(30,3),
     1 v2h2(30,3),s2h(30,3)
cc      SAVE /hflow/
        common/ebe/v2hp(3),xnhadp(3),v2hsum(3),v2h2sm(3)
cc      SAVE /ebe/
        common/input1/ MASSPR,MASSTA,ISEED,IAVOID,DT
cc      SAVE /input1/
        COMMON /INPUT2/ ILAB, MANYB, NTMAX, ICOLL, INSYS, IPOT, MODE, 
     &   IMOMEN, NFREQ, ICFLOW, ICRHO, ICOU, KPOTEN, KMUL
cc      SAVE /INPUT2/
        common /lastt/itimeh,bimp
cc      SAVE /lastt/
        SAVE   
      
c     idd=0: initialization for flow analysis, called by artdri.f::
        if(idd.eq.0) then
           itimeh=0
c
           do 1001 ii = 1, 31
              tsh(ii)=float(ii-1)
 1001      continue
c
           do 1003 ii=1,30
              do 1002 iy=1,3
                 v2h(ii,iy)=0d0
                 xnhadr(ii,iy)=0d0
                 eth(ii,iy)=0d0
                 v2h2(ii,iy)=0d0
                 s2h(ii,iy)=0d0
 1002         continue
 1003      continue
           do 1004 iy=1,3
              v2hp(iy)=0d0
              xnhadp(iy)=0d0
              v2hsum(iy)=0d0
              v2h2sm(iy)=0d0
            if(iy.eq.1) then
               nunit=59
            elseif(iy.eq.2) then
               nunit=68
            else
               nunit=69
            endif
              write(nunit,*) '   tsh,   v2h,     v2h2,     s2h, '//
     1 ' eth,   xmulth'
 1004      continue
c     idd=2: calculate average hadronic elliptic flow, called by artdri.f:
        else if(idd.eq.2) then
           do 100 ii=1, 30
              do 1005 iy=1,3
                 if(xnhadr(ii,iy).eq.0) then
                    xmulth=0.
                 elseif(xnhadr(ii,iy).gt.1) then
                    v2h(ii,iy)=v2h(ii,iy)/xnhadr(ii,iy)
                    eth(ii,iy)=eth(ii,iy)/dble(NEVNT)
                    v2h2(ii,iy)=dsqrt((v2h2(ii,iy)/xnhadr(ii,iy)
     1                    -v2h(ii,iy)**2)/(xnhadr(ii,iy)-1))
                    s2h(ii,iy)=s2h(ii,iy)/xnhadr(ii,iy)
                    xmulth=sngl(xnhadr(ii,iy)/NEVNT)
                 endif
             if(iy.eq.1) then
                nunit=59
             elseif(iy.eq.2) then
                nunit=68
             else
                nunit=69
             endif
                 if(tsh(ii).le.(ntmax*dt)) 
     1                    write (nunit,200) tsh(ii),v2h(ii,iy),
     2      v2h2(ii,iy),s2h(ii,iy),eth(ii,iy),xmulth
 1005         continue
 100           continue
c     event-by-event average & variance of v2h:
           do 1006 iy=1,3
              v2havg(iy)=v2hsum(iy)/dble(NEVNT)
      varv2h(iy)=dsqrt(v2h2sm(iy)/dble(NEVNT)-v2havg(iy)**2)
 1006 continue
           write(88, 240) 'EBE v2h,v2h(y2),v2h(y1): avg=', v2havg
           write(88, 240) 'EBE v2h,v2h(y2),v2h(y1): var=', varv2h
        endif
 200        format(2x,f5.2,3(2x,f7.4),2(2x,f9.2))
 240        format(a30,3(2x,f9.5))
        return
        end

c=======================================================================
c     2/23/00 flow from all initial hadrons just before entering ARTMN:
        subroutine iniflw(NEVNT,idd)
        PARAMETER (MAXSTR=150001, MAXR=1)
        DOUBLE PRECISION  v2i,eti,xmulti,v2mi,s2mi,xmmult,
     1       v2bi,s2bi,xbmult
        COMMON /RUN/ NUM
cc      SAVE /RUN/
        COMMON /ARERC1/MULTI1(MAXR)
cc      SAVE /ARERC1/
        COMMON /ARPRC1/ITYP1(MAXSTR, MAXR),
     &     GX1(MAXSTR, MAXR), GY1(MAXSTR, MAXR), GZ1(MAXSTR, MAXR), 
     &     FT1(MAXSTR, MAXR),
     &     PX1(MAXSTR, MAXR), PY1(MAXSTR, MAXR), PZ1(MAXSTR, MAXR),
     &     EE1(MAXSTR, MAXR), XM1(MAXSTR, MAXR)
cc      SAVE /ARPRC1/
        COMMON/iflow/v2i,eti,xmulti,v2mi,s2mi,xmmult,v2bi,s2bi,xbmult
cc      SAVE /iflow/
        SAVE   
c        
        if(idd.eq.0) then
           v2i=0d0
           eti=0d0
           xmulti=0d0
           v2mi=0d0
           s2mi=0d0
           xmmult=0d0
           v2bi=0d0
           s2bi=0d0
           xbmult=0d0
        else if(idd.eq.1) then
           do 1002 J = 1, NUM
              do 1001 I = 1, MULTI1(J)
                 ITYP = ITYP1(I, J)
c     all hadrons:
                 IF (ITYP .GT. -100 .AND. ITYP .LT. 100) GOTO 100
                 xmulti=xmulti+1.d0
                 PX = PX1(I, J)
                 PY = PY1(I, J)
                 XM = XM1(I, J)
                 pt2=px**2+py**2
                 xh=gx1(I,J)
                 yh=gy1(I,J)
                 xt2=xh**2+yh**2
                 if(pt2.gt.0) v2i=v2i+dble((px**2-py**2)/pt2)
                 eti=eti+dble(SQRT(PX ** 2 + PY ** 2 + XM ** 2))
c     baryons only:
                 IF (ITYP .LT. -1000 .or. ITYP .GT. 1000) then
                    xbmult=xbmult+1.d0
                    if(pt2.gt.0) v2bi=v2bi+dble((px**2-py**2)/pt2)
                    if(xt2.gt.0) s2bi=s2bi+dble((xh**2-yh**2)/xt2)
c     mesons only:
                 else
                    xmmult=xmmult+1.d0
                    if(pt2.gt.0) v2mi=v2mi+dble((px**2-py**2)/pt2)
                    if(xt2.gt.0) s2mi=s2mi+dble((xh**2-yh**2)/xt2)
                 endif
 100                 continue
 1001         continue
 1002      continue
        else if(idd.eq.2) then
           if(xmulti.ne.0) v2i=v2i/xmulti
           eti=eti/dble(NEVNT)
           xmulti=xmulti/dble(NEVNT)
           if(xmmult.ne.0) then
              v2mi=v2mi/xmmult
              s2mi=s2mi/xmmult
           endif
           xmmult=xmmult/dble(NEVNT)
           if(xbmult.ne.0) then
              v2bi=v2bi/xbmult
              s2bi=s2bi/xbmult
           endif
           xbmult=xbmult/dble(NEVNT)
        endif
c
        return
        end

c=======================================================================
c     2/25/00 dN/dt analysis for production (before ZPCMN)  
c     and freezeout (right after ZPCMN) for all partons.
        subroutine frztm(NEVNT,idd)
c
        implicit double precision  (a-h, o-z)
        PARAMETER (MAXPTN=400001)
        dimension tsf(31)
        COMMON /PARA1/ MUL
cc      SAVE /PARA1/
        COMMON /prec1/GX0(MAXPTN),GY0(MAXPTN),GZ0(MAXPTN),FT0(MAXPTN),
     &       PX0(MAXPTN), PY0(MAXPTN), PZ0(MAXPTN), E0(MAXPTN),
     &       XMASS0(MAXPTN), ITYP0(MAXPTN)
cc      SAVE /prec1/
        COMMON /prec2/GX5(MAXPTN),GY5(MAXPTN),GZ5(MAXPTN),FT5(MAXPTN),
     &       PX5(MAXPTN), PY5(MAXPTN), PZ5(MAXPTN), E5(MAXPTN),
     &       XMASS5(MAXPTN), ITYP5(MAXPTN)
cc      SAVE /prec2/
        COMMON /frzout/ xnprod(30),etprod(30),xnfrz(30),etfrz(30),
     & dnprod(30),detpro(30),dnfrz(30),detfrz(30)
cc      SAVE /frzout/ 
        SAVE   
        data tsf/0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 
     &       1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 
     &       2  , 3,   4,   5,   6,   7,   8,   9,   10,  20,  30/
c
        if(idd.eq.0) then
           do 1001 ii=1,30
              xnprod(ii)=0d0
              etprod(ii)=0d0
              xnfrz(ii)=0d0
              etfrz(ii)=0d0
              dnprod(ii)=0d0
              detpro(ii)=0d0
              dnfrz(ii)=0d0
              detfrz(ii)=0d0
 1001      continue
           OPEN (86, FILE = 'ana1/production.dat', STATUS = 'UNKNOWN')
           OPEN (87, FILE = 'ana1/freezeout.dat', STATUS = 'UNKNOWN')
        else if(idd.eq.1) then
           DO 100 ip = 1, MUL
              do 1002 ii=1,30
                 eth0=dSQRT(PX0(ip)**2+PY0(ip)**2+XMASS0(ip)**2)
                 eth2=dSQRT(PX5(ip)**2+PY5(ip)**2+XMASS5(ip)**2)
c     total number and Et produced by time tsf(ii):
                 if (ft0(ip).lt.tsf(ii+1)) then
                    xnprod(ii)=xnprod(ii)+1d0
                    etprod(ii)=etprod(ii)+eth0
c     number and Et produced from time tsf(ii) to tsf(ii+1):
                    if (ft0(ip).ge.tsf(ii)) then
                       dnprod(ii)=dnprod(ii)+1d0
                       detpro(ii)=detpro(ii)+eth0
                    endif
                 endif
c     total number and Et freezed out by time tsf(ii):
                 if (FT5(ip).lt.tsf(ii+1)) then
                    xnfrz(ii)=xnfrz(ii)+1d0
                    etfrz(ii)=etfrz(ii)+eth2
c     number and Et freezed out from time tsf(ii) to tsf(ii+1):
                    if (FT5(ip).ge.tsf(ii)) then
                       dnfrz(ii)=dnfrz(ii)+1d0
                       detfrz(ii)=detfrz(ii)+eth2
                    endif
                 endif
 1002         continue
 100           continue
        else if(idd.eq.2) then
           write (86,*) '       t,       np,       dnp/dt,      etp '//
     1 ' detp/dt'
           write (87,*) '       t,       nf,       dnf/dt,      etf '//
     1 ' detf/dt'
           do 1003 ii=1,30
              xnp=xnprod(ii)/dble(NEVNT)
              xnf=xnfrz(ii)/dble(NEVNT)
              etp=etprod(ii)/dble(NEVNT)
              etf=etfrz(ii)/dble(NEVNT)
              dxnp=dnprod(ii)/dble(NEVNT)/(tsf(ii+1)-tsf(ii))
              dxnf=dnfrz(ii)/dble(NEVNT)/(tsf(ii+1)-tsf(ii))
              detp=detpro(ii)/dble(NEVNT)/(tsf(ii+1)-tsf(ii))
              detf=detfrz(ii)/dble(NEVNT)/(tsf(ii+1)-tsf(ii))
              write (86, 200) 
     1        tsf(ii+1),xnp,dxnp,etp,detp
              write (87, 200) 
     1        tsf(ii+1),xnf,dxnf,etf,detf
 1003      continue
        endif
 200    format(2x,f9.2,4(2x,f10.2))
c
        return
        end

c=======================================================================
clin-6/2009 write out initial minijet information 
c     before propagating to its formation time:
clin-2/2012:
c        subroutine minijet_out(BB)
        subroutine minijet_out(BB,phiRP)
        PARAMETER (MAXSTR=150001)
        COMMON/HPARNT/HIPR1(100),IHPR2(50),HINT1(100),IHNT2(50)
        COMMON/hjcrdn/YP(3,300),YT(3,300)
        COMMON/HJJET1/NPJ(300),KFPJ(300,500),PJPX(300,500),
     &                PJPY(300,500),PJPZ(300,500),PJPE(300,500),
     &                PJPM(300,500),NTJ(300),KFTJ(300,500),
     &                PJTX(300,500),PJTY(300,500),PJTZ(300,500),
     &                PJTE(300,500),PJTM(300,500)
        COMMON/HJJET2/NSG,NJSG(MAXSTR),IASG(MAXSTR,3),K1SG(MAXSTR,100),
     &       K2SG(MAXSTR,100),PXSG(MAXSTR,100),PYSG(MAXSTR,100),
     &       PZSG(MAXSTR,100),PESG(MAXSTR,100),PMSG(MAXSTR,100)
        COMMON /AREVT/ IAEVT, IARUN, MISS
        common /para7/ ioscar,nsmbbbar,nsmmeson
        common/phidcy/iphidcy,pttrig,ntrig,maxmiss,ipi0dcy
        SAVE
        ntrig=0
        do I = 1, IHNT2(1)
           do J = 1, NPJ(I)
              pt=sqrt(PJPX(I,J)**2+PJPY(I,J)**2)
              if(pt.ge.pttrig) ntrig=ntrig+1
           enddo
        enddo
        do I = 1, IHNT2(3)
           do J = 1, NTJ(I)
              pt=sqrt(PJTX(I,J)**2+PJTY(I,J)**2)
              if(pt.ge.pttrig) ntrig=ntrig+1
           enddo
        enddo
        do I = 1, NSG
           do J = 1, NJSG(I)
              pt=sqrt(PXSG(I,J)**2+PYSG(I,J)**2)
              if(pt.ge.pttrig) ntrig=ntrig+1
           enddo
        enddo
c     Require at least 1 initial minijet parton above the trigger Pt value:
        if(ntrig.eq.0) return

c.....transfer data from HIJING to ZPC
        if(ioscar.eq.3) write(96,*) IAEVT,MISS,IHNT2(1),IHNT2(3)
        DO 1008 I = 1, IHNT2(1)
           DO 1007 J = 1, NPJ(I)
              ityp=KFPJ(I,J)
c     write out not only gluons:
c              if(ityp.ne.21) goto 1007
clin-2/2012:
c              gx=YP(1,I)+0.5*BB
c              gy=YP(2,I)
              gx=YP(1,I)+0.5*BB*cos(phiRP)
              gy=YP(2,I)+0.5*BB*sin(phiRP)
              gz=0.
              ft=0.
              px=PJPX(I,J)
              py=PJPY(I,J)
              pz=PJPZ(I,J)
              xmass=PJPM(I,J)
              if(ioscar.eq.3) then
                 if(amax1(abs(gx),abs(gy),
     1                abs(gz),abs(ft)).lt.9999) then
                    write(96,200) ityp,px,py,pz,xmass,gx,gy,gz,ft,1
                 else
                    write(96,201) ityp,px,py,pz,xmass,gx,gy,gz,ft,1
                 endif
              endif
 1007      CONTINUE
 1008   CONTINUE
        DO 1010 I = 1, IHNT2(3)
           DO 1009 J = 1, NTJ(I)
              ityp=KFTJ(I,J)
c              if(ityp.ne.21) goto 1009
clin-2/2012:
c              gx=YT(1,I)-0.5*BB
c              gy=YT(2,I)
              gx=YT(1,I)-0.5*BB*cos(phiRP)
              gy=YT(2,I)-0.5*BB*sin(phiRP)
              gz=0.
              ft=0.
              px=PJTX(I,J)
              py=PJTY(I,J)
              pz=PJTZ(I,J)
              xmass=PJTM(I,J)
              if(ioscar.eq.3) then
                 if(amax1(abs(gx),abs(gy),
     1                abs(gz),abs(ft)).lt.9999) then
                    write(96,200) ityp,px,py,pz,xmass,gx,gy,gz,ft,2
                 else
                    write(96,201) ityp,px,py,pz,xmass,gx,gy,gz,ft,2
                 endif
              endif
 1009      CONTINUE
 1010   CONTINUE
        DO 1012 I = 1, NSG
           DO 1011 J = 1, NJSG(I)
              ityp=K2SG(I,J)
c              if(ityp.ne.21) goto 1011
              gx=0.5*(YP(1,IASG(I,1))+YT(1,IASG(I,2)))
              gy=0.5*(YP(2,IASG(I,1))+YT(2,IASG(I,2)))
              gz=0.
              ft=0.
              px=PXSG(I,J)
              py=PYSG(I,J)
              pz=PZSG(I,J)
              xmass=PMSG(I,J)
              if(ioscar.eq.3) then
                 if(amax1(abs(gx),abs(gy),
     1                abs(gz),abs(ft)).lt.9999) then
                    write(96,200) ityp,px,py,pz,xmass,gx,gy,gz,ft,3
                 else
                    write(96,201) ityp,px,py,pz,xmass,gx,gy,gz,ft,3
                 endif
              endif
 1011      CONTINUE
 1012   CONTINUE
 200  format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,2(1x,f8.2),2(2x,f2.0),2x,I2)
 201  format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,2(1x,e8.2),2(2x,f2.0),2x,I2)
c
        return
        end

c=======================================================================
clin-6/2009 embed back-to-back high-Pt quark/antiquark pair
c     via embedding back-to-back high-Pt pion pair then melting the pion pair
c     by generating the internal quark and antiquark momentum parallel to 
c      the pion momentum (in order to produce a high-Pt and a low Pt parton):
      subroutine embedHighPt
      PARAMETER (MAXSTR=150001,MAXR=1,pichmass=0.140,pi0mass=0.135,
     1     pi=3.1415926,nxymax=10001)
      common/embed/iembed,nsembd,pxqembd,pyqembd,xembd,yembd,
     1     psembd,tmaxembd,phidecomp
      COMMON/RNDF77/NSEED
      COMMON/HMAIN1/EATT,JATT,NATT,NT,NP,N0,N01,N10,N11
      COMMON/HMAIN2/KATT(MAXSTR,4),PATT(MAXSTR,4)
      COMMON /ARPRC/ ITYPAR(MAXSTR),
     &     GXAR(MAXSTR), GYAR(MAXSTR), GZAR(MAXSTR), FTAR(MAXSTR),
     &     PXAR(MAXSTR), PYAR(MAXSTR), PZAR(MAXSTR), PEAR(MAXSTR),
     &     XMAR(MAXSTR)
      common/anim/nevent,isoft,isflag,izpc
      COMMON /AREVT/ IAEVT, IARUN, MISS
      common/xyembed/nxyjet,xyjet(nxymax,2)
      SAVE
c
      if(iembed.eq.1.or.iembed.eq.2) then
         xjet=xembd
         yjet=yembd
      elseif(iembed.eq.3.or.iembed.eq.4) then
         if(nevent.le.nxyjet) then
            read(97,*) xjet,yjet
         else
            ixy=mod(IAEVT,nxyjet)
            if(ixy.eq.0) ixy=nxyjet
            xjet=xyjet(ixy,1)
            yjet=xyjet(ixy,2)
         endif
      else
         return
      endif
c
      ptq=sqrt(pxqembd**2+pyqembd**2)
      if(ptq.lt.(pichmass/2.)) then
         print *, 'Embedded quark transverse momentum is too small'
         stop
      endif
c     Randomly embed u/ubar or d/dbar at high Pt:
      idqembd=1+int(2*RANART(NSEED))
c     Flavor content for the charged pion that contains the leading quark:
      if(idqembd.eq.1) then 
         idqsoft=-2
         idpi1=-211
      elseif(idqembd.eq.2) then 
         idqsoft=-1
         idpi1=211
      else
         print *, 'Wrong quark flavor embedded'
         stop
      endif
c     Caculate transverse momentum of the parent charged pion:
      xmq=ulmass(idqembd)
      xmqsoft=ulmass(idqsoft)
      ptpi=((pichmass**2+xmq**2-xmqsoft**2)*ptq
     1     -sqrt((xmq**2+ptq**2)*(pichmass**4
     2     -2.*pichmass**2*(xmq**2+xmqsoft**2)+(xmq**2-xmqsoft**2)**2)))
     3     /(2.*xmq**2)
      if(iembed.eq.1.or.iembed.eq.3) then
         pxpi1=ptpi*pxqembd/ptq
         pypi1=ptpi*pyqembd/ptq
         phidecomp=acos(pxqembd/ptq)
         if(pyqembd.lt.0) phidecomp=2.*pi-phidecomp
      else
         phidecomp=2.*pi*RANART(NSEED)
         pxpi1=ptpi*cos(phidecomp)
         pypi1=ptpi*sin(phidecomp)
      endif
c     Embedded quark/antiquark are assumed to have pz=0:
      pzpi1=0.
c     Insert the two parent charged pions, 
c     ipion=1 for the pion containing the leading quark, 
c     ipion=2 for the pion containing the leading antiquark of the same flavor:
      do ipion=1,2
         if(ipion.eq.1) then
            idpi=idpi1
            pxpi=pxpi1
            pypi=pypi1
            pzpi=pzpi1
         elseif(ipion.eq.2) then
            idpi=-idpi1
            pxpi=-pxpi1
            pypi=-pypi1
            pzpi=-pzpi1
         endif
         NATT=NATT+1
         KATT(NATT,1)=idpi
         KATT(NATT,2)=40
         KATT(NATT,3)=0
         PATT(NATT,1)=pxpi
         PATT(NATT,2)=pypi
         PATT(NATT,3)=pzpi
         PATT(NATT,4)=sqrt(pxpi**2+pypi**2+pzpi**2+pichmass**2)
         EATT=EATT+PATT(NATT,4)
         GXAR(NATT)=xjet
         GYAR(NATT)=yjet
         GZAR(NATT)=0.
         FTAR(NATT)=0.
         ITYPAR(NATT)=KATT(NATT,1) 
         PXAR(NATT)=PATT(NATT,1)
         PYAR(NATT)=PATT(NATT,2)
         PZAR(NATT)=PATT(NATT,3)
         PEAR(NATT)=PATT(NATT,4)
         XMAR(NATT)=pichmass
      enddo
c
clin-8/2009
c     Randomly embed a number of soft pions around each high-Pt quark in pair:
      if(nsembd.gt.0) then
         do ipion=1,2
            do ispion=1,nsembd
               idsart=3+int(3*RANART(NSEED))
               if(idsart.eq.3) then 
                  pimass=pichmass
                  idpis=-211
               elseif(idsart.eq.4) then 
                  pimass=pi0mass
                  idpis=111
               else
                  pimass=pichmass
                  idpis=211
               endif
               NATT=NATT+1
               KATT(NATT,1)=idpis
               KATT(NATT,2)=40
               KATT(NATT,3)=0
c     theta: relative angle between soft pion & associated high-Pt q or qbar,
c     generate theta and phi uniformly:
c     Note: it is not generated uniformly in solid angle because that gives 
c     a valley at theta=0, unlike the jet-like correlation (a peak at theta=0).
               theta=tmaxembd*RANART(NSEED)
               phi=2.*pi*RANART(NSEED)
               pxspi=psembd*sin(theta)*cos(phi)
               pyspi=psembd*sin(theta)*sin(phi)
               pzspi=psembd*cos(theta)
               if(ipion.eq.1) then
                  call rotate(pxpi1,pypi1,pzpi1,pxspi,pyspi,pzspi)
               else
                  call rotate(-pxpi1,-pypi1,-pzpi1,pxspi,pyspi,pzspi)
               endif
ctest off
c               write(99,*) "2  ",pxspi,pyspi,pzspi
               PATT(NATT,1)=pxspi
               PATT(NATT,2)=pyspi
               PATT(NATT,3)=pzspi
               PATT(NATT,4)=sqrt(psembd**2+pimass**2)
               EATT=EATT+PATT(NATT,4)
               GXAR(NATT)=xjet
               GYAR(NATT)=yjet
               GZAR(NATT)=0.
               FTAR(NATT)=0.
               ITYPAR(NATT)=KATT(NATT,1) 
               PXAR(NATT)=PATT(NATT,1)
               PYAR(NATT)=PATT(NATT,2)
               PZAR(NATT)=PATT(NATT,3)
               PEAR(NATT)=PATT(NATT,4)
               XMAR(NATT)=pimass
            enddo
         enddo
      endif
clin-8/2009-end
c
      return
      end
c.................... zpc.f
c	PROGRAM ZPC
      SUBROUTINE ZPCMN
c       Version: 1.0.1
c       Author: Bin Zhang 
c       (suggestions, problems -> bzhang@nt1.phys.columbia.edu)
        implicit double precision (a-h, o-z)
clin-4/20/01        PARAMETER (NMAXGL = 16000)
        parameter (MAXPTN=400001)
        common /para3/ nsevt, nevnt, nsbrun, ievt, isbrun
cc      SAVE /para3/
        SAVE   
c
c       loop over events
        do 1000 i = 1, nevnt
           ievt = i
c       generation of the initial condition for one event
           call inievt
c      loop over many runs of the same event
           do 2000 j = 1, nsbrun
              isbrun = j
c       initialization for one run of an event
              call inirun
clin-4/2008 not used:
c             CALL HJAN1A
 3000         continue
c       do one collision
              call zpcrun(*4000)
              call zpca1
              goto 3000
 4000         continue
              call zpca2
 2000      continue
 1000   continue
        call zpcou
clin-5/2009 ctest off
c     5/17/01 calculate v2 for parton already frozen out:
c        call flowp(3)
c.....to get average values for different strings
        CALL zpstrg
        RETURN
        end

******************************************************************************
******************************************************************************

        block data zpcbdt
c       set initial values in block data

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        PARAMETER (MAXSTR=150001)
        common /para1/ mul
cc      SAVE /para1/
        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para3/ nsevt, nevnt, nsbrun, ievt, isbrun
cc      SAVE /para3/
        common /para4/ iftflg, ireflg, igeflg, ibstfg
cc      SAVE /para4/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /para6/ centy
cc      SAVE /para6/
clin-6/2009 nsmbbbar and nsmmeson respectively give the total number of 
c     baryons/anti-baryons and mesons for each event:
c        common /para7/ ioscar
        common /para7/ ioscar,nsmbbbar,nsmmeson
cc      SAVE /para7/
        COMMON /prec1/GX0(MAXPTN),GY0(MAXPTN),GZ0(MAXPTN),FT0(MAXPTN),
     &       PX0(MAXPTN), PY0(MAXPTN), PZ0(MAXPTN), E0(MAXPTN),
     &       XMASS0(MAXPTN), ITYP0(MAXPTN)
cc      SAVE /prec1/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec3/gxs(MAXPTN),gys(MAXPTN),gzs(MAXPTN),fts(MAXPTN),
     &     pxs(MAXPTN), pys(MAXPTN), pzs(MAXPTN), es(MAXPTN),
     &     xmasss(MAXPTN), ityps(MAXPTN)
cc      SAVE /prec3/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /prec5/ eta(MAXPTN), rap(MAXPTN), tau(MAXPTN)
cc      SAVE /prec5/
        common /prec6/ etas(MAXPTN), raps(MAXPTN), taus(MAXPTN)
cc      SAVE /prec6/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist2/ icell, icel(10,10,10)
cc      SAVE /ilist2/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
c     6/07/02 initialize in ftime to expedite compiling:
c        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        common /ilist6/ t, iopern, icolln
cc      SAVE /ilist6/
        COMMON /ilist7/ LSTRG0(MAXPTN), LPART0(MAXPTN)
cc      SAVE /ilist7/
        COMMON /ilist8/ LSTRG1(MAXPTN), LPART1(MAXPTN)
cc      SAVE /ilist8/
        common /rndm1/ number
cc      SAVE /rndm1/
        common /rndm2/ iff
cc      SAVE /rndm2/
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        common /ana1/ ts(12)
cc      SAVE /ana1/
        common /ana2/
     &     det(12), dn(12), detdy(12), detdn(12), dndy(12),
     &     det1(12), dn1(12), detdy1(12), detdn1(12), dndy1(12),
     &     det2(12), dn2(12), detdy2(12), detdn2(12), dndy2(12)
cc      SAVE /ana2/
        common /ana3/ em(4, 4, 12)
cc      SAVE /ana3/
        common /ana4/ fdetdy(24), fdndy(24), fdndpt(12)
cc      SAVE /ana4/
        SAVE   
        data centy/0d0/
c     6/07/02 initialize in ftime to expedite compiling:
c        data (ct(i), i = 1, MAXPTN)/MAXPTN*0d0/
c        data (ot(i), i = 1, MAXPTN)/MAXPTN*0d0/
c        data tlarge/1000000.d0/
        data number/0/
        data ts/0.11d0, 0.12d0, 0.15d0, 0.2d0, 0.3d0, 0.4d0, 0.6d0,
     &     0.8d0, 1d0, 2d0, 4d0, 6d0/
c
        end

******************************************************************************
******************************************************************************

        subroutine inizpc

        implicit double precision (a-h, o-z)
        SAVE   

        call readpa

        call inipar

        call inian1

        return
        end

        subroutine readpa

        implicit double precision (a-h, o-z)

        external ran1

        character*50 str

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para3/ nsevt, nevnt, nsbrun, ievt, isbrun
cc      SAVE /para3/
        common /para4/ iftflg, ireflg, igeflg, ibstfg
cc      SAVE /para4/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /para7/ ioscar,nsmbbbar,nsmmeson
cc      SAVE /para7/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /rndm1/ number
cc      SAVE /rndm1/
        common /rndm2/ iff
cc      SAVE /rndm2/
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        SAVE   

        iseed=iseedp
c       this is the initialization file containing the initial values of 
c          the parameters
cbz1/31/99
c        open (5, file = 'zpc.ini', status = 'unknown')
cbz1/31/99end

c       this is the final data file containing general info about the cascade
cbz1/31/99
c        open (6, file = 'zpc.res', status = 'unknown')
        open (25, file = 'ana/zpc.res', status = 'unknown')
cbz1/31/99end

c       this is the input file containing initial particle records
cbz1/25/99
c        open (7, file = 'zpc.inp', status = 'unknown')
cbz1/25/99end

c       this gives the optional OSCAR standard output
cbz1/31/99
c        open (8, file = 'zpc.oscar', status = 'unknown')
        if(ioscar.eq.1) then
           open (26, file = 'ana/parton.oscar', status = 'unknown')
           open (19, file = 'ana/hadron.oscar', status = 'unknown')
        endif
cbz1/31/99end

c     2/11/03 combine zpc initialization into ampt.ini:
c        open (29, file = 'zpc.ini', status = 'unknown')
c        read (29, *) str, xmp
        xmp=0d0
c        read (29, *) str, xmu
c        read (29, *) str, alpha
        cutof2 = 4.5d0 * (alpha / xmu) ** 2
c        read (29, *) str, rscut2
        rscut2=0.01d0
c        read (29, *) str, nsevt
        nsevt=1
c        read (29, *) str, nevnt
        nevnt=1
c        read (29, *) str, nsbrun
        nsbrun=1
c        read (29, *) str, iftflg
        iftflg=0
c        read (29, *) str, ireflg
        ireflg=1
cbz1/31/99
        IF (ireflg .EQ. 0) THEN
           OPEN (27, FILE = 'zpc.inp', STATUS = 'UNKNOWN')
        END IF
cbz1/31/99end
c        read (29, *) str, igeflg
        igeflg=0
c        read (29, *) str, ibstfg
        ibstfg=0
c        read (29, *) str, iconfg
        iconfg=1
c        read (29, *) str, iordsc
        iordsc=11
c        read (29, *) str, ioscar
c        read (29, *) str, v1, v2, v3
        v1=0.2d0
        v2=0.2d0
        v3=0.2d0
c        read (29, *) str, size1, size2, size3
        size1=1.5d0
        size2=1.5d0
        size3=0.7d0
        if (size1 .eq. 0d0 .or. size2 .eq. 0d0 .or. 
     &     size3 .eq. 0d0) then
           if (size1 .ne. 0d0 .or. size2 .ne. 0d0 .or. size3 .ne. 0d0
     &        .or. v1 .ne. 0d0 .or. v2 .ne. 0d0 .or. v3 .ne. 0d0) then
              print *, 'to get rid of space division:'
              print *, 'set all sizes and vs to 0'
              stop 'chker'
           end if
        end if
        size = min(size1, size2, size3)
c        read (29, *) str, iff
        iff=-1
c        read (29, *) str, iseed

c     10/24/02 get rid of argument usage mismatch in ran1():
        isedng=-iseed
c        a = ran1(-iseed)
        a = ran1(isedng)
c        read (29, *) str, irused
        irused=2
        do 1001 i = 1, irused - 1
c           a = ran1(2)
           iseed2=2
           a = ran1(iseed2)
 1001   continue
c     10/24/02-end

        if (iconfg .eq. 2 .or. iconfg .eq. 3) then
           v1 = 0d0
           v2 = 0d0
        end if

        if (iconfg .eq. 4 .or. iconfg .eq. 5) then
           v1 = 0d0
           v2 = 0d0
           v3 = 0d0
        end if

        close(5)

        return
        end

        subroutine inipar

        implicit double precision (a-h,o-z)

        common /para4/ iftflg, ireflg, igeflg, ibstfg
cc      SAVE /para4/
        common /para6/ centy
cc      SAVE /para6/
        SAVE   

        if (ibstfg .ne. 0) then
           centy = -6d0
        end if

        return
        end

        subroutine inian1

        implicit double precision (a-h,o-z)

        common /para4/ iftflg, ireflg, igeflg, ibstfg
cc      SAVE /para4/
        common /ana1/ ts(12)
cc      SAVE /ana1/   
        SAVE   
        if (ibstfg .ne. 0) then
           a = cosh(6d0)
           do 1001 i = 1, 12
              ts(i) = ts(i) * a
 1001      continue
        end if

        return
        end

******************************************************************************

        subroutine inievt

        implicit double precision (a-h, o-z)

        COMMON /para1/ mul
cc      SAVE /para1/
        common /para4/ iftflg, ireflg, igeflg, ibstfg
cc      SAVE /para4/
        SAVE   

cbz1/25/99
c        mul = 0
cbz1/25/99
        if (ireflg .eq. 0) call readi
        if (igeflg .ne. 0) call genei
        if (ibstfg .ne. 0) call boosti

        return
        end

        subroutine readi

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        double precision field(9)
        common /para1/ mul
cc      SAVE /para1/
        common /para3/ nsevt, nevnt, nsbrun, ievt, isbrun
cc      SAVE /para3/
        COMMON /prec1/GX0(MAXPTN),GY0(MAXPTN),GZ0(MAXPTN),FT0(MAXPTN),
     &       PX0(MAXPTN), PY0(MAXPTN), PZ0(MAXPTN), E0(MAXPTN),
     &       XMASS0(MAXPTN), ITYP0(MAXPTN)
cc      SAVE /prec1/
        SAVE   
        do 1001 i = 1, MAXPTN
           if (ievt .ne. 1 .and. i .eq. 1) then
              ityp0(i) = ntyp
              gx0(1) = field(1)
              gy0(1) = field(2)
              gz0(1) = field(3)
              ft0(1) = field(4)
              px0(1) = field(5)
              py0(1) = field(6)
              pz0(1) = field(7)
              e0(1) = field(8)
              xmass0(i) = field(9)
              mul = 1
           else
 900              read (27, *, end = 1000) neve, ntyp, field
              if (neve .lt. nsevt) goto 900
              if (neve .gt.
     &           nsevt + ievt - 1) goto 1000
              ityp0(i) = ntyp
              gx0(i) = field(1)
              gy0(i) = field(2)
              gz0(i) = field(3)
              ft0(i) = field(4)
              px0(i) = field(5)
              py0(i) = field(6)
              pz0(i) = field(7)
              e0(i) = field(8)
              xmass0(i) = field(9)
              mul = mul + 1
           end if
 1001   continue
        
 1000        continue
        
        return
        end

        subroutine genei

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /para1/ mul
cc      SAVE /para1/
        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para3/ nsevt, nevnt, nsbrun, ievt, isbrun
cc      SAVE /para3/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        COMMON /prec1/GX0(MAXPTN),GY0(MAXPTN),GZ0(MAXPTN),FT0(MAXPTN),
     &       PX0(MAXPTN), PY0(MAXPTN), PZ0(MAXPTN), E0(MAXPTN),
     &       XMASS0(MAXPTN), ITYP0(MAXPTN)
cc      SAVE /prec1/
        common /prec5/ eta(MAXPTN), rap(MAXPTN), tau(MAXPTN)
cc      SAVE /prec5/
        common /lor/ enenew, pxnew, pynew, pznew
cc      SAVE /lor/
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        SAVE   

        external ran1

        iseed=iseedp
        incmul = 4000
        temp = 0.5d0
        etamin = -5d0        
        etamax = 5d0
        r0 = 5d0
        tau0 = 0.1d0
        deta = etamax - etamin

        do 1001 i = mul + 1, mul + incmul
           ityp0(i) = 21
           xmass0(i) = xmp
           call energy(e, temp)
           call momntm(px, py, pz, e)
c     7/20/01:
c           e = sqrt(e ** 2 + xmp ** 2)
           e = dsqrt(e ** 2 + xmp ** 2)
           if (iconfg .le. 3) then
              eta(i) = etamin + deta * ran1(iseed)
              bex = 0d0
              bey = 0d0
              bez = -tanh(eta(i))
              call lorenz(e, px, py, pz, bex, bey, bez)
              px0(i) = pxnew
              py0(i) = pynew
              pz0(i) = pznew
              e0(i) = enenew
           else
              px0(i) = px
              py0(i) = py
              pz0(i) = pz
              e0(i) = e
           end if
 1001   continue

        do 1002 i = mul + 1, mul + incmul
           if (iconfg .le. 3) then
              gz0(i) = tau0 * sinh(eta(i))
              ft0(i) = tau0 * cosh(eta(i))
              if (iconfg .eq. 1) then
                 call posit1(x, y, r0)
                 gx0(i) = x + px0(i) * ft0(i)/e0(i)
                 gy0(i) = y + py0(i) * ft0(i)/e0(i)
              else if (iconfg .eq. 2 .or. iconfg .eq. 3) then
                 call posit2(x, y)
                 gx0(i) = x
                 gy0(i) = y
              end if
           else
              ft0(i) = 0d0
              call posit3(x, y, z)
              gx0(i) = x
              gy0(i) = y
              gz0(i) = z
           end if
 1002   continue

        mul = mul + incmul
            
c       check if it's necessary to adjust array size 'adarr'
            if (mul .ge. MAXPTN .or. mul .eq. 0) then
           print *, 'event',ievt,'has',mul,'number of gluon',
     &          'adjusting counting is necessary'
           stop 'adarr'
        end if
        
        return
        end

        subroutine posit1(x, y, r0)
        
        implicit double precision (a-h, o-z)

        external ran1
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        SAVE   

        iseed=iseedp
 10        x = 2d0 * ran1(iseed) - 1d0
        y = 2d0 * ran1(iseed) - 1d0
        if (x ** 2 + y ** 2 .gt. 1d0) goto 10
        x = x * r0
        y = y * r0
        
        return
        end

        subroutine posit2(x, y)
        
        implicit double precision (a-h, o-z)

        external ran1

        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        SAVE   
        iseed=iseedp
         x = 2d0 * ran1(iseed) - 1d0
        y = 2d0 * ran1(iseed) - 1d0
        x = x * 5d0 * size1
        y = y * 5d0 * size2
        
        return
        end

        subroutine posit3(x, y, z)
        
        implicit double precision (a-h, o-z)

        external ran1

        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        SAVE   

        iseed=iseedp
         x = 2d0 * ran1(iseed) - 1d0
        y = 2d0 * ran1(iseed) - 1d0
        z = 2d0 * ran1(iseed) - 1d0
        x = x * 5d0 * size1
        y = y * 5d0 * size2
        z = z * 5d0 * size3
        
        return
        end
        
        subroutine energy(e, temp)

c       to generate the magnitude of the momentum e,
c       knowing the temperature of the local thermal distribution temp
        
        implicit double precision (a-h, o-z)
        
        external ran1

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        SAVE   

        iseed=iseedp
 1000        continue
        
        e = ran1(iseed)
        e = e * ran1(iseed)
        e = e * ran1(iseed)

        if (e .le. 0d0) goto 1000
        e = - temp * log(e)
        if (ran1(iseed) .gt. 
     &     exp((e - dsqrt(e ** 2 + xmp ** 2))/temp)) then
           goto 1000
        end if

        return
        end
        
        subroutine momntm(px, py, pz, e)

c       to generate the 3 components of the momentum px, py, pz,
c       from the magnitude of the momentum e
        
        implicit double precision (a-h,o-z)
        
        external ran1
        
        parameter (pi = 3.14159265358979d0)
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        SAVE   

        iseed=iseedp
        cost = 2d0 * ran1(iseed) - 1d0
c     7/20/01:
c        sint = sqrt(1d0 - cost ** 2)
        sint = dsqrt(1d0 - cost ** 2)
        phi = 2d0 * pi * ran1(iseed)
      
        px = e * sint * cos(phi)
        py = e * sint * sin(phi)
        pz = e * cost
        
        return
        end

        subroutine boosti

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /para1/ mul
cc      SAVE /para1/
        common /para6/ centy
cc      SAVE /para6/
        COMMON /prec1/GX0(MAXPTN),GY0(MAXPTN),GZ0(MAXPTN),FT0(MAXPTN),
     &       PX0(MAXPTN), PY0(MAXPTN), PZ0(MAXPTN), E0(MAXPTN),
     &       XMASS0(MAXPTN), ITYP0(MAXPTN)
cc      SAVE /prec1/
        common /lor/ enenew, pxnew, pynew, pznew
cc      SAVE /lor/
        SAVE   

        external lorenz

        bex = 0d0 
        bey = 0d0
        bez = - tanh(centy)
        
c       save data for many runs of the same initial condition           
        do 1001 i = 1, mul
           px1 = gx0(i)
           py1 = gy0(i)
           pz1 = gz0(i)
           e1 = ft0(i)
           call lorenz(e1, px1, py1, pz1, bex, bey, bez)
           gx0(i) = pxnew
           gy0(i) = pynew
           gz0(i) = pznew
           ft0(i) = enenew
           px1 = px0(i)
           py1 = py0(i)
           pz1 = pz0(i)
           e1 = e0(i)
           call lorenz(e1, px1, py1, pz1, bex, bey, bez)
           px0(i) = pxnew
           py0(i) = pynew
           pz0(i) = pznew
           e0(i) = enenew
 1001   continue
        
        return
        end

******************************************************************************

        subroutine inirun
        SAVE   

c       sort prec2 according to increasing formation time
        call ftime
        call inirec
        call iilist
        call inian2

        return
        end

        subroutine ftime
c       this subroutine generates formation time for the particles
c       indexing ft(i)
c       input e(i)
c       output ft(i), indx(i)

        implicit double precision (a-h, o-z)

        external ftime1
        parameter (MAXPTN=400001)
        common /para1/ mul
cc      SAVE /para1/
        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para4/ iftflg, ireflg, igeflg, ibstfg
cc      SAVE /para4/
        COMMON /prec1/GX0(MAXPTN),GY0(MAXPTN),GZ0(MAXPTN),FT0(MAXPTN),
     &       PX0(MAXPTN), PY0(MAXPTN), PZ0(MAXPTN), E0(MAXPTN),
     &       XMASS0(MAXPTN), ITYP0(MAXPTN)
cc      SAVE /prec1/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        common /par1/ formt
cc      SAVE /par1/
        common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        SAVE   

        iseed=iseedp
clin-6/07/02 initialize here to expedite compiling, instead in zpcbdt:
        do 1001 i = 1, MAXPTN
           ct(i)=0d0
           ot(i)=0d0
 1001   continue
        tlarge=1000000.d0
clin-6/07/02-end

        if (iftflg .eq. 0) then
c     5/01/01 different prescription for parton initial formation time:
           if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) then
              do 1002 i = 1, mul
                 if (ft0(i) .gt. tlarge) ft0(i) = tlarge
 1002         continue
              goto 150
           else
c     5/01/01-end

           do 1003 i = 1, MAXPTN
              ft0(i) = tlarge
 1003      continue
           do 1004 i = 1, mul
              xmt2 = px0(i) ** 2 + py0(i) ** 2 + xmp ** 2
              formt = xmt2 / e0(i)           
              ft0(i) = ftime1(iseed)
              if (ft0(i) .gt. tlarge) ft0(i) = tlarge
 1004      continue
c     5/01/01:
        endif

        end if

c     5/01/01:
 150        continue

c        call index1(MAXPTN, mul, ft0, indx)
        if (mul .gt. 1) then
           call index1(MAXPTN, mul, ft0, indx)
        else
clin-7/09/03: need to set value for mul=1:
           indx(1)=1
        end if
c
        return
        end

        subroutine inirec

        implicit double precision (a-h, o-z)
        external ran1
        parameter (MAXPTN=400001)
        common /para1/ mul
cc      SAVE /para1/
        common /para4/ iftflg, ireflg, igeflg, ibstfg
cc      SAVE /para4/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        COMMON /prec1/GX0(MAXPTN),GY0(MAXPTN),GZ0(MAXPTN),FT0(MAXPTN),
     &       PX0(MAXPTN), PY0(MAXPTN), PZ0(MAXPTN), E0(MAXPTN),
     &       XMASS0(MAXPTN), ITYP0(MAXPTN)
cc      SAVE /prec1/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec3/gxs(MAXPTN),gys(MAXPTN),gzs(MAXPTN),fts(MAXPTN),
     &     pxs(MAXPTN), pys(MAXPTN), pzs(MAXPTN), es(MAXPTN),
     &     xmasss(MAXPTN), ityps(MAXPTN)
cc      SAVE /prec3/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /prec5/ eta(MAXPTN), rap(MAXPTN), tau(MAXPTN)
cc      SAVE /prec5/
        common /prec6/ etas(MAXPTN), raps(MAXPTN), taus(MAXPTN)
cc      SAVE /prec6/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
cbz1/25/99
        COMMON /ilist7/ LSTRG0(MAXPTN), LPART0(MAXPTN)
cc      SAVE /ilist7/
        COMMON /ilist8/ LSTRG1(MAXPTN), LPART1(MAXPTN)
cc      SAVE /ilist8/
cbz1/25/99end
        COMMON /smearz/smearp,smearh
cc      SAVE /smearz/
clin-8/2015:
c        dimension vxp(MAXPTN), vyp(MAXPTN), vzp(MAXPTN)
        common /precpb/vxp(MAXPTN),vyp(MAXPTN),vzp(MAXPTN)
clin-8/2015:
        common /precpa/vxp0(MAXPTN),vyp0(MAXPTN),vzp0(MAXPTN),
     1       xstrg0(MAXPTN),ystrg0(MAXPTN),
     2       xstrg(MAXPTN),ystrg(MAXPTN),istrg0(MAXPTN),istrg(MAXPTN)
c        common /precpa/ vxp0(MAXPTN), vyp0(MAXPTN), vzp0(MAXPTN)
cc      SAVE /precpa/
        common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
clin-6/06/02 local parton freezeout:
        common /frzprc/ 
     &       gxfrz(MAXPTN), gyfrz(MAXPTN), gzfrz(MAXPTN), ftfrz(MAXPTN),
     &       pxfrz(MAXPTN), pyfrz(MAXPTN), pzfrz(MAXPTN), efrz(MAXPTN),
     &       xmfrz(MAXPTN), 
     &       tfrz(302), ifrz(MAXPTN), idfrz(MAXPTN), itlast
cc      SAVE /frzprc/
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        common /para7/ ioscar,nsmbbbar,nsmmeson
        COMMON /AREVT/ IAEVT, IARUN, MISS
        SAVE   
        iseed=iseedp
clin-6/06/02 local freezeout initialization:
        if(isoft.eq.5) then
           itlast=0
           call inifrz
        endif

        do 1001 i = 1, mul
clin-7/09/01 define indx(i) to save time:
c           ityp(i) = ityp0(indx(i))
c           gx(i) = gx0(indx(i))
c           gy(i) = gy0(indx(i))
c           gz(i) = gz0(indx(i))
c           ft(i) = ft0(indx(i))
c           px(i) = px0(indx(i))
c           py(i) = py0(indx(i))
c           pz(i) = pz0(indx(i))
c           e(i) = e0(indx(i))
c           xmass(i) = xmass0(indx(i))
ccbz1/25/99
c           LSTRG1(I) = LSTRG0(INDX(I))
c           LPART1(I) = LPART0(INDX(I))
ccbz1/25/99end
           indxi=indx(i)
           ityp(i) = ityp0(indxi)
           gx(i) = gx0(indxi)
           gy(i) = gy0(indxi)
           gz(i) = gz0(indxi)
           ft(i) = ft0(indxi)
           px(i) = px0(indxi)
           py(i) = py0(indxi)
           pz(i) = pz0(indxi)
           e(i) = e0(indxi)
           xmass(i) = xmass0(indxi)
           LSTRG1(I) = LSTRG0(INDXI)
           LPART1(I) = LPART0(INDXI)
           vxp(I) = vxp0(INDXI)
           vyp(I) = vyp0(INDXI)
           vzp(I) = vzp0(INDXI)
clin-8/2015:
           xstrg0(I) = xstrg(INDXI)
           ystrg0(I) = ystrg(INDXI)
           istrg0(I) = istrg(INDXI)
clin-7/09/01-end
c
clin-6/06/02 local freezeout initialization:
         if(isoft.eq.5) then
            idfrz(i)=ityp(i)
            gxfrz(i)=gx(i)
            gyfrz(i)=gy(i)
            gzfrz(i)=gz(i)
            ftfrz(i)=ft(i)
            pxfrz(i)=px(i)
            pyfrz(i)=py(i)
            pzfrz(i)=pz(i)
            efrz(i)=e(i)
            xmfrz(i)=xmass(i)
            ifrz(i)=0
         endif
clin-6/06/02-end
 1001 continue

c       save particle info for fixed time analysis
        do 1002 i = 1, mul
           ityps(i) = ityp(i)
           gxs(i) = gx(i)
           gys(i) = gy(i)
           gzs(i) = gz(i)
           fts(i) = ft(i)
           pxs(i) = px(i)
           pys(i) = py(i)
           pzs(i) = pz(i)
           es(i) = e(i)
           xmasss(i) = xmass(i)
 1002   continue

clin-6/2009
        if(isoft.eq.1.and.(ioscar.eq.2.or.ioscar.eq.3))
     1       write(92,*) iaevt,miss,mul

        do 1003 i = 1, mul
           energy = e(i)
           vx(i) = px(i) / energy
           vy(i) = py(i) / energy
           vz(i) = pz(i) / energy
           if (iftflg .eq. 0) then
              formt = ft(i)
c     7/09/01 propagate partons with parent velocity till formation
c     so that partons in same hadron have 0 distance:
c            gx(i) = gx(i) + vx(i) * formt
c            gy(i) = gy(i) + vy(i) * formt
c            gz(i) = gz(i) + vz(i) * formt
            if(isoft.eq.3.or.isoft.eq.4.or.isoft.eq.5) then
               gx(i) = gx(i) + vxp(i) * formt
               gy(i) = gy(i) + vyp(i) * formt
               gz(i) = gz(i) + vzp(i) * formt
            else
               gx(i) = gx(i) + vx(i) * formt
               gy(i) = gy(i) + vy(i) * formt
               gz(i) = gz(i) + vz(i) * formt
            endif
c     7/09/01-end
c
c     3/27/00-ctest off no smear z on partons to avoid eta overflow:
c              gz(i) = gz(i)+smearp*(2d0 * ran1(iseed) - 1d0)
c     to give eta=y +- smearp*random:
c              smeary=smearp*(2d0 * ran1(iseed) - 1d0)
c              smearf=dexp(2*smeary)*(1+vz(i))/(1-vz(i)+1.d-8)
c              gz(i) = gz(i)+formt*(smearf-1)/(smearf+1)
c     3/27/00-end
           end if

clin-6/2009 write out initial parton information after string melting
c     and after propagating to its format time:
           if(ioscar.eq.2.or.ioscar.eq.3) then
              if(dmax1(abs(gx(i)),abs(gy(i)),
     1             abs(gz(i)),abs(ft(i))).lt.9999) then
clin-8/2015:
                 write(92,200) ityp(i),px(i),py(i),pz(i),xmass(i),
     1           gx(i),gy(i),gz(i),ft(i),istrg0(i),xstrg0(i),ystrg0(i)
              else
clin-8/2015:
                 write(92,201) ityp(i),px(i),py(i),pz(i),xmass(i),
     1           gx(i),gy(i),gz(i),ft(i),istrg0(i),xstrg0(i),ystrg0(i)
              endif
           endif
clin-8/2015:
c 200       format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,f8.2))
c 201       format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,e8.2))
c     reduce file size:
c 200       format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,f9.3),
c     1          1x,I6,2(1x,f8.3))
c 201       format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,e9.3),
c     1          1x,I6,2(1x,f8.3))
 200       format(I3,2(1x,f7.2),1x,f8.2,1x,f6.3,4(1x,f8.2),
     1          1x,I5,2(1x,f7.2))
 201       format(I3,2(1x,f7.2),1x,f8.2,1x,f6.3,4(1x,e8.2),
     1          1x,I5,2(1x,f7.2))
c
 1003   continue

        if (iconfg .le. 3) then
           do 1004 i = 1, mul
              if (ft(i) .le. abs(gz(i))) then
                 eta(i) = 1000000.d0
              else
                 eta(i) = 0.5d0 * log((ft(i) + gz(i)) / (ft(i) - gz(i)))
              end if
              if (e(i) .le. abs(pz(i))) then
                 rap(i) = 1000000.d0
              else
                 rap(i) = 0.5d0 * log((e(i) + pz(i)) / (e(i) - pz(i)))
              end if
clin-8/2015 to avoid IEEE_OVERFLOW_FLAG:
c              tau(i) = ft(i) / cosh(eta(i))
              if(eta(i).lt.1000000.d0) then
                 tau(i) = ft(i) / cosh(eta(i))
              else
                 tau(i) = 1d-10
              endif
c
 1004      continue
           
           do 1005 i = 1, mul
              etas(i) = eta(i)
              raps(i) = rap(i)
              taus(i) = tau(i)
 1005      continue
        end if

        return
        end

        subroutine iilist

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /para1/ mul
cc      SAVE /para1/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist2/ icell, icel(10,10,10)
cc      SAVE /ilist2/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        common /ilist6/ t, iopern, icolln
cc      SAVE /ilist6/
        SAVE   

        iscat = MAXPTN
        jscat = MAXPTN

        do 1001 i = 1, mul
           next(i) = 0
           last(i) = 0
           icsta(i) = 0
           nic(i) = 0
           icels(i) = 0
 1001   continue

        icell = 0
        do 1004 i1 = 1, 10
           do 1003 i2 = 1, 10
              do 1002 i3 = 1, 10
                 icel(i1, i2, i3) = 0
 1002         continue
 1003      continue
 1004   continue

        ichkpt = 0
        ifmpt = 1

        do 1005 i = 1, mul
           ct(i) = tlarge
           ot(i) = tlarge
 1005   continue

        iopern = 0
        icolln = 0
        t = 0.d0

        return
        end

        subroutine inian2

        implicit double precision (a-h, o-z)

        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /ana2/
     &     det(12), dn(12), detdy(12), detdn(12), dndy(12),
     &     det1(12), dn1(12), detdy1(12), detdn1(12), dndy1(12),
     &     det2(12), dn2(12), detdy2(12), detdn2(12), dndy2(12)
cc      SAVE /ana2/
        SAVE   

        if (iconfg .le. 3) then
           do 1001 i = 1, 12
              det(i) = 0d0
              dn(i) = 0d0
              det1(i) = 0d0
              dn1(i) = 0d0
              det2(i) = 0d0
              dn2(i) = 0d0
 1001      continue
        end if

        return
        end

******************************************************************************
******************************************************************************

        subroutine zpcrun(*)

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        parameter (tend1 = 250d0)
        parameter (tend2 = 6.1d0)
        common /para1/ mul
cc      SAVE /para1/
        common /para5/ iconfg, iordsc
        common /para7/ ioscar,nsmbbbar,nsmmeson
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /prec5/ eta(MAXPTN), rap(MAXPTN), tau(MAXPTN)
cc      SAVE /prec5/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        common /ilist6/ t, iopern, icolln
cc      SAVE /ilist6/
        common /ana1/ ts(12)
cc      SAVE /ana1/
        common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
        COMMON /AREVT/ IAEVT, IARUN, MISS
        SAVE   

c       save last collision info
        if (mod(ictype, 2) .eq. 0) then
           call savrec(iscat)
           call savrec(jscat)
        end if

c1      get operation type
        call getict(t1)
c2      check freezeout condition
        if (iconfg .eq. 1 .and. t1 .gt. tlarge / 2d0) return 1
        if (iconfg .eq. 2 .or. iconfg .eq. 3) then
           if (t1 .gt. tend1) return 1
c           if (ichkpt .eq. mul) then
c              ii = 0
c              do i = 1, mul
c                 gztemp = gz(i) + vz(i) * (t1 - ft(i))
c                 if (sqrt(t1 ** 2 - gztemp ** 2) .lt. tend) then
c                    ii = 1
c                    goto 1000
c                 end if
c              end do
c 1000              continue
c              if (ii .eq. 0) return 1
c           end if
        end if
        if (iconfg .eq. 4 .or. iconfg .eq. 5) then
           if (t1 .gt. tend2) return 1
        end if

clin-6/06/02 local freezeout for string melting,
c     decide what partons have frozen out at time t1:
      if(isoft.eq.5) then
         call local(t1)
      endif

c3      update iopern, t

        iopern = iopern + 1
        t = t1
        if (mod(ictype, 2) .eq. 0) then
           icolln = icolln + 1

c     4/18/01-ctest off
c           write (2006, 1233) 'iscat=', iscat, 'jscat=', jscat,
c           write (2006, *) 'iscat=', iscat, ' jscat=', jscat,
c     1 ityp(iscat), ityp(jscat)
c           write (2006, 1233) 'iscat=', max(indx(iscat), indx(jscat)),
c     &        'jscat=', min(indx(iscat), indx(jscat))

c           write (2006, 1234) ' icolln=', icolln, 't=', t

c 1233           format (a10, i10, a10, i10)
c 1234           format (a15, i10, a5, f23.17, a5, f23.17)
        end if

c4.1    deal with formation
        if (iconfg .eq. 1
     &     .or. iconfg .eq. 2
     &     .or. iconfg .eq. 4) then
           if (ictype .eq. 1 .or. ictype .eq. 2 .or. 
     &        ictype .eq. 5 .or. ictype .eq. 6) then
              call celasn
           end if
        end if

c4.2    deal with collisions

        if (ictype .ne. 1) then

           iscat0 = iscat
           jscat0 = jscat
           
c        iscat is the larger one so that if it's a wall collision,
c       it's still ok
           iscat = max0(iscat0, jscat0)
           jscat = min0(iscat0, jscat0)

ctest off check icsta(i): 0 with f77 compiler
c        write(9,*) 'BB:ictype,t1,iscat,jscat,icsta(i)=',
c     1 ictype,t1,iscat,jscat,icsta(iscat)
           
c       check collision time table error 'tterr'
clin-4/2008 to avoid out-of-bound error in next():
c           if (jscat .ne. 0 .and. next(jscat) .ne. iscat)
c     &        then
c              print *, 'iscat=', iscat, 'jscat=', jscat,
c     &             'next(', jscat, ')=', next(jscat)
c
c              if (ct(iscat) .lt. tlarge / 2d0) stop 'tterr'
c              if (ct(jscat) .lt. tlarge / 2d0) stop 'tterr'
c           end if 
           if (jscat .ne. 0) then
              if(next(jscat) .ne. iscat) then
                 print *, 'iscat=', iscat, 'jscat=', jscat,
     &                'next(', jscat, ')=', next(jscat)
                 if (ct(iscat) .lt. tlarge / 2d0) stop 'tterr'
                 if (ct(jscat) .lt. tlarge / 2d0) stop 'tterr'
              endif
           end if 
clin-4/2008-end
           
c4.2.1     collisions with wall

c     8/19/02 avoid actual argument in common blocks of cellre:
         niscat=iscat
         njscat=jscat
c           if (icsta(iscat) .ne. 0) call cellre(iscat, t)
c           if (jscat .ne. 0) then
c              if (icsta(jscat) .ne. 0) call cellre(jscat, t)
c           end if
           if (icsta(iscat) .ne. 0) call cellre(niscat, t)
           if (jscat .ne. 0) then
              if (icsta(jscat) .ne. 0) call cellre(njscat, t)
           end if

c4.2.2     collision between particles     

clin-6/2009 write out info for each collision:
c           if (mod(ictype, 2) .eq. 0) call scat(t, iscat, jscat)
           if (mod(ictype, 2) .eq. 0) then
              if(ioscar.eq.3) then
            write(95,*) 'event,miss,iscat,jscat=',iaevt,miss,iscat,jscat
                 if(dmax1(abs(gx(iscat)),abs(gy(iscat)),
     1                abs(gz(iscat)),abs(ft(iscat)),abs(gx(jscat)),
     2                abs(gy(jscat)),abs(gz(jscat)),abs(ft(jscat)))
     3                .lt.9999) then
                    write(95,200) ityp(iscat),px(iscat),py(iscat),
     1                   pz(iscat),xmass(iscat),gx(iscat),gy(iscat),
     2                   gz(iscat),ft(iscat)
                    write(95,200) ityp(jscat),px(jscat),py(jscat),
     1                   pz(jscat),xmass(jscat),gx(jscat),gy(jscat),
     2                   gz(jscat),ft(jscat)
                 else
                    write(95,201) ityp(iscat),px(iscat),py(iscat),
     1                   pz(iscat),xmass(iscat),gx(iscat),gy(iscat),
     2                   gz(iscat),ft(iscat)
                    write(95,201) ityp(jscat),px(jscat),py(jscat),
     1                   pz(jscat),xmass(jscat),gx(jscat),gy(jscat),
     2                   gz(jscat),ft(jscat)
                 endif
              endif
c     
              call scat(t, iscat, jscat)
c     
              if(ioscar.eq.3) then
                 if(dmax1(abs(gx(iscat)),abs(gy(iscat)),
     1                abs(gz(iscat)),abs(ft(iscat)),abs(gx(jscat)),
     2                abs(gy(jscat)),abs(gz(jscat)),abs(ft(jscat)))
     3                .lt.9999) then
                    write(95,200) ityp(iscat),px(iscat),py(iscat),
     1                   pz(iscat),xmass(iscat),gx(iscat),gy(iscat),
     2                   gz(iscat),ft(iscat)
                    write(95,200) ityp(jscat),px(jscat),py(jscat),
     1                   pz(jscat),xmass(jscat),gx(jscat),gy(jscat),
     2                   gz(jscat),ft(jscat)
                 else
                    write(95,201) ityp(iscat),px(iscat),py(iscat),
     1                   pz(iscat),xmass(iscat),gx(iscat),gy(iscat),
     2                   gz(iscat),ft(iscat)
                    write(95,201) ityp(jscat),px(jscat),py(jscat),
     1                   pz(jscat),xmass(jscat),gx(jscat),gy(jscat),
     2                   gz(jscat),ft(jscat)
                 endif
              endif
           endif
 200       format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,f8.2))
 201       format(I6,2(1x,f8.3),1x,f10.3,1x,f6.3,4(1x,e8.2))
           
        end if

c5      update the interaction list
        call ulist(t)

c6      update ifmpt. ichkpt
c       old ichkpt and ifmpt are more conveniently used in ulist
        if (ifmpt .le. mul) then
           if (ictype .ne. 0 .and. ictype .ne. 3 
     &        .and. ictype .ne. 4) then
              ichkpt = ichkpt + 1
              ifmpt = ifmpt + 1
           end if
        end if

        return
        end

        subroutine savrec(i)

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec3/gxs(MAXPTN),gys(MAXPTN),gzs(MAXPTN),fts(MAXPTN),
     &     pxs(MAXPTN), pys(MAXPTN), pzs(MAXPTN), es(MAXPTN),
     &     xmasss(MAXPTN), ityps(MAXPTN)
cc      SAVE /prec3/
        common /prec5/ eta(MAXPTN), rap(MAXPTN), tau(MAXPTN)
cc      SAVE /prec5/
        common /prec6/ etas(MAXPTN), raps(MAXPTN), taus(MAXPTN)
cc      SAVE /prec6/
        SAVE   

        ityps(i) = ityp(i)
        gxs(i) = gx(i)
        gys(i) = gy(i)
        gzs(i) = gz(i)
        fts(i) = ft(i)
        pxs(i) = px(i)
        pys(i) = py(i)
        pzs(i) = pz(i)
        es(i) = e(i)
        xmasss(i) = xmass(i)
        etas(i) = eta(i)
        raps(i) = rap(i)
        taus(i) = tau(i)

        return
        end

        subroutine getict(t1)
        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /para1/ mul
cc      SAVE /para1/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

c       neglect possibility of 2 collisions at the same time
c0       set initial conditions

        t1 = tlarge
        iscat = 0
        jscat = 0

c1      get next collision between particles
        do 1001 i = 1, ichkpt
           if (ot(i) .lt. t1) then
              t1 = ot(i)
              iscat = i
           end if
 1001   continue
        if (iscat .ne. 0) jscat = next(iscat)

c2      get ictype
c     10/30/02 ictype=0:collision; 1:parton formation
        if (iscat .ne. 0 .and. jscat .ne. 0) then
           if (icsta(iscat) .eq. 0 .and. icsta(jscat) .eq. 0) then
              ictype = 0
           else
              ictype = 4
           end if
        else if (iscat .ne. 0 .or. jscat .ne. 0) then
           ictype = 3
        end if
c
        if (ifmpt .le. mul) then
           if (ft(ifmpt) .lt. t1) then
              ictype = 1
              t1 = ft(ifmpt)
           else if (ft(ifmpt) .eq. t1) then
              if (ictype .eq. 0) ictype = 2
              if (ictype .eq. 3) ictype = 5
              if (ictype .eq. 4) ictype = 6
           end if
        end if

        return
        end

        subroutine celasn
c       this subroutine is used to assign a cell for a newly formed particle
c       output: nic(MAXPTN) icels(MAXPTN) in the common /ilist1/
c       icell, and icel(10,10,10) in the common /ilist2/

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /para1/ mul
cc      SAVE /para1/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist2/ icell, icel(10,10,10)
cc      SAVE /ilist2/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        SAVE   

        external integ

        i = ifmpt
        tt = ft(i)
        td = tt - size
        if (iconfg .eq. 1 .and. (size1 .eq. 0d0 .or.
     &     size2 .eq. 0d0 .or. size3 .eq. 0d0)) then
           i1 = 11
           i2 = 11
           i3 = 11
        else if (iconfg .eq. 4 .or. td .le. 0d0) then
           i1 = integ(gx(i) / size1) + 6
           i2 = integ(gy(i) / size2) + 6
           i3 = integ(gz(i) / size3) + 6
           if (integ(gx(i) / size1) .eq. gx(i) / size1 .and. 
     &        vx(i) .lt. 0d0)
     &        i1 = i1 - 1
           if (integ(gy(i) / size2) .eq. gy(i) / size2 .and. 
     &        vy(i) .lt. 0d0)
     &        i2 = i2 - 1
           if (integ(gz(i) / size3) .eq. gz(i) / size3 .and. 
     &        vz(i) .lt. 0d0)
     &        i3 = i3 - 1
        else
           i1 = integ(gx(i) / (size1 + v1 * td)) + 6
           i2 = integ(gy(i) / (size2 + v2 * td)) + 6
           i3 = integ(gz(i) / (size3 + v3 * td)) + 6
           if (integ(gx(i) / (size1 + v1 * td)) .eq. gx(i) / 
     &        (size1 + v1 * td) .and. vx(i) .lt. (i1 - 6) * v1)
     &        i1 = i1 - 1
           if (integ(gy(i) / (size2 + v2 * td)) .eq. gy(i)/
     &        (size2 + v2 * td) .and. vy(i) .lt. (i2 - 6) * v2)
     &        i2 = i2 - 1
           if (integ(gz(i) / (size3 + v3 * td)) .eq. gz(i)/
     &        (size3 + v3 * td) .and. vz(i) .lt. (i3 - 6) * v3)
     &        i3 = i3 - 1
        end if

        if (i1 .le. 0 .or. i1 .ge. 11 .or. i2 .le. 0 .or.
     &     i2 .ge. 11 .or. i3 .le. 0 .or. i3 .ge. 11) then
           i1 = 11
           i2 = 11
           i3 = 11
        end if

        if (i1 .eq. 11) then
           j = icell
           call newcre(i, j)
           icell = j
           icels(i) = 111111
        else
           j = icel(i1, i2, i3)
           call newcre(i, j)
           icel(i1, i2, i3) = j
           icels(i) = i1 * 10000 + i2 * 100 + i3
        end if

        return
        end

        integer function integ(x)
c       this function is used to get the largest integer that is smaller than
c       x

        implicit double precision (a-h, o-z)
        SAVE   

        if (x .lt. 0d0) then
           integ = int(x - 1d0)
        else
           integ = int( x )
        end if

        return
        end

        subroutine cellre(i, t)
c       this subroutine is used for changing the cell of a particle that
c       collide with the wall

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist2/ icell, icel(10,10,10)
cc      SAVE /ilist2/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical good

        external integ

c       this happens before update the /prec2/ common; in contrast with 
c       scat which happens after updating the glue common

        t0 = t

 1000        continue

        if (iconfg .eq. 3 .or. iconfg .eq. 5) then
           k = mod(icsta(i), 10)

           if (k .eq. 1) then
              gx(i) = gx(i) - 10d0 * size1
              dgxa(i) = dgxa(i) + 10d0 * size1
              do 1001 ii = 1, ichkpt
                 if (next(ii) .eq. i) then
                    dgxa(ii) = dgxa(ii) - 10d0 * size1
                 end if
 1001         continue
           end if
           if (k .eq. 2) then
              gx(i) = gx(i) + 10d0 * size1
              dgxa(i) = dgxa(i) - 10d0 * size1
              do 1002 ii = 1, ichkpt
                 if (next(ii) .eq. i) then
                    dgxa(ii) = dgxa(ii) + 10d0 * size1
                 end if
 1002         continue
           end if
           if (k .eq. 3) then
              gy(i) = gy(i) - 10d0 * size2
              dgya(i) = dgya(i) + 10d0 * size2
              do 1003 ii = 1, ichkpt
                 if (next(ii) .eq. i) then
                    dgya(ii) = dgya(ii) - 10d0 * size2
                 end if
 1003         continue
           end if
           if (k .eq. 4) then
              gy(i) = gy(i) + 10d0 * size2
              dgya(i) = dgya(i) - 10d0 * size2
              do 1004 ii = 1, ichkpt
                 if (next(ii) .eq. i) then
                    dgya(ii) = dgya(ii) + 10d0 * size2
                 end if
 1004         continue
           end if
           if (iconfg .eq. 5) then
              if (k .eq. 5) then
                 gz(i) = gz(i) - 10d0 * size3
                 dgza(i) = dgza(i) + 10d0 * size3
                 do 1005 ii = 1, ichkpt
                    if (next(ii) .eq. i) then
                       dgza(ii) = dgza(ii) - 10d0 * size3
                    end if
 1005            continue
              end if
              if (k .eq. 6) then
                 gz(i) = gz(i) + 10d0 * size3
                 dgza(i) = dgza(i) - 10d0 * size3
                 do 1006 ii = 1, ichkpt
                    if (next(ii) .eq. i) then
                       dgza(ii) = dgza(ii) + 10d0 * size3
                    end if
 1006               continue
              end if
           end if
        else
           icels0 = icels(i)

           i1 = icels0 / 10000
           i2 = (icels0 - i1 * 10000) / 100
           i3 = icels0 - i1 * 10000 - i2 * 100
           
cc       for particle inside the cube
           if (i1 .ge. 1 .and. i1 .le. 10
     &        .and. i2 .ge. 1 .and. i2 .le. 10
     &        .and. i3 .ge. 1 .and. i3 .le. 10) then

c       this assignment takes care of nic(i)=0 automatically
              if (icel(i1, i2, i3) .eq. i) icel(i1, i2, i3) = nic(i)

c1      rearrange the old cell

              call oldcre(i)

c2      rearrange the new cell

              k = mod(icsta(i), 10)
              
c2.1    particle goes out of the cube       
              if (iconfg .eq. 1) then
                 good = (i1 .eq. 1 .and. k .eq. 2)
     &              .or. (i1 .eq. 10 .and. k .eq. 1)
     &              .or. (i2 .eq. 1 .and. k .eq. 4)
     &              .or. (i2 .eq. 10 .and. k .eq. 3)
     &              .or. (i3 .eq. 1 .and. k .eq. 6)
     &              .or. (i3 .eq. 10 .and. k .eq. 5)
              end if
              if (iconfg .eq. 2) then
                 good = (i3 .eq. 1 .and. k .eq. 6)
     &              .or. (i3 .eq. 10 .and. k .eq. 5)
              end if
              if (good) then

c                j = icell
                 call newcre(i, icell)
c                 icell = j

                 icels(i) = 111111

c2.2    particle moves inside the cube
              else

                 if (k .eq. 1) i1 = i1 + 1
                 if (k .eq. 2) i1 = i1 - 1
                 if (k .eq. 3) i2 = i2 + 1
                 if (k .eq. 4) i2 = i2 - 1
                 if (k .eq. 5) i3 = i3 + 1
                 if (k .eq. 6) i3 = i3 - 1
                 
                 if (iconfg .eq. 2 .or. iconfg .eq. 4) then
                    if (i1 .eq. 0) then
                       i1 = 10
                       gx(i) = gx(i) + 10d0 * size1
                    end if
                    if (i1 .eq. 11) then
                       i1 = 1
                       gx(i) = gx(i) - 10d0 * size1
                    end if
                    if (i2 .eq. 0) then
                       i2 = 10
                       gy(i) = gy(i) + 10d0 * size2
                    end if
                    if (i2 .eq. 11) then
                       i2 = 1
                       gy(i) = gy(i) - 10d0 * size2
                    end if
                    if (iconfg .eq. 4) then
                       if (i3 .eq. 0) then
                          i3 = 10
                          gz(i) = gz(i) + 10d0 * size3
                       end if
                       if (i3 .eq. 11) then
                          i3 = 1
                          gz(i) = gz(i) - 10d0 * size3
                       end if
                    end if
                 end if
                 
                 j = icel(i1, i2, i3)
                 
                 call newcre(i, j)
c       in case icel changes
                 
                 icel(i1 ,i2, i3) = j
                 
                 icels(i) = i1 * 10000 + i2 * 100 + i3
                 
              end if
              
cc       for particles outside the cube
           else
              
              if (icell .eq. i) icell = nic(i)
              
              call oldcre(i)
              
              k = mod(icsta(i), 10)
              
              ddt = t - ft(i)
              dtt = t - size
              if (dtt .le. 0d0) then
                 i1 = integ((gx(i) + vx(i) * ddt) / size1) + 6
                 i2 = integ((gy(i) + vy(i) * ddt) / size2) + 6
                 i3 = integ((gz(i) + vz(i) * ddt) / size3) + 6
              else
                 i1 = integ((gx(i) + vx(i) * ddt) / 
     &               (size1 + v1 * dtt)) + 6
                 i2 = integ((gy(i) + vy(i) * ddt) /
     &               (size2 + v2 * dtt)) + 6
                 i3 = integ((gz(i) + vz(i) * ddt) /
     &               (size3 + v3 * dtt)) + 6
              end if 


              if (k .eq. 1) i1 = 1
              if (k .eq. 2) i1 = 10
              if (k .eq. 3) i2 = 1
              if (k .eq. 4) i2 = 10
              if (k .eq. 5) i3 = 1
              if (k .eq. 6) i3 = 10

              j = icel(i1, i2, i3)
              call newcre(i, j)
              icel(i1, i2, i3) = j
              
              icels(i) = i1 * 10000 + i2 * 100 + i3
              
           end if
        end if

        if (next(i) .ne. 0) then
           otmp = ot(next(i))
           ctmp = ct(next(i))
        end if

        if (i1 .eq. 11 .and. i2 .eq. 11 .and. i3 .eq. 11) then
           call dchout(i, k, t)
        else
           if (iconfg .eq. 1) then
              call dchin1(i, k, i1, i2, i3, t)
           else if (iconfg .eq. 2) then
              call dchin2(i, k, i1, i2, i3, t)
           else if (iconfg .eq. 4) then
              call dchin3(i, k, i1, i2, i3, t)              
           end if
        end if

        if (icsta(i) / 10 .eq. 11) then
           ot(next(i)) = otmp
           ct(next(i)) = ctmp
           next(next(i)) = i
           call wallc(i, i1, i2, i3, t0, tmin1)
           if (tmin1 .lt. ct(i)) then
              icsta(i) = icsta(i) + 10
              t0 = tmin1
              goto 1000
           end if
        end if

        return
        end
           
        subroutine oldcre(i) 
c       this subroutine is used to rearrange the old cell nic when a particle 
c       goes out of the cell

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        SAVE   

        if (nic(i) .eq. 0) return

        j = nic(i)

        if (nic(j) .eq. i) then
           nic(j) = 0
           return
        end if

        do 10 while (nic(j) .ne. i)
           j = nic(j)
 10        continue
        
        nic(j) = nic(i)

        return
        end


        subroutine newcre(i, k)
c       this subroutine is used to mk rearrange of the new cell a particle
c       enters,
c       input i
c       output nic(i)

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        SAVE   

        if (k .eq. 0) then
           k = i
           nic(i) = 0
        else if (nic(k) .eq. 0) then
           nic(k) = i
           nic(i) = k
        else
           j = k
           do 10 while (nic(j) .ne. k)
              j = nic(j)
 10           continue

           nic(j) = i
           nic(i) = k

        end if
        
        return
        end

        subroutine scat(t, iscat, jscat)

c       this subroutine is used to calculate the 2 particle scattering

        implicit double precision (a-h, o-z)
        SAVE   

        call newpos(t, iscat)
        call newpos(t, jscat)
        call newmom(t)

        return
        end

        subroutine newpos(t, i)

c       this subroutine is used to calculate the 2 particle scattering
c       get new position

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /prec5/ eta(MAXPTN), rap(MAXPTN), tau(MAXPTN)
cc      SAVE /prec5/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        dt1 = ct(i) - ft(i)
        
        gx(i) = gx(i) + vx(i) * dt1
        gy(i) = gy(i) + vy(i) * dt1
        gz(i) = gz(i) + vz(i) * dt1
        ft(i) = ct(i)
           
        if (iconfg .le. 3) then
           if (ft(i) .le. abs(gz(i))) then
              eta(i) = 1000000.d0
           else
              eta(i) = 0.5d0 * log((ft(i) + gz(i)) / (ft(i) - gz(i)))
           end if
clin-8/2015 to avoid IEEE_OVERFLOW_FLAG:
c           tau(i) = ft(i) / cosh(eta(i))
           if(eta(i).lt.1000000.d0) then
              tau(i) = ft(i) / cosh(eta(i))
           else
              tau(i) = 1d-10
           endif
c
        end if

        return
        end

        subroutine newmom(t)

c       this subroutine is used to calculate the 2 particle scattering

        implicit double precision (a-h, o-z)

        parameter (hbarc = 0.197327054d0)
        parameter (MAXPTN=400001)
        parameter (pi = 3.14159265358979d0)
        COMMON /para1/ mul
cc      SAVE /para1/
        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
ctrans
        common /para6/ centy
cc      SAVE /para6/
ctransend
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /prec5/ eta(MAXPTN), rap(MAXPTN), tau(MAXPTN)
cc      SAVE /prec5/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /lor/ enenew, pxnew, pynew, pznew
cc      SAVE /lor/
        common /cprod/ xn1, xn2, xn3
cc      SAVE /cprod/
        common /rndm2/ iff
cc      SAVE /rndm2/
        common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
        common /frzprc/ 
     &       gxfrz(MAXPTN), gyfrz(MAXPTN), gzfrz(MAXPTN), ftfrz(MAXPTN),
     &       pxfrz(MAXPTN), pyfrz(MAXPTN), pzfrz(MAXPTN), efrz(MAXPTN),
     &       xmfrz(MAXPTN), 
     &       tfrz(302), ifrz(MAXPTN), idfrz(MAXPTN), itlast
cc      SAVE /frzprc/
        SAVE   

clin-6/06/02 no momentum change for partons already frozen out,
c     however, spatial upgrade is needed to ensure overall system freezeout:
      if(isoft.eq.5) then
         if(ifrz(iscat).eq.1.or.ifrz(jscat).eq.1) then
            last(iscat) = jscat
            last(jscat) = iscat
            return
         endif
      endif
clin-6/06/02-end

c       iff is used to randomize the interaction to have both attractive and
c        repulsive

        iff = - iff

        if (iconfg .eq. 2 .or. iconfg .eq. 4) then
           icels1 = icels(iscat)
           i1 = icels1 / 10000
           j1 = (icels1 - i1 * 10000) / 100
           icels2 = icels(jscat)
           i2 = icels2 / 10000
           j2 = (icels2 - i2 * 10000) / 100
           if (iconfg .eq. 4) then
              k1 = icels1 - i1 * 10000 - j1 * 100
              k2 = icels2 - i2 * 10000 - j2 * 100
           end if
        end if

        px1 = px(iscat)
        py1 = py(iscat)
        pz1 = pz(iscat)
        e1 = e(iscat)
        x1 = gx(iscat)
        y1 = gy(iscat)
        z1 = gz(iscat)
        t1 = ft(iscat)
        px2 = px(jscat)
        py2 = py(jscat)
        pz2 = pz(jscat)
        e2 = e(jscat)

        if (iconfg .eq. 1) then
           x2 = gx(jscat)
           y2 = gy(jscat)
           z2 = gz(jscat)
        else if (iconfg .eq. 2 .or. iconfg .eq. 4) then
           if (i1 - i2 .gt. 5) then
              x2 = gx(jscat) + 10d0 * size1
           else if (i1 - i2 .lt. -5) then
              x2 = gx(jscat) - 10d0 * size1
           else
              x2 = gx(jscat)
           end if
           if (j1 - j2 .gt. 5) then
              y2 = gy(jscat) + 10d0 * size2
           else if (j1 - j2 .lt. -5) then
              y2 = gy(jscat) - 10d0 * size2
           else
              y2 = gy(jscat)
           end if
           if (iconfg .eq. 4) then
              if (k1 - k2 .gt. 5) then
                 z2 = gz(jscat) + 10d0 * size3
              else if (k1 - k2 .lt. -5) then
                 z2 = gz(jscat) - 10d0 * size3
              else
                 z2 = gz(jscat)
              end if
           else
              z2 = gz(jscat)
           end if
        else if (iconfg .eq. 3 .or. iconfg .eq. 5) then
           x2 = gx(jscat) + dgxa(jscat)
           y2 = gy(jscat) + dgya(jscat)
           if (iconfg .eq. 5) then
              z2 = gz(jscat) + dgza(jscat)
           else
              z2 = gz(jscat)
           end if
        end if
        t2 = ft(jscat)
ctrans
        rts2 = (e1 + e2) ** 2 - (px1 + px2) ** 2 -
     &     (py1 + py2) ** 2 - (pz1 + pz2) ** 2
ctransend
        bex = (px1 + px2) / (e1 + e2)
        bey = (py1 + py2) / (e1 + e2)
        bez = (pz1 + pz2) / (e1 + e2)

clin-11/2015-ctest off
c        write(99,*) 'iscat,jscat,etotalA=',iscat,jscat,e1+e2

        call lorenz(e1, px1, py1, pz1, bex, bey, bez)
cc      SAVE pxnew, ..., values for later use.
        px1 = pxnew
        py1 = pynew
        pz1 = pznew
        e1 = enenew

        pp2 = pxnew ** 2 + pynew ** 2 + pznew ** 2
        call getht(iscat, jscat, pp2, that)
        theta = dacos(that / (2d0 * pp2) + 1d0)
        theta = dble(iff) * theta

c       we boost to the cm frame, get rotation axis, and rotate 1 particle 
c       momentum

        call lorenz(t1, x1, y1, z1, bex, bey, bez)

        x1 = pxnew
        y1 = pynew
        z1 = pznew

        call lorenz(t2, x2, y2, z2, bex, bey, bez)

        x2 = pxnew
        y2 = pynew
        z2 = pznew

c       notice now pxnew, ..., are new positions
        call cropro(x1-x2, y1-y2, z1-z2, px1, py1, pz1)

        call xnormv(xn1, xn2, xn3)

cbz1/29/99
c        call rotate(xn1, xn2, xn3, theta, px1, py1, pz1)
        call zprota(xn1, xn2, xn3, theta, px1, py1, pz1)
cbz1/29/99end

c       we invert the momentum to get the other particle's momentum
        px2 = -px1
        py2 = -py1
        pz2 = -pz1
clin-4/13/01: modify in case m1, m2 are different:
c        e2 = e1
        e2 = dsqrt(px2**2+py2**2+pz2**2+xmass(jscat)**2)

clin-11/2015-ctest off
c        write(99,*) 'iscat,jscat,masses= ',iscat,jscat,
c     1       xmass(iscat),xmass(jscat)

c       boost the 2 particle 4 momentum back to lab frame
        call lorenz(e1, px1, py1, pz1, -bex, -bey, -bez)
        px(iscat) = pxnew
        py(iscat) = pynew
        pz(iscat) = pznew
        e(iscat) = enenew
        call lorenz(e2, px2, py2, pz2, -bex, -bey, -bez)        
        px(jscat) = pxnew
        py(jscat) = pynew
        pz(jscat) = pznew
        e(jscat) = enenew

clin-11/2015-ctest off
c        write(99,*) 'iscat,jscat,etotalB= ',iscat,jscat,
c     1       e(iscat)+e(jscat)

        vx(iscat) = px(iscat) / e(iscat)
        vy(iscat) = py(iscat) / e(iscat)
        vz(iscat) = pz(iscat) / e(iscat)
        vx(jscat) = px(jscat) / e(jscat)
        vy(jscat) = py(jscat) / e(jscat)
        vz(jscat) = pz(jscat) / e(jscat)
        
        last(iscat) = jscat
        last(jscat) = iscat

        if (iconfg .le. 3) then
           if (e(iscat) .le. abs(pz(iscat))) then
              rap(iscat) = 1000000.d0
           else
              rap(iscat) = 0.5d0 * log((e(iscat) + pz(iscat)) /
     &           (e(iscat) - pz(iscat)))
           end if

           if (e(jscat) .le. abs(pz(jscat))) then
              rap(jscat) = 1000000.d0
           else
              rap(jscat) = 0.5d0 * log((e(jscat) + pz(jscat)) /
     &           (e(jscat) - pz(jscat)))
           end if

ctrans
           rap1 = rap(iscat)
           rap2 = rap(jscat)

           if ((rap1 .lt. centy + 0.5d0 .and.
     &        rap1 .gt. centy - 0.5d0)) then
c              write (9, *) sqrt(ft(iscat) ** 2 - gz(iscat) ** 2), rts2
           end if
           if ((rap2 .lt. centy + 0.5d0 .and.
     &        rap2 .gt. centy - 0.5d0)) then
c              write (9, *) sqrt(ft(jscat) ** 2 - gz(jscat) ** 2), rts2
           end if
ctransend
        end if

clin-11/2015-ctest off
c        write(99,*) 'iscat,jscat,xmp,xmu,that=',iscat,jscat,xmp,xmu,that

        return
        end

        subroutine getht(iscat, jscat, pp2, that)

c       this subroutine is used to get \hat{t} for a particular processes

        implicit double precision (a-h, o-z)

        parameter (hbarc = 0.197327054d0)
        parameter (MAXPTN=400001)
        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common/anim/nevent,isoft,isflag,izpc
cc      SAVE /anim/
        external ran1
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        SAVE   

        iseed=iseedp
        xmu2 = (hbarc * xmu) ** 2
        xmp2 = xmp ** 2
        xm2 = xmu2 + xmp2
        rx=ran1(iseed)
        that = xm2*(1d0+1d0/((1d0-xm2/(4d0*pp2+xm2))*rx-1d0))
ctest off isotropic scattering:
c     &     + 1d0/((1d0 - xm2 / (4d0 * pp2 + xm2)) * ran1(2) - 1d0))
c        if(izpc.eq.100) that=-4d0*pp2*ran1(2)
        if(izpc.eq.100) that=-4d0*pp2*rx

        return
        end

      subroutine ulist(t)
c     this subroutine is used to update a new collision time list
c       notice this t has been updated

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        SAVE   

        if (ictype .eq. 1 .or. ictype .eq. 2 .or. ictype .eq. 5
     &     .or. ictype .eq. 6) then
           l = ifmpt
           call ulist1(l, t)
        end if
        if (ictype .ne. 1) then
           l = iscat
           call ulist1(l, t)
           if (jscat .ne. 0) then
              l = jscat
              call ulist1(l, t)
           end if
        end if

        return
        end

        subroutine ulist1(l, t)
c       this subroutine is used to update the interaction list when particle
c       l is disturbed.

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        icels0 = icels(l)
        i1 = icels0 / 10000
        i2 = (icels0 - i1 * 10000) / 100
        i3 = icels0 - i1 * 10000 - i2 * 100
c       save collision info for use when the collision is a collision with wall
c       otherwise wallc will change icsta
        k = mod(icsta(l), 10)

        call wallc(l, i1, i2, i3, t, tmin1)
        tmin = tmin1
        nc = 0

        if (i1 .eq. 11 .and. i2 .eq. 11 .and. i3 .eq. 11) then
           call chkout(l, t, tmin, nc)
        else
           if (iconfg .eq. 1) then
              call chkin1(l, i1, i2, i3, t, tmin, nc)
           else if (iconfg .eq. 2) then
              call chkin2(l, i1, i2, i3, t, tmin, nc)
           else if (iconfg .eq. 4) then
              call chkin3(l, i1, i2, i3, t, tmin, nc)
           else if (iconfg .eq. 3 .or. iconfg .eq. 5) then
              call chkcel(l, i1, i2, i3, t, tmin, nc)
           end if
        end if
        
        call fixtim(l, t, tmin1, tmin, nc)

        return
        end
        
        subroutine wallc(i, i1, i2, i3, t, tmin)
c       this subroutine calculates the next time for collision with wall 
c       for particle i
c       input particle label i,t
c       output tmin collision time with wall, icsta(i) wall collision
c       information

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        tmin = tlarge

        if (iconfg .le. 2 .or. iconfg .eq. 4) then
c       if particle is inside the cube
           if ((i1 .ge. 1 .and. i1 .le. 10)
     &          .or. (i2 .ge. 1 .and. i2 .le. 10)
     &          .or. (i3 .ge. 1 .and. i3 .le. 10)) then
              call wallc1(i, i1, i2, i3, t, tmin)
c       if particle is outside the cube
           else
              call wallcb(i, t, tmin)              
           end if
        else if (iconfg .eq. 3 .or. iconfg .eq. 5) then
           call wallc2(i, i1, i2, i3, t, tmin)
        end if

        return
        end

        subroutine wallc1(i, i1, i2, i3, t, tmin)
c       this subroutine is used to get wall collision time
c       when particle is inside the cube, it sets the icsta at the same time
c       input i,i1,i2,i3,t
c       output tmin, icsta(i)
c       note the icsta is not finally set. we need further judgement in 
c       fixtim

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        x1p = gx(i)
        x2p = gy(i)
        x3p = gz(i)
        tf = ft(i)
        v1p = vx(i)
        v2p = vy(i)
        v3p = vz(i)

        if (t .lt. size .and. tf .lt. size) then

           if (v1p .gt. 0d0) then
              t1 = ((dble(i1) - 5d0) * size1 - x1p) / v1p + tf
           else if (v1p .lt. 0d0) then
              t1 = ((dble(i1) - 6d0) * size1 - x1p) / v1p + tf
           else
              t1 = tlarge
           end if
           
           if (v2p .gt. 0d0) then
              t2 = ((dble(i2) - 5d0) * size2 - x2p) / v2p + tf
           else if (v2p .lt. 0d0) then
              t2 = ((dble(i2) - 6d0) * size2 - x2p) / v2p + tf
           else
              t2 = tlarge
           end if
           
           if (v3p .gt. 0d0) then
              t3 = ((dble(i3) - 5d0) * size3 - x3p) / v3p + tf
           else if (v3p .lt. 0d0) then
              t3 = ((dble(i3) - 6d0) * size3 - x3p) / v3p + tf
           else
              t3 = tlarge
           end if
           
c       if a particle is on the wall, we don't collide it on the same wall
           
c        if (t1 .eq. 0d0) t1 = tlarge
c        if (t2 .eq. 0d0) t2 = tlarge
c        if (t3 .eq. 0d0) t3 = tlarge
           
           tmin = min(t1, t2, t3)
           
c       set icsta,
c       after checking this is not an earlier collision comparing with 
c       a collision with another particle, we need to set icsta=0
c       after checking whether there is also a particle collision 
c       at the same time, we need to reset the second bit of icsta
           
           if (tmin .eq. t1) then
              if (v1p .gt. 0d0) then
                 icsta(i) = 101
              else
                 icsta(i) = 102
              end if
           end if
           
           if (tmin .eq. t2) then
              if (v2p .gt. 0d0) then
                 icsta(i) = 103
              else
                 icsta(i) = 104
              end if
           end if
           
           if (tmin .eq. t3) then
              if (v3p .gt. 0d0) then
                 icsta(i) = 105
              else
                 icsta(i) = 106
              end if
           end if
           
        if (tmin .le. size) return

        end if

        if (v1p .gt. (i1 - 5) * v1) then
           t1 = ((i1 - 5) * (size1 - v1 * size) +
     &          v1p * tf - x1p) / (v1p - (i1 - 5) * v1)
        else if (v1p .lt. (i1 - 6) * v1) then
           t1 = ((i1 - 6) * (size1 - v1 * size) +
     &          v1p * tf - x1p) / (v1p - (i1 - 6) * v1)
        else
           t1 = tlarge
        end if
        
        if (v2p .gt. (i2 - 5) * v2) then
           t2 = ((i2 - 5) * (size2 - v2 * size) +
     &          v2p * tf - x2p) / (v2p - (i2 - 5) * v2)
        else if (v2p .lt. (i2 - 6) * v2) then
           t2 = ((i2 - 6) * (size2 - v2 * size) +
     &          v2p * tf - x2p) / (v2p - (i2 - 6) * v2)
        else
           t2 = tlarge
        end if
        
        if (v3p .gt. (i3 - 5) * v3) then
           t3 = ((i3 - 5) * (size3 - v3 * size) +
     &          v3p * tf - x3p) / (v3p - (i3 - 5) * v3)
        else if (v3p .lt. (i3 - 6) * v3) then
           t3 = ((i3 - 6) * (size3 - v3 * size) +
     &          v3p * tf - x3p) / (v3p - (i3 - 6) * v3)
        else
           t3 = tlarge
        end if
        
c       if a particle is on the wall, we don't collide it on the same wall
        
c        if (t1 .eq. 0d0) t1 = tlarge
c        if (t2 .eq. 0d0) t2 = tlarge
c        if (t3 .eq. 0d0) t3 = tlarge
        
        tmin = min(t1, t2, t3)
        
c       set icsta,
c       after checking this is not an earlier collision comparing with 
c       a collision with another particle, we need to set icsta=0
c       after checking whether there is also a particle collision 
c       at the same time, we need to reset the second bit of icsta
        
        if (tmin .eq. t1) then
           if (v1p .gt. (i1 - 5) * v1) then
              icsta(i) = 101
           else
              icsta(i) = 102
           end if
        end if
        
        if (tmin .eq. t2) then
           if (v2p .gt. (i2 - 5) * v2) then
              icsta(i) = 103
           else
              icsta(i) = 104
           end if
        end if
        
        if (tmin .eq. t3) then
           if (v3p .gt. (i3 - 5) * v3) then
              icsta(i) = 105
           else
              icsta(i) = 106
           end if
        end if
        
        return
        end

        subroutine wallc2(i, i1, i2, i3, t, tmin)
c       this subroutine is used to get wall collision time
c       when particle is inside the cube, it sets the icsta at the same time
c       input i,i1,i2,i3,t
c       output tmin, icsta(i)
c       note the icsta is not finally set. we need further judgement in 
c       fixtim

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        x1p = gx(i)
        x2p = gy(i)
        x3p = gz(i)
        tf = ft(i)
        v1p = vx(i)
        v2p = vy(i)
        v3p = vz(i)

        if (v1p .gt. 0d0) then
           t1 = (5d0 * size1 - x1p) / v1p + tf
        else if (v1p .lt. 0d0) then
           t1 = (-5d0 * size1 - x1p) / v1p + tf
        else
           t1 = tlarge
        end if
        
        if (v2p .gt. 0d0) then
           t2 = (5d0 * size2 - x2p) / v2p + tf
        else if (v2p .lt. 0d0) then
           t2 = (- 5d0 * size2 - x2p) / v2p +tf
        else
           t2 = tlarge
        end if

        if (iconfg .eq. 5) then
           if (v3p .gt. 0d0) then
              t3 = (5d0 * size3 - x3p) / v3p + tf
           else if (v3p .lt. 0d0) then
              t3 = (- 5d0 * size3 - x3p) / v3p +tf
           else
              t3 = tlarge
           end if
        else
           t3 = tlarge
        end if
           
        tmin = min(t1, t2, t3)
        
c       set icsta,
c       after checking this is not an earlier collision comparing with 
c       a collision with another particle, we need to set icsta=0
c       after checking whether there is also a particle collision 
c       at the same time, we need to reset the second bit of icsta
           
        if (tmin .eq. t1) then
           if (v1p .gt. 0d0) then
              icsta(i) = 101
           else
              icsta(i) = 102
           end if
        end if
        
        if (tmin .eq. t2) then
           if (v2p .gt. 0d0) then
              icsta(i) = 103
           else
              icsta(i) = 104
           end if
        end if

        if (tmin .eq. t3) then
           if (v3p .gt. 0d0) then
              icsta(i) = 105
           else
              icsta(i) = 106
           end if
        end if
           
        return
        end

        subroutine wallcb(i, t, tmin)
c       this subroutine is used to calculate the wall collision time 
c       when the particle is outside the cube
c       input i,t
c       output tmin,icsta(i)
c       note the icsta is not finally set. we need further judgement in 
c       fixtim

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

c       check if there is a collision by looking at the closest approach point
c       and see if it's inside the cube

        if (size1 .eq. 0d0 .or. size2 .eq. 0d0 .or. 
     &     size3 .eq. 0d0) return

        x1p = gx(i)
        x2p = gy(i)
        x3p = gz(i)
        v1p = vx(i)
        v2p = vy(i)
        v3p = vz(i)
        tf = ft(i)

        if (t .lt. size .and. tf .lt. size) then
           if (x1p .lt. - 5d0 * size1 .and. v1p .gt. 0d0) then
              t1 = (- 5d0 * size1 - x1p) / v1p + tf
           else if(x1p .gt. 5d0 * size1 .and. v1p .lt. 0d0) then
              t1 = - (x1p - 5d0 * size1) / v1p + tf
           else
              t1 = tlarge 
           end if

           if (t1 .ne. tlarge) then
              x2pp = x2p + v2p * (t1 - tf)
              x3pp = x3p + v3p * (t1 - tf)
              if (x2pp .le. - 5d0 * size2 .or. x2pp .ge. 5d0 * size2
     &             .or. x3pp .le. - 5d0 * size3 
     &             .or. x3pp .ge. 5d0 * size3)
     &             t1 = tlarge
           end if
           
           if (x2p .lt. - 5d0 * size2 .and. v2p .gt. 0d0) then
              t2 = (- 5d0 * size2 - x2p) / v2p + tf
           else if(x2p .gt. 5d0 * size2 .and. v2p .lt. 0d0) then
              t2 = - (x2p - 5d0 * size2) / v2p + tf
           else
              t2 = tlarge 
           end if
           
           if (t2 .ne. tlarge) then
              x1pp = x1p + v1p * (t2 - tf)
              x3pp = x3p + v3p * (t2 - tf)
              if (x1pp .le. - 5d0 * size1 .or. x1pp .ge. 5d0 * size1
     &          .or. x3pp .le. - 5d0 * size3 .or. x3pp .ge. 5d0 * size3)
     &             t2 = tlarge
           end if
           
           if (x3p .lt. - 5d0 * size3 .and. v3p .gt. 0d0) then
              t3 = (- 5d0 * size3 - x3p) / v3p + tf
           else if(x3p .gt. 5d0 * size3 .and. v3p .lt. 0d0) then
              t3 = - (x3p - 5d0 * size3) / v3p + tf
           else
              t3 = tlarge 
           end if
           
           if (t3 .ne. tlarge) then
              x1pp = x1p + v1p * (t3 - tf)
              x2pp = x2p + v2p * (t3 - tf)
              if (x1pp .le. - 5d0 * size1 .or. x1pp .ge. 5d0 * size1
     &          .or. x2pp .le. - 5d0 * size2 .or. x2pp .ge. 5d0 * size2)
     &             t3 = tlarge
           end if
           
           tmin = min(t1, t2, t3)

c       set icsta,
c       after checking this is not an earlier collision comparing with 
c       a collision with another particle, we need to set icsta=0
c       after checking whether there is also a particle collision 
c       at the same time, we need to reset the second bit of icsta

           if (tmin .eq. t1) then
              if (v1p .gt. 0d0) then
                 icsta(i) = 101
              else
                 icsta(i) = 102
              end if
           end if
           
           if (tmin .eq. t2) then
              if (v2p .gt. 0d0) then
                 icsta(i) = 103
              else
                 icsta(i) = 104
              end if
           end if
        
           if (tmin .eq. t3) then
              if (v3p .gt. 0d0) then
                 icsta(i) = 105
              else
                 icsta(i) = 106
              end if
           end if
           
        if (tmin .le. size) return

        end if

c       notice now x1q, x2q, x3q are coordinates at time t
        x1q = x1p + v1p * (t - tf)
        x2q = x2p + v2p * (t - tf)
        x3q = x3p + v3p * (t - tf)

        if (x1q .lt. - 5d0 * (size1 + v1 * (t - size)) .and. 
     &      v1p .gt. - 5d0 * v1) then
           t1 = (- 5d0 * (size1 - v1 * size) + v1p * tf - x1p) /
     &          (v1p - (- 5d0) * v1)
           icsta1 = 101
        else if (x1q .gt. 5d0 * (size1 + v1 * (t-size)) .and. 
     &     v1p .lt. 5d0 * v1) then
           t1 = (5d0 * (size1 - v1 * size) + v1p * tf - x1p) /
     &          (v1p - 5d0 * v1)
           icsta1 = 102
        else
           t1 = tlarge 
        end if
        
        if (t1 .ne. tlarge) then
           x2pp = x2p + v2p * (t1 - tf)
           x3pp = x3p + v3p * (t1 - tf)
           if (x2pp .le. - 5d0 * (size2 + v2 * (t1 - size))
     &        .or. x2pp .ge. 5d0 * (size2 + v2 * (t1 - size))
     &        .or. x3pp .le. - 5d0 * (size3 + v3 * (t1 - size))
     &        .or. x3pp .ge. 5d0 * (size3 + v3 * (t1 - size)))
     &        t1 = tlarge
        end if

        if (x2q .lt. - 5d0 * (size2 + v2 * (t - size)) .and.
     &     v2p .gt. - 5d0 * v2) then
           t2 = (- 5d0 * (size2 - v2 * size) + v2p * tf - x2p) /
     &          (v2p - (- 5d0) * v2)
           icsta2 = 103
        else if (x2q .gt. 5d0 * (size2 + v2 * (t - size)) .and.
     &     v2p .lt. 5d0 * v2) then
           t2 = (5d0 * (size2 - v2 * size) + v2p * tf - x2p) / 
     &          (v2p - 5d0 * v2)
           icsta2 = 104
        else
           t2 = tlarge 
        end if
        
        if (t2 .ne. tlarge) then
           x1pp = x1p + v1p * (t2 - tf)
           x3pp = x3p + v3p * (t2 - tf)
           if (x1pp .le. - 5d0 * (size1 + v1 * (t2 - size))
     &        .or. x1pp .ge. 5d0 * (size1 + v1 * (t2 - size))
     &        .or. x3pp .le. - 5d0 * (size3 + v3 * (t2 - size))
     &        .or. x3pp .ge. 5d0 * (size3 + v3 * (t2 - size)))
     &        t2 = tlarge
        end if

        if (x3q .lt. - 5d0 * (size3 + v3 * (t - size)) .and. 
     &     v3p .gt. - 5d0 * v3) then
           t3 = (- 5d0 * (size3 - v3 * size) + v3p * tf - x3p) /
     &          (v3p - (- 5d0) * v3)
           icsta3 = 105
        else if (x3q .gt. 5d0 * (size3 + v3 * (t - size)) .and.
     &     v3p .lt. 5d0 * v3) then
           t3 = (5d0 * (size3 - v3 * size) + v3p * tf - x3p) /
     &          (v3p - 5d0 * v3)
           icsta3 = 106
        else
           t3 = tlarge 
        end if
        
        if (t3 .ne. tlarge) then
           x2pp = x2p + v2p * (t3 - tf)
           x1pp = x1p + v1p * (t3 - tf)
           if (x2pp .le. - 5d0 * (size2 + v2 * (t3 - size))
     &        .or. x2pp .ge. 5d0 * (size2 + v2 * (t3 - size))
     &        .or. x1pp .le. - 5d0 * (size1 + v1 * (t3 - size))
     &        .or. x1pp .ge. 5d0 * (size1 + v1 * (t3 - size)))
     &        t3 = tlarge
        end if
        
        tmin = min(t1, t2, t3)
        
c       set icsta,
c       after checking this is not an earlier collision comparing with 
c       a collision with another particle, we need to set icsta=0
c       after checking whether there is also a particle collision 
c       at the same time, we need to reset the second bit of icsta
        
        if (tmin .eq. t1) then
           icsta(i) = icsta1
        else if (tmin .eq. t2) then
           icsta(i) = icsta2
        else if (tmin .eq. t3) then
           icsta(i) = icsta3
        end if
        
        return
        end
           
        subroutine chkout(l, t, tmin, nc)
c       this subroutine is used to check the collisions with particles in 
c       surface cells to see if we can get a smaller collision time than tmin
c       with particle nc, when the colliding particle is outside the cube
c       input l,t,tmin,nc
c       output tmin, nc

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        SAVE   

        m1 = 11
        m2 = 11
        m3 = 11
        call chkcel(l, m1, m2, m3, t, tmin, nc)

        do 1003 i = 1, 10
           do 1002 j = 1, 10
              do 1001 k = 1, 10
                 if (i .eq. 1 .or. i .eq. 10 .or. j .eq. 1
     &              .or. j .eq. 10 .or. k .eq. 1 .or. k .eq. 10) 
     &                    call chkcel(l, i, j, k, t, tmin, nc)
 1001         continue
 1002      continue
 1003   continue

        return
        end

        subroutine chkin1(l, i1, i2, i3, t, tmin, nc)
c       this subroutine is used to check collisions for particle inside
c       the cube
c       and update the afftected particles through chkcel

        implicit double precision (a-h, o-z)
        SAVE   

c       itest is a flag to make sure the 111111 cell is checked only once
        itest = 0
        
        do 1003 i = i1 - 1, i1 + 1
           do 1002 j = i2 - 1, i2 + 1
              do 1001 k =  i3 - 1, i3 + 1
                 if (i .ge. 1 .and. i .le. 10 .and. j .ge. 1 .and.
     &               j .le. 10 .and. k .ge. 1 .and. k .le. 10) then
                    call chkcel(l, i, j, k, t, tmin, nc)
                 else if (itest .eq. 0) then
                    m1 = 11
                    m2 = 11
                    m3 = 11
                    call chkcel(l, m1, m2, m3, t, tmin, nc)
                    itest = 1
                 end if   
 1001         continue
 1002      continue
 1003   continue

        return
        end

        subroutine chkin2(l, i1, i2, i3, t, tmin, nc)
c       this subroutine is used to check collisions for particle inside
c       the cube
c       and update the afftected particles through chkcel

        implicit double precision (a-h, o-z)
        SAVE   

c       itest is a flag to make sure the 111111 cell is checked only once
        itest = 0
        
        do 1003 i = i1 - 1, i1 + 1
           do 1002 j = i2 - 1, i2 + 1
              do 1001 k =  i3 - 1, i3 + 1
                 ia = i
                 ib = j
                 ic = k
                 if (k .ge. 1 .and. k .le. 10) then
                    if (i .eq. 0) ia = 10
                    if (i .eq. 11) ia = 1
                    if (j .eq. 0) ib = 10
                    if (j .eq. 11) ib = 1
                    call chkcel(l, ia, ib, ic, t, tmin, nc)
                 end if
 1001         continue
 1002      continue
 1003   continue

        return
        end

        subroutine chkin3(l, i1, i2, i3, t, tmin, nc)
c       this subroutine is used to check collisions for particle inside
c       the cube
c       and update the afftected particles through chkcel

        implicit double precision (a-h, o-z)
        SAVE   

c       itest is a flag to make sure the 111111 cell is checked only once
        itest = 0
        
        do 1003 i = i1 - 1, i1 + 1
           do 1002 j = i2 - 1, i2 + 1
              do 1001 k =  i3 - 1, i3 + 1
                 if (i .eq. 0) then
                    ia = 10
                 else if (i .eq. 11) then
                    ia = 1
                 else
                    ia = i
                 end if
                 if (j .eq. 0) then
                    ib = 10
                 else if (j .eq. 11) then
                    ib = 1
                 else
                    ib = j
                 end if
                 if (k .eq. 0) then
                    ic = 10
                 else if (k .eq. 11) then
                    ic = 1
                 else
                    ic = k
                 end if
                 call chkcel(l, ia, ib, ic, t, tmin, nc)
 1001         continue
 1002      continue
 1003   continue

        return
        end

        subroutine chkcel(il, i1, i2, i3, t, tmin, nc)
c       this program is used to check through all the particles
c       in the cell (i1,i2,i3) and see if we can get a particle collision 
c       with time less than the original input tmin ( the collision time of 
c       il with the wall
c       and update the affected particles

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist2/ icell, icel(10, 10, 10)
cc      SAVE /ilist2/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        SAVE   

        if (iconfg .eq. 3 .or. iconfg .eq. 5) then
           jj = ichkpt
           do 1001 j = 1, jj
              call ck(j, ick)
c     10/24/02 get rid of argument usage mismatch in ud2():
                            jud2=j
c              if (ick .eq. 1) call ud2(j, il, t, tmin, nc)
              if (ick .eq. 1) call ud2(jud2, il, t, tmin, nc)
 1001      continue
           return
        end if

        if (i1 .eq. 11 .and. i2 .eq. 11 .and. i3 .eq. 11) then
           l = icell
        else
           l = icel(i1, i2, i3)
        end if

c       if there is no particle
        if (l .eq. 0) then
           return
        end if
        j = nic(l)
c       if there is only one particle
        if (j .eq. 0) then
           call ck(l, ick)
           if (ick .eq. 1) call ud2(l, il, t, tmin, nc)

c       if there are many particles
        else

c       we don't worry about the other colliding particle because it's
c       set in last(), and will be checked in ud2

           call ck(l, ick)
           if (ick .eq. 1) call ud2(l, il, t, tmin, nc)

           do 10 while(j .ne. l)
              call ck(j, ick)
              if (ick .eq. 1) call ud2(j, il, t, tmin, nc)
              j = nic(j)
 10           continue
        end if

        return
        end

        subroutine ck(l, ick)
c       this subroutine is used for chcell to check whether l should be
c       checked or not for updating tmin, nc
c       input l
c       output ick
c       if ick=1, l should be checked, otherwise it should not be.

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        SAVE   

        ick = 1
        if (ictype .eq. 1) then
           if (l .eq. ifmpt) ick = 0
        else if (ictype .eq. 0 .or. ictype .eq. 3 .or. 
     &     ictype .eq. 4) then
           if (l .eq. iscat .or. l .eq. jscat) ick = 0
        else
           if (l .eq. iscat .or. l .eq. jscat .or.
     &         l .eq. ifmpt) ick = 0
        end if
c       notice il is either iscat or jscat, or ifmpt, we deal with them
c       seperately according to ictype

        return
        end
           
        subroutine dchout(l, ii, t)
c       this subroutine is used to check collisions of l with particles when 
c       l is outside the cube and the collision just happened is a collision
c       including a collision with wall (hence we need to use dcheck to throw
c       away old collisions that are not in the new neighboring cells.

c       input l,t

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        external integ

        tt = ft(l)
        td = t - size
        x1 = gx(l) + vx(l) * (t - tt)
        x2 = gy(l) + vy(l) * (t - tt)
        x3 = gz(l) + vz(l) * (t - tt)
        if (td .le. 0d0) then
           i1 = integ(x1 / size1) + 6
           i2 = integ(x2 / size2 ) + 6
           i3 = integ(x3 / size3 ) + 6
           if (integ(x1 / size1) .eq. x1 / size1 .and. vx(l) .lt. 0d0)
     &        i1 = i1 - 1
           if (integ(x2 / size2) .eq. x2 / size2 .and. vy(l) .lt. 0d0)
     &        i2 = i2 - 1
           if (integ(x3 / size3) .eq. x3 / size3 .and. vz(l) .lt. 0d0)
     &        i3 = i3 - 1
        else
           i1 = integ(x1 / (size1 + v1 * td)) + 6
           i2 = integ(x2 / (size2 + v2 * td)) + 6
           i3 = integ(x3 / (size3 + v3 * td)) + 6
c     10/24/02 (i) below should be (l):
           if (integ(x1 / (size1 + v1 * td)) .eq. 
     &        x1 / (size1 +v1 * td) .and. 
     &        vx(l) .lt. (i1 - 6) * v1) i1 = i1 - 1
c     &        vx(i) .lt. (i1 - 6) * v1) i1 = i1 - 1
           if (integ(x2 / (size2 + v2 * td)) .eq.
     &        x2 / (size2 + v2 * td) .and.
     &        vy(l) .lt. (i2 - 6) * v2) i2 = i2 - 1
c     &        vy(i) .lt. (i2 - 6) * v2) i2 = i2 - 1
           if (integ(x3 / (size3 + v3 * td)) .eq. 
     &        x3 / (size3 + v3 * td) .and.
     &        vz(l) .lt. (i3 - 6) * v3) i3 = i3 - 1
c     &        vz(i) .lt. (i3 - 6) * v3) i3 = i3 - 1
        end if

        if (ii .eq. 1) then
           i = 9
           do 1002 j = i2 - 1, i2 + 1
              do 1001 k = i3 - 1, i3 + 1
                 if (j .ge. 1 .and. j .le. 10 .and. k .ge. 1 .and.
     &              k .le. 10) then
                    call dchcel(l, i, j, k, t)
                 end if
 1001         continue
 1002      continue
        end if

        if (ii .eq. 2) then
           i = 2
           do 1004 j = i2 - 1, i2 + 1
              do 1003 k = i3 - 1, i3 + 1
                 if (j .ge. 1 .and. j .le. 10 .and. k .ge. 1 .and. 
     &              k .le. 10) then
                    call dchcel(l, i, j, k, t)
                 end if
 1003         continue
 1004      continue
        end if

        if (ii .eq. 3) then
           j = 9
           do 1006 i = i1 - 1, i1 + 1
              do 1005 k = i3 - 1, i3 + 1
                 if (i .ge. 1 .and. i .le. 10 .and. k .ge. 1 .and.
     &              k .le. 10) then
                    call dchcel(l, i, j, k, t)
                 end if
 1005         continue
 1006      continue
        end if

        if (ii .eq. 4) then
           j = 2
           do 1008 i = i1 - 1, i1 + 1
              do 1007 k = i3 - 1, i3 + 1
                 if (i .ge. 1 .and. i .le. 10 .and. k .ge. 1 .and.
     &              k .le. 10) then
                    call dchcel(l, i, j, k, t)
                 end if
 1007         continue
 1008      continue
        end if

        if (ii .eq. 5) then
           k = 9
           do 1010 i = i1 - 1, i1 + 1
              do 1009 j = i2 - 1, i2 + 1
                 if (i .ge. 1 .and. i .le. 10 .and. j .ge. 1 .and.
     &              j .le. 10) then
                    call dchcel(l, i, j, k, t)
                 end if
 1009         continue
 1010      continue
        end if

        if (ii .eq. 6) then
           k = 2
           do 1012 i = i1 - 1, i1 + 1
              do 1011 j = i2 - 1, i2 + 1
                 if (i .ge. 1 .and. i .le. 10 .and. j .ge. 1 .and.
     &              j .le. 10) then
                    call dchcel(l, i, j, k, t)
                 end if
 1011         continue
 1012      continue
        end if

        return
        end

        subroutine dchin1(l, ii, i1, i2, i3, t)
c       this subroutine is used to check collisions for particle inside
c       the cube when the collision just happened is a collision including 
c       collision with wall
c       and update the afftected particles through chkcel

c       input l,ii(specifying the direction of the wall collision),
c          i1,i2,i3, (specifying the position of the cell 
c                    we are going to check)
c          t

        implicit double precision (a-h, o-z)
        SAVE   

c       itest is a flag to make sure the 111111 cell is checked only once
        itest = 0
        
        if (ii .eq. 1) then
           if (i1 .eq. 1) goto 100
           if (i1 .eq. 2) then
              if (i2 .ge. 2 .and. i2 .le. 9 .and. i3 .ge. 2 .and.
     &           i3 .le. 9) then
                 i = 11
                 j = 11
                 k = 11
                 call dchcel(l, i, j, k, t)
              end if
              goto 100
           end if
           i = i1 - 2
           do 1002 j = i2 - 1, i2 + 1
              do 1001 k = i3 - 1, i3 + 1
                 if (j .ge. 1 .and. j .le. 10 .and. k .ge. 1 .and.
     &              k .le. 10)
     &                    call dchcel(l, i, j, k, t)
 1001         continue
 1002      continue
        end if

        if (ii .eq. 2) then
           if (i1 .eq. 10) goto 100
           if (i1 .eq. 9) then
              if (i2 .ge. 2 .and. i2 .le. 9 .and. i3 .ge. 2 .and.
     &           i3 .le. 9) then
                 i = 11
                 j = 11
                 k = 11
                 call dchcel(l, i, j, k, t)
              end if
              goto 100
           end if
           i = i1 + 2
           do 1004 j = i2 - 1, i2 + 1
              do 1003 k = i3 - 1, i3 + 1
                 if (j .ge. 1 .and. j .le. 10 .and. k .ge. 1 .and.
     &              k .le. 10)
     &                    call dchcel(l, i, j, k, t)
 1003         continue
 1004      continue
        end if

        if (ii .eq. 3) then
           if (i2 .eq. 1) goto 100
           if (i2 .eq. 2) then
              if (i1 .ge. 2 .and. i1 .le. 9 .and. i3 .ge. 2 .and.
     &           i3 .le. 9) then
                 i = 11
                 j = 11
                 k = 11
                 call dchcel(l, i, j, k, t)
              end if
              goto 100
           end if
           j = i2 - 2
           do 1006 i = i1 - 1, i1 + 1
              do 1005 k = i3 - 1, i3 + 1
                 if (i .ge. 1 .and. i .le. 10 .and. k .ge. 1 .and.
     &              k .le. 10)
     &              call dchcel(l, i, j, k, t)
 1005         continue
 1006      continue
        end if

        if (ii .eq. 4) then
           if (i2 .eq. 10) goto 100
           if (i2 .eq. 9) then
              if (i1 .ge. 2 .and. i1 .le. 9 .and. i3 .ge. 2 .and.
     &           i3 .le. 9) then
                 i = 11
                 j = 11
                 k = 11
                 call dchcel(l, i, j, k, t)
              end if
              goto 100
           end if
           j = i2 + 2
           do 1008 i = i1 - 1, i1 + 1
              do 1007 k = i3 - 1, i3 + 1
                 if (i .ge. 1 .and. i .le. 10 .and. k .ge. 1 .and.
     &           k .le. 10)
     &                 call dchcel(l, i, j, k, t)
 1007         continue
 1008      continue
        end if

        if (ii .eq. 5) then
           if (i3 .eq. 1) goto 100
           if (i3 .eq. 2) then
              if (i1 .ge. 2 .and. i1 .le. 9 .and. i2 .ge. 2 .and.
     &           i2 .le. 9) then
                 i = 11
                 j = 11
                 k = 11
                 call dchcel(l, i, j, k, t)
              end if
              goto 100
           end if
           k = i3 - 2
           do 1010 i = i1 - 1, i1 + 1
              do 1009 j = i2 - 1, i2 + 1
                 if (i .ge. 1 .and. i .le. 10 .and. j .ge. 1 .and.
     &           j .le. 10)
     &                 call dchcel(l, i, j, k, t)
 1009         continue
 1010      continue
        end if

        if (ii .eq. 6) then
           if (i3 .eq. 10) goto 100
           if (i3 .eq. 9) then
              if (i1 .ge. 2 .and. i1 .le. 9 .and. i2 .ge. 2 .and.
     &           i2 .le. 9) then
                 i = 11
                 j = 11
                 k = 11
                 call dchcel(l, i, j, k, t)
              end if
              goto 100
           end if
           k = i3 + 2
           do 1012 i = i1 - 1, i1 + 1
              do 1011 j = i2 - 1, i2 + 1
                 if (i .ge. 1 .and. i .le. 10 .and. j .ge. 1 .and.
     &           j .le. 10)
     &                 call dchcel(l, i, j, k, t)
 1011         continue
 1012      continue
        end if

 100        continue

        return
        end

        subroutine dchin2(l, ii, i1, i2, i3, t)
c       this subroutine is used to check collisions for particle inside
c       the cube when the collision just happened is a collision including 
c       collision with wall
c       and update the afftected particles through chkcel

c       input l,ii(specifying the direction of the wall collision),
c          i1,i2,i3, (specifying the position of the cell 
c                    we are going to check)
c          t

        implicit double precision (a-h, o-z)
        SAVE   

        if (ii .eq. 1) then
           i = i1 - 2
           if (i .le. 0) i = i + 10
           ia = i
           do 1002 j = i2 - 1, i2 + 1
              do 1001 k = i3 - 1, i3 + 1
                 ib = j
                 ic = k
                 if (j .eq. 0) ib = 10
                 if (j .eq. 11) ib = 1
                 if (k .ge. 1 .and. k .le. 10) then
                    call dchcel(l, ia, ib, ic, t)
                 end if
 1001         continue
 1002      continue
        end if

        if (ii .eq. 2) then
           i = i1 + 2
           if (i .ge. 11) i = i - 10
           ia = i
           do 1004 j = i2 - 1, i2 + 1
              do 1003 k = i3 - 1, i3 + 1
                 ib = j
                 ic = k
                 if (j .eq. 0) ib = 10
                 if (j .eq. 11) ib = 1
                 if (k .ge. 1 .and. k .le. 10) then
                    call dchcel(l, ia, ib, ic, t)
                 end if
 1003         continue
 1004      continue
        end if

        if (ii .eq. 3) then
           j = i2 - 2
           if (j .le. 0) j = j + 10
           ib = j
           do 1006 i = i1 - 1, i1 + 1
              do 1005 k = i3 - 1, i3 + 1
                 ia = i
                 ic = k
                 if (i .eq. 0) ia = 10
                 if (i .eq. 11) ia = 1
                 if (k .ge. 1 .and. k .le. 10) then
                    call dchcel(l, ia, ib, ic, t)
                 end if
 1005         continue
 1006      continue
        end if

        if (ii .eq. 4) then
           j = i2 + 2
           if (j .ge. 11) j = j - 10
           ib = j
           do 1008 i = i1 - 1, i1 + 1
              do 1007 k = i3 - 1, i3 + 1
                 ia = i
                 ic = k
                 if (i .eq. 0) ia = 10
                 if (i .eq. 11) ia = 1
                 if (k .ge. 1 .and. k .le. 10) then
                    call dchcel(l, ia, ib, ic, t)
                 end if
 1007         continue
 1008      continue
        end if

        if (ii .eq. 5) then
           if (i3 .eq. 2) goto 100
           k = i3 - 2
           ic = k
           do 1010 i = i1 - 1, i1 + 1
              do 1009 j = i2 - 1, i2 + 1
                 ia = i
                 ib = j
                 if (i .eq. 0) ia = 10
                 if (i .eq. 11) ia = 1
                 if (j .eq. 0) ib = 10
                 if (j .eq. 11) ib = 1
                     call dchcel(l, ia, ib, ic, t)
 1009         continue
 1010      continue
        end if

        if (ii .eq. 6) then
           if (i3 .eq. 9) goto 100
           k = i3 + 2
           ic = k
           do 1012 i = i1 - 1, i1 + 1
              do 1011 j = i2 - 1, i2 + 1
                 ia = i
                 ib = j
                 if (i .eq. 0) ia = 10
                 if (i .eq. 11) ia = 1
                 if (j .eq. 0) ib = 10
                 if (j .eq. 11) ib = 1
                     call dchcel(l, ia, ib, ic, t)
 1011         continue
 1012      continue
        end if

 100        continue

        return
        end

        subroutine dchin3(l, ii, i1, i2, i3, t)
c       this subroutine is used to check collisions for particle inside
c       the cube when the collision just happened is a collision including 
c       collision with wall
c       and update the afftected particles through chkcel

c       input l,ii(specifying the direction of the wall collision),
c          i1,i2,i3, (specifying the position of the cell 
c                    we are going to check)
c          t

        implicit double precision (a-h, o-z)
        SAVE   

        if (ii .eq. 1) then
           i = i1 - 2
           if (i .le. 0) i = i + 10
           ia = i
           do 1002 j = i2 - 1, i2 + 1
              do 1001 k = i3 - 1, i3 + 1
                 ib = j
                 ic = k
                 if (j .eq. 0) ib = 10
                 if (j .eq. 11) ib = 1
                 if (k .eq. 0) ic = 10
                 if (k .eq. 11) ic = 1
                 call dchcel(l, ia, ib, ic, t)
 1001         continue
 1002      continue
        end if

        if (ii .eq. 2) then
           i = i1 + 2
           if (i .ge. 11) i = i - 10
           ia = i
           do 1004 j = i2 - 1, i2 + 1
              do 1003 k = i3 - 1, i3 + 1
                 ib = j
                 ic = k
                 if (j .eq. 0) ib = 10
                 if (j .eq. 11) ib = 1
                 if (k .eq. 0) ic = 10
                 if (k .eq. 11) ic = 1
                 call dchcel(l, ia, ib, ic, t)
 1003         continue
 1004      continue
        end if

        if (ii .eq. 3) then
           j = i2 - 2
           if (j .le. 0) j = j + 10
           ib = j
           do 1006 i = i1 - 1, i1 + 1
              do 1005 k = i3 - 1, i3 + 1
                 ia = i
                 ic = k
                 if (i .eq. 0) ia = 10
                 if (i .eq. 11) ia = 1
                 if (k .eq. 0) ic = 10
                 if (k .eq. 11) ic = 1
                 call dchcel(l, ia, ib, ic, t)
 1005         continue
 1006      continue
        end if

        if (ii .eq. 4) then
           j = i2 + 2
           if (j .ge. 11) j = j - 10
           ib = j
           do 1008 i = i1 - 1, i1 + 1
              do 1007 k = i3 - 1, i3 + 1
                 ia = i
                 ic = k
                 if (i .eq. 0) ia = 10
                 if (i .eq. 11) ia = 1
                 if (k .eq. 0) ic = 10
                 if (k .eq. 11) ic = 1
                 call dchcel(l, ia, ib, ic, t)
 1007         continue
 1008      continue
        end if

        if (ii .eq. 5) then
           k = i3 - 2
           if (k .le. 0) k = k + 10
           ic = k
           do 1010 i = i1 - 1, i1 + 1
              do 1009 j = i2 - 1, i2 + 1
                 ia = i
                 ib = j
                 if (i .eq. 0) ia = 10
                 if (i .eq. 11) ia = 1
                 if (j .eq. 0) ib = 10
                 if (j .eq. 11) ib = 1
                     call dchcel(l, ia, ib, ic, t)
 1009         continue
 1010      continue
        end if

        if (ii .eq. 6) then
           k = i3 + 2
           if (k .ge. 11) k = k - 10
           ic = k
           do 1012 i = i1 - 1, i1 + 1
              do 1011 j = i2 - 1, i2 + 1
                 ia = i
                 ib = j
                 if (i .eq. 0) ia = 10
                 if (i .eq. 11) ia = 1
                 if (j .eq. 0) ib = 10
                 if (j .eq. 11) ib = 1
                     call dchcel(l, ia, ib, ic, t)
 1011         continue
 1012      continue
        end if
c
        return
        end

        subroutine dchcel(l, i, j, k, t)
c       this subroutine is used to recalculate next collision time for 
c       particles in the cell i,j,k if the next collision partener is l

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist2/ icell, icel(10, 10, 10)
cc      SAVE /ilist2/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        if (i .eq. 11 .or. j .eq. 11 .or. k .eq. 11) then
           if ( .not. (i .eq. 11 .and. j .eq. 11 .and.
     &     k .eq. 11)) stop 'cerr'
           m = icell
        else
           m = icel(i, j, k)
        end if

        if (m .eq. 0) return
        if (next(m) .eq. l) then
           tm = tlarge
           last0 = 0
           call reor(t, tm, m, last0)
        end if
        n = nic(m)
        if (n .eq. 0) return
        do 10 while(n .ne. m)
           if (next(n) .eq. l) then
              tm = tlarge
              last0 = 0
              call reor(t, tm, n, last0)
           end if
           n = nic(n)
 10        continue

        return
        end

        subroutine fixtim(l, t, tmin1, tmin, nc)
c       this subroutine is used to compare the collision time with wall tmin1
c       and new collision time with particles for particle l
c       when used in ulist, input nc may be 0, which indicates no particle
c       collisions happen before wall collision, of course, then tmin=tmin1

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        k = nc
        if (tmin .lt. tmin1) then
           ot(l) = tmin
           if (ct(l) .lt. tmin1) then
              icsta(l) = 0
           else
              icsta(l) = icsta(l) + 10
           end if
           next(l) = k
        else if (tmin .eq. tmin1) then
           ot(l) = tmin
           if (nc .eq. 0) then
              next(l) = 0
           else
              icsta(l) = icsta(l) + 10
              next(l) = k
           end if
        else
           ot(l) = tmin1
           next(l) = 0
        end if
        
        return
        end

        subroutine ud2(i, j, t, tmin, nc)
c       this subroutine is used to update next(i), ct(i), ot(i),
c        and get tmin, nc for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok

        call isco(i, j, allok, tm, t1, t2)

        if (allok) then
c       tm eq tmin, change nc to make sure fixtime get the collision with both 
c       wall and particle

             if (tm .lt. tmin) then
                tmin = tm
                ct(j) = t2
                nc = i
                if (iconfg .eq. 3 .or. iconfg .eq. 5) then
                   dgxa(j) = jxa * 10d0 * size1
                   dgya(j) = jya * 10d0 * size2
                   if (iconfg .eq. 5) then
                      dgza(j) = jza * 10d0 * size3
                   end if
                end if
             end if

             if (tm .le. ot(i)) then
                ct(i) = t1
                icels0 = icels(i)
                i1 = icels0 / 10000
                i2 = (icels0 - i1 * 10000) / 100
                i3 = icels0 - i1 * 10000 - i2 * 100
                call wallc(i, i1, i2, i3, t, tmin1)
                call fixtim(i, t, tmin1, tm, j)
                if (iconfg .eq. 3 .or. iconfg .eq. 5) then
                   dgxa(i) = - jxa * 10d0 * size1
                   dgya(i) = - jya * 10d0 * size2
                   if (iconfg .eq. 5) then
                      dgza(i) = - jza * 10d0 * size3
                   end if
                end if
             end if

             if (tm .gt. ot(i) .and. next(i) .eq. j) then
                ct(i) = t1
                call reor(t, tm, i, j)
             end if

           else if (next(i) .eq. j) then

             tm = tlarge
                
             call reor(t, tm, i, j)

          end if

        return
        end

        subroutine isco(i, j, allok, tm, t1, t2)

        implicit double precision (a-h, o-z)

        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        SAVE   

        logical allok

        iorder = iordsc / 10
        if (iconfg .eq. 1) then
           if (iorder .eq. 1) then
              call isco1(i, j, allok, tm, t1, t2)
           else if (iorder .eq. 2) then
              call isco2(i, j, allok, tm, t1, t2)
           else if (iorder .eq. 3) then
              call isco3(i, j, allok, tm, t1, t2)
           end if
        else if (iconfg .eq. 2 .or. iconfg .eq. 4) then
           if (iorder .eq. 1) then
              call isco4(i, j, allok, tm, t1, t2)
           else if (iorder .eq. 2) then
              call isco5(i, j, allok, tm, t1, t2)
           else if (iorder .eq. 3) then
              call isco6(i, j, allok, tm, t1, t2)
           end if
        else if (iconfg .eq. 3) then
           if (iorder .eq. 1) then
              call isco7(i, j, allok, tm, t1, t2)
           else if (iorder .eq. 2) then
              call isco8(i, j, allok, tm, t1, t2)
           else if (iorder .eq. 3) then
              call isco9(i, j, allok, tm, t1, t2)
           end if
        else if (iconfg .eq. 5) then
           if (iorder .eq. 1) then
              call isco10(i, j, allok, tm, t1, t2)
           else if (iorder .eq. 2) then
              call isco11(i, j, allok, tm, t1, t2)
           else if (iorder .eq. 3) then
              call isco12(i, j, allok, tm, t1, t2)
           end if
        end if

        return
        end

        subroutine isco1(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

c       set up numbers for later calculations
        i1 = i
        i2 = j

        p4 = ft(i2) - ft(i1)
        p1 = gx(i2) - gx(i1)
        p2 = gy(i2) - gy(i1)
        p3 = gz(i2) - gz(i1)

        q4 = e(i1)
        q1 = px(i1)
        q2 = py(i1)
        q3 = pz(i1)

        r4 = e(i2)
        r1 = px(i2)
        r2 = py(i2)
        r3 = pz(i2)

        a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3
        b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3
        c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3
        d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3
        ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3
        f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3

c       make sure particle 2 formed early
        h = a + b
        if (h .gt. 0d0) then
           g = a
           a = -b
           b = -g

           g = c
           c = d
           d = g

           i1 = j
           i2 = i
        end if

c       check the approaching criteria
        if (allok) then

           vp = a * d - b * ee

           allok = allok .and. vp .lt. 0d0

        end if

c       check the closest approach distance criteria
         if (allok) then

           dm2 = - f - (a ** 2 * d + b ** 2 * c - 2d0 * a * b * ee) /
     &           (ee ** 2 - c * d)

           allok = allok .and. dm2 .lt. cutof2

        end if

c       check the time criteria
        if (allok) then

           tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (ee ** 2 - c * d)
           tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (ee ** 2 - c * d)
           tm = 0.5d0 * (tc1 + tc2)

           allok = allok .and. tm .gt. ft(i) .and. tm .gt. ft(j)

        end if

c        check rts cut
        if (allok) then

           rts2 = (q4 + r4) ** 2 - (q1 + r1) ** 2
     &          - (q2 + r2) ** 2 - (q3 + r3) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if
          
        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else if (h .gt. 0d0) then
           t1 = tm
           t2 = tm
        else
           t1 = tm
           t2 = tm
        end if

        return
        end

        subroutine isco2(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

c       set up numbers for later calculations
        i1 = i
        i2 = j

        p4 = ft(i2) - ft(i1)
        p1 = gx(i2) - gx(i1)
        p2 = gy(i2) - gy(i1)
        p3 = gz(i2) - gz(i1)

        q4 = e(i1)
        q1 = px(i1)
        q2 = py(i1)
        q3 = pz(i1)

        r4 = e(i2)
        r1 = px(i2)
        r2 = py(i2)
        r3 = pz(i2)

        a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3
        b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3
        c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3
        d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3
        ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3
        f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3

c       make sure particle 2 formed early
        h = a + b
        if (h .gt. 0d0) then
           g = a
           a = -b
           b = -g

           g = c
           c = d
           d = g

           i1 = j
           i2 = i
        end if

c       check the approaching criteria
        if (allok) then

           vp = a * d - b * ee

           allok = allok .and. vp .lt. 0d0

        end if

c       check the closest approach distance criteria
         if (allok) then

           dm2 = - f - (a ** 2 * d + b ** 2 * c - 2d0 * a * b * ee) /
     &          (ee ** 2 - c * d)

           allok = allok .and. dm2 .lt. cutof2

        end if

c       check the time criteria
        if (allok) then

           tc1 = ft(i1) - e(i1) * (a * d - b * ee)/(ee ** 2 - c * d)
           tc2 = ft(i2) + e(i2) * (b * c - a * ee)/(ee ** 2 - c * d)
           if (iordsc .eq. 20) then
              tm = min(tc1, tc2)
           else if (iordsc .eq. 21) then
              tm = 0.5d0 * (tc1 + tc2)
           else
              tm = max(tc1, tc2)
           end if

           allok = allok .and. tm .gt. ft(i) .and. tm .gt. ft(j)

        end if

c        check rts cut
        if (allok) then

           rts2 = (q4 + r4) ** 2 - (q1 + r1) ** 2
     &          - (q2 + r2) ** 2 - (q3 + r3) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if
          
        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else if (h .gt. 0d0) then
           t1 = tc2
           t2 = tc1
        else
           t1 = tc1
           t2 = tc2
        end if

        return
        end

        subroutine isco3(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/  
        SAVE   

        logical allok

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

        if (ft(i) .ge. ft(j)) then
           i1 = j
           i2 = i
        else 
           i1 = i
           i2 = j
        end if
        
        if (allok) then

           t1 = ft(i1)
           vx1 = vx(i1)
           vy1 = vy(i1)
           vz1 = vz(i1)

           t2 = ft(i2)

           dvx = vx(i2) - vx1
           dvy = vy(i2) - vy1
           dvz = vz(i2) - vz1

           dt = t2 - t1

           dx = gx(i2) - gx(i1) - vx1 * dt
           dy = gy(i2) - gy(i1) - vy1 * dt
           dz = gz(i2) - gz(i1) - vz1 * dt

           vp = dvx * dx + dvy * dy + dvz * dz

           allok = allok .and. vp .lt. 0d0

        end if

        if (allok) then

           v2= dvx * dvx + dvy * dvy + dvz * dvz

           if (v2 .eq. 0d0) then
              tm = tlarge
           else
              tm = t2 - vp / v2
           end if

c       note now tm is the absolute time

           allok = allok .and. tm .gt. t1 .and. tm .gt. t2

        end if

        if (allok) then

           dgx = dx - dvx * t2
           dgy = dy - dvy * t2
           dgz = dz - dvz * t2

           dm2 = - v2 * tm ** 2  + dgx * dgx + dgy * dgy + dgz * dgz

           allok = allok .and. dm2 .lt. cutof2

        end if
        
        if (allok) then

           e1 = e(i1)
           px1 = px(i1)
           py1 = py(i1)
           pz1 = pz(i1)
           e2 = e(i2)
           px2 = px(i2)
           py2 = py(i2)
           pz2 = pz(i2)

           rts2 = (e1 + e2) ** 2 - (px1 + px2) ** 2
     &          - (py1 + py2) ** 2 - (pz1 + pz2) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if

        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else
           t1 = tm
           t2 = tm
        end if

        return
        end

        subroutine isco4(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

c       set up numbers for later calculations

        icels1 = icels(i)
        ii1 = icels1 / 10000
        jj1 = (icels1 - ii1 * 10000) / 100
        kk1 = icels1 - ii1 * 10000 - jj1 * 100
        icels2 = icels(j)
        ii2 = icels2 / 10000
        jj2 = (icels2 - ii2 * 10000) / 100
        kk2 = icels2 - ii2 * 10000 - jj2 * 100

        i1 = i
        i2 = j

        p4 = ft(i2) - ft(i1)
        p1 = gx(i2) - gx(i1)
        p2 = gy(i2) - gy(i1)
        p3 = gz(i2) - gz(i1)

        if (ii1 - ii2 .gt. 5) then
           p1 = p1 + 10d0 * size1
        else if (ii1 - ii2 .lt. -5) then
           p1 = p1 - 10d0 * size1
        end if
        if (jj1 - jj2 .gt. 5) then
           p2 = p2 + 10d0 * size2
        else if (jj1 - jj2 .lt. -5) then
           p2 = p2 - 10d0 * size2
        end if
        if (kk1 - kk2 .gt. 5) then
           p3 = p3 + 10d0 * size3
        else if (kk1 - kk2 .lt. -5) then
           p3 = p3 - 10d0 * size3
        end if

        q4 = e(i1)
        q1 = px(i1)
        q2 = py(i1)
        q3 = pz(i1)

        r4 = e(i2)
        r1 = px(i2)
        r2 = py(i2)
        r3 = pz(i2)

        a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3
        b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3
        c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3
        d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3
        ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3
        f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3

c       make sure particle 2 formed early
        h = a + b
        if (h .gt. 0d0) then
           g = a
           a = -b
           b = -g

           g = c
           c = d
           d = g

           i1 = j
           i2 = i
        end if

c       check the approaching criteria
        if (allok) then

           vp = a * d - b * ee

           allok = allok .and. vp .lt. 0d0

        end if

c       check the closest approach distance criteria
         if (allok) then

           dm2 = - f - (a ** 2 * d + b ** 2 * c - 2d0 * a * b * ee) /
     &           (ee ** 2 - c * d)

           allok = allok .and. dm2 .lt. cutof2

        end if

c       check the time criteria
        if (allok) then

           tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (ee ** 2 - c * d)
           tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (ee ** 2 - c * d)
           tm = 0.5d0 * (tc1 + tc2)

           allok = allok .and. tm .gt. ft(i) .and. tm .gt. ft(j)

        end if

c        check rts cut
        if (allok) then

           rts2 = (q4 + r4) ** 2 - (q1 + r1) ** 2
     &          - (q2 + r2) ** 2 - (q3 + r3) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if
          
        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else if (h .gt. 0d0) then
           t1 = tm
           t2 = tm
        else
           t1 = tm
           t2 = tm
        end if

        return
        end

        subroutine isco5(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

c       set up numbers for later calculations

        icels1 = icels(i)
        ii1 = icels1 / 10000
        jj1 = (icels1 - ii1 * 10000) / 100
        kk1 = icels1 - ii1 * 10000 - jj1 * 100
        icels2 = icels(j)
        ii2 = icels2 / 10000
        jj2 = (icels2 - ii2 * 10000) / 100
        kk2 = icels2 - ii2 * 10000 - jj2 * 100

        i1 = i
        i2 = j

        p4 = ft(i2) - ft(i1)
        p1 = gx(i2) - gx(i1)
        p2 = gy(i2) - gy(i1)
        p3 = gz(i2) - gz(i1)

        if (ii1 - ii2 .gt. 5) then
           p1 = p1 + 10d0 * size1
        else if (ii1 - ii2 .lt. -5) then
           p1 = p1 - 10d0 * size1
        end if
        if (jj1 - jj2 .gt. 5) then
           p2 = p2 + 10d0 * size2
        else if (jj1 - jj2 .lt. -5) then
           p2 = p2 - 10d0 * size2
        end if
        if (kk1 - kk2 .gt. 5) then
           p3 = p3 + 10d0 * size3
        else if (kk1 - kk2 .lt. -5) then
           p3 = p3 - 10d0 * size3
        end if

        q4 = e(i1)
        q1 = px(i1)
        q2 = py(i1)
        q3 = pz(i1)

        r4 = e(i2)
        r1 = px(i2)
        r2 = py(i2)
        r3 = pz(i2)

        a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3
        b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3
        c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3
        d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3
        ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3
        f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3

c       make sure particle 2 formed early
        h = a + b
        if (h .gt. 0d0) then
           g = a
           a = -b
           b = -g

           g = c
           c = d
           d = g

           i1 = j
           i2 = i
        end if

c       check the approaching criteria
        if (allok) then

           vp = a * d - b * ee

           allok = allok .and. vp .lt. 0d0

        end if

c       check the closest approach distance criteria
         if (allok) then

           dm2 = - f - (a ** 2 * d + b ** 2 * c - 2d0 * a * b * ee) /
     &           (ee ** 2 - c * d)

           allok = allok .and. dm2 .lt. cutof2

        end if

c       check the time criteria
        if (allok) then

           tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (ee ** 2 - c * d)
           tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (ee ** 2 - c * d)
           if (iordsc .eq. 20) then
              tm = min(tc1, tc2)
           else if (iordsc .eq. 21) then
              tm = 0.5d0 * (tc1 + tc2)
           else
              tm = max(tc1, tc2)
           end if

           allok = allok .and. tm .gt. ft(i) .and. tm .gt. ft(j)

        end if

c        check rts cut
        if (allok) then

           rts2 = (q4 + r4) ** 2 - (q1 + r1) ** 2
     &          - (q2 + r2) ** 2 - (q3 + r3) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if
          
        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else if (h .gt. 0d0) then
           t1 = tc2
           t2 = tc1
        else
           t1 = tc1
           t2 = tc2
        end if

        return
        end

        subroutine isco6(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

        if (ft(i) .ge. ft(j)) then
           i1 = j
           i2 = i
        else 
           i1 = i
           i2 = j
        end if

        icels1 = icels(i1)
        ii1 = icels1 / 10000
        jj1 = (icels1 - ii1 * 10000) / 100
        kk1 = icels1 - ii1 * 10000 - jj1 * 100
        icels2 = icels(i2)
        ii2 = icels2 / 10000
        jj2 = (icels2 - ii2 * 10000) / 100
        kk2 = icels2 - ii2 * 10000 - jj2 * 100
        
        if (allok) then

           t1 = ft(i1)
           vx1 = vx(i1)
           vy1 = vy(i1)
           vz1 = vz(i1)

           t2 = ft(i2)

           dvx = vx(i2) - vx1
           dvy = vy(i2) - vy1
           dvz = vz(i2) - vz1

           dt = t2 - t1

           dx = gx(i2) - gx(i1) - vx1 * dt
           dy = gy(i2) - gy(i1) - vy1 * dt
           dz = gz(i2) - gz(i1) - vz1 * dt

           if (ii1 - ii2 .gt. 5) then
              dx = dx + 10d0 * size1
           else if (ii1 - ii2 .lt. - 5) then
              dx = dx - 10d0 * size1
           end if

           if (jj1 - jj2 .gt. 5) then
              dy = dy + 10d0 * size2
           else if (jj1 - jj2 .lt. - 5) then
              dy = dy - 10d0 * size2
           end if

           if (kk1 - kk2 .gt. 5) then
              dz = dz + 10d0 * size3
           else if (kk1 - kk2 .lt. -5) then
              dz = dz - 10d0 * size3
           end if

           vp = dvx * dx + dvy * dy + dvz * dz

           allok = allok .and. vp .lt. 0d0

        end if

        if (allok) then

           v2p = dvx * dvx + dvy * dvy + dvz * dvz

           if (v2p .eq. 0d0) then
              tm = tlarge
           else
              tm = t2 - vp / v2p
           end if

c       note now tm is the absolute time

           allok = allok .and. tm .gt. t1 .and. tm .gt. t2

        end if

        if (allok) then

           dgx = dx - dvx * t2
           dgy = dy - dvy * t2
           dgz = dz - dvz * t2

           dm2 = - v2p * tm ** 2  + dgx * dgx + dgy * dgy + dgz * dgz

           allok = allok .and. dm2 .lt. cutof2

        end if
        
        if (allok) then

           e1 = e(i1)
           px1 = px(i1)
           py1 = py(i1)
           pz1 = pz(i1)
           e2 = e(i2)
           px2 = px(i2)
           py2 = py(i2)
           pz2 = pz(i2)

           rts2 = (e1 + e2) ** 2 - (px1 + px2) ** 2
     &          - (py1 + py2) ** 2 - (pz1 + pz2) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if

        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else
           t1 = tm
           t2 = tm
        end if

        return
        end

        subroutine isco7(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok, allokp

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

c       set up numbers for later calculations

        tm = tlarge

        if (allok) then
           do 1000 ii = - 1, 1
              do 2000 jj = - 1, 1

                 allokp = .true.
                 
                 i1 = i
                 i2 = j

                 p4 = ft(j) - ft(i)
                 p1 = gx(j) - gx(i)
                 p2 = gy(j) - gy(i)
                 p3 = gz(j) - gz(i)

                 p1 = p1 + ii * 10d0 * size1
                 p2 = p2 + jj * 10d0 * size2

                 q4 = e(i)
                 q1 = px(i)
                 q2 = py(i)
                 q3 = pz(i)
                 
                 r4 = e(j)
                 r1 = px(j)
                 r2 = py(j)
                 r3 = pz(j)

                 a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3
                 b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3
                 c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3
                 d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3
                 ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3
                 f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3

c       make sure particle 2 formed early
                 h = a + b
                 if (h .gt. 0d0) then
                    g = a
                    a = -b
                    b = -g
                    g = c
                    c = d
                    d = g
                    i1 = j
                    i2 = i
                 end if
                 
c       check the approaching criteria
                 if (allokp) then
                    vp = a * d - b * ee
                    allokp = allokp .and. vp .lt. 0d0
                 end if

c       check the closest approach distance criteria
                 if (allokp) then
           dm2 = - f - (a ** 2 * d + b ** 2 * c - 2d0 * a * b * ee) /
     &            (ee ** 2 - c * d)
                    allokp = allokp .and. dm2 .lt. cutof2
                 end if

c       check the time criteria
                 if (allokp) then
           tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (ee ** 2 - c * d)
           tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (ee ** 2 - c * d)
           tmp = 0.5d0 * (tc1 + tc2)
           allokp = allokp .and. tmp .gt. ft(i) .and. tmp .gt. ft(j)
                 end if

                 if (allokp .and. tmp .lt. tm) then
                    tm = tmp
                    jxa = ii
                    jya = jj
cd                    dgxa(j) = ii * 10d0 * size1
cd                    dgya(j) = jj * 10d0 * size2
cd                    dgxa(i) = - dgxa(j)
cd                    dgya(i) = - dgya(j)
                 end if

 2000              continue
 1000           continue

           if (tm .eq. tlarge) then
              allok = .false.
           end if
           
        end if

c        check rts cut
        if (allok) then

           q4 = e(i1)
           q1 = px(i1)
           q2 = py(i1)
           q3 = pz(i1)

           r4 = e(i2)
           r1 = px(i2)
           r2 = py(i2)
           r3 = pz(i2)

           rts2 = (q4 + r4) ** 2 - (q1 + r1) ** 2
     &          - (q2 + r2) ** 2 - (q3 + r3) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if
          
        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else if (h .gt. 0d0) then
           t1 = tm
           t2 = tm
        else
           t1 = tm
           t2 = tm
        end if

        return
        end

        subroutine isco8(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok, allokp

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

c       set up numbers for later calculations

        tm = tlarge

        if (allok) then
           do 1000 ii = - 1, 1
              do 2000 jj = - 1, 1

                 allokp = .true.
                 
                 i1 = i
                 i2 = j

                 p4 = ft(j) - ft(i)
                 p1 = gx(j) - gx(i)
                 p2 = gy(j) - gy(i)
                 p3 = gz(j) - gz(i)

                 p1 = p1 + ii * 10d0 * size1
                 p2 = p2 + jj * 10d0 * size2

                 q4 = e(i)
                 q1 = px(i)
                 q2 = py(i)
                 q3 = pz(i)
                 
                 r4 = e(j)
                 r1 = px(j)
                 r2 = py(j)
                 r3 = pz(j)

                 a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3
                 b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3
                 c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3
                 d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3
                 ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3
                 f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3

c       make sure particle 2 formed early
                 h = a + b
                 if (h .gt. 0d0) then
                    g = a
                    a = -b
                    b = -g
                    g = c
                    c = d
                    d = g
                    i1 = j
                    i2 = i
                 end if
                 
c       check the approaching criteria
                 if (allokp) then
                    vp = a * d - b * ee
                    allokp = allokp .and. vp .lt. 0d0
                 end if

c       check the closest approach distance criteria
                 if (allokp) then
           dm2 = - f - (a ** 2 * d + b ** 2 * c - 2d0 * a * b * ee) /
     &            (ee ** 2 - c * d)
                    allokp = allokp .and. dm2 .lt. cutof2
                 end if

c       check the time criteria
                 if (allokp) then
           tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (ee ** 2 - c * d)
           tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (ee ** 2 - c * d)
                    if (iordsc .eq. 20) then
                       tmp = min(tc1, tc2)
                    else if (iordsc .eq. 21) then
                       tmp = 0.5d0 * (tc1 + tc2)
                    else
                       tmp = max(tc1, tc2)
                    end if
           allokp = allokp .and. tmp .gt. ft(i) .and. tmp .gt. ft(j)
                 end if

                 if (allokp .and. tmp .lt. tm) then
                    tm = tmp
                    jxa = ii
                    jya = jj
                    ha = h
                    tc1a = tc1
                    tc2a = tc2
cd                    dgxa(j) = ii * 10d0 * size1
cd                    dgya(j) = jj * 10d0 * size2
cd                    dgxa(i) = - dgxa(j)
cd                    dgya(i) = - dgya(j)
                 end if

 2000              continue
 1000           continue

           if (tm .eq. tlarge) then
              allok = .false.
           end if
           
        end if

c        check rts cut
        if (allok) then

           q4 = e(i1)
           q1 = px(i1)
           q2 = py(i1)
           q3 = pz(i1)

           r4 = e(i2)
           r1 = px(i2)
           r2 = py(i2)
           r3 = pz(i2)

           rts2 = (q4 + r4) ** 2 - (q1 + r1) ** 2
     &          - (q2 + r2) ** 2 - (q3 + r3) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if
          
        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else if (ha .gt. 0d0) then
           t1 = tc2a
           t2 = tc1a
        else
           t1 = tc1a
           t2 = tc2a
        end if

        return
        end

        subroutine isco9(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok, allokp

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

        if (ft(i) .ge. ft(j)) then
           i1 = j
           i2 = i
           isign = -1
        else 
           i1 = i
           i2 = j
           isign = 1
        end if

        if (allok) then
           tm = tlarge
           
           t1 = ft(i1)
           vx1 = vx(i1)
           vy1 = vy(i1)
           vz1 = vz(i1)
           
           t2 = ft(i2)
           
           dvx = vx(i2) - vx1
           dvy = vy(i2) - vy1
           dvz = vz(i2) - vz1
           
           dt = t2 - t1

           do 1000 ii = - 1, 1
              do 2000 jj = - 1, 1

                 allokp = .true.

                 dx = gx(i2) - gx(i1) - vx1 * dt
                 dy = gy(i2) - gy(i1) - vy1 * dt
                 dz = gz(i2) - gz(i1) - vz1 * dt

                 dx = dx + ii * 10d0 * size1
                 dy = dy + jj * 10d0 * size2

                 vp = dvx * dx + dvy * dy + dvz * dz

                 allokp = allokp .and. vp .lt. 0d0
                 
                 if (allokp) then

                    v2 = dvx * dvx + dvy * dvy + dvz * dvz

                    if (v2 .eq. 0d0) then
                       tmp = tlarge
                    else
                       tmp = t2 - vp / v2
                    end if

c       note now tm is the absolute time

                    allokp = allokp .and. tmp .gt. t1 .and.
     &                         tmp .gt. t2

                 end if

                 if (allokp) then

                    dgx = dx - dvx * t2
                    dgy = dy - dvy * t2
                    dgz = dz - dvz * t2

                    dm2 = - v2 * tmp ** 2  + dgx * dgx +
     &                    dgy * dgy + dgz * dgz

                    allokp = allokp .and. dm2 .lt. cutof2

                 end if

                 if (allokp .and. tmp .lt. tm) then
                    tm = tmp
                    jxa = isign * ii
                    jya = isign * jj
                 end if

 2000              continue
 1000           continue
           
           if (tm .eq. tlarge) then
              allok = .false.
           end if
        end if
        
        if (allok) then

           e1 = e(i1)
           px1 = px(i1)
           py1 = py(i1)
           pz1 = pz(i1)
           e2 = e(i2)
           px2 = px(i2)
           py2 = py(i2)
           pz2 = pz(i2)

           rts2 = (e1 + e2) ** 2 - (px1 + px2) ** 2
     &          - (py1 + py2) ** 2 - (pz1 + pz2) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if

        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else
           t1 = tm
           t2 = tm
        end if

        return
        end

        subroutine isco10(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok, allokp

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

c       set up numbers for later calculations

        tm = tlarge

        if (allok) then
           do 1000 ii = - 1, 1
              do 2000 jj = - 1, 1
                 do 3000 kk = -1, 1
                 allokp = .true.
                 
                 i1 = i
                 i2 = j

                 p4 = ft(j) - ft(i)
                 p1 = gx(j) - gx(i)
                 p2 = gy(j) - gy(i)
                 p3 = gz(j) - gz(i)

                 p1 = p1 + ii * 10d0 * size1
                 p2 = p2 + jj * 10d0 * size2
                 p3 = p3 + kk * 10d0 * size3

                 q4 = e(i)
                 q1 = px(i)
                 q2 = py(i)
                 q3 = pz(i)
                 
                 r4 = e(j)
                 r1 = px(j)
                 r2 = py(j)
                 r3 = pz(j)

                 a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3
                 b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3
                 c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3
                 d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3
                 ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3
                 f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3

c       make sure particle 2 formed early
                 h = a + b
                 if (h .gt. 0d0) then
                    g = a
                    a = -b
                    b = -g
                    g = c
                    c = d
                    d = g
                    i1 = j
                    i2 = i
                 end if
                 
c       check the approaching criteria
                 if (allokp) then
                    vp = a * d - b * ee
                    allokp = allokp .and. vp .lt. 0d0
                 end if

c       check the closest approach distance criteria
                 if (allokp) then
           dm2 = - f - (a ** 2 * d + b ** 2 * c - 2d0 * a * b * ee) /
     &            (ee ** 2 - c * d)
                    allokp = allokp .and. dm2 .lt. cutof2
                 end if

c       check the time criteria
                 if (allokp) then
           tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (ee ** 2 - c * d)
           tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (ee ** 2 - c * d)
           tmp = 0.5d0 * (tc1 + tc2)
           allokp = allokp .and. tmp .gt. ft(i) .and. tmp .gt. ft(j)
                 end if

                 if (allokp .and. tmp .lt. tm) then
                    tm = tmp
                    jxa = ii
                    jya = jj
                    jza = kk
cd                    dgxa(j) = ii * 10d0 * size1
cd                    dgya(j) = jj * 10d0 * size2
cd                    dgxa(i) = - dgxa(j)
cd                    dgya(i) = - dgya(j)
                 end if

 3000                 continue
 2000              continue
 1000           continue

           if (tm .eq. tlarge) then
              allok = .false.
           end if
           
        end if

c        check rts cut
        if (allok) then

           q4 = e(i1)
           q1 = px(i1)
           q2 = py(i1)
           q3 = pz(i1)

           r4 = e(i2)
           r1 = px(i2)
           r2 = py(i2)
           r3 = pz(i2)

           rts2 = (q4 + r4) ** 2 - (q1 + r1) ** 2
     &          - (q2 + r2) ** 2 - (q3 + r3) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if
          
        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else if (h .gt. 0d0) then
           t1 = tm
           t2 = tm
        else
           t1 = tm
           t2 = tm
        end if

        return
        end

        subroutine isco11(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok, allokp

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

c       set up numbers for later calculations

        tm = tlarge

        if (allok) then
           do 1000 ii = - 1, 1
              do 2000 jj = - 1, 1
                 do 3000 kk = - 1, 1

                 allokp = .true.
                 
                 i1 = i
                 i2 = j

                 p4 = ft(j) - ft(i)
                 p1 = gx(j) - gx(i)
                 p2 = gy(j) - gy(i)
                 p3 = gz(j) - gz(i)

                 p1 = p1 + ii * 10d0 * size1
                 p2 = p2 + jj * 10d0 * size2
                 p3 = p3 + kk * 10d0 * size3

                 q4 = e(i)
                 q1 = px(i)
                 q2 = py(i)
                 q3 = pz(i)
                 
                 r4 = e(j)
                 r1 = px(j)
                 r2 = py(j)
                 r3 = pz(j)

                 a = p4 * q4 - p1 * q1 - p2 * q2 - p3 * q3
                 b = p4 * r4 - p1 * r1 - p2 * r2 - p3 * r3
                 c = q4 * q4 - q1 * q1 - q2 * q2 - q3 * q3
                 d = r4 * r4 - r1 * r1 - r2 * r2 - r3 * r3
                 ee = q4 * r4 - q1 * r1 - q2 * r2 - q3 * r3
                 f = p4 * p4 - p1 * p1 - p2 * p2 - p3 * p3

c       make sure particle 2 formed early
                 h = a + b
                 if (h .gt. 0d0) then
                    g = a
                    a = -b
                    b = -g
                    g = c
                    c = d
                    d = g
                    i1 = j
                    i2 = i
                 end if
                 
c       check the approaching criteria
                 if (allokp) then
                    vp = a * d - b * ee
                    allokp = allokp .and. vp .lt. 0d0
                 end if

c       check the closest approach distance criteria
                 if (allokp) then
           dm2 = - f - (a ** 2 * d + b ** 2 * c - 2d0 * a * b * ee) /
     &            (ee ** 2 - c * d)
                    allokp = allokp .and. dm2 .lt. cutof2
                 end if

c       check the time criteria
                 if (allokp) then
           tc1 = ft(i1) - e(i1) * (a * d - b * ee) / (ee ** 2 - c * d)
           tc2 = ft(i2) + e(i2) * (b * c - a * ee) / (ee ** 2 - c * d)
                    if (iordsc .eq. 20) then
                       tmp = min(tc1, tc2)
                    else if (iordsc .eq. 21) then
                       tmp = 0.5d0 * (tc1 + tc2)
                    else
                       tmp = max(tc1, tc2)
                    end if
           allokp = allokp .and. tmp .gt. ft(i) .and. tmp .gt. ft(j)
                 end if

                 if (allokp .and. tmp .lt. tm) then
                    tm = tmp
                    jxa = ii
                    jya = jj
                    jza = kk
                    ha = h
                    tc1a = tc1
                    tc2a = tc2
cd                    dgxa(j) = ii * 10d0 * size1
cd                    dgya(j) = jj * 10d0 * size2
cd                    dgxa(i) = - dgxa(j)
cd                    dgya(i) = - dgya(j)
                 end if

 3000                 continue
 2000              continue
 1000           continue

           if (tm .eq. tlarge) then
              allok = .false.
           end if
           
        end if

c        check rts cut
        if (allok) then

           q4 = e(i1)
           q1 = px(i1)
           q2 = py(i1)
           q3 = pz(i1)

           r4 = e(i2)
           r1 = px(i2)
           r2 = py(i2)
           r3 = pz(i2)

           rts2 = (q4 + r4) ** 2 - (q1 + r1) ** 2
     &          - (q2 + r2) ** 2 - (q3 + r3) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if

        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else if (ha .gt. 0d0) then
           t1 = tc2a
           t2 = tc1a
        else
           t1 = tc1a
           t2 = tc2a
        end if

        return
        end

        subroutine isco12(i, j, allok, tm, t1, t2)
c       this subroutine is used to decide whether there is a collision between
c       particle i and j, if there is one allok=1, and tm gives the 
c       collision time, t1 the collision time for i,
c       t2 the collision time for j

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec4/ vx(MAXPTN), vy(MAXPTN), vz(MAXPTN)
cc      SAVE /prec4/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok, allokp

c       preventing consecutive collisions
        allok = last(i) .ne. j .or. last(j) .ne. i

        if (ft(i) .ge. ft(j)) then
           i1 = j
           i2 = i
           isign = -1
        else 
           i1 = i
           i2 = j
           isign = 1
        end if

        if (allok) then
           tm = tlarge
           
           t1 = ft(i1)
           vx1 = vx(i1)
           vy1 = vy(i1)
           vz1 = vz(i1)
           
           t2 = ft(i2)
           
           dvx = vx(i2) - vx1
           dvy = vy(i2) - vy1
           dvz = vz(i2) - vz1
           
           dt = t2 - t1

           do 1000 ii = - 1, 1
              do 2000 jj = - 1, 1
                 do 3000 kk = -1, 1

                 allokp = .true.

                 dx = gx(i2) - gx(i1) - vx1 * dt
                 dy = gy(i2) - gy(i1) - vy1 * dt
                 dz = gz(i2) - gz(i1) - vz1 * dt

                 dx = dx + ii * 10d0 * size1
                 dy = dy + jj * 10d0 * size2
                 dz = dz + kk * 10d0 * size3

                 vp = dvx * dx + dvy * dy + dvz * dz

                 allokp = allokp .and. vp .lt. 0d0
                 
                 if (allokp) then

                    v2 = dvx * dvx + dvy * dvy + dvz * dvz

                    if (v2 .eq. 0d0) then
                       tmp = tlarge
                    else
                       tmp = t2 - vp / v2
                    end if

c       note now tm is the absolute time

                    allokp = allokp .and. tmp .gt. t1 .and.
     &                         tmp .gt. t2

                 end if

                 if (allokp) then

                    dgx = dx - dvx * t2
                    dgy = dy - dvy * t2
                    dgz = dz - dvz * t2

                    dm2 = - v2 * tmp ** 2  + dgx * dgx +
     &                    dgy * dgy + dgz * dgz

                    allokp = allokp .and. dm2 .lt. cutof2

                 end if

                 if (allokp .and. tmp .lt. tm) then
                    tm = tmp
                    jxa = isign * ii
                    jya = isign * jj
                    jza = isign * kk
                 end if

 3000                 continue
 2000              continue
 1000           continue
           
           if (tm .eq. tlarge) then
              allok = .false.
           end if
        end if
        
        if (allok) then

           e1 = e(i1)
           px1 = px(i1)
           py1 = py(i1)
           pz1 = pz(i1)
           e2 = e(i2)
           px2 = px(i2)
           py2 = py(i2)
           pz2 = pz(i2)

           rts2 = (e1 + e2) ** 2 - (px1 + px2) ** 2
     &          - (py1 + py2) ** 2 - (pz1 + pz2) ** 2

           allok = allok .and. rts2 .gt. rscut2
        end if

        if (.not. allok) then
           tm = tlarge
           t1 = tlarge
           t2 = tlarge
        else
           t1 = tm
           t2 = tm
        end if

        return
        end

        subroutine reor(t, tmin, j, last0)
c       this subroutine is used to fix ct(i) when tm is greater than ct(i)
c       next(i) is last1 or last2

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
cd        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        icels0 = icels(j)

        i1 = icels0 / 10000
        i2 = (icels0 - i1 * 10000) / 100
        i3 = icels0 - i1 * 10000 - i2 * 100

        call wallc(j, i1, i2, i3, t, tmin1)

        if (tmin .le. tmin1) then
           nc = last0
        else
           tmin = tmin1
           nc = 0
        end if

        if (iconfg .eq. 3 .or. iconfg .eq. 5) then
           call chcell(j, i1, i2, i3, last0, t, tmin, nc)
        else
           if (i1 .eq. 11 .and. i2 .eq. 11 .and. i3 .eq. 11) then
              call chout(j, last0, t, tmin, nc)
           else
              if (iconfg .eq. 1) then
                 call chin1(j, i1, i2, i3, last0, t, tmin, nc)
              else if (iconfg .eq. 2) then
                 call chin2(j, i1, i2, i3, last0, t, tmin, nc)
              else if (iconfg .eq. 4) then
                 call chin3(j, i1, i2, i3, last0, t, tmin, nc)
              end if
           end if
        end if
        
        call fixtim(j, t, tmin1, tmin, nc)

        return
        end

        subroutine chout(l, last0, t, tmin, nc)
c       this subroutine is used to check the surface when the colliding
c       particle is outside the cube

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        SAVE   

        m1 = 11
        m2 = 11
        m3 = 11
        call chcell(l, m1, m2, m3, last0, t, tmin, nc)

        do 1003 i = 1, 10
           do 1002 j = 1, 10
              do 1001 k = 1, 10
                 if (i .eq. 1 .or. i .eq. 10 .or. j .eq. 1 .or.
     &              j .eq. 10 .or. k .eq. 1 .or. k. eq. 10)
     &               call chcell(l, i, j, k, last0, t, tmin, nc)
 1001         continue
 1002      continue
 1003   continue

        return
        end

        subroutine chin1(l, i1, i2, i3, last0, t, tmin, nc)
c       this subroutine is used to check collisions for particle inside
c       the cube
c       and update the afftected particles through chcell

        implicit double precision (a-h, o-z)
        SAVE   
        
c       itest is a flag to make sure the 111111 cell is checked only once
        itest = 0

        do 1003 i = i1 - 1, i1 + 1
           do 1002 j = i2 - 1, i2 + 1
              do 1001 k = i3 - 1, i3 + 1
                 if (i .ge. 1 .and. i .le. 10
     &              .and. j .ge. 1 .and. j .le. 10
     &              .and. k .ge. 1 .and. k .le. 10) then
                    call chcell(l, i, j, k, last0, t, tmin, nc)
                 else if (itest .eq. 0) then
                    m1 = 11
                    m2 = 11
                    m3 = 11
                    call chcell(l, m1, m2, m3, last0, t, tmin, nc)
                    itest = 1
                 end if   
 1001         continue
 1002      continue
 1003   continue

        return
        end

        subroutine chin2(l, i1, i2, i3, last0, t, tmin, nc)
c       this subroutine is used to check collisions for particle inside
c       the cube
c       and update the afftected particles through chcell

        implicit double precision (a-h, o-z)
        SAVE   
        
c       itest is a flag to make sure the 111111 cell is checked only once
        itest = 0

        do 1003 i = i1 - 1, i1 + 1
           do 1002 j = i2 - 1, i2 + 1
              do 1001 k = i3 - 1, i3 + 1
                 ia = i
                 ib = j
                 ic = k
                 if (k .ge. 1 .and. k .le. 10) then
                    if (i .eq. 0) ia = 10
                    if (i .eq. 11) ia = 1
                    if (j .eq. 0) ib = 10
                    if (j .eq. 11) ib = 1
                    call chcell(l, ia, ib, ic, last0, t, tmin, nc)
                 end if
 1001         continue
 1002      continue
 1003   continue

        return
        end

        subroutine chin3(l, i1, i2, i3, last0, t, tmin, nc)
c       this subroutine is used to check collisions for particle inside
c       the cube
c       and update the afftected particles through chcell

        implicit double precision (a-h, o-z)
        SAVE   
        
c       itest is a flag to make sure the 111111 cell is checked only once
        itest = 0

        do 1003 i = i1 - 1, i1 + 1
           do 1002 j = i2 - 1, i2 + 1
              do 1001 k = i3 - 1, i3 + 1
                 if (i .eq. 0) then
                    ia = 10
                 else if (i .eq. 11) then
                    ia = 1
                 else
                    ia = i
                 end if
                 if (j .eq. 0) then
                    ib = 10
                 else if (j .eq. 11) then
                    ib = 1
                 else
                    ib = j
                 end if
                 if (k .eq. 0) then
                    ic = 10
                 else if (k .eq. 11) then
                    ic = 1
                 else
                    ic = k
                 end if
                 call chcell(l, ia, ib, ic, last0, t, tmin, nc)
 1001         continue
 1002      continue
 1003   continue

        return
        end

        subroutine chcell(il, i1, i2, i3, last0, t, tmin, nc)
c       this program is used to check through all the particles, except last0
c       in the cell (i1,i2,i3) and see if we can get a particle collision 
c       with time less than the original input tmin ( the collision time of 
c       il with the wall
c       last0 cas be set to 0 if we don't want to exclude last0

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)
        
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist2/ icell, icel(10, 10, 10)
cc      SAVE /ilist2/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        SAVE   

        if (iconfg .eq. 3 .or. iconfg .eq. 5) then
           jj = ichkpt
           do 1001 j = 1, jj
c     10/24/02 get rid of argument usage mismatch in mintm():
              jmintm=j
              if (j .ne. il .and. j .ne. last0)
     &          call mintm(il, jmintm, tmin, nc)
c     &          call mintm(il, j, tmin, nc)

 1001         continue
           return
        end if

c       set l
        if (i1 .eq. 11 .and. i2 .eq. 11 .and. i3 .eq. 11) then
           l = icell
        else
           l = icel(i1 ,i2, i3)
        end if

        if (l .eq. 0) return
        
        j = nic(l)
        
c       if there is only one particle
        if (j .eq. 0) then
           
c       if it's not il or last0,when last is not wall
           if (l .eq. il .or. l .eq. last0) return
           call mintm(il, l, tmin, nc)
           
c       if there are many particles
        else
           if (l .ne. il .and. l .ne. last0)
     &        call mintm(il, l, tmin, nc)
           do 10 while(j .ne. l)
              if (j .ne. il .and. j .ne. last0)
     &             call mintm(il, j, tmin, nc)
              j = nic(j)
 10           continue
        end if
        
        return
        end

        subroutine mintm(i, j, tmin, nc)
c       this subroutine is used to check whether particle j has smaller
c       collision time with particle i than other particles
c       or in other words, update next(i)

c       input i,j,tmin,nc
c       output tmin,nc

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /aurec1/ jxa, jya, jza
cc      SAVE /aurec1/
        common /aurec2/ dgxa(MAXPTN), dgya(MAXPTN), dgza(MAXPTN)
cc      SAVE /aurec2/
        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        SAVE   

        logical allok

        call isco(i, j, allok, tm, t1, t2)

        if (allok .and. tm .lt. tmin) then
           tmin = tm
           ct(i) = t1
           nc = j
           if (iconfg .eq. 3 .or. iconfg .eq. 5) then
              dgxa(i) = - jxa * 10d0 * size1
              dgya(i) = - jya * 10d0 * size2
              if (iconfg .eq. 5) then
                 dgza(i) = - jza * 10d0 * size3
              end if
           end if
        end if

         return
        end

******************************************************************************
******************************************************************************

        subroutine zpca1

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /ilist1/
     &     iscat, jscat, next(MAXPTN), last(MAXPTN),
     &     ictype, icsta(MAXPTN),
     &     nic(MAXPTN), icels(MAXPTN)
cc      SAVE /ilist1/
        SAVE   

        if (mod(ictype,2) .eq. 0) then
           call zpca1a(iscat)
           call zpca1a(jscat)
clin-5/2009 ctest off v2 for parton:
c           call flowp(1)
        end if

        return
        end

        subroutine zpca1a(i)

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec3/gxs(MAXPTN),gys(MAXPTN),gzs(MAXPTN),fts(MAXPTN),
     &     pxs(MAXPTN), pys(MAXPTN), pzs(MAXPTN), es(MAXPTN),
     &     xmasss(MAXPTN), ityps(MAXPTN)
cc      SAVE /prec3/
        common /prec5/ eta(MAXPTN), rap(MAXPTN), tau(MAXPTN)
cc      SAVE /prec5/
        common /prec6/ etas(MAXPTN), raps(MAXPTN), taus(MAXPTN)
cc      SAVE /prec6/
        common /ana1/ ts(12)
cc      SAVE /ana1/
        SAVE   

        if (iconfg .eq. 1) then
           t1 = fts(i)
           t2 = ft(i)
           ipic = 11
        else if (iconfg .eq. 2 .or.
     &     iconfg .eq. 3) then
cd           t1 = fts(i)
cd           t2 = ft(i)
           t1 = taus(i)
           t2 = tau(i)
           ipic = 12
        else if (iconfg .eq. 4 .or.
     &     iconfg .eq. 5) then
           t1 = fts(i)
           t2 = ft(i)
           ipic = 12
        end if

        if (iconfg .le. 3) then
           do 1002 ian = 1, ipic
              if (t1 .le. ts(ian) .and.
     &           t2 .gt. ts(ian)) then
                 rapi = raps(i)
c     7/20/01:
c                 et = sqrt(pxs(i) ** 2 + pys(i) ** 2 + xmp ** 2)
                 et = dsqrt(pxs(i) ** 2 + pys(i) ** 2 + xmp ** 2)
                 call zpca1b(rapi, et, ian)
              end if
 1002      continue
        else
           do 1003 ian = 1, ipic
              if (t1 .le. ts(ian) .and.
     &           t2 .gt. ts(ian)) then
                 p0 = es(i)
                 p1 = pxs(i)
                 p2 = pys(i)
                 p3 = pzs(i)
                 call zpca1c(p0, p1, p2, p3, ian)
              end if
 1003      continue
        end if

        return
        end

        subroutine zpca1b(rapi, et, ian)

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para6/ centy
cc      SAVE /para6/
        common /ilist6/ t, iopern, icolln
cc      SAVE /ilist6/
        common /ana2/
     &     det(12), dn(12), detdy(12), detdn(12), dndy(12),
     &     det1(12), dn1(12), detdy1(12), detdn1(12), dndy1(12),
     &     det2(12), dn2(12), detdy2(12), detdn2(12), dndy2(12)
cc      SAVE /ana2/
        SAVE   

        if (rapi .gt. centy - 0.5d0 .and. 
     &     rapi .lt. centy + 0.5d0) then
           det2(ian) = det2(ian) + et
           dn2(ian) = dn2(ian) + 1d0
cdtrans
           if (ian .eq. 10) then
cd              write (10, *) t, det2(ian)
           end if
           if (ian .eq. 11) then
cd              write (11, *) t, det2(ian)
           end if
           if (ian .eq. 12) then
cd              write (12, *) t, det2(ian)
           end if
cdtransend
           if (rapi .gt. centy - 0.25d0 .and. 
     &        rapi .lt. centy + 0.25d0) then
              det1(ian) = det1(ian) + et
              dn1(ian) = dn1(ian) + 1d0
              if (rapi .gt. centy - 0.1d0 .and.
     &           rapi .lt. centy + 0.1d0) then
                 det(ian) = det(ian) + et
                 dn(ian) = dn(ian) + 1d0
              end if
           end if
        end if

        return
        end

        subroutine zpca1c(p0, p1, p2, p3, ian)

        implicit double precision (a-h, o-z)

        common /ana3/ em(4, 4, 12)
cc      SAVE /ana3/

        dimension en(4)
        SAVE   

        en(1) = p0
        en(2) = p1
        en(3) = p2
        en(4) = p3

        do 1002 i = 1, 4
           do 1001 j = 1, 4
              em(i, j, ian) = em(i, j, ian) + en(i) * en(j) / p0
 1001      continue
 1002   continue

        return
        end

******************************************************************************

        subroutine zpca2

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para3/ nsevt, nevnt, nsbrun, ievt, isbrun
cc      SAVE /para3/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /para7/ ioscar,nsmbbbar,nsmmeson
cc      SAVE /para7/
        common /ilist6/ t, iopern, icolln
cc      SAVE /ilist6/
        common /rndm1/ number
cc      SAVE /rndm1/
        common /rndm2/ iff
cc      SAVE /rndm2/
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        COMMON /AREVT/ IAEVT, IARUN, MISS
cc      SAVE /AREVT/
        SAVE   

        if (iconfg .le. 3) then
           call zpca2a
        else
           call zpca2b
        end if

        if (ioscar .eq. 1) then
           call zpca2c
        end if

cbzdbg2/17/99
c        write (25, *) 'Event', nsevt - 1 + ievt, 
c    &         ', run', isbrun,
c        WRITE (25, *) ' Event ', IAEVT, ', run ', IARUN,
c     &     ',\n\t number of operations = ', iopern,
c     &     ',\n\t number of collisions between particles = ', 
c     &         icolln,
c     &     ',\n\t freezeout time=', t,
c     &     ',\n\t ending at the ', number, 'th random number',
c     &     ',\n\t ending collision iff=', iff
        WRITE (25, *) ' Event ', IAEVT, ', run ', IARUN
        WRITE (25, *) '    number of operations = ', iopern
        WRITE (25, *) '    number of collisions between particles = ', 
     &       icolln
        WRITE (25, *) '    freezeout time=', t
        WRITE (25, *) '    ending at the ', number, 'th random number'
        WRITE (25, *) '    ending collision iff=', iff

        return
        end

        subroutine zpca2a

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /para1/ mul
cc      SAVE /para1/
        common /para2/ xmp, xmu, alpha, rscut2, cutof2
cc      SAVE /para2/
        common /para3/ nsevt, nevnt, nsbrun, ievt, isbrun
cc      SAVE /para3/
        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        common /para6/ centy
cc      SAVE /para6/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /prec5/ eta(MAXPTN), rap(MAXPTN), tau(MAXPTN)
cc      SAVE /prec5/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        common /ilist6/ t, iopern, icolln
cc      SAVE /ilist6/
        common /rndm1/ number
cc      SAVE /rndm1/
        common /rndm2/ iff
cc      SAVE /rndm2/
        common /rndm3/ iseedp
cc      SAVE /rndm3/
        common /ana1/ ts(12)
cc      SAVE /ana1/
        common /ana2/
     &     det(12), dn(12), detdy(12), detdn(12), dndy(12),
     &     det1(12), dn1(12), detdy1(12), detdn1(12), dndy1(12),
     &     det2(12), dn2(12), detdy2(12), detdn2(12), dndy2(12)
cc      SAVE /ana2/
        common /ana4/ fdetdy(24), fdndy(24), fdndpt(12)
cc      SAVE /ana4/
        SAVE   

        do 1004 i = 1, ichkpt
           rapi = rap(i)
c     7/20/01:
c           et = sqrt(px(i) ** 2 + py(i) ** 2 + xmp ** 2)
           et = dsqrt(px(i) ** 2 + py(i) ** 2 + xmp ** 2)

           do 1001 j = 1, 24
              if (rapi .gt. j + centy - 13d0 
     &           .and. rapi .lt. j  + centy - 12d0) then
                 fdetdy(j) = fdetdy(j) + et
                 fdndy(j) = fdndy(j) + 1d0
              end if
 1001      continue

           do 1002 j = 1, 12
              if (et .gt. 0.5d0 * (j - 1) .and.
     &           et .lt. 0.5d0 * j ) then
                 fdndpt(j) = fdndpt(j) + 1d0
              end if
 1002      continue

           if (iconfg .eq. 1) then
              t1 = ft(i)
              t2 = tlarge
              ipic = 11
           else
              t1 = tau(i)
              t2 = tlarge
              ipic = 12
           end if

           do 1003 ian = 1, ipic
              if (t1 .le. ts(ian) .and.
     &           t2 .gt. ts(ian)) then
                 call zpca1b(rapi, et, ian)
              end if
 1003      continue

           if (iconfg .eq. 1) then
              call zpca1b(rapi, et, 12)
           end if
 1004   continue

        do 1005 ian = 1, 12
           if (dn(ian) .eq. 0d0 .or. dn1(ian) .eq. 0d0 .or.
     &        dn2(ian) .eq. 0d0) then
clin-9/2012 suppress output:
c              print *, 'event=', ievt
c              print *, 'dn(', ian, ')=', dn(ian), 'dn1(', ian,
c     &           ')=', dn1(ian), 'dn2(', ian, ')=', dn2(ian)
           end if
           detdy(ian) = detdy(ian) + det(ian)
           if (dn(ian) .ne. 0) then
              detdn(ian) = detdn(ian) + det(ian) / dn(ian)
           end if
           dndy(ian) = dndy(ian) + dn(ian)
           detdy1(ian) = detdy1(ian) + det1(ian)
           if (dn1(ian) .ne. 0) then
              detdn1(ian) = detdn1(ian) + det1(ian) / dn1(ian)
           end if
           dndy1(ian) = dndy1(ian) + dn1(ian)
           detdy2(ian) = detdy2(ian) + det2(ian)
           if (dn2(ian) .ne. 0) then
              detdn2(ian) = detdn2(ian) + det2(ian) / dn2(ian)
           end if
           dndy2(ian) = dndy2(ian) + dn2(ian)
 1005   continue

        return
        end

        subroutine zpca2b

        implicit double precision (a-h, o-z)
        parameter (MAXPTN=400001)

        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        common /ilist4/ ifmpt, ichkpt, indx(MAXPTN)
cc      SAVE /ilist4/
        common /ilist5/ ct(MAXPTN), ot(MAXPTN), tlarge
cc      SAVE /ilist5/
        common /ana1/ ts(12)
cc      SAVE /ana1/
        SAVE   

        do 1002 i = 1, ichkpt
           t1 = ft(i)
           t2 = tlarge
           ipic = 12

           do 1001 ian = 1, ipic
              if (t1 .le. ts(ian) .and.
     &           t2 .gt. ts(ian)) then
                 p0 = e(i)
                 p1 = px(i)
                 p2 = py(i)
                 p3 = pz(i)
                 call zpca1c(p0, p1, p2, p3, ian)
              end if
 1001      continue
 1002   continue

        return
        end

        subroutine zpca2c

        implicit double precision (a-h, o-z)

        character*8 code, versn
        character*4 reffra
        integer aproj, zproj, atarg, ztarg, event
        parameter (MAXPTN=400001)

        common /para1/ mul
cc      SAVE /para1/
        common /prec2/gx(MAXPTN),gy(MAXPTN),gz(MAXPTN),ft(MAXPTN),
     &       px(MAXPTN), py(MAXPTN), pz(MAXPTN), e(MAXPTN),
     &       xmass(MAXPTN), ityp(MAXPTN)
cc      SAVE /prec2/
        SAVE   
        data nff/0/

c       file header
        if (nff .eq. 0) then
           write (26, 101) 'OSCAR1997A'
           write (26, 101) 'final_id_p_x'
           code = 'ZPC'
           versn = '1.0.1'
           aproj = -1
           zproj = -1
           atarg = -1
           ztarg = -1
           reffra = 'cm'
           ebeam = 0d0
           ntestp = 1
           write (26, 102) code, versn, aproj, zproj, atarg, ztarg,
     &        reffra, ebeam, ntestp
           nff = 1
           event = 1
           bimp = 0d0
           phi = 0d0
        end if

c       comment

c       event header
        write (26, 103) event, mul, bimp, phi

c       particles
        do 99 i = 1, mul
           write (26, 104) i, ityp(i),
     &        px(i), py(i), pz(i), e(i), xmass(i),
     &        gx(i), gy(i), gz(i), ft(i)
 99         continue

         event = event + 1

 101        format (a12)
 102        format (2(a8, 2x), '(',i3, ',',i6, ')+(',i3, ',', i6, ')',
     &     2x, a4, 2x, e10.4, 2x, i8)
 103        format (i10, 2x, i10, 2x, f8.3, 2x, f8.3)
 104        format (i10, 2x, i10, 2x, 9(e12.6, 2x))

        return
        end

******************************************************************************

        subroutine zpcou

        implicit double precision (a-h, o-z)

        common /para5/ iconfg, iordsc
cc      SAVE /para5/
        SAVE   

        if (iconfg .le. 3) then
           call zpcou1
        else
           call zpcou2
        end if

        return
        end

        subroutine zpcou1

        implicit double precision (a-h, o-z)

        common /para3/ nsevt, nevnt, nsbrun, ievt, isbrun
cc      SAVE /para3/
        common /ana1/ ts(12)
cc      SAVE /ana1/
        common /ana2/
     &     det(12), dn(12), detdy(12), detdn(12), dndy(12),
     &     det1(12), dn1(12), detdy1(12), detdn1(12), dndy1(12),
     &     det2(12), dn2(12), detdy2(12), detdn2(12), dndy2(12)
cc      SAVE /ana2/
        common /ana4/ fdetdy(24), fdndy(24), fdndpt(12)
cc      SAVE /ana4/
        SAVE   
c
        dpt = 0.5d0
        dy2 = 1d0
        dy1 = 0.5d0
        dy = 0.2d0
        ntotal = nevnt * nsbrun
c
        return
        end

        subroutine zpcou2

        implicit double precision (a-h, o-z)

        common /para3/ nsevt, nevnt, nsbrun, ievt, isbrun
cc      SAVE /para3/
        common /ilist3/ size1, size2, size3, v1, v2, v3, size
cc      SAVE /ilist3/
        common /ana1/ ts(12)
cc      SAVE /ana1/
        common /ana3/ em(4, 4, 12)
cc      SAVE /ana3/
        SAVE   
c
        open (28, file = 'ana4/em.dat', status = 'unknown')
        vol = 1000.d0 * size1 * size2 * size3
        ntotal = nevnt * nsbrun

        do 1002 ian = 1, 12
           write (28, *) '*** for time ', ts(ian), 'fm(s)'
           do 1001 i = 1, 4
              write (28, *) em(i, 1, ian) / vol / ntotal,
     &                        em(i, 2, ian) / vol / ntotal,
     &                        em(i, 3, ian) / vol / ntotal,
     &                        em(i, 4, ian) / vol / ntotal
 1001      continue
 1002   continue

        return
        end

******************************************************************************

      subroutine lorenz(energy, px, py, pz, bex, bey, bez)

c     add in a cut for beta2 to prevent gam to be nan (infinity)

      implicit double precision (a-h, o-z)

      common /lor/ enenew, pxnew, pynew, pznew
cc      SAVE /lor/
      SAVE   

      beta2 = bex ** 2 + bey ** 2 + bez ** 2
      if (beta2 .eq. 0d0) then
         enenew = energy
         pxnew = px
         pynew = py
         pznew = pz
      else
         if (beta2 .gt. 0.999999999999999d0) then
            beta2 = 0.999999999999999d0
            print *,'beta2=0.999999999999999'
         end if
clin-7/20/01:
c         gam = 1.d0 / sqrt(1.d0 - beta2)
         gam = 1.d0 / dsqrt(1.d0 - beta2)
         enenew = gam * (energy - bex * px - bey * py - bez * pz)
         pxnew = - gam * bex * energy + (1.d0 
     &        + (gam - 1.d0) * bex ** 2 / beta2) * px
     &        + (gam - 1.d0) * bex * bey/beta2 * py
     &        + (gam - 1.d0) * bex * bez/beta2 * pz     
         pynew = - gam * bey * energy 
     &        + (gam - 1.d0) * bex * bey / beta2 * px
     &        + (1.d0 + (gam - 1.d0) * bey ** 2 / beta2) * py
     &        + (gam - 1.d0) * bey * bez / beta2 * pz         
         pznew = - gam * bez * energy
     &        +  (gam - 1.d0) * bex * bez / beta2 * px
     &        + (gam - 1.d0) * bey * bez / beta2 * py
     &        + (1.d0 + (gam - 1.d0) * bez ** 2 / beta2) * pz    
      endif

      return
      end

      subroutine index1(n, m, arrin, indx)
c     indexes the first m elements of ARRIN of length n, i.e., outputs INDX
c     such that ARRIN(INDEX(J)) is in ascending order for J=1,...,m

      implicit double precision (a-h, o-z)

      dimension arrin(n), indx(n)
      SAVE   
      do 1001 j = 1, m
         indx(j) = j
 1001   continue
      l = m / 2 + 1
      ir = m
 10   continue
      if (l .gt. 1) then
         l = l - 1
         indxt = indx(l)
         q = arrin(indxt)
      else
         indxt = indx(ir)
         q = arrin(indxt)
         indx(ir) = indx(1)
         ir = ir - 1
         if (ir .eq. 1) then
            indx(1) = indxt
            return
         end if
      end if
      i = l
      j = l + l
 20   if (j .le. ir) then
         if (j .lt. ir) then
            if (arrin(indx(j)) .lt. arrin(indx(j + 1))) j = j + 1
         end if
         if (q .lt. arrin(indx(j))) then
            indx(i) = indx(j)
            i = j
            j = j + j
         else
            j = ir + 1
         end if
      goto 20
      end if
      indx(i) = indxt
      goto 10

      end


        double precision function ftime1(iseed)

c       this program is used to generate formation time
c       the calling program needs a common /par1/
c       and declare external ftime1

clin-8/19/02
        implicit double precision (a-h, o-z)

        external ran1

        parameter (hbarc = 0.197327054d0)

        common /par1/ formt
cc      SAVE /par1/
        SAVE   

        aa = hbarc / formt

clin7/20/01:
c        ftime1 = aa * sqrt(1d0 / ran1(iseed) - 1d0)
        ftime1 = aa * dsqrt(1d0 / ran1(iseed) - 1d0)
        return
        end


      subroutine cropro(vx1, vy1, vz1, vx2, vy2, vz2)

c     this subroutine is used to calculate the cross product of 
c     (vx1,vy1,vz1) and (vx2,vy2,vz2) and get the result (vx3,vy3,vz3)
c     and put the vector into common /cprod/

      implicit double precision (a-h, o-z)

      common/cprod/ vx3, vy3, vz3
cc      SAVE /cprod/
      SAVE   

      vx3 = vy1 * vz2 - vz1 * vy2
      vy3 = vz1 * vx2 - vx1 * vz2
      vz3 = vx1 * vy2 - vy1 * vx2

      return
      end
      
      subroutine xnormv(vx, vy, vz)

c      this subroutine is used to get a normalized vector 

      implicit double precision (a-h, o-z)
      SAVE   

clin-7/20/01:
c      vv = sqrt(vx ** 2 + vy ** 2 + vz ** 2)
      vv = dsqrt(vx ** 2 + vy ** 2 + vz ** 2)
      vx = vx / vv
      vy = vy / vv
      vz = vz / vv

      return
      end

cbz1/29/99
c      subroutine rotate(xn1, xn2, xn3, theta, v1, v2, v3)
      subroutine zprota(xn1, xn2, xn3, theta, v1, v2, v3)
cbz1/29/99end

c     this subroutine is used to rotate the vector (v1,v2,v3) by an angle theta
c     around the unit vector (xn1, xn2, xn3)

      implicit double precision (a-h, o-z)
      SAVE   

      vx = v1
      vy = v2
      vz = v3
      c = cos(theta)
      omc = 1d0 - c
      s = sin(theta)
      a11 = xn1 ** 2 * omc + c
      a12 = xn1 * xn2 * omc - s * xn3
      a13 = xn1 * xn3 * omc + s * xn2
      a21 = xn1 * xn2 * omc + s * xn3
      a22 = xn2 **2 * omc + c
      a23 = xn2 * xn3 * omc - s * xn1
      a31 = xn1 * xn3 * omc - s * xn2
      a32 = xn3 * xn2 * omc + s * xn1
      a33 = xn3 ** 2 * omc + c
      v1 = vx * a11 + vy * a12 + vz * a13
      v2 = vx * a21 + vy * a22 + vz * a23
      v3 = vx * a31 + vy * a32 + vz * a33
      
      return
      end

      double precision function ran1(idum)

*     return a uniform random deviate between 0.0 and 1.0. set idum to 
*     any negative value to initialize or reinitialize the sequence.

      implicit double precision (a-h, o-z)

      dimension r(97)

      common /rndm1/ number
cc      SAVE /rndm1/
      parameter (m1 = 259200, ia1 = 7141, ic1 = 54773, rm1 = 1d0 / m1)
      parameter (m2 = 134456, ia2 = 8121, ic2 = 28411, rm2 = 1d0 / m2)
      parameter (m3 = 243000, ia3 = 4561, ic3 = 51349)
clin-6/23/00 save ix1-3:
clin-10/30/02 r unsaved, causing wrong values for ran1 when compiled with f77:
cc      SAVE ix1,ix2,ix3,r
      SAVE   
      data iff/0/

      if (idum .lt. 0 .or. iff .eq. 0) then
         iff = 1
         ix1 = mod(ic1 - idum, m1)
         ix1 = mod(ia1 * ix1 + ic1, m1)
         ix2 = mod(ix1, m2)
         ix1 = mod(ia1 * ix1 + ic1, m1)
         ix3 = mod(ix1, m3)
         do 11 j = 1, 97
            ix1 = mod(ia1 * ix1 + ic1, m1)
            ix2 = mod(ia2 * ix2 + ic2, m2)
            r(j) = (dble(ix1) + dble(ix2) * rm2) * rm1
 11         continue
         idum = 1
      end if
      ix1 = mod(ia1 * ix1 + ic1, m1)
      ix2 = mod(ia2 * ix2 + ic2, m2)
      ix3 = mod(ia3 * ix3 + ic3, m3)
clin-7/01/02       j = 1 + (97 * i x 3) / m3
      j=1+(97*ix3)/m3
clin-4/2008:
c      if (j .gt. 97 .or. j .lt. 1) pause
      if (j .gt. 97 .or. j .lt. 1) print *, 'In zpc ran1, j<1 or j>97',j
      ran1 = r(j)
      r(j) = (dble(ix1) + dble(ix2) * rm2) * rm1

clin-6/23/00 check random number generator:
      number = number + 1
c      if(number.le.100000) write(99,*) 'number, ran1=', number,ran1

      return
      end

